<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>一些常见的并发编程错误 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="一些常见的并发编程错误"><meta property="og:description" content="Go 并不会阻止一些因 Go 程序员粗心大意或者缺乏经验而造成的并发编程错误。在本文的下面部分将展示一些在 Go 编程中常见的并发编程错误，以帮助 Go 程序员们避免再犯类似的错误。"><meta property="og:type" content="article"><meta property="og:url" content="/article-9726-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-06-08T00:52:05+00:00"><meta property="article:modified_time" content="2018-06-08T00:52:05+00:00"><meta itemprop=name content="一些常见的并发编程错误"><meta itemprop=description content="Go 并不会阻止一些因 Go 程序员粗心大意或者缺乏经验而造成的并发编程错误。在本文的下面部分将展示一些在 Go 编程中常见的并发编程错误，以帮助 Go 程序员们避免再犯类似的错误。"><meta itemprop=datePublished content="2018-06-08T00:52:05+00:00"><meta itemprop=dateModified content="2018-06-08T00:52:05+00:00"><meta itemprop=wordCount content="901"><meta itemprop=keywords content="Go,并发,协程,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>一些常见的并发编程错误</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2018-06-08T00:52:05Z>June 08, 2018</time></div></div></header><div class="content post__content clearfix"><p><img src=/data/attachment/album/201806/08/005141b113xwdldwcv1wgv.jpg alt></p><p>Go 是一个内置支持并发编程的语言。借助使用 <code>go</code> 关键字去创建 协程 goroutine （轻量级线程）和在 Go 中提供的 <a href=https://go101.org/article/channel-use-cases.html>使用</a> <a href=https://go101.org/article/channel.html>信道</a> 和 <a href=https://go101.org/article/concurrent-atomic-operation.html>其它的并发</a> <a href=https://go101.org/article/concurrent-synchronization-more.html>同步方法</a>，使得并发编程变得很容易、很灵活和很有趣。</p><p>另一方面，Go 并不会阻止一些因 Go 程序员粗心大意或者缺乏经验而造成的并发编程错误。在本文的下面部分将展示一些在 Go 编程中常见的并发编程错误，以帮助 Go 程序员们避免再犯类似的错误。</p><h3 id=需要同步的时候没有同步>需要同步的时候没有同步</h3><p>代码行或许 <a href=https://go101.org/article/memory-model.html>不是按出现的顺序运行的</a>。</p><p>在下面的程序中有两个错误。</p><ul><li>第一，在 <code>main</code> 协程中读取 <code>b</code> 和在新的 协程 中写入 <code>b</code> 可能导致数据争用。</li><li>第二，条件 <code>b == true</code> 并不能保证在 <code>main</code> 协程 中的 <code>a != nil</code>。在新的协程中编译器和 CPU 可能会通过 <a href=https://go101.org/article/memory-model.html>重排序指令</a> 进行优化，因此，在运行时 <code>b</code> 赋值可能发生在 <code>a</code> 赋值之前，在 <code>main</code> 协程 中当 <code>a</code> 被修改后，它将会让部分 <code>a</code> 一直保持为 <code>nil</code>。</li></ul><pre tabindex=0><code>package main

import (
    &#34;time&#34;
    &#34;runtime&#34;
)

func main() {
    var a []int // nil
    var b bool  // false

    // a new goroutine
    go func () {
        a = make([]int, 3)
        b = true // write b
    }()

    for !b { // read b
        time.Sleep(time.Second)
        runtime.Gosched()
    }
    a[0], a[1], a[2] = 0, 1, 2 // might panic
}
</code></pre><p>上面的程序或者在一台计算机上运行的很好，但是在另一台上可能会引发异常。或者它可能运行了 <em>N</em> 次都很好，但是可能在第 <em>(N+1)</em> 次引发了异常。</p><p>我们将使用 <code>sync</code> 标准包中提供的信道或者同步方法去确保内存中的顺序。例如，</p><pre tabindex=0><code>package main

func main() {
    var a []int = nil
    c := make(chan struct{})

    // a new goroutine
    go func () {
        a = make([]int, 3)
        c &lt;- struct{}{}
    }()

    &lt;-c
    a[0], a[1], a[2] = 0, 1, 2
}
</code></pre><h3 id=使用-timesleep-调用去做同步>使用 <code>time.Sleep</code> 调用去做同步</h3><p>我们先来看一个简单的例子。</p><pre tabindex=0><code>package main

import (
    &#34;fmt&#34;
    &#34;time&#34;
)

func main() {
    var x = 123

    go func() {
        x = 789 // write x
    }()

    time.Sleep(time.Second)
    fmt.Println(x) // read x
}
</code></pre><p>我们预期程序将打印出 <code>789</code>。如果我们运行它，通常情况下，它确定打印的是 <code>789</code>。但是，这个程序使用的同步方式好吗？No！原因是 Go 运行时并不保证 <code>x</code> 的写入一定会发生在 <code>x</code> 的读取之前。在某些条件下，比如在同一个操作系统上，大部分 CPU 资源被其它运行的程序所占用的情况下，写入 <code>x</code> 可能就会发生在读取 <code>x</code> 之后。这就是为什么我们在正式的项目中，从来不使用 <code>time.Sleep</code> 调用去实现同步的原因。</p><p>我们来看一下另外一个示例。</p><pre tabindex=0><code>package main

import (
    &#34;fmt&#34;
    &#34;time&#34;
)

var x = 0

func main() {
    var num = 123
    var p = &amp;num

    c := make(chan int)

    go func() {
        c &lt;- *p + x
    }()

    time.Sleep(time.Second)
    num = 789
    fmt.Println(&lt;-c)
}
</code></pre><p>你认为程序的预期输出是什么？<code>123</code> 还是 <code>789</code>？事实上它的输出与编译器有关。对于标准的 Go 编译器 1.10 来说，这个程序很有可能输出是 <code>123</code>。但是在理论上，它可能输出的是 <code>789</code>，或者其它的随机数。</p><p>现在，我们来改变 <code>c &lt;- *p + x</code> 为 <code>c &lt;- *p</code>，然后再次运行这个程序。你将会发现输出变成了 <code>789</code> （使用标准的 Go 编译器 1.10）。这再次说明它的输出是与编译器相关的。</p><p>是的，在上面的程序中存在数据争用。表达式 <code>*p</code> 可能会被先计算、后计算、或者在处理赋值语句 <code>num = 789</code> 时计算。<code>time.Sleep</code> 调用并不能保证 <code>*p</code> 发生在赋值语句处理之前进行。</p><p>对于这个特定的示例，我们将在新的协程创建之前，将值保存到一个临时值中，然后在新的协程中使用临时值去消除数据争用。</p><pre tabindex=0><code>...
    tmp := *p + x
    go func() {
        c &lt;- tmp
    }()
...
</code></pre><h3 id=使协程挂起>使协程挂起</h3><p>挂起协程是指让协程一直处于阻塞状态。导致协程被挂起的原因很多。比如，</p><ul><li>一个协程尝试从一个 nil 信道中或者从一个没有其它协程给它发送值的信道中检索数据。</li><li>一个协程尝试去发送一个值到 nil 信道，或者发送到一个没有其它的协程接收值的信道中。</li><li>一个协程被它自己死锁。</li><li>一组协程彼此死锁。</li><li>当运行一个没有 <code>default</code> 分支的 <code>select</code> 代码块时，一个协程被阻塞，以及在 <code>select</code> 代码块中 <code>case</code> 关键字后的所有信道操作保持阻塞状态。</li></ul><p>除了有时我们为了避免程序退出，特意让一个程序中的 <code>main</code> 协程保持挂起之外，大多数其它的协程挂起都是意外情况。Go 运行时很难判断一个协程到底是处于挂起状态还是临时阻塞。因此，Go 运行时并不会去释放一个挂起的协程所占用的资源。</p><p>在 <a href=https://go101.org/article/channel-use-cases.html#first-response-wins>谁先响应谁获胜</a> 的信道使用案例中，如果使用的 future 信道容量不够大，当尝试向 Future 信道发送结果时，一些响应较慢的信道将被挂起。比如，如果调用下面的函数，将有 4 个协程处于永远阻塞状态。</p><pre tabindex=0><code>func request() int {
    c := make(chan int)
    for i := 0; i &lt; 5; i++ {
        i := i
        go func() {
            c &lt;- i // 4 goroutines will hang here.
        }()
    }
    return &lt;-c
}
</code></pre><p>为避免这 4 个协程一直处于挂起状态， <code>c</code> 信道的容量必须至少是 <code>4</code>。</p><p>在 <a href=https://go101.org/article/channel-use-cases.html#first-response-wins-2>实现谁先响应谁获胜的第二种方法</a> 的信道使用案例中，如果将 future 信道用做非缓冲信道，那么有可能这个信息将永远也不会有响应而挂起。例如，如果在一个协程中调用下面的函数，协程可能会挂起。原因是，如果接收操作 <code>&lt;-c</code> 准备就绪之前，五个发送操作全部尝试发送，那么所有的尝试发送的操作将全部失败，因此那个调用者协程将永远也不会接收到值。</p><pre tabindex=0><code>func request() int {
    c := make(chan int)
    for i := 0; i &lt; 5; i++ {
        i := i
        go func() {
            select {
            case c &lt;- i:
            default:
            }
        }()
    }
    return &lt;-c
}
</code></pre><p>将信道 <code>c</code> 变成缓冲信道将保证五个发送操作中的至少一个操作会发送成功，这样，上面函数中的那个调用者协程将不会被挂起。</p><h3 id=在-sync-标准包中拷贝类型值>在 <code>sync</code> 标准包中拷贝类型值</h3><p>在实践中，<code>sync</code> 标准包中的类型值不会被拷贝。我们应该只拷贝这个值的指针。</p><p>下面是一个错误的并发编程示例。在这个示例中，当调用 <code>Counter.Value</code> 方法时，将拷贝一个 <code>Counter</code> 接收值。作为接收值的一个字段，<code>Counter</code> 接收值的各个 <code>Mutex</code> 字段也会被拷贝。拷贝不是同步发生的，因此，拷贝的 <code>Mutex</code> 值可能会出错。即便是没有错误，拷贝的 <code>Counter</code> 接收值的访问保护也是没有意义的。</p><pre tabindex=0><code>import &#34;sync&#34;

type Counter struct {
    sync.Mutex
    n int64
}

// This method is okay.
func (c *Counter) Increase(d int64) (r int64) {
    c.Lock()
    c.n += d
    r = c.n
    c.Unlock()
    return
}

// The method is bad. When it is called, a Counter
// receiver value will be copied.
func (c Counter) Value() (r int64) {
    c.Lock()
    r = c.n
    c.Unlock()
    return
}
</code></pre><p>我们只需要改变 <code>Value</code> 接收类型方法为指针类型 <code>*Counter</code>，就可以避免拷贝 <code>Mutex</code> 值。</p><p>在官方的 Go SDK 中提供的 <code>go vet</code> 命令将会报告潜在的错误值拷贝。</p><h3 id=在错误的地方调用-syncwaitgroup-的方法>在错误的地方调用 <code>sync.WaitGroup</code> 的方法</h3><p>每个 <code>sync.WaitGroup</code> 值维护一个内部计数器，这个计数器的初始值为 0。如果一个 <code>WaitGroup</code> 计数器的值是 0，调用 <code>WaitGroup</code> 值的 <code>Wait</code> 方法就不会被阻塞，否则，在计数器值为 0 之前，这个调用会一直被阻塞。</p><p>为了让 <code>WaitGroup</code> 值的使用有意义，当一个 <code>WaitGroup</code> 计数器值为 0 时，必须在相应的 <code>WaitGroup</code> 值的 <code>Wait</code> 方法调用之前，去调用 <code>WaitGroup</code> 值的 <code>Add</code> 方法。</p><p>例如，下面的程序中，在不正确位置调用了 <code>Add</code> 方法，这将使最后打印出的数字不总是 <code>100</code>。事实上，这个程序最后打印的数字可能是在 <code>[0, 100)</code> 范围内的一个随意数字。原因就是 <code>Add</code> 方法的调用并不保证一定会发生在 <code>Wait</code> 方法调用之前。</p><pre tabindex=0><code>package main

import (
    &#34;fmt&#34;
    &#34;sync&#34;
    &#34;sync/atomic&#34;
)

func main() {
    var wg sync.WaitGroup
    var x int32 = 0
    for i := 0; i &lt; 100; i++ {
        go func() {
            wg.Add(1)
            atomic.AddInt32(&amp;x, 1)
            wg.Done()
        }()
    }

    fmt.Println(&#34;To wait ...&#34;)
    wg.Wait()
    fmt.Println(atomic.LoadInt32(&amp;x))
}
</code></pre><p>为让程序的表现符合预期，在 <code>for</code> 循环中，我们将把 <code>Add</code> 方法的调用移动到创建的新协程的范围之外，修改后的代码如下。</p><pre tabindex=0><code>...
    for i := 0; i &lt; 100; i++ {
        wg.Add(1)
        go func() {
            atomic.AddInt32(&amp;x, 1)
            wg.Done()
        }()
    }
...
</code></pre><h3 id=不正确使用-futures-信道>不正确使用 futures 信道</h3><p>在 <a href=https://go101.org/article/channel-use-cases.html>信道使用案例</a> 的文章中，我们知道一些函数将返回 <a href=https://go101.org/article/channel-use-cases.html#future-promise>futures 信道</a>。假设 <code>fa</code> 和 <code>fb</code> 就是这样的两个函数，那么下面的调用就使用了不正确的 future 参数。</p><pre tabindex=0><code>doSomethingWithFutureArguments(&lt;-fa(), &lt;-fb())
</code></pre><p>在上面的代码行中，两个信道接收操作是顺序进行的，而不是并发的。我们做如下修改使它变成并发操作。</p><pre tabindex=0><code>ca, cb := fa(), fb()
doSomethingWithFutureArguments(&lt;-c1, &lt;-c2)
</code></pre><h3 id=没有等协程的最后的活动的发送结束就关闭信道>没有等协程的最后的活动的发送结束就关闭信道</h3><p>Go 程序员经常犯的一个错误是，还有一些其它的协程可能会发送值到以前的信道时，这个信道就已经被关闭了。当这样的发送（发送到一个已经关闭的信道）真实发生时，将引发一个异常。</p><p>这种错误在一些以往的著名 Go 项目中也有发生，比如在 Kubernetes 项目中的 <a href="https://github.com/kubernetes/kubernetes/pull/45291/files?diff=split">这个 bug</a> 和 <a href="https://github.com/kubernetes/kubernetes/pull/39479/files?diff=split">这个 bug</a>。</p><p>如何安全和优雅地关闭信道，请阅读 <a href=https://go101.org/article/channel-closing.html>这篇文章</a>。</p><h3 id=在值上做-64-位原子操作时没有保证值地址-64-位对齐>在值上做 64 位原子操作时没有保证值地址 64 位对齐</h3><p>到目前为止（Go 1.10），在标准的 Go 编译器中，在一个 64 位原子操作中涉及到的值的地址要求必须是 64 位对齐的。如果没有对齐则导致当前的协程异常。对于标准的 Go 编译器来说，这种失败仅发生在 32 位的架构上。请阅读 <a href=https://go101.org/article/memory-layout.html>内存布局</a> 去了解如何在一个 32 位操作系统上保证 64 位对齐。</p><h3 id=没有注意到大量的资源被-timeafter-函数调用占用>没有注意到大量的资源被 <code>time.After</code> 函数调用占用</h3><p>在 <code>time</code> 标准包中的 <code>After</code> 函数返回 <a href=https://go101.org/article/channel-use-cases.html#timer>一个延迟通知的信道</a>。这个函数在某些情况下用起来很便捷，但是，每次调用它将创建一个 <code>time.Timer</code> 类型的新值。这个新创建的 <code>Timer</code> 值在通过传递参数到 <code>After</code> 函数指定期间保持激活状态，如果在这个期间过多的调用了该函数，可能会有太多的 <code>Timer</code> 值保持激活，这将占用大量的内存和计算资源。</p><p>例如，如果调用了下列的 <code>longRunning</code> 函数，将在一分钟内产生大量的消息，然后在某些周期内将有大量的 <code>Timer</code> 值保持激活，即便是大量的这些 <code>Timer</code> 值已经没用了也是如此。</p><pre tabindex=0><code>import (
    &#34;fmt&#34;
    &#34;time&#34;
)

// The function will return if a message arrival interval
// is larger than one minute.
func longRunning(messages &lt;-chan string) {
    for {
        select {
        case &lt;-time.After(time.Minute):
            return
        case msg := &lt;-messages:
            fmt.Println(msg)
        }
    }
}
</code></pre><p>为避免在上述代码中创建过多的 <code>Timer</code> 值，我们将使用一个单一的 <code>Timer</code> 值去完成同样的任务。</p><pre tabindex=0><code>func longRunning(messages &lt;-chan string) {
    timer := time.NewTimer(time.Minute)
    defer timer.Stop()

    for {
        select {
        case &lt;-timer.C:
            return
        case msg := &lt;-messages:
            fmt.Println(msg)
            if !timer.Stop() {
                &lt;-timer.C
            }
        }

        // The above &#34;if&#34; block can also be put here.

        timer.Reset(time.Minute)
    }
}
</code></pre><h3 id=不正确地使用-timetimer-值>不正确地使用 <code>time.Timer</code> 值</h3><p>在最后，我们将展示一个符合语言使用习惯的 <code>time.Timer</code> 值的使用示例。需要注意的一个细节是，那个 <code>Reset</code> 方法总是在停止或者 <code>time.Timer</code> 值释放时被使用。</p><p>在 <code>select</code> 块的第一个 <code>case</code> 分支的结束部分，<code>time.Timer</code> 值被释放，因此，我们不需要去停止它。但是必须在第二个分支中停止定时器。如果在第二个分支中 <code>if</code> 代码块缺失，它可能至少在 <code>Reset</code> 方法调用时，会（通过 Go 运行时）发送到 <code>timer.C</code> 信道，并且那个 <code>longRunning</code> 函数可能会早于预期返回，对于 <code>Reset</code> 方法来说，它可能仅仅是重置内部定时器为 0，它将不会清理（耗尽）那个发送到 <code>timer.C</code> 信道的值。</p><p>例如，下面的程序很有可能在一秒内而不是十秒时退出。并且更重要的是，这个程序并不是 DRF 的（LCTT 译注：data race free，多线程程序的一种同步程度）。</p><pre tabindex=0><code>package main

import (
    &#34;fmt&#34;
    &#34;time&#34;
)

func main() {
    start := time.Now()
    timer := time.NewTimer(time.Second/2)
    select {
    case &lt;-timer.C:
    default:
        time.Sleep(time.Second) // go here
    }
    timer.Reset(time.Second * 10)
    &lt;-timer.C
    fmt.Println(time.Since(start)) // 1.000188181s
}
</code></pre><p>当 <code>time.Timer</code> 的值不再被其它任何一个东西使用时，它的值可能被停留在一种非停止状态，但是，建议在结束时停止它。</p><p>在多个协程中如果不按建议使用 <code>time.Timer</code> 值并发，可能会有 bug 隐患。</p><p>我们不应该依赖一个 <code>Reset</code> 方法调用的返回值。<code>Reset</code> 方法返回值的存在仅仅是为了兼容性目的。</p><hr><p>via: <a href=https://go101.org/article/concurrent-common-mistakes.html>https://go101.org/article/concurrent-common-mistakes.html</a></p><p>作者：&lt;go101.org> 译者：<a href=https://github.com/qhwdw>qhwdw</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/go/ rel=tag>Go</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E5%B9%B6%E5%8F%91/ rel=tag>并发</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E5%8D%8F%E7%A8%8B/ rel=tag>协程</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>