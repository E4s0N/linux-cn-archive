<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Headless Chrome 入门 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="Headless Chrome 入门"><meta property="og:description" content="在 Chrome 59　中开始搭载 Headless Chrome。这是一种在无需显示的环境下运行 Chrome 浏览器的方式。从本质上来说，就是不用 chrome 浏览器来运行 Chrome 的功能！它将 Chromium 和 Blink 渲染引擎提供的所有现代 Web 平台的功能都带入了命令行。"><meta property="og:type" content="article"><meta property="og:url" content="/article-8850-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-09-08T11:34:00+00:00"><meta property="article:modified_time" content="2017-09-08T11:34:00+00:00"><meta itemprop=name content="Headless Chrome 入门"><meta itemprop=description content="在 Chrome 59　中开始搭载 Headless Chrome。这是一种在无需显示的环境下运行 Chrome 浏览器的方式。从本质上来说，就是不用 chrome 浏览器来运行 Chrome 的功能！它将 Chromium 和 Blink 渲染引擎提供的所有现代 Web 平台的功能都带入了命令行。"><meta itemprop=datePublished content="2017-09-08T11:34:00+00:00"><meta itemprop=dateModified content="2017-09-08T11:34:00+00:00"><meta itemprop=wordCount content="1201"><meta itemprop=keywords content="浏览器,Chrome,Headless,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>Headless Chrome 入门</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-09-08T11:34:00Z>September 08, 2017</time></div></div></header><div class="content post__content clearfix"><p><img src=/data/attachment/album/201709/08/113337g9jjamqsizxmie3s.png alt></p><h3 id=摘要>摘要</h3><p>在 Chrome 59　中开始搭载 <a href=https://chromium.googlesource.com/chromium/src/+/lkgr/headless/README.md>Headless Chrome</a>。这是一种在 无需显示 headless 的环境下运行 Chrome 浏览器的方式。从本质上来说，就是不用 chrome 浏览器来运行 Chrome 的功能！它将 Chromium 和 Blink 渲染引擎提供的所有现代 Web 平台的功能都带入了命令行。</p><p>它有什么用？</p><p>无需显示 headless 的浏览器对于自动化测试和不需要可视化 UI 界面的服务器环境是一个很好的工具。例如，你可能需要对真实的网页运行一些测试，创建一个 PDF，或者只是检查浏览器如何呈现 URL。</p><blockquote><p><strong>注意：</strong> Mac 和 Linux 上的 Chrome 59 都可以运行无需显示模式。<a href="https://bugs.chromium.org/p/chromium/issues/detail?id=686608">对 Windows 的支持</a>将在 Chrome 60 中提供。要检查你使用的 Chrome 版本，请在浏览器中打开 <code>chrome://version</code>。</p></blockquote><h3 id=开启ruby-无需显示-rt--headless-rtruby模式命令行界面>开启 无需显示 headless 模式（命令行界面）</h3><p>开启 无需显示 headless 模式最简单的方法是从命令行打开 Chrome 二进制文件。如果你已经安装了 Chrome 59 以上的版本，请使用 <code>--headless</code> 标志启动 Chrome：</p><pre tabindex=0><code>chrome \
  --headless \                   # Runs Chrome in headless mode.
  --disable-gpu \                # Temporarily needed for now.
  --remote-debugging-port=9222 \
  https://www.chromestatus.com   # URL to open. Defaults to about:blank.
</code></pre><blockquote><p>**注意：**目前你仍然需要使用 <code>--disable-gpu</code> 标志。但它最终会不需要的。</p></blockquote><p><code>chrome</code> 二进制文件应该指向你安装 Chrome 的位置。确切的位置会因平台差异而不同。当前我在 Mac 上操作，所以我为安装的每个版本的 Chrome 都创建了方便使用的别名。</p><p>如果您使用 Chrome 的稳定版，并且无法获得测试版，我建议您使用 <code>chrome-canary</code> 版本：</p><pre tabindex=0><code>alias chrome=&#34;/Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome&#34;
alias chrome-canary=&#34;/Applications/Google\ Chrome\ Canary.app/Contents/MacOS/Google\ Chrome\ Canary&#34;
alias chromium=&#34;/Applications/Chromium.app/Contents/MacOS/Chromium&#34;
</code></pre><p>在<a href=https://www.google.com/chrome/browser/canary.html>这里</a>下载 Chrome Cannary。</p><h3 id=命令行的功能>命令行的功能</h3><p>在某些情况下，你可能不需要<a href=https://developers.google.com/web/updates/2017/04/headless-chrome#node>以脚本编程的方式</a>操作 Headless Chrome。可以使用一些<a href=https://cs.chromium.org/chromium/src/headless/app/headless_shell_switches.cc>有用的命令行标志</a>来执行常见的任务。</p><h4 id=打印-dom>打印 DOM</h4><p><code>--dump-dom</code> 标志将打印 <code>document.body.innerHTML</code> 到标准输出：</p><pre tabindex=0><code>chrome --headless --disable-gpu --dump-dom https://www.chromestatus.com/
</code></pre><h4 id=创建一个-pdf>创建一个 PDF</h4><p><code>--print-to-pdf</code> 标志将页面转出为 PDF 文件：</p><pre tabindex=0><code>chrome --headless --disable-gpu --print-to-pdf https://www.chromestatus.com/
</code></pre><h4 id=截图>截图</h4><p>要捕获页面的屏幕截图，请使用 <code>--screenshot</code> 标志：</p><pre tabindex=0><code>chrome --headless --disable-gpu --screenshot https://www.chromestatus.com/

# Size of a standard letterhead.
chrome --headless --disable-gpu --screenshot --window-size=1280,1696 https://www.chromestatus.com/

# Nexus 5x
chrome --headless --disable-gpu --screenshot --window-size=412,732 https://www.chromestatus.com/
</code></pre><p>使用 <code>--screenshot</code> 标志运行 Headless Chrome 将在当前工作目录中生成一个名为 <code>screenshot.png</code> 的文件。如果你正在寻求整个页面的截图，那么会涉及到很多事情。来自 David Schnurr 的一篇很棒的博文已经介绍了这一内容。请查看 <a href=https://medium.com/@dschnr/using-headless-chrome-as-an-automated-screenshot-tool-4b07dffba79a>使用 headless Chrome 作为自动截屏工具</a>。</p><h4 id=repl-模式-read-eval-print-loop>REPL 模式 (read-eval-print loop)</h4><p><code>--repl</code> 标志可以使 Headless Chrome 运行在一个你可以使用浏览器评估 JS 表达式的模式下。执行下面的命令：</p><pre tabindex=0><code>$ chrome --headless --disable-gpu --repl https://www.chromestatus.com/
[0608/112805.245285:INFO:headless_shell.cc(278)] Type a Javascript expression to evaluate or &#34;quit&#34; to exit.
&gt;&gt;&gt; location.href
{&#34;result&#34;:{&#34;type&#34;:&#34;string&#34;,&#34;value&#34;:&#34;https://www.chromestatus.com/features&#34;}}
&gt;&gt;&gt; quit
</code></pre><h3 id=在没有浏览器界面的情况下调试-chrome>在没有浏览器界面的情况下调试 Chrome</h3><p>当你使用 <code>--remote-debugging-port=9222</code> 运行 Chrome 时，它会启动一个支持 <a href=https://chromedevtools.github.io/devtools-protocol/>DevTools 协议</a>的实例。该协议用于与 Chrome 进行通信，并且驱动 Headless Chrome 浏览器实例。它也是一个类似 Sublime、VS Code 和 Node 的工具，可用于应用程序的远程调试。#协同效应</p><p>由于你没有浏览器用户界面可用来查看网页，请在另一个浏览器中输入 <code>http://localhost:9222</code>，以检查一切是否正常。你将会看到一个 可检查的 inspectable 页面的列表，可以点击它们来查看 Headless Chrome 正在呈现的内容：</p><p><img src=/data/attachment/album/201709/08/113716ghwls9r2wtu2mwhl.jpg alt></p><p><em>DevTools 远程调试界面</em></p><p>从这里，你就可以像往常一样使用熟悉的 DevTools 来检查、调试和调整页面了。如果你以编程方式使用 Headless Chrome，这个页面也是一个功能强大的调试工具，用于查看所有通过网络与浏览器交互的原始 DevTools 协议命令。</p><h3 id=使用编程模式-node>使用编程模式 （Node）</h3><h4 id=puppeteer-库-api>Puppeteer 库 API</h4><p><a href=https://github.com/GoogleChrome/puppeteer>Puppeteer</a> 是一个由 Chrome 团队开发的 Node 库。它提供了一个高层次的 API 来控制无需显示版（或 完全版）的 Chrome。它与其他自动化测试库，如 Phantom 和 NightmareJS 相类似，但是只适用于最新版本的 Chrome。</p><p>除此之外，Puppeteer 还可用于轻松截取屏幕截图，创建 PDF，页面间导航以及获取有关这些页面的信息。如果你想快速地自动化进行浏览器测试，我建议使用该库。它隐藏了 DevTools 协议的复杂性，并可以处理诸如启动 Chrome 调试实例等繁冗的任务。</p><p>安装：</p><pre tabindex=0><code>yarn add puppeteer
</code></pre><p><strong>例子</strong> - 打印用户代理：</p><pre tabindex=0><code>const puppeteer = require(&#39;puppeteer&#39;);

(async() =&gt; {
  const browser = await puppeteer.launch();
  console.log(await browser.version());
  browser.close();
})();
</code></pre><p><strong>例子</strong> - 获取页面的屏幕截图：</p><pre tabindex=0><code>const puppeteer = require(&#39;puppeteer&#39;);

(async() =&gt; {

const browser = await puppeteer.launch();
const page = await browser.newPage();
await page.goto(&#39;https://www.chromestatus.com&#39;, {waitUntil: &#39;networkidle&#39;});
await page.pdf({path: &#39;page.pdf&#39;, format: &#39;A4&#39;});

browser.close();
})();
</code></pre><p>查看 <a href=https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md>Puppeteer 的文档</a>，了解完整 API 的更多信息。</p><h4 id=cri-库>CRI 库</h4><p><a href=https://www.npmjs.com/package/chrome-remote-interface>chrome-remote-interface</a> 是一个比 Puppeteer API 更低层次的库。如果你想要更接近原始信息和更直接地使用 <a href=https://chromedevtools.github.io/devtools-protocol/>DevTools 协议</a>的话，我推荐使用它。</p><p><strong>启动 Chrome</strong></p><p>chrome-remote-interface 不会为你启动 Chrome，所以你要自己启动它。</p><p>在前面的 CLI 章节中，我们使用 <code>--headless --remote-debugging-port=9222</code> <a href=https://developers.google.com/web/updates/2017/04/headless-chrome#cli>手动启动了 Chrome</a>。但是，要想做到完全自动化测试，你可能希望从你的应用程序中启动 Chrome。</p><p>其中一种方法是使用 <code>child_process</code>：</p><pre tabindex=0><code>const execFile = require(&#39;child_process&#39;).execFile;

function launchHeadlessChrome(url, callback) {
  // Assuming MacOSx.
  const CHROME = &#39;/Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome&#39;;
  execFile(CHROME, [&#39;--headless&#39;, &#39;--disable-gpu&#39;, &#39;--remote-debugging-port=9222&#39;, url], callback);
}

launchHeadlessChrome(&#39;https://www.chromestatus.com&#39;, (err, stdout, stderr) =&gt; {
  ...
});
</code></pre><p>但是如果你想要在多个平台上运行可移植的解决方案，事情会变得很棘手。请注意 Chrome 的硬编码路径：</p><p><strong>使用 ChromeLauncher</strong></p><p><a href=https://developers.google.com/web/tools/lighthouse/>Lighthouse</a> 是一个令人称奇的网络应用的质量测试工具。Lighthouse 内部开发了一个强大的用于启动 Chrome 的模块，现在已经被提取出来单独使用。<a href=https://www.npmjs.com/package/chrome-launcher>chrome-launcher NPM 模块</a> 可以找到 Chrome 的安装位置，设置调试实例，启动浏览器和在程序运行完之后将其杀死。它最好的一点是可以跨平台工作，感谢 Node！</p><p>默认情况下，<strong>chrome-launcher 会尝试启动 Chrome Canary</strong>（如果已经安装），但是你也可以更改它，手动选择使用的 Chrome 版本。要想使用它，首先从 npm 安装：</p><pre tabindex=0><code>yarn add chrome-launcher
</code></pre><p><strong>例子</strong> - 使用 <code>chrome-launcher</code> 启动 Headless Chrome：</p><pre tabindex=0><code>const chromeLauncher = require(&#39;chrome-launcher&#39;);

// Optional: set logging level of launcher to see its output.
// Install it using: yarn add lighthouse-logger
// const log = require(&#39;lighthouse-logger&#39;);
// log.setLevel(&#39;info&#39;);

/**
 * Launches a debugging instance of Chrome.
 * @param {boolean=} headless True (default) launches Chrome in headless mode.
 *     False launches a full version of Chrome.
 * @return {Promise&lt;ChromeLauncher&gt;}
 */
function launchChrome(headless=true) {
  return chromeLauncher.launch({
    // port: 9222, // Uncomment to force a specific port of your choice.
    chromeFlags: [
      &#39;--window-size=412,732&#39;,
      &#39;--disable-gpu&#39;,
      headless ? &#39;--headless&#39; : &#39;&#39;
    ]
  });
}

launchChrome().then(chrome =&gt; {
  console.log(`Chrome debuggable on port: ${chrome.port}`);
  ...
  // chrome.kill();
});
</code></pre><p>运行这个脚本没有做太多的事情，但你应该能在任务管理器中看到启动了一个 Chrome 的实例，它加载了页面 <code>about:blank</code>。记住，它不会有任何的浏览器界面，我们是无需显示的。</p><p>为了控制浏览器，我们需要 DevTools 协议！</p><h4 id=检索有关页面的信息>检索有关页面的信息</h4><blockquote><p><strong>警告：</strong> DevTools 协议可以做一些有趣的事情，但是起初可能有点令人生畏。我建议先花点时间浏览 <a href=https://chromedevtools.github.io/devtools-protocol/>DevTools 协议查看器</a>。然后，转到 <code>chrome-remote-interface</code> 的 API 文档，看看它是如何包装原始协议的。</p></blockquote><p>我们来安装该库：</p><pre tabindex=0><code>yarn add chrome-remote-interface
</code></pre><p><strong>例子</strong> - 打印用户代理：</p><pre tabindex=0><code>const CDP = require(&#39;chrome-remote-interface&#39;);

...

launchChrome().then(async chrome =&gt; {
  const version = await CDP.Version({port: chrome.port});
  console.log(version[&#39;User-Agent&#39;]);
});
</code></pre><p>结果是类似这样的东西：<code>HeadlessChrome/60.0.3082.0</code>。</p><p><strong>例子</strong> - 检查网站是否有 <a href=https://developers.google.com/web/fundamentals/engage-and-retain/web-app-manifest/>Web 应用程序清单</a>：</p><pre tabindex=0><code>const CDP = require(&#39;chrome-remote-interface&#39;);

...

(async function() {

const chrome = await launchChrome();
const protocol = await CDP({port: chrome.port});

// Extract the DevTools protocol domains we need and enable them.
// See API docs: https://chromedevtools.github.io/devtools-protocol/
const {Page} = protocol;
await Page.enable();

Page.navigate({url: &#39;https://www.chromestatus.com/&#39;});

// Wait for window.onload before doing stuff.
Page.loadEventFired(async () =&gt; {
  const manifest = await Page.getAppManifest();

  if (manifest.url) {
    console.log(&#39;Manifest: &#39; + manifest.url);
    console.log(manifest.data);
  } else {
    console.log(&#39;Site has no app manifest&#39;);
  }

  protocol.close();
  chrome.kill(); // Kill Chrome.
});

})();
</code></pre><p><strong>例子</strong> - 使用 DOM API 提取页面的 <code>&lt;title></code>：</p><pre tabindex=0><code>const CDP = require(&#39;chrome-remote-interface&#39;);

...

(async function() {

const chrome = await launchChrome();
const protocol = await CDP({port: chrome.port});

// Extract the DevTools protocol domains we need and enable them.
// See API docs: https://chromedevtools.github.io/devtools-protocol/
const {Page, Runtime} = protocol;
await Promise.all([Page.enable(), Runtime.enable()]);

Page.navigate({url: &#39;https://www.chromestatus.com/&#39;});

// Wait for window.onload before doing stuff.
Page.loadEventFired(async () =&gt; {
  const js = &#34;document.querySelector(&#39;title&#39;).textContent&#34;;
  // Evaluate the JS expression in the page.
  const result = await Runtime.evaluate({expression: js});

  console.log(&#39;Title of page: &#39; + result.result.value);

  protocol.close();
  chrome.kill(); // Kill Chrome.
});

})();
</code></pre><h3 id=使用-seleniumwebdriver-和-chromedriver>使用 Selenium、WebDriver 和 ChromeDriver</h3><p>现在，Selenium 开启了 Chrome 的完整实例。换句话说，这是一个自动化的解决方案，但不是完全无需显示的。但是，Selenium 只需要进行小小的配置即可运行 Headless Chrome。如果你想要关于如何自己设置的完整说明，我建议你阅读“<a href=https://intoli.com/blog/running-selenium-with-headless-chrome/>使用 Headless Chrome 来运行 Selenium</a>”，不过你可以从下面的一些示例开始。</p><h4 id=使用-chromedriver>使用 ChromeDriver</h4><p><a href=https://sites.google.com/a/chromium.org/chromedriver/>ChromeDriver</a> 2.3.0 支持 Chrome 59 及更新版本，可与 Headless Chrome 配合使用。在某些情况下，你可能需要等到 Chrome 60 以解决 bug。例如，Chrome 59 中屏幕截图已知存在问题。</p><p>安装：</p><pre tabindex=0><code>yarn add selenium-webdriver chromedriver
</code></pre><p>例子：</p><pre tabindex=0><code>const fs = require(&#39;fs&#39;);
const webdriver = require(&#39;selenium-webdriver&#39;);
const chromedriver = require(&#39;chromedriver&#39;);

// This should be the path to your Canary installation.
// I&#39;m assuming Mac for the example.
const PATH_TO_CANARY = &#39;/Applications/Google Chrome Canary.app/Contents/MacOS/Google Chrome Canary&#39;;

const chromeCapabilities = webdriver.Capabilities.chrome();
chromeCapabilities.set(&#39;chromeOptions&#39;, {
  binary: PATH_TO_CANARY // Screenshots require Chrome 60\. Force Canary.
  &#39;args&#39;: [
    &#39;--headless&#39;,
  ]
});

const driver = new webdriver.Builder()
  .forBrowser(&#39;chrome&#39;)
  .withCapabilities(chromeCapabilities)
  .build();

// Navigate to google.com, enter a search.
driver.get(&#39;https://www.google.com/&#39;);
driver.findElement({name: &#39;q&#39;}).sendKeys(&#39;webdriver&#39;);
driver.findElement({name: &#39;btnG&#39;}).click();
driver.wait(webdriver.until.titleIs(&#39;webdriver - Google Search&#39;), 1000);

// Take screenshot of results page. Save to disk.
driver.takeScreenshot().then(base64png =&gt; {
  fs.writeFileSync(&#39;screenshot.png&#39;, new Buffer(base64png, &#39;base64&#39;));
});

driver.quit();
</code></pre><h4 id=使用-webdriverio>使用 WebDriverIO</h4><p><a href=http://webdriver.io/>WebDriverIO</a> 是一个在 Selenium WebDrive 上构建的更高层次的 API。</p><p>安装：</p><pre tabindex=0><code>yarn add webdriverio chromedriver
</code></pre><p>例子：过滤 chromestatus.com 上的 CSS 功能：</p><pre tabindex=0><code>const webdriverio = require(&#39;webdriverio&#39;);
const chromedriver = require(&#39;chromedriver&#39;);

// This should be the path to your Canary installation.
// I&#39;m assuming Mac for the example.
const PATH_TO_CANARY = &#39;/Applications/Google Chrome Canary.app/Contents/MacOS/Google Chrome Canary&#39;;
const PORT = 9515;

chromedriver.start([
  &#39;--url-base=wd/hub&#39;,
  `--port=${PORT}`,
  &#39;--verbose&#39;
]);

(async () =&gt; {

const opts = {
  port: PORT,
  desiredCapabilities: {
    browserName: &#39;chrome&#39;,
    chromeOptions: {
      binary: PATH_TO_CANARY // Screenshots require Chrome 60\. Force Canary.
      args: [&#39;--headless&#39;]
    }
  }
};

const browser = webdriverio.remote(opts).init();

await browser.url(&#39;https://www.chromestatus.com/features&#39;);

const title = await browser.getTitle();
console.log(`Title: ${title}`);

await browser.waitForText(&#39;.num-features&#39;, 3000);
let numFeatures = await browser.getText(&#39;.num-features&#39;);
console.log(`Chrome has ${numFeatures} total features`);

await browser.setValue(&#39;input[type=&#34;search&#34;]&#39;, &#39;CSS&#39;);
console.log(&#39;Filtering features...&#39;);
await browser.pause(1000);

numFeatures = await browser.getText(&#39;.num-features&#39;);
console.log(`Chrome has ${numFeatures} CSS features`);

const buffer = await browser.saveScreenshot(&#39;screenshot.png&#39;);
console.log(&#39;Saved screenshot...&#39;);

chromedriver.stop();
browser.end();

})();
</code></pre><h3 id=更多资源>更多资源</h3><p>以下是一些可以带你入门的有用资源：</p><p>文档</p><ul><li><a href=https://chromedevtools.github.io/devtools-protocol/>DevTools Protocol Viewer</a> - API 参考文档</li></ul><p>工具</p><ul><li><a href=https://www.npmjs.com/package/chrome-remote-interface>chrome-remote-interface</a> - 基于 DevTools 协议的 node 模块</li><li><a href=https://github.com/GoogleChrome/lighthouse>Lighthouse</a> - 测试 Web 应用程序质量的自动化工具；大量使用了协议</li><li><a href=https://github.com/GoogleChrome/lighthouse/tree/master/chrome-launcher>chrome-launcher</a> - 用于启动 Chrome 的 node 模块，可以自动化</li></ul><p>样例</p><ul><li>&ldquo;<a href=https://paul.kinlan.me/the-headless-web/>The Headless Web</a>&rdquo; - Paul Kinlan 发布的使用了 Headless 和 api.ai 的精彩博客</li></ul><h3 id=常见问题>常见问题</h3><p><strong>我需要 <code>--disable-gpu</code> 标志吗？</strong></p><p>目前是需要的。<code>--disable-gpu</code> 标志在处理一些 bug 时是需要的。在未来版本的 Chrome 中就不需要了。查看 <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=546953#c152">https://crbug.com/546953#c152</a> 和 <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=695212">https://crbug.com/695212</a> 获取更多信息。</p><p><strong>所以我仍然需要 Xvfb 吗？</strong></p><p>不。Headless Chrome 不使用窗口，所以不需要像 Xvfb 这样的显示服务器。没有它你也可以愉快地运行你的自动化测试。</p><p>什么是 Xvfb？Xvfb 是一个用于类 Unix 系统的运行于内存之内的显示服务器，可以让你运行图形应用程序（如 Chrome），而无需附加的物理显示器。许多人使用 Xvfb 运行早期版本的 Chrome 进行 “headless” 测试。</p><p><strong>如何创建一个运行 Headless Chrome 的 Docker 容器？</strong></p><p>查看 <a href=https://github.com/ebidel/lighthouse-ci>lighthouse-ci</a>。它有一个使用 Ubuntu 作为基础镜像的 <a href=https://github.com/ebidel/lighthouse-ci/blob/master/builder/Dockerfile.headless>Dockerfile 示例</a>，并且在 App Engine Flexible 容器中安装和运行了 Lighthouse。</p><p><strong>我可以把它和 Selenium / WebDriver / ChromeDriver 一起使用吗？</strong></p><p>是的。查看 <a href=https://developers.google.com/web/updates/2017/04/headless-chrome#drivers>Using Selenium, WebDrive, or ChromeDriver</a>。</p><p><strong>它和 PhantomJS 有什么关系？</strong></p><p>Headless Chrome 和 <a href=http://phantomjs.org/>PhantomJS</a> 是类似的工具。它们都可以用来在无需显示的环境中进行自动化测试。两者的主要不同在于 Phantom 使用了一个较老版本的 WebKit 作为它的渲染引擎，而 Headless Chrome 使用了最新版本的 Blink。</p><p>目前，Phantom 提供了比 <a href=https://chromedevtools.github.io/devtools-protocol/>DevTools protocol</a> 更高层次的 API。</p><p><strong>我在哪儿提交 bug？</strong></p><p>对于 Headless Chrome 的 bug，请提交到 <a href="https://bugs.chromium.org/p/chromium/issues/entry?components=Blink&amp;blocking=705916&amp;cc=skyostil%40chromium.org&amp;Proj=Headless">crbug.com</a>。</p><p>对于 DevTools 协议的 bug，请提交到 <a href=https://github.com/ChromeDevTools/devtools-protocol/issues/new>github.com/ChromeDevTools/devtools-protocol</a>。</p><hr><p>作者简介</p><p><a href=https://developers.google.com/web/resources/contributors#ericbidelman>Eric Bidelman</a> 谷歌工程师，Lighthouse 开发，Web 和 Web 组件开发，Chrome 开发</p><hr><p>via: <a href=https://developers.google.com/web/updates/2017/04/headless-chrome>https://developers.google.com/web/updates/2017/04/headless-chrome</a></p><p>作者：<a href=https://developers.google.com/web/resources/contributors#ericbidelman>Eric Bidelman</a> 译者：<a href=https://github.com/firmianay>firmianay</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/ rel=tag>浏览器</a></li><li class=tags__item><a class="tags__link btn" href=/tags/chrome/ rel=tag>Chrome</a></li><li class=tags__item><a class="tags__link btn" href=/tags/headless/ rel=tag>Headless</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>