<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>利用 ONLYOFFICE 将在线文档编辑器集成到 Python Web 应用程序中 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="利用 ONLYOFFICE 将在线文档编辑器集成到 Python Web 应用程序中"><meta property="og:description" content="通过 API，开发人员可以将 ONLYOFFICE 编辑器集成到网站和利用程序设计语言编写的应用程序中，并能配置和管理编辑器。"><meta property="og:type" content="article"><meta property="og:url" content="/article-13037-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-01-21T10:49:27+00:00"><meta property="article:modified_time" content="2021-01-21T10:49:27+00:00"><meta itemprop=name content="利用 ONLYOFFICE 将在线文档编辑器集成到 Python Web 应用程序中"><meta itemprop=description content="通过 API，开发人员可以将 ONLYOFFICE 编辑器集成到网站和利用程序设计语言编写的应用程序中，并能配置和管理编辑器。"><meta itemprop=datePublished content="2021-01-21T10:49:27+00:00"><meta itemprop=dateModified content="2021-01-21T10:49:27+00:00"><meta itemprop=wordCount content="699"><meta itemprop=keywords content="ONLYOFFICE,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>利用 ONLYOFFICE 将在线文档编辑器集成到 Python Web 应用程序中</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2021-01-21T10:49:27Z>January 21, 2021</time></div></div></header><div class="content post__content clearfix"><p><img src=https://img.linux.net.cn/data/attachment/album/202101/21/104928pv6l5gcjo8gmzb5l.jpg alt title="Typist composing text in laptop"></p><p><a href=https://www.onlyoffice.com/en/>ONLYOFFICE</a> 是根据 GNU AGPL v.3 许可证条款分发的开源协作办公套件。它包含三个用于文本文档、电子表格和演示文稿的编辑器，并具有以下功能:</p><ul><li>查看，编辑和协同编辑 <code>.docx</code>、<code>.xlsx</code>、<code>.pptx</code> 文件。OOXML 作为一种核心格式，可确保与 Microsoft Word、Excel 和 PowerPoint 文件的高度兼容性。</li><li>通过内部转换为 OOXML，编辑其他流行格式（<code>.odt</code>、<code>.rtf</code>、<code>.txt</code>、<code>.html</code>、<code>.ods</code>、<code>.csv</code>、<code>.odp</code>）。</li><li>熟悉的选项卡式界面。</li><li>协作工具：两种协同编辑模式（快速和严谨），跟踪更改，评论和集成聊天。</li><li>灵活的访问权限管理：完全访问权限、只读、审阅、表单填写和评论。</li><li>使用 API 构建附加组件。</li><li>250 种可用语言和象形字母表。</li></ul><p>通过 API，开发人员可以将 ONLYOFFICE 编辑器集成到网站和利用程序设计语言编写的应用程序中，并能配置和管理编辑器。</p><p>要集成 ONLYOFFICE 编辑器，我们需要一个集成应用程序来连接编辑器（ONLYOFFICE 文档服务器）和服务。 要在你的界面中使用编辑器，因该授予 ONLYOFFICE 以下权限：</p><ul><li>添加并执行自定义代码。</li><li>用于下载和保存文件的匿名访问权限。这意味着编辑器仅与服务器端的服务通信，而不包括客户端的任何用户授权数据（浏览器 cookies）。</li><li>在用户界面添加新按钮（例如，“在 ONLYOFFICE 中打开”、“在 ONLYOFFICE 中编辑”）。</li><li>开启一个新页面，ONLYOFFICE 可以在其中执行脚本以添加编辑器。</li><li>能够指定文档服务器连接设置。</li></ul><p>流行的协作解决方案的成功集成案例有很多，如 Nextcloud、ownCloud、Alfresco、Confluence 和 SharePoint，都是通过 ONLYOFFICE 提供的官方即用型连接器实现的。</p><p>实际的集成案例之一是 ONLYOFFICE 编辑器与以 C＃ 编写的开源协作平台的集成。该平台具有文档和项目管理、CRM、电子邮件聚合器、日历、用户数据库、博客、论坛、调查、Wiki 和即时通讯程序的功能。</p><p>将在线编辑器与 CRM 和项目模块集成，你可以：</p><ul><li>文档关联到 CRM 时机和容器、项目任务和讨论，甚至创建一个单独的文件夹，其中包含与项目相关的文档、电子表格和演示文稿。</li><li>直接在 CRM 或项目模块中创建新的文档、工作表和演示文稿。</li><li>打开和编辑关联的文档，或者下载和删除。</li><li>将联系人从 CSV 文件批量导入到 CRM 中，并将客户数据库导出为 CSV 文件。</li></ul><p>在“邮件”模块中，你可以关联存储在“文档模块”中的文件，或者将指向所需文档的链接插入到邮件正文中。 当 ONLYOFFICE 用户收到带有附件的文档的消息时，他们可以：下载附件、在浏览器中查看文件、打开文件进行编辑或将其保存到“文档模块”。 如上所述，如果格式不同于 OOXML ，则文件将自动转换为 <code>.docx</code>、<code>.xlsx</code>、<code>.pptx</code>，并且其副本也将以原始格式保存。</p><p>在本文中，你将看到 ONLYOFFICE 与最流行的编程语言之一的 Python 编写的文档管理系统的集成过程。 以下步骤将向你展示如何创建所有必要的部分，以使在 DMS（ 文档管理系统 Document Management System ）界面内的文档中可以进行协同工作成为可能：查看、编辑、协同编辑、保存文件和用户访问管理，并可以作为服务的示例集成到 Python 应用程序中。</p><h3 id=1前置需求>1、前置需求</h3><p>首先，创建集成过程的关键组件：<a href=https://www.onlyoffice.com/en/developer-edition.aspx>ONLYOFFICE 文档服务器</a> 和用 Python 编写的文件管理系统。</p><h4 id=11onlyoffice-文档服务器>1.1、ONLYOFFICE 文档服务器</h4><p>要安装 ONLYOFFICE 文档服务器，你可以从多个安装选项中进行选择：编译 GitHub 上可用的源代码，使用 <code>.deb</code> 或 <code>.rpm</code> 软件包亦或 Docker 镜像。</p><p>我们推荐使用下面这条命令利用 Docker 映像安装文档服务器和所有必需的依赖。请注意，选择此方法，你需要安装最新的 Docker 版本。</p><pre tabindex=0><code>docker run -itd -p 80:80 onlyoffice/documentserver-de
</code></pre><h4 id=12利用-python-开发-dms>1.2、利用 Python 开发 DMS</h4><p>如果已经拥有一个，请检查它是否满足以下条件：</p><ul><li>包含需要打开以查看/编辑的保留文件</li><li>允许下载文件</li></ul><p>对于该应用程序，我们将使用 Bottle 框架。我们将使用以下命令将其安装在工作目录中：</p><pre tabindex=0><code>pip install bottle
</code></pre><p>然后我们创建应用程序代码 <code>main.py</code> 和模板 <code>index.tpl</code>。</p><p>我们将以下代码添加到 <code>main.py</code> 文件中：</p><pre tabindex=0><code>from bottle import route, run, template, get, static_file # connecting the framework and the necessary components
@route(&#39;/&#39;) # setting up routing for requests for /
def index():
    return template(&#39;index.tpl&#39;) # showing template in response to request

run(host=&#34;localhost&#34;, port=8080) # running the application on port 8080
</code></pre><p>一旦我们运行该应用程序，点击 <a href=http://localhost:8080>http://localhost:8080</a> 就会在浏览器上呈现一个空白页面 。 为了使文档服务器能够创建新文档，添加默认文件并在模板中生成其名称列表，我们应该创建一个文件夹 <code>files</code> 并将3种类型文件（<code>.docx</code>、<code>.xlsx</code> 和 <code>.pptx</code>）放入其中。</p><p>要读取这些文件的名称，我们使用 <code>listdir</code> 组件（模块）：</p><pre tabindex=0><code>from os import listdir
</code></pre><p>现在让我们为文件夹中的所有文件名创建一个变量：</p><pre tabindex=0><code>sample_files = [f for f in listdir(&#39;files&#39;)]
</code></pre><p>要在模板中使用此变量，我们需要通过 <code>template</code> 方法传递它：</p><pre tabindex=0><code>def index():
    return template(&#39;index.tpl&#39;, sample_files=sample_files)
</code></pre><p>这是模板中的这个变量：</p><pre tabindex=0><code>% for file in sample_files:
  &lt;div&gt;
    &lt;span&gt;{{file}}&lt;/span&gt;
  &lt;/div&gt;
% end
</code></pre><p>我们重新启动应用程序以查看页面上的文件名列表。</p><p>使这些文件可用于所有应用程序用户的方法如下：</p><pre tabindex=0><code>@get(&#34;/files/&lt;filepath:re:.*\.*&gt;&#34;)
def show_sample_files(filepath):
    return static_file(filepath, root=&#34;files&#34;)
</code></pre><h3 id=2查看文档>2、查看文档</h3><p>所有组件准备就绪后，让我们添加函数以使编辑者可以利用应用接口操作。</p><p>第一个选项使用户可以打开和查看文档。连接模板中的文档编辑器 API ：</p><pre tabindex=0><code>&lt;script type=&#34;text/javascript&#34; src=&#34;editor_url/web-apps/apps/api/documents/api.js&#34;&gt;&lt;/script&gt;
</code></pre><p><code>editor_url</code> 是文档编辑器的链接接口。</p><p>打开每个文件以供查看的按钮：</p><pre tabindex=0><code>&lt;button onclick=&#34;view(&#39;files/{{file}}&#39;)&#34;&gt;view&lt;/button&gt;
</code></pre><p>现在我们需要添加带有 <code>id</code> 的 <code>div</code> 标签，打开文档编辑器：</p><pre tabindex=0><code>&lt;div id=&#34;editor&#34;&gt;&lt;/div&gt;
</code></pre><p>要打开编辑器，必须调用调用一个函数：</p><pre tabindex=0><code>&lt;script&gt;
function view(filename) {
    if (/docx$/.exec(filename)) {
        filetype = &#34;text&#34;
    }
    if (/xlsx$/.exec(filename)) {
        filetype = &#34;spreadsheet&#34;
    }
    if (/pptx$/.exec(filename)) {
        filetype = &#34;presentation&#34;,
        title: filename
    }
​
    new DocsAPI.DocEditor(&#34;editor&#34;,
        {
            documentType: filetype,
            document: {
                url: &#34;host_url&#34; + &#39;/&#39; + filename,
                title: filename
            },
            editorConfig: {mode: &#39;view&#39;}
        });
  }
&lt;/script&gt;
</code></pre><p>DocEditor 函数有两个参数：将在其中打开编辑器的元素 <code>id</code> 和带有编辑器设置的 <code>JSON</code>。 在此示例中，使用了以下必需参数：</p><ul><li><code>documentType</code> 由其格式标识（<code>.docx</code>、<code>.xlsx</code>、<code>.pptx</code> 用于相应的文本、电子表格和演示文稿）</li><li><code>document.url</code> 是你要打开的文件链接。</li><li><code>editorConfig.mode</code>。</li></ul><p>我们还可以添加将在编辑器中显示的 <code>title</code>。</p><p>接下来，我们可以在 Python 应用程序中查看文档。</p><h3 id=3编辑文档>3、编辑文档</h3><p>首先，添加 “Edit”（编辑）按钮：</p><pre tabindex=0><code>&lt;button onclick=&#34;edit(&#39;files/{{file}}&#39;)&#34;&gt;edit&lt;/button&gt;
</code></pre><p>然后创建一个新功能，打开文件进行编辑。类似于查看功能。</p><p>现在创建 3 个函数：</p><pre tabindex=0><code>&lt;script&gt;
    var editor;
    function view(filename) {
        if (editor) {
            editor.destroyEditor()
        }
        editor = new DocsAPI.DocEditor(&#34;editor&#34;,
            {
                documentType: get_file_type(filename),
                document: {
                    url: &#34;host_url&#34; + &#39;/&#39; + filename,
                    title: filename
                },
                editorConfig: {mode: &#39;view&#39;}
            });
    }

    function edit(filename) {
        if (editor) {
            editor.destroyEditor()
        }
        editor = new DocsAPI.DocEditor(&#34;editor&#34;,
            {
                documentType: get_file_type(filename),
                document: {
                    url: &#34;host_url&#34; + &#39;/&#39; + filename,
                    title: filename
                }
            });
    }

    function get_file_type(filename) {
        if (/docx$/.exec(filename)) {
            return &#34;text&#34;
        }
        if (/xlsx$/.exec(filename)) {
            return &#34;spreadsheet&#34;
        }
        if (/pptx$/.exec(filename)) {
            return &#34;presentation&#34;
        }
    }
&lt;/script&gt;
</code></pre><p><code>destroyEditor</code> 被调用以关闭一个打开的编辑器。</p><p>你可能会注意到，<code>edit()</code> 函数中缺少 <code>editorConfig</code> 参数，因为默认情况下它的值是：<code>{"mode":"edit"}</code>。</p><p>现在，我们拥有了打开文档以在 Python 应用程序中进行协同编辑的所有功能。</p><h3 id=4如何在-python-应用中利用-onlyoffice-协同编辑文档>4、如何在 Python 应用中利用 ONLYOFFICE 协同编辑文档</h3><p>通过在编辑器中设置对同一文档使用相同的 <code>document.key</code> 来实现协同编辑。 如果没有此键值，则每次打开文件时，编辑器都会创建编辑会话。</p><p>为每个文档设置唯一键，以使用户连接到同一编辑会话时进行协同编辑。 密钥格式应为以下格式：<code>filename +"_key"</code>。下一步是将其添加到当前文档的所有配置中。</p><pre tabindex=0><code>document: {
    url: &#34;host_url&#34; + &#39;/&#39; + filepath,
    title: filename,
    key: filename + &#39;_key&#39;
},
</code></pre><h3 id=5如何在-python-应用中利用-onlyoffice-保存文档>5、如何在 Python 应用中利用 ONLYOFFICE 保存文档</h3><p>每次我们更改并保存文件时，ONLYOFFICE 都会存储其所有版本。 让我们仔细看看它是如何工作的。 关闭编辑器后，文档服务器将构建要保存的文件版本并将请求发送到 <code>callbackUrl</code> 地址。 该请求包含 <code>document.key</code>和指向刚刚构建的文件的链接。</p><p><code>document.key</code> 用于查找文件的旧版本并将其替换为新版本。 由于这里没有任何数据库，因此仅使用 <code>callbackUrl</code> 发送文件名。</p><p>在 <code>editorConfig.callbackUrl</code> 的设置中指定 <code>callbackUrl</code> 参数并将其添加到 <code>edit()</code> 方法中：</p><pre tabindex=0><code> function edit(filename) {
        const filepath = &#39;files/&#39; + filename;
        if (editor) {
            editor.destroyEditor()
        }
        editor = new DocsAPI.DocEditor(&#34;editor&#34;,
            {
                documentType: get_file_type(filepath),
                document: {
                    url: &#34;host_url&#34; + &#39;/&#39; + filepath,
                    title: filename, 
                    key: filename + &#39;_key&#39;
                }
                ,
                editorConfig: {
                    mode: &#39;edit&#39;,
                    callbackUrl: &#34;host_url&#34; + &#39;/callback&#39; + &#39;&amp;amp;filename=&#39; + filename  // add file name as a request parameter
                }
            });
    }
</code></pre><p>编写一种方法，在获取到 POST 请求发送到 <code>/callback</code> 地址后将保存文件：</p><pre tabindex=0><code>@post(&#34;/callback&#34;) # processing post requests for /callback
def callback():
    if request.json[&#39;status&#39;] == 2:
        file = requests.get(request.json[&#39;url&#39;]).content
        with open(&#39;files/&#39; + request.query[&#39;filename&#39;], &#39;wb&#39;) as f:
            f.write(file)
    return &#34;{\&#34;error\&#34;:0}&#34;
​
</code></pre><p><code># status 2</code> 是已生成的文件，当我们关闭编辑器时，新版本的文件将保存到存储器中。</p><h3 id=6管理用户>6、管理用户</h3><p>如果应用中有用户，并且你需要查看谁在编辑文档，请在编辑器的配置中输入其标识符（<code>id</code>和<code>name</code>）。</p><p>在界面中添加选择用户的功能：</p><pre tabindex=0><code>&lt;select id=&#34;user_selector&#34; onchange=&#34;pick_user()&#34;&gt;
    &lt;option value=&#34;1&#34; selected=&#34;selected&#34;&gt;JD&lt;/option&gt;
    &lt;option value=&#34;2&#34;&gt;Turk&lt;/option&gt;
    &lt;option value=&#34;3&#34;&gt;Elliot&lt;/option&gt;
    &lt;option value=&#34;4&#34;&gt;Carla&lt;/option&gt;
&lt;/select&gt;
</code></pre><p>如果在标记 <code>&lt;script></code> 的开头添加对函数 <code>pick_user()</code> 的调用，负责初始化函数自身 <code>id</code> 和 <code>name</code> 变量。</p><pre tabindex=0><code>function pick_user() {
    const user_selector = document.getElementById(&#34;user_selector&#34;);
    this.current_user_name = user_selector.options[user_selector.selectedIndex].text;
    this.current_user_id = user_selector.options[user_selector.selectedIndex].value;
}
</code></pre><p>使用 <code>editorConfig.user.id</code> 和 <code>editorConfig.user.name</code> 来配置用户设置。将这些参数添加到文件编辑函数中的编辑器配置中。</p><pre tabindex=0><code>function edit(filename) {
    const filepath = &#39;files/&#39; + filename;
    if (editor) {
        editor.destroyEditor()
    }
    editor = new DocsAPI.DocEditor(&#34;editor&#34;,
        {
            documentType: get_file_type(filepath),
            document: {
                url: &#34;host_url&#34; + &#39;/&#39; + filepath,
                title: filename
            },
            editorConfig: {
                mode: &#39;edit&#39;,
                callbackUrl: &#34;host_url&#34; + &#39;/callback&#39; + &#39;?filename=&#39; + filename,
                user: {
                    id: this.current_user_id,
                    name: this.current_user_name
                }
            }
        });
}
</code></pre><p>使用这种方法，你可以将 ONLYOFFICE 编辑器集成到用 Python 编写的应用程序中，并获得用于在文档上进行协同工作的所有必要工具。有关更多集成示例（Java、Node.js、PHP、Ruby），请参考官方的 <a href=https://api.onlyoffice.com/editors/basic>API 文档</a>。</p><hr><p>via: <a href=https://opensourceforu.com/2019/09/integrate-online-documents-editors-into-a-python-web-app-using-onlyoffice/>https://opensourceforu.com/2019/09/integrate-online-documents-editors-into-a-python-web-app-using-onlyoffice/</a></p><p>作者：<a href=https://opensourceforu.com/author/aashima-sharma/>Aashima Sharma</a> 选题：<a href=https://github.com/lujun9972>lujun9972</a> 译者：<a href=https://github.com/stevenzdg988>stevenzdg988</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/onlyoffice/ rel=tag>ONLYOFFICE</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>