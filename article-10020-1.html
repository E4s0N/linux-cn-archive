<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>8 个用于有效地管理进程的 Linux 命令 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="8 个用于有效地管理进程的 Linux 命令"><meta property="og:description" content="通过这些关键的命令来全程管理你的应用。"><meta property="og:type" content="article"><meta property="og:url" content="/article-10020-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-09-16T22:53:23+00:00"><meta property="article:modified_time" content="2018-09-16T22:53:23+00:00"><meta itemprop=name content="8 个用于有效地管理进程的 Linux 命令"><meta itemprop=description content="通过这些关键的命令来全程管理你的应用。"><meta itemprop=datePublished content="2018-09-16T22:53:23+00:00"><meta itemprop=dateModified content="2018-09-16T22:53:23+00:00"><meta itemprop=wordCount content="941"><meta itemprop=keywords content="进程,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>8 个用于有效地管理进程的 Linux 命令</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2018-09-16T22:53:23Z>September 16, 2018</time></div></div></header><div class="content post__content clearfix"><blockquote><p>通过这些关键的命令来全程管理你的应用。</p></blockquote><p><img src=/data/attachment/album/201809/16/225342dggc8idpid9mpp85.png alt></p><p>一般来说，应用程序进程的生命周期有三种主要状态：启动、运行和停止。如果我们想成为称职的管理员，每个状态都可以而且应该得到认真的管理。这八个命令可用于管理进程的整个生命周期。</p><h3 id=启动进程>启动进程</h3><p>启动进程的最简单方法是在命令行中键入其名称，然后按回车键。如果要启动 Nginx web 服务器，请键入 <code>nginx</code> 。也许您只是想看看其版本。</p><pre tabindex=0><code>alan@workstation:~$ nginx

alan@workstation:~$ nginx -v
nginx version: nginx/1.14.0
</code></pre><h3 id=查看您的可执行路径>查看您的可执行路径</h3><p>以上启动进程的演示是假设可执行文件位于您的可执行路径中。理解这个路径是可靠地启动和管理进程的关键。管理员通常会为他们想要的目的定制这条路径。您可以使用 <code>echo $PATH</code> 查看您的可执行路径。</p><pre tabindex=0><code>alan@workstation:~$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin
</code></pre><h4 id=which>WHICH</h4><p>使用 <code>which</code> 命令查看可执行文件的完整路径。</p><pre tabindex=0><code>alan@workstation:~$ which nginx
/opt/nginx/bin/nginx
</code></pre><p>我将使用流行的 web 服务器软件 Nginx 作为我的例子。假设安装了 Nginx。如果执行 <code>which nginx</code> 的命令什么也不返回，那么是找不到 Nginx 了，因为它只搜索您指定的可执行路径。有三种方法可以补救一个进程不能简单地通过名字启动的情况。首先是键入完整路径 —— 虽然，我不情愿输入全部路径，您会吗？</p><pre tabindex=0><code>alan@workstation:~$ /home/alan/web/prod/nginx/sbin/nginx -v
nginx version: nginx/1.14.0
</code></pre><p>第二个解决方案是将应用程序安装在可执行文件路径中的目录中。然而，这有时可能是办不到的，特别是如果您没有 root 权限。</p><p>第三个解决方案是更新您的可执行路径环境变量，包括要使用的特定应用程序的安装目录。这个解决方案是与 shell 相关的。例如，Bash 用户需要在他们的 <code>.bashrc</code> 文件中编辑 <code>PATH=</code> 行。</p><pre tabindex=0><code>PATH=&#34;$HOME/web/prod/nginx/sbin:$PATH&#34;
</code></pre><p>现在，重复您的 <code>echo</code> 和 <code>which</code> 命令或者尝试检查版本。容易多了！</p><pre tabindex=0><code>alan@workstation:~$ echo $PATH
/home/alan/web/prod/nginx/sbin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin

alan@workstation:~$ which nginx
/home/alan/web/prod/nginx/sbin/nginx

alan@workstation:~$ nginx -v                                                
nginx version: nginx/1.14.0
</code></pre><h3 id=保持进程运行>保持进程运行</h3><h4 id=nohup>NOHUP</h4><p>注销或关闭终端时，进程可能不会继续运行。这种特殊情况可以通过在要使用 <code>nohup</code> 命令放在要运行的命令前面让进程持续运行。此外，附加一个<code>&</code> 符号将会把进程发送到后台，并允许您继续使用终端。例如，假设您想运行 <code>myprogram.sh</code> 。</p><pre tabindex=0><code>nohup myprogram.sh &amp;
</code></pre><p><code>nohup</code> 会返回运行进程的 PID。接下来我会更多地谈论 PID。</p><h3 id=管理正在运行的进程>管理正在运行的进程</h3><p>每个进程都有一个唯一的进程标识号 (PID) 。这个数字是我们用来管理每个进程的。我们还可以使用进程名称，我将在下面演示。有几个命令可以检查正在运行的进程的状态。让我们快速看看这些命令。</p><h4 id=ps>PS</h4><p>最常见的是 <code>ps</code> 命令。<code>ps</code> 的默认输出是当前终端中运行的进程的简单列表。如下所示，第一列包含 PID。</p><pre tabindex=0><code>alan@workstation:~$ ps
PID TTY          TIME CMD
23989 pts/0    00:00:00 bash
24148 pts/0    00:00:00 ps
</code></pre><p>我想看看我之前启动的 Nginx 进程。为此，我告诉 <code>ps</code> 给我展示每一个正在运行的进程（<code>-e</code>）和完整的列表（<code>-f</code>）。</p><pre tabindex=0><code>alan@workstation:~$ ps -ef
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 Aug18 ?        00:00:10 /sbin/init splash
root         2     0  0 Aug18 ?        00:00:00 [kthreadd]
root         4     2  0 Aug18 ?        00:00:00 [kworker/0:0H]
root         6     2  0 Aug18 ?        00:00:00 [mm_percpu_wq]
root         7     2  0 Aug18 ?        00:00:00 [ksoftirqd/0]
root         8     2  0 Aug18 ?        00:00:20 [rcu_sched]
root         9     2  0 Aug18 ?        00:00:00 [rcu_bh]
root        10     2  0 Aug18 ?        00:00:00 [migration/0]
root        11     2  0 Aug18 ?        00:00:00 [watchdog/0]
root        12     2  0 Aug18 ?        00:00:00 [cpuhp/0]
root        13     2  0 Aug18 ?        00:00:00 [cpuhp/1]
root        14     2  0 Aug18 ?        00:00:00 [watchdog/1]
root        15     2  0 Aug18 ?        00:00:00 [migration/1]
root        16     2  0 Aug18 ?        00:00:00 [ksoftirqd/1]
alan     20506 20496  0 10:39 pts/0    00:00:00 bash
alan     20520  1454  0 10:39 ?        00:00:00 nginx: master process nginx
alan     20521 20520  0 10:39 ?        00:00:00 nginx: worker process
alan     20526 20506  0 10:39 pts/0    00:00:00 man ps
alan     20536 20526  0 10:39 pts/0    00:00:00 pager
alan     20564 20496  0 10:40 pts/1    00:00:00 bash
</code></pre><p>您可以在上面 <code>ps</code> 命令的输出中看到 Nginx 进程。这个命令显示了将近 300 行，但是我在这个例子中缩短了它。可以想象，试图处理 300 行过程信息有点混乱。我们可以将这个输出输送到 <code>grep</code>，过滤一下仅显示 nginx。</p><pre tabindex=0><code>alan@workstation:~$ ps -ef |grep nginx
alan     20520  1454  0 10:39 ?        00:00:00 nginx: master process nginx
alan     20521 20520  0 10:39 ?        00:00:00 nginx: worker process
</code></pre><p>确实更好了。我们可以很快看到，Nginx 有 20520 和 20521 的 PID。</p><h4 id=pgrep>PGREP</h4><p><code>pgrep</code> 命令更加简化单独调用 <code>grep</code> 遇到的问题。</p><pre tabindex=0><code>alan@workstation:~$ pgrep nginx
20520
20521
</code></pre><p>假设您在一个托管环境中，多个用户正在运行几个不同的 Nginx 实例。您可以使用 <code>-u</code> 选项将其他人排除在输出之外。</p><pre tabindex=0><code>alan@workstation:~$ pgrep -u alan nginx
20520
20521
</code></pre><h4 id=pidof>PIDOF</h4><p>另一个好用的是 <code>pidof</code>。此命令将检查特定二进制文件的 PID，即使另一个同名进程正在运行。为了建立一个例子，我将我的 Nginx 复制到第二个目录，并以相应的路径前缀启动。在现实生活中，这个实例可能位于不同的位置，例如由不同用户拥有的目录。如果我运行两个 Nginx 实例，则<code>pidof</code> 输出显示它们的所有进程。</p><pre tabindex=0><code>alan@workstation:~$ ps -ef |grep nginx
alan     20881  1454  0 11:18 ?        00:00:00 nginx: master process ./nginx -p /home/alan/web/prod/nginxsec
alan     20882 20881  0 11:18 ?        00:00:00 nginx: worker process
alan     20895  1454  0 11:19 ?        00:00:00 nginx: master process nginx
alan     20896 20895  0 11:19 ?        00:00:00 nginx: worker process
</code></pre><p>使用 <code>grep</code> 或 <code>pgrep</code> 将显示 PID 数字，但我们可能无法辨别哪个实例是哪个。</p><pre tabindex=0><code>alan@workstation:~$ pgrep nginx
20881
20882
20895
20896
</code></pre><p><code>pidof</code> 命令可用于确定每个特定 Nginx 实例的 PID。</p><pre tabindex=0><code>alan@workstation:~$ pidof /home/alan/web/prod/nginxsec/sbin/nginx
20882 20881

alan@workstation:~$ pidof /home/alan/web/prod/nginx/sbin/nginx
20896 20895
</code></pre><h4 id=top>TOP</h4><p><code>top</code> 命令已经有很久的历史了，对于查看运行进程的细节和快速识别内存消耗等问题是非常有用的。其默认视图如下所示。</p><pre tabindex=0><code>top - 11:56:28 up 1 day, 13:37,  1 user,  load average: 0.09, 0.04, 0.03
Tasks: 292 total,   3 running, 225 sleeping,   0 stopped,   0 zombie
%Cpu(s):  0.1 us,  0.2 sy,  0.0 ni, 99.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem : 16387132 total, 10854648 free,  1859036 used,  3673448 buff/cache
KiB Swap:        0 total,        0 free,        0 used. 14176540 avail Mem

  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
17270 alan      20   0 3930764 247288  98992 R   0.7  1.5   5:58.22 gnome-shell
20496 alan      20   0  816144  45416  29844 S   0.5  0.3   0:22.16 gnome-terminal-
21110 alan      20   0   41940   3988   3188 R   0.1  0.0   0:00.17 top
    1 root      20   0  225564   9416   6768 S   0.0  0.1   0:10.72 systemd
    2 root      20   0       0      0      0 S   0.0  0.0   0:00.01 kthreadd
    4 root       0 -20       0      0      0 I   0.0  0.0   0:00.00 kworker/0:0H
    6 root       0 -20       0      0      0 I   0.0  0.0   0:00.00 mm_percpu_wq
    7 root      20   0       0      0      0 S   0.0  0.0   0:00.08 ksoftirqd/0
</code></pre><p>可以通过键入字母 <code>s</code> 和您喜欢的更新秒数来更改更新间隔。为了更容易监控我们的示例 Nginx 进程，我们可以使用 <code>-p</code> 选项并传递 PID 来调用 <code>top</code>。这个输出要干净得多。</p><pre tabindex=0><code>alan@workstation:~$ top -p20881 -p20882 -p20895 -p20896

Tasks:   4 total,   0 running,   4 sleeping,   0 stopped,   0 zombie
%Cpu(s):  2.8 us,  1.3 sy,  0.0 ni, 95.9 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem : 16387132 total, 10856008 free,  1857648 used,  3673476 buff/cache
KiB Swap:        0 total,        0 free,        0 used. 14177928 avail Mem

  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
20881 alan      20   0   12016    348      0 S   0.0  0.0   0:00.00 nginx
20882 alan      20   0   12460   1644    932 S   0.0  0.0   0:00.00 nginx
20895 alan      20   0   12016    352      0 S   0.0  0.0   0:00.00 nginx
20896 alan      20   0   12460   1628    912 S   0.0  0.0   0:00.00 nginx
</code></pre><p>在管理进程，特别是终止进程时，正确确定 PID 是非常重要。此外，如果以这种方式使用 <code>top</code>，每当这些进程中的一个停止或一个新进程开始时，<code>top</code> 都需要被告知有新的进程。</p><h3 id=终止进程>终止进程</h3><h4 id=kill>KILL</h4><p>有趣的是，没有 <code>stop</code> 命令。在 Linux 中，有 <code>kill</code> 命令。<code>kill</code> 用于向进程发送信号。最常用的信号是“终止”（<code>SIGTERM</code>）或“杀死”（<code>SIGKILL</code>）。然而，还有更多。下面是一些例子。完整的列表可以用 <code>kill -L</code> 显示。</p><pre tabindex=0><code> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP
 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1
11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM
</code></pre><p>注意第 9 号信号是 <code>SIGKILL</code>，通常，我们会发出比如 <code>kill -9 20896</code> 这样的命令。默认信号是 15，这是 <code>SIGTERM</code>。请记住，许多应用程序都有自己的停止方法。Nginx 使用 <code>-s</code> 选项传递信号，如 <code>stop</code> 或 <code>reload</code>。通常，我更喜欢使用应用程序的特定方法来停止操作。然而，我将演示用 <code>kill</code> 命令来停止 Nginx 进程 20896，然后用 <code>pgrep</code> 确认它已经停止。PID 20896 就不再出现。</p><pre tabindex=0><code>alan@workstation:~$ kill -9 20896
 
alan@workstation:~$ pgrep nginx
20881
20882
20895
22123
</code></pre><h4 id=pkill>PKILL</h4><p>命令 <code>pkill</code> 类似于 <code>pgrep</code>，因为它可以按名称搜索。这意味着在使用 <code>pkill</code> 时必须非常小心。在我的 Nginx 示例中，如果我只想杀死一个 Nginx 实例，我可能不会选择使用它。我可以将 Nginx 选项 <code>-s stop</code> 传递给特定的实例来消除它，或者我需要使用 <code>grep</code> 来过滤整个 <code>ps</code> 输出。</p><pre tabindex=0><code>/home/alan/web/prod/nginx/sbin/nginx -s stop
/home/alan/web/prod/nginxsec/sbin/nginx -s stop
</code></pre><p>如果我想使用 <code>pkill</code>，我可以包括 <code>-f</code> 选项，让 <code>pkill</code> 过滤整个命令行参数。这当然也适用于 <code>pgrep</code>。所以，在执行 <code>pkill -f</code> 之前，首先我可以用 <code>pgrep -a</code> 确认一下。</p><pre tabindex=0><code>alan@workstation:~$ pgrep -a nginx
20881 nginx: master process ./nginx -p /home/alan/web/prod/nginxsec
20882 nginx: worker process
20895 nginx: master process nginx
20896 nginx: worker process
</code></pre><p>我也可以用 <code>pgrep -f</code> 缩小我的结果。<code>pkill</code> 使用相同参数会停止该进程。</p><pre tabindex=0><code>alan@workstation:~$ pgrep -f nginxsec
20881
                                           
alan@workstation:~$ pkill -f nginxsec
</code></pre><p><code>pgrep</code>（尤其是 <code>pkill</code>）要记住的关键点是，您必须始终确保搜索结果准确性，这样您就不会无意中影响到错误的进程。</p><p>大多数这些命令都有许多命令行选项，所以我总是建议阅读每一个命令的 <a href=https://www.kernel.org/doc/man-pages/>man 手册页</a>。虽然大多数这些命令都存在于 Linux、Solaris 和 BSD 等平台上，但也有一些不同之处。在命令行工作或编写脚本时，始终测试并随时准备根据需要进行更正。</p><hr><p>via: <a href=https://opensource.com/article/18/9/linux-commands-process-management>https://opensource.com/article/18/9/linux-commands-process-management</a></p><p>作者：<a href=https://opensource.com/users/alanfdoss>Alan Formy-Duval</a> 选题：<a href=https://github.com/lujun9972>lujun9972</a> 译者：<a href=https://github.com/heguangzhi>heguangzhi</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/%E8%BF%9B%E7%A8%8B/ rel=tag>进程</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>