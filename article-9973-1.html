<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>全面教程：在 RxJS 中创建流 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="全面教程：在 RxJS 中创建流"><meta property="og:description" content="有些时候，混用响应式和非响应式代码似乎很有用。然后大家就开始热衷流的创造。不论是在编写异步代码或者是数据处理时，流都是一个不错的方案。"><meta property="og:type" content="article"><meta property="og:url" content="/article-9973-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-09-01T22:59:02+00:00"><meta property="article:modified_time" content="2018-09-01T22:59:02+00:00"><meta itemprop=name content="全面教程：在 RxJS 中创建流"><meta itemprop=description content="有些时候，混用响应式和非响应式代码似乎很有用。然后大家就开始热衷流的创造。不论是在编写异步代码或者是数据处理时，流都是一个不错的方案。"><meta itemprop=datePublished content="2018-09-01T22:59:02+00:00"><meta itemprop=dateModified content="2018-09-01T22:59:02+00:00"><meta itemprop=wordCount content="1328"><meta itemprop=keywords content="stream,RxJS,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>全面教程：在 RxJS 中创建流</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2018-09-01T22:59:02Z>September 01, 2018</time></div></div></header><div class="content post__content clearfix"><p><img src=/data/attachment/album/201809/01/225906f2vnvoglzjzmn37l.jpg alt></p><p>对大多数开发者来说，与 RxJS 的初次接触是通过库的形式，就像 Angular。一些函数会返回 流 stream ，要使用它们就得把注意力放在操作符上。</p><p>有些时候，混用响应式和非响应式代码似乎很有用。然后大家就开始热衷流的创造。不论是在编写异步代码或者是数据处理时，流都是一个不错的方案。</p><p>RxJS 提供很多方式来创建流。不管你遇到的是什么情况，都会有一个完美的创建流的方式。你可能根本用不上它们，但了解它们可以节省你的时间，让你少码一些代码。</p><p>我把所有可能的方法，按它们的主要目的，放在四个分类当中：</p><ul><li>流式化现有数据</li><li>生成数据</li><li>使用现有 API 进行交互</li><li>选择现有的流，并结合起来</li></ul><p>注意：示例用的是 RxJS 6，可能会以前的版本有所不同。已知的区别是你导入函数的方式不同了。</p><p>RxJS 6</p><pre tabindex=0><code>import {of, from} from &#39;rxjs&#39;;

of(...);
from(...);
</code></pre><p>RxJS &lt; 6</p><pre tabindex=0><code>import { Observable } from &#39;rxjs/Observable&#39;;
import &#39;rxjs/add/observable/of&#39;;
import &#39;rxjs/add/observable/from&#39;;

Observable.of(...);
Observable.from(...);

//或

import { of } from &#39;rxjs/observable/of&#39;;
import { from } from &#39;rxjs/observable/from&#39;;

of(...);
from(...);
</code></pre><p>流的图示中的标记：</p><ul><li><code>|</code> 表示流结束了</li><li><code>X</code> 表示流出现错误并被终结</li><li><code>...</code> 表示流的走向不定</li></ul><h3 id=流式化已有数据>流式化已有数据</h3><p>你有一些数据，想把它们放到流中。有三种方式，并且都允许你把调度器当作最后一个参数传入（你如果想深入了解调度器，可以看看我的 <a href=https://itnext.io/concurrency-and-asynchronous-behavior-with-rxjs-11b0c4b22597>上一篇文章</a>）。这些生成的流都是静态的。</p><h4 id=of>of</h4><p>如果只有一个或者一些不同的元素，使用 <code>of</code>：</p><pre tabindex=0><code>of(1,2,3)
  .subscribe();
</code></pre><pre tabindex=0><code>// 结果
// 1 2 3 |
</code></pre><h4 id=from>from</h4><p>如果有一个数组或者 <em>可迭代的对象</em> ，而且你想要其中的所有元素发送到流中，使用 <code>from</code>。你也可以用它来把一个 promise 对象变成可观测的。</p><pre tabindex=0><code>const foo = [1,2,3];

from(foo)
  .subscribe();
</code></pre><pre tabindex=0><code>// 结果
// 1 2 3 |
</code></pre><h4 id=pairs>pairs</h4><p>流式化一个对象的键/值对。用这个对象表示字典时特别有用。</p><pre tabindex=0><code>const foo = { a: 1, b: 2};

pairs(foo)
  .subscribe();
</code></pre><pre tabindex=0><code>// 结果
// [a,1] [b,2] |
</code></pre><h4 id=那么其他的数据结构呢>那么其他的数据结构呢？</h4><p>也许你的数据存储在自定义的结构中，而它又没有实现 <em>可迭代的对象</em> 接口，又或者说你的结构是递归的、树状的。也许下面某种选择适合这些情况：</p><ol><li>先将数据提取到数组里</li><li>使用下一节将会讲到的 <code>generate</code> 函数，遍历所有数据</li><li>创建一个自定义流（见下一节）</li><li>创建一个迭代器</li></ol><p>稍后会讲到选项 2 和 3 ，因此这里的重点是创建一个迭代器。我们可以对一个 <em>可迭代的对象</em> 调用 <code>from</code> 创建一个流。 <em>可迭代的对象</em> 是一个对象，可以产生一个迭代器（如果你对细节感兴趣，参考 <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols>这篇 mdn 文章</a>）。</p><p>创建一个迭代器的简单方式是 生成函数 generator function 。当你调用一个生成函数时，它返回一个对象，该对象同时遵循 <em>可迭代的对象</em> 接口和 <em>迭代器</em> 接口。</p><pre tabindex=0><code>// 自定义的数据结构
class List {
  add(element) ...
  get(index) ...
  get size() ...
  ...
}

function* listIterator(list) {
  for (let i = 0; i&lt;list.size; i++) {
    yield list.get(i);
  }
}

const myList = new List();
myList.add(1);
myList.add(3);

from(listIterator(myList))
  .subscribe(console.log);
</code></pre><pre tabindex=0><code>// 结果
// 1 3 |    
</code></pre><p>调用 <code>listIterator</code> 函数时，返回值是一个 <em>可迭代的对象</em> / <em>迭代器</em> 。函数里面的代码在调用 <code>subscribe</code> 前不会执行。</p><h3 id=生成数据>生成数据</h3><p>你知道要发送哪些数据，但想（或者必须）动态生成它。所有函数的最后一个参数都可以用来接收一个调度器。他们产生静态的流。</p><h4 id=范围range>范围（<code>range</code>）</h4><p>从初始值开始，发送一系列数字，直到完成了指定次数的迭代。</p><pre tabindex=0><code>range(10, 2)  // 从 10 开始，发送两个值
  .subscribe();
</code></pre><pre tabindex=0><code>// 结果
// 10 11 |
</code></pre><h4 id=间隔interval--定时器timer>间隔（<code>interval</code>） / 定时器（<code>timer</code>）</h4><p>有点像范围，但定时器是周期性的发送累加的数字（就是说，不是立即发送）。两者的区别在于在于定时器允许你为第一个元素设定一个延迟。也可以只产生一个值，只要不指定周期。</p><pre tabindex=0><code>interval(1000) // 每 1000ms = 1 秒 发送数据
  .subscribe()
</code></pre><pre tabindex=0><code>// 结果
// 0  1  2  3  4 ...
</code></pre><pre tabindex=0><code>delay(5000, 1000) // 和上面相同，在开始前先等待 5000ms

delay(5000)
.subscribe(i =&gt; console.log(&#34;foo&#34;);
// 5 秒后打印 foo
</code></pre><p>大多数定时器将会用来周期性的处理数据：</p><pre tabindex=0><code>interval(10000).pipe(
  flatMap(i =&gt; fetch(&#34;https://server/stockTicker&#34;)
).subscribe(updateChart)
</code></pre><p>这段代码每 10 秒获取一次数据，更新屏幕。</p><h4 id=生成generate>生成（<code>generate</code>）</h4><p>这是个更加复杂的函数，允许你发送一系列任意类型的对象。它有一些重载，这里你看到的是最有意思的部分：</p><pre tabindex=0><code>generate(
  0,           // 从这个值开始
  x =&gt; x &lt; 10, // 条件：只要值小于 10，就一直发送
  x =&gt; x*2     // 迭代：前一个值加倍
).subscribe();
</code></pre><pre tabindex=0><code>// 结果
// 1 2 4 8 |
</code></pre><p>你也可以用它来迭代值，如果一个结构没有实现 <em>可迭代的对象</em> 接口。我们用前面的列表例子来进行演示：</p><pre tabindex=0><code>const myList = new List();
myList.add(1);
myList.add(3);

generate(
  0,                  // 从这个值开始
  i =&gt; i &lt; list.size, // 条件：发送数据，直到遍历完整个列表
  i =&gt; ++i,           // 迭代：获取下一个索引
  i =&gt; list.get(i)    // 选择器：从列表中取值
).subscribe();
</code></pre><pre tabindex=0><code>// 结果
// 1 3 |
</code></pre><p>如你所见，我添加了另一个参数：选择器。它和 <code>map</code> 操作符作用类似，将生成的值转换为更有用的东西。</p><h3 id=空的流>空的流</h3><p>有时候你要传递或返回一个不用发送任何数据的流。有三个函数分别用于不同的情况。你可以给这三个函数传递调度器。<code>empty</code> 和 <code>throwError</code> 接收一个调度器参数。</p><h4 id=empty><code>empty</code></h4><p>创建一个空的流，一个值也不发送。</p><pre tabindex=0><code>empty()
  .subscribe();
</code></pre><pre tabindex=0><code>// 结果
// |
</code></pre><h4 id=never><code>never</code></h4><p>创建一个永远不会结束的流，仍然不发送值。</p><pre tabindex=0><code>never()
  .subscribe();
</code></pre><pre tabindex=0><code>// 结果
// ...
</code></pre><h4 id=throwerror><code>throwError</code></h4><p>创建一个流，流出现错误，不发送数据。</p><pre tabindex=0><code>throwError(&#39;error&#39;)
  .subscribe();
</code></pre><pre tabindex=0><code>// 结果
// X
</code></pre><h3 id=挂钩已有的-api>挂钩已有的 API</h3><p>不是所有的库和所有你之前写的代码使用或者支持流。幸运的是 RxJS 提供函数用来桥接非响应式和响应式代码。这一节仅仅讨论 RxJS 为桥接代码提供的模版。</p><p>你可能还对这篇出自 <a href=https://medium.com/@benlesh>Ben Lesh</a> 的 <a href=https://medium.com/@benlesh/rxjs-observable-interop-with-promises-and-async-await-bebb05306875>全面的文章</a> 感兴趣，这篇文章讲了几乎所有能与 promises 交互操作的方式。</p><h4 id=from-1><code>from</code></h4><p>我们已经用过它，把它列在这里是因为，它可以封装一个含有 observable 对象的 promise 对象。</p><pre tabindex=0><code>from(new Promise(resolve =&gt; resolve(1)))
  .subscribe();
</code></pre><pre tabindex=0><code>// 结果
// 1 |
</code></pre><h4 id=fromevent>fromEvent</h4><p>fromEvent 为 DOM 元素添加一个事件监听器，我确定你知道这个。但你可能不知道的是，也可以通过其它类型来添加事件监听器，例如，一个 jQuery 对象。</p><pre tabindex=0><code>const element = $(&#39;#fooButton&#39;); // 从 DOM 元素中创建一个 jQuery 对象

from(element, &#39;click&#39;)
  .subscribe();
</code></pre><pre tabindex=0><code>// 结果
// clickEvent ...
</code></pre><h4 id=fromeventpattern>fromEventPattern</h4><p>要理解为什么有 fromEvent 了还需要 fromEventPattern，我们得先理解 fromEvent 是如何工作的。看这段代码：</p><pre tabindex=0><code>from(document, &#39;click&#39;)
  .subscribe();
</code></pre><p>这告诉 RxJS 我们想要监听 document 中的点击事件。在提交过程中，RxJS 发现 document 是一个 <em>EventTarget</em> 类型，因此它可以调用它的 <code>addEventListener</code> 方法。如果我们传入的是一个 jQuery 对象而非 document，那么 RxJs 知道它得调用 <em>on</em> 方法。</p><p>这个例子用的是 <em>fromEventPattern</em> ，和 <em>fromEvent</em> 的工作基本上一样：</p><pre tabindex=0><code>function addClickHandler(handler) {
  document.addEventListener(&#39;click&#39;, handler);
}

function removeClickHandler(handler) {
  document.removeEventListener(&#39;click&#39;, handler);
}

fromEventPattern(
  addClickHandler,
  removeClickHandler,
)
.subscribe(console.log);

// 等效于
fromEvent(document, &#39;click&#39;)
</code></pre><p>RxJS 自动创建实际的监听器（ <em>handler</em> ）你的工作是添加或者移除监听器。<em>fromEventPattern</em> 的目的基本上是告诉 RxJS 如何注册和移除事件监听器。</p><p>现在想象一下你使用了一个库，你可以调用一个叫做 <em>registerListener</em> 的方法。我们不能再用 <em>fromEvent</em>，因为它并不知道该怎么处理这个对象。</p><pre tabindex=0><code>const listeners = [];

class Foo {
  registerListener(listener) {
    listeners.push(listener);
  }

  emit(value) {
    listeners.forEach(listener =&gt; listener(value));
  }
}

const foo = new Foo();

fromEventPattern(listener =&gt; foo.registerListener(listener))
  .subscribe();

foo.emit(1);
</code></pre><pre tabindex=0><code>// 结果
// 1 ...
</code></pre><p>当我们调用 <code>foo.emit(1)</code> 时，RxJS 中的监听器将被调用，然后它就能把值发送到流中。</p><p>你也可以用它来监听多个事件类型，或者结合所有可以通过回调进行通讯的 API，例如，WebWorker API:</p><pre tabindex=0><code>const myWorker = new Worker(&#39;worker.js&#39;);

fromEventPattern(
  handler =&gt; { myWorker.onmessage = handler },
  handler =&gt; { myWorker.onmessage = undefined }
)
.subscribe();
</code></pre><pre tabindex=0><code>// 结果
// workerMessage ...
</code></pre><h4 id=bindcallback>bindCallback</h4><p>它和 fromEventPattern 相似，但它能用于单个值。就在回调函数被调用时，流就结束了。用法当然也不一样 —— 你可以用 bindCallBack 封装函数，然后它就会在调用时魔术般的返回一个流：</p><pre tabindex=0><code>function foo(value, callback) {
  callback(value);
}

// 没有流
foo(1, console.log); //prints 1 in the console

// 有流
const reactiveFoo = bindCallback(foo); 
// 当我们调用 reactiveFoo 时，它返回一个 observable 对象

reactiveFoo(1)
  .subscribe(console.log); // 在控制台打印 1
</code></pre><pre tabindex=0><code>// 结果
// 1 |
</code></pre><h4 id=websocket>websocket</h4><p>是的，你完全可以创建一个 websocket 连接然后把它暴露给流：</p><pre tabindex=0><code>import { webSocket } from &#39;rxjs/webSocket&#39;; 

let socket$ = webSocket(&#39;ws://localhost:8081&#39;);

// 接收消息
socket$.subscribe(
  (msg) =&gt; console.log(&#39;message received: &#39; + msg),
  (err) =&gt; console.log(err),
  () =&gt; console.log(&#39;complete&#39;) * );

// 发送消息
socket$.next(JSON.stringify({ op: &#39;hello&#39; }));
</code></pre><p>把 websocket 功能添加到你的应用中真的很简单。<em>websocket</em> 创建一个 subject。这意味着你可以订阅它，通过调用 <code>next</code> 来获得消息和发送消息。</p><h4 id=ajax>ajax</h4><p>如你所知：类似于 websocket，提供 AJAX 查询的功能。你可能用了一个带有 AJAX 功能的库或者框架。或者你没有用，那么我建议使用 fetch（或者必要的话用 polyfill），把返回的 promise 封装到一个 observable 对象中（参考稍后会讲到的 <code>defer</code> 函数）。</p><h3 id=定制流>定制流</h3><p>有时候已有的函数用起来并不是足够灵活。或者你需要对订阅有更强的控制。</p><h4 id=主题subject>主题（<code>Subject</code>）</h4><p><code>Subject</code> 是一个特殊的对象，它使得你的能够把数据发送到流中，并且能够控制数据。<code>Subject</code> 本身就是一个可观察对象，但如果你想要把流暴露给其它代码，建议你使用 <code>asObservable</code> 方法。这样你就不能意外调用原始方法。</p><pre tabindex=0><code>const subject = new Subject();
const observable = subject.asObservable();

observable.subscribe();

subject.next(1);
subject.next(2);
subject.complete();
</code></pre><pre tabindex=0><code>// 结果
// 1 2 |
</code></pre><p>注意在订阅前发送的值将会“丢失”：</p><pre tabindex=0><code>const subject = new Subject();
const observable = subject.asObservable();

subject.next(1);

observable.subscribe(console.log);

subject.next(2);
subject.complete();
</code></pre><pre tabindex=0><code>// 结果
// 2
</code></pre><p>除了常规的 <code>Subject</code>，RxJS 还提供了三种特殊的版本。</p><p><code>AsyncSubject</code> 在结束后只发送最后的一个值。</p><pre tabindex=0><code>const subject = new AsyncSubject();
const observable = subject.asObservable();

observable.subscribe(console.log);

subject.next(1);
subject.next(2);
subject.complete();
</code></pre><pre tabindex=0><code>// 输出
// 2
</code></pre><p><code>BehaviorSubject</code> 使得你能够提供一个（默认的）值，如果当前没有其它值发送的话，这个值会被发送给每个订阅者。否则订阅者收到最后一个发送的值。</p><pre tabindex=0><code>const subject = new BehaviorSubject(1);
const observable = subject.asObservable();

const subscription1 = observable.subscribe(console.log);

subject.next(2);
subscription1.unsubscribe();
</code></pre><pre tabindex=0><code>// 输出
// 1
// 2
</code></pre><pre tabindex=0><code>const subscription2 = observable.subscribe(console.log);

// 输出
// 2
</code></pre><p><code>ReplaySubject</code> 存储一定数量、或一定时间或所有的发送过的值。所有新的订阅者将会获得所有存储了的值。</p><pre tabindex=0><code>const subject = new ReplaySubject();
const observable = subject.asObservable();

subject.next(1);

observable.subscribe(console.log);

subject.next(2);
subject.complete();
</code></pre><pre tabindex=0><code>// 输出
// 1
// 2
</code></pre><p>你可以在 <a href=http://reactivex.io/documentation/subject.html>ReactiveX 文档</a>（它提供了一些其它的连接） 里面找到更多关于 <code>Subject</code> 的信息。<a href=https://medium.com/@benlesh>Ben Lesh</a> 在 <a href=https://medium.com/@benlesh/on-the-subject-of-subjects-in-rxjs-2b08b7198b93>On The Subject Of Subjects</a> 上面提供了一些关于 <code>Subject</code> 的理解，<a href=https://medium.com/@cartant>Nicholas Jamieson</a> 在 <a href=https://blog.angularindepth.com/rxjs-understanding-subjects-5c585188c3e1>in RxJS: Understanding Subjects</a> 上也提供了一些理解。</p><h4 id=可观察对象>可观察对象</h4><p>你可以简单地用 new 操作符创建一个可观察对象。通过你传入的函数，你可以控制流，只要有人订阅了或者它接收到一个可以当成 <code>Subject</code> 使用的观察者，这个函数就会被调用，比如，调用 <code>next</code>、<code>complet</code> 和 <code>error</code>。</p><p>让我们回顾一下列表示例：</p><pre tabindex=0><code>const myList = new List();
myList.add(1);
myList.add(3);

new Observable(observer =&gt; {
  for (let i = 0; i&lt;list.size; i++) {
    observer.next(list.get(i));
  }

  observer.complete();
})
.subscribe();
</code></pre><pre tabindex=0><code>// 结果
// 1 3 |
</code></pre><p>这个函数可以返回一个 <code>unsubcribe</code> 函数，当有订阅者取消订阅时这个函数就会被调用。你可以用它来清楚或者执行一些收尾操作。</p><pre tabindex=0><code>new Observable(observer =&gt; {
  // 流式化

  return () =&gt; {
                 //clean up
               };
})
.subscribe();
</code></pre><h4 id=继承可观察对象>继承可观察对象</h4><p>在有可用的操作符前，这是一种实现自定义操作符的方式。RxJS 在内部扩展了 <em>可观察对象</em> 。<code>Subject</code> 就是一个例子，另一个是 <code>publisher</code> 操作符。它返回一个 <code>ConnectableObservable</code> 对象，该对象提供额外的方法 <code>connect</code>。</p><h4 id=实现-subscribable-接口>实现 <code>Subscribable</code> 接口</h4><p>有时候你已经用一个对象来保存状态，并且能够发送值。如果你实现了 <code>Subscribable</code> 接口，你可以把它转换成一个可观察对象。<code>Subscribable</code> 接口中只有一个 <code>subscribe</code> 方法。</p><pre tabindex=0><code>interface Subscribable&lt;T&gt; {  subscribe(observerOrNext?: PartialObserver&lt;T&gt; | ((value: T) =&gt; void), error?: (error: any) =&gt; void, complete?: () =&gt; void): Unsubscribable}
</code></pre><h3 id=结合和选择现有的流>结合和选择现有的流</h3><p>知道怎么创建一个独立的流还不够。有时候你有好几个流但其实只需要一个。有些函数也可作为操作符，所以我不打算在这里深入展开。推荐看看 <a href=https://medium.com/@maximus.koretskyi>Max NgWizard K</a> 所写的一篇 <a href=https://blog.angularindepth.com/learn-to-combine-rxjs-sequences-with-super-intuitive-interactive-diagrams-20fce8e6511>文章</a>，它还包含一些有趣的动画。</p><p>还有一个建议：你可以通过拖拽元素的方式交互式的使用结合操作，参考 <a href=http://rxmarbles.com/#merge>RxMarbles</a>。</p><h4 id=observableinput-类型>ObservableInput 类型</h4><p>期望接收流的操作符和函数通常不单独和可观察对象一起工作。相反，它们实际上期望的参数类型是 ObservableInput，定义如下：</p><pre tabindex=0><code>type ObservableInput&lt;T&gt; = SubscribableOrPromise&lt;T&gt; | ArrayLike&lt;T&gt; | Iterable&lt;T&gt;;
</code></pre><p>这意味着你可以传递一个 promises 或者数组却不需要事先把他们转换成可观察对象。</p><h4 id=defer>defer</h4><p>主要的目的是把一个 observable 对象的创建延迟（<code>defer</code>）到有人想要订阅的时间。在以下情况，这很有用：</p><ul><li>创建可观察对象的开销较大</li><li>你想要给每个订阅者新的可观察对象</li><li>你想要在订阅时候选择不同的可观察对象</li><li>有些代码必须在订阅之后执行</li></ul><p>最后一点包含了一个并不起眼的用例：Promises（<code>defer</code> 也可以返回一个 promise 对象）。看看这个用到了 fetch API 的例子：</p><pre tabindex=0><code>function getUser(id) {
  console.log(&#34;fetching data&#34;);
  return fetch(`https://server/user/${id}`);
}

const userPromise = getUser(1);
console.log(&#34;I don&#39;t want that request now&#34;);

// 其它地方
userPromise.then(response =&gt; console.log(&#34;done&#34;);
</code></pre><pre tabindex=0><code>// 输出
// fetching data
// I don&#39;t want that request now
// done
</code></pre><p>只要流在你订阅的时候执行了，promise 就会立即执行。我们调用 <code>getUser</code> 的瞬间，就发送了一个请求，哪怕我们这个时候不想发送请求。当然，我们可以使用 <code>from</code> 来把一个 promise 对象转换成可观察对象，但我们传递的 promise 对象已经创建或执行了。<code>defer</code> 让我们能够等到订阅才发送这个请求：</p><pre tabindex=0><code>const user$ = defer(() =&gt; getUser(1));

console.log(&#34;I don&#39;t want that request now&#34;);

// 其它地方
user$.subscribe(response =&gt; console.log(&#34;done&#34;);
</code></pre><pre tabindex=0><code>// 输出
// I don&#39;t want that request now
// fetching data
// done
</code></pre><h4 id=iif>iif</h4><p><code>iif</code> 包含了一个关于 <code>defer</code> 的特殊用例：在订阅时选择两个流中的一个：</p><pre tabindex=0><code>iif(
  () =&gt; new Date().getHours() &lt; 12,
  of(&#34;AM&#34;),
  of(&#34;PM&#34;)
)
.subscribe();
</code></pre><pre tabindex=0><code>// 结果
// AM before noon, PM afterwards
</code></pre><p>引用该文档：</p><blockquote><p>实际上 <a href=https://rxjs-dev.firebaseapp.com/api/index/iif>iif</a> 能够轻松地用 <a href=https://rxjs-dev.firebaseapp.com/api/index/defer>defer</a> 实现，它仅仅是出于方便和可读性的目的。</p></blockquote><h4 id=onerrorresumenext>onErrorResumeNext</h4><p>开启第一个流并且在失败的时候继续进行下一个流。错误被忽略掉。</p><pre tabindex=0><code>const stream1$ = of(1, 2).pipe(
  tap(i =&gt; { if(i&gt;1) throw &#39;error&#39;}) //fail after first element
);

const stream2$ = of(3,4);

onErrorResumeNext(stream1$, stream2$)
  .subscribe(console.log);
</code></pre><pre tabindex=0><code>// 结果
// 1 3 4 |
</code></pre><p>如果你有多个 web 服务，这就很有用了。万一主服务器开启失败，那么备份的服务就能自动调用。</p><h4 id=forkjoin>forkJoin</h4><p>它让流并行运行，当流结束时发送存在数组中的最后的值。由于每个流只有最后一个值被发送，它一般用在只发送一个元素的流的情况，就像 HTTP 请求。你让请求并行运行，在所有流收到响应时执行某些任务。</p><pre tabindex=0><code>function handleResponses([user, account]) {
  // 执行某些任务
}

forkJoin(
  fetch(&#34;https://server/user/1&#34;),
  fetch(&#34;https://server/account/1&#34;)
)
.subscribe(handleResponses);
</code></pre><h4 id=merge--concat>merge / concat</h4><p>发送每一个从可观察对象源中发出的值。</p><p><code>merge</code> 接收一个参数，让你定义有多少流能被同时订阅。默认是无限制的。设为 1 就意味着监听一个源流，在它结束的时候订阅下一个。由于这是一个常见的场景，RxJS 为你提供了一个显示的函数：<code>concat</code>。</p><pre tabindex=0><code>merge(
  interval(1000).pipe(mapTo(&#34;Stream 1&#34;), take(2)),
  interval(1200).pipe(mapTo(&#34;Stream 2&#34;), take(2)),
  timer(0, 1000).pipe(mapTo(&#34;Stream 3&#34;), take(2)),
  2 //two concurrent streams
)
.subscribe();

// 只订阅流 1 和流 2

// 输出
// Stream 1 -&gt; after 1000ms
// Stream 2 -&gt; after 1200ms
// Stream 1 -&gt; after 2000ms

// 流 1 结束后，开始订阅流 3

// 输出
// Stream 3 -&gt; after 0 ms
// Stream 2 -&gt; after 400 ms (2400ms from beginning)
// Stream 3 -&gt; after 1000ms

merge(
  interval(1000).pipe(mapTo(&#34;Stream 1&#34;), take(2)),
  interval(1200).pipe(mapTo(&#34;Stream 2&#34;), take(2))
  1
)
// 等效于
concat(
  interval(1000).pipe(mapTo(&#34;Stream 1&#34;), take(2)),
  interval(1200).pipe(mapTo(&#34;Stream 2&#34;), take(2))
)

// 输出
// Stream 1 -&gt; after 1000ms
// Stream 1 -&gt; after 2000ms
// Stream 2 -&gt; after 3200ms
// Stream 2 -&gt; after 4400ms
</code></pre><h4 id=zip--combinelatest>zip / combineLatest</h4><p><code>merge</code> 和 <code>concat</code> 一个接一个的发送所有从源流中读到的值，而 <code>zip</code> 和 <code>combineLatest</code> 是把每个流中的一个值结合起来一起发送。<code>zip</code> 结合所有源流中发送的第一个值。如果流的内容相关联，那么这就很有用。</p><pre tabindex=0><code>zip(
  interval(1000),
  interval(1200),
)
.subscribe();
</code></pre><pre tabindex=0><code>// 结果
// [0, 0] [1, 1] [2, 2] ...
</code></pre><p><code>combineLatest</code> 与之类似，但结合的是源流中发送的最后一个值。直到所有源流至少发送一个值之后才会触发事件。这之后每次源流发送一个值，它都会把这个值与其他流发送的最后一个值结合起来。</p><pre tabindex=0><code>combineLatest(
  interval(1000),
  interval(1200),
)
.subscribe();
</code></pre><pre tabindex=0><code>// 结果
// [0, 0] [1, 0] [1, 1] [2, 1] ...
</code></pre><p>两个函数都让允许传递一个选择器函数，把元素结合成其它对象而不是数组：</p><pre tabindex=0><code>zip(
  interval(1000),
  interval(1200),
  (e1, e2) -&gt; e1 + e2
)
.subscribe();
</code></pre><pre tabindex=0><code>// 结果
// 0 2 4 6 ...
</code></pre><h4 id=race>race</h4><p>选择第一个发送数据的流。产生的流基本是最快的。</p><pre tabindex=0><code>race(
  interval(1000),
  of(&#34;foo&#34;)
)
.subscribe();
</code></pre><pre tabindex=0><code>// 结果
// foo |
</code></pre><p>由于 <code>of</code> 立即产生一个值，因此它是最快的流，然而这个流就被选中了。</p><h3 id=总结>总结</h3><p>已经有很多创建可观察对象的方式了。如果你想要创造响应式的 API 或者想用响应式的 API 结合传统 API，那么了解这些方法很重要。</p><p>我已经向你展示了所有可用的方法，但它们其实还有很多内容可以讲。如果你想更加深入地了解，我极力推荐你查阅 <a href=http://reactivex.io/documentation/operators.html#creating>文档</a> 或者阅读相关文章。</p><p><a href=https://rxviz.com/>RxViz</a> 是另一种值得了解的有意思的方式。你编写 RxJS 代码，产生的流可以用图形或动画进行显示。</p><hr><p>via: <a href=https://blog.angularindepth.com/the-extensive-guide-to-creating-streams-in-rxjs-aaa02baaff9a>https://blog.angularindepth.com/the-extensive-guide-to-creating-streams-in-rxjs-aaa02baaff9a</a></p><p>作者：<a href=https://blog.angularindepth.com/@abetteroliver>Oliver Flaggl</a> 译者：<a href=https://github.com/BriFuture>BriFuture</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/stream/ rel=tag>stream</a></li><li class=tags__item><a class="tags__link btn" href=/tags/rxjs/ rel=tag>RxJS</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>