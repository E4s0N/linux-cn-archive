<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>为 Python 写一个 C++ 扩展模块 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="为 Python 写一个 C++ 扩展模块"><meta property="og:description" content="使用 C 扩展为 Python 提供特定功能。"><meta property="og:type" content="article"><meta property="og:url" content="/article-15405-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-01-02T17:35:18+00:00"><meta property="article:modified_time" content="2023-01-02T17:35:18+00:00"><meta itemprop=name content="为 Python 写一个 C++ 扩展模块"><meta itemprop=description content="使用 C 扩展为 Python 提供特定功能。"><meta itemprop=datePublished content="2023-01-02T17:35:18+00:00"><meta itemprop=dateModified content="2023-01-02T17:35:18+00:00"><meta itemprop=wordCount content="660"><meta itemprop=keywords content="Python,扩展,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>为 Python 写一个 C++ 扩展模块</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2023-01-02T17:35:18Z>January 02, 2023</time></div></div></header><div class="content post__content clearfix"><p><img src=https://img.linux.net.cn/data/attachment/album/202301/02/173501o26htajatlpj0lqt.jpg alt></p><blockquote><p>使用 C 扩展为 Python 提供特定功能。</p></blockquote><p>在前一篇文章中，我介绍了 <a href=https://opensource.com/article/22/9/python-interpreters-2022>六个 Python 解释器</a>。在大多数系统上，CPython 是默认的解释器，而且根据民意调查显示，它还是最流行的解释器。Cpython 的独有功能是使用扩展 API 用 C 语言编写 Python 模块。用 C 语言编写 Python 模块允许你将计算密集型代码转移到 C，同时保留 Python 的易用性。</p><p>在本文中，我将向你展示如何编写一个 C++ 扩展模块。使用 C++ 而不是 C，因为大多数编译器通常都能理解这两种语言。我必须提前说明缺点：以这种方式构建的 Python 模块不能移植到其他解释器中。它们只与 CPython 解释器配合工作。因此，如果你正在寻找一种可移植性更好的与 C 语言模块交互的方式，考虑下使用 <a href=https://docs.python.org/3/library/ctypes.html#module-ctypes>ctypes</a> 模块。</p><h3 id=源代码>源代码</h3><p>和往常一样，你可以在 <a href=https://github.com/hANSIc99/PythonCppExtension>GitHub</a> 上找到相关的源代码。仓库中的 C++ 文件有以下用途：</p><ul><li><code>my_py_module.cpp</code>: Python 模块 <code>MyModule</code> 的定义</li><li><code>my_cpp_class.h</code>: 一个头文件 - 只有一个暴露给 Python 的 C++ 类</li><li><code>my_class_py_type.h/cpp</code>: Python 形式的 C++ 类</li><li><code>pydbg.cpp</code>: 用于调试的单独应用程序</li></ul><p>本文构建的 Python 模块不会有任何实际用途，但它是一个很好的示例。</p><h3 id=构建模块>构建模块</h3><p>在查看源代码之前，你可以检查它是否能在你的系统上编译。<a href=https://opensource.com/article/21/5/cmake>我使用 CMake</a> 来创建构建的配置信息，因此你的系统上必须安装 CMake。为了配置和构建这个模块，可以让 Python 去执行这个过程：</p><pre tabindex=0><code>$ python3 setup.py build
</code></pre><p>或者手动执行：</p><pre tabindex=0><code>$ cmake -B build
$ cmake --build build
</code></pre><p>之后，在 <code>/build</code> 子目录下你会有一个名为 <code>MyModule. so</code> 的文件。</p><h3 id=定义扩展模块>定义扩展模块</h3><p>首先，看一下 <code>my_py_module.cpp</code> 文件，尤其是 <code>PyInit_MyModule</code> 函数：</p><pre tabindex=0><code>PyMODINIT_FUNC
PyInit_MyModule(void) {
    PyObject* module = PyModule_Create(&amp;my_module);
    
    PyObject *myclass = PyType_FromSpec(&amp;spec_myclass);
    if (myclass == NULL){
        return NULL;
    }
    Py_INCREF(myclass);
    
    if(PyModule_AddObject(module, &#34;MyClass&#34;, myclass) &lt; 0){
        Py_DECREF(myclass);
        Py_DECREF(module);
        return NULL;
    }
    return module;
}
</code></pre><p>这是本例中最重要的代码，因为它是 CPython 的入口点。一般来说，当一个 Python C 扩展被编译并作为共享对象二进制文件提供时，CPython 会在同名二进制文件中（<code>&lt;ModuleName>.so</code>）搜索 <code>PyInit_&lt;ModuleName></code> 函数，并在试图导入时执行它。</p><p>无论是声明还是实例，所有 Python 类型都是 <a href="https://docs.python.org/release/3.9.1/c-api/structures.html?highlight=pyobject#c.PyObject">PyObject</a> 的一个指针。在此函数的第一部分中，<code>module</code> 通过 <code>PyModule_Create(...)</code> 创建的。正如你在 <code>module</code> 详述（<code>my_py_module</code>，同名文件）中看到的，它没有任何特殊的功能。</p><p>之后，调用 <a href=https://docs.python.org/3/c-api/type.html#c.PyType_FromSpec>PyType_FromSpec</a> 为自定义类型 <code>MyClass</code> 创建一个 Python <a href=https://docs.python.org/3/c-api/typeobj.html#heap-types>堆类型</a> 定义。一个堆类型对应于一个 Python 类，然后将它赋值给 <code>MyModule</code> 模块。</p><p><em>注意，如果其中一个函数返回失败，则必须减少以前创建的复制对象的引用计数，以便解释器删除它们。</em></p><h3 id=指定-python-类型>指定 Python 类型</h3><p><code>MyClass</code> 详述在 <a href=https://github.com/hANSIc99/PythonCppExtension/blob/main/my_class_py_type.h>my_class_py_type.h</a> 中可以找到，它作为 <a href=https://docs.python.org/3/c-api/type.html#c.PyType_Spec>PyType_Spec</a> 的一个实例：</p><pre tabindex=0><code>static PyType_Spec spec_myclass = {
    &#34;MyClass&#34;,                                  // name
    sizeof(MyClassObject) + sizeof(MyClass),    // basicsize
    0,                                          // itemsize
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   // flags
    MyClass_slots                               // slots
};
</code></pre><p>它定义了一些基本类型信息，它的大小包括 Python 表示的大小（<code>MyClassObject</code>）和普通 C++ 类的大小（<code>MyClass</code>）。<code>MyClassObject</code> 定义如下：</p><pre tabindex=0><code>typedef struct {
    PyObject_HEAD
    int         m_value;
    MyClass*    m_myclass;
} MyClassObject;
</code></pre><p>Python 表示的话就是 <a href="https://docs.python.org/release/3.9.1/c-api/structures.html?highlight=pyobject#c.PyObject">PyObject</a> 类型，由 <code>PyObject_HEAD</code> 宏和其他一些成员定义。成员 <code>m_value</code> 视为普通类成员，而成员 <code>m_myclass</code> 只能在 C++ 代码内部访问。</p><p><a href="https://docs.python.org/release/3.9.1/c-api/type.html?highlight=pytype_slot#c.PyType_Slot">PyType_Slot</a> 定义了一些其他功能：</p><pre tabindex=0><code>static PyType_Slot MyClass_slots[] = {
    {Py_tp_new,     (void*)MyClass_new},
    {Py_tp_init,    (void*)MyClass_init},
    {Py_tp_dealloc, (void*)MyClass_Dealloc},
    {Py_tp_members, MyClass_members},
    {Py_tp_methods, MyClass_methods},
    {0, 0} /* Sentinel */
};
</code></pre><p>在这里，设置了一些初始化和析构函数的跳转，还有普通的类方法和成员，还可以设置其他功能，如分配初始属性字典，但这是可选的。这些定义通常以一个哨兵结束，包含 <code>NULL</code> 值。</p><p>要完成类型详述，还包括下面的方法和成员表：</p><pre tabindex=0><code>static PyMethodDef MyClass_methods[] = {
    {&#34;addOne&#34;, (PyCFunction)MyClass_addOne, METH_NOARGS,  PyDoc_STR(&#34;Return an incrmented integer&#34;)},
    {NULL, NULL} /* Sentinel */
};

static struct PyMemberDef MyClass_members[] = {
    {&#34;value&#34;, T_INT, offsetof(MyClassObject, m_value)},
    {NULL} /* Sentinel */
};
</code></pre><p>在方法表中，定义了 Python 方法 <code>addOne</code>，它指向相关的 C++ 函数 <code>MyClass_addOne</code>。它充当了一个包装器，它在 C++ 类中调用 <code>addOne()</code> 方法。</p><p>在成员表中，只有一个为演示目的而定义的成员。不幸的是，在 <a href="https://docs.python.org/release/3.9.1/c-api/structures.html?highlight=pymemberdef#c.PyMemberDef">PyMemberDef</a> 中使用的 <a href=https://en.cppreference.com/w/cpp/types/offsetof>offsetof</a> 不允许添加 C++ 类型到 <code>MyClassObject</code>。如果你试图放置一些 C++ 类型的容器（如 <a href=https://en.cppreference.com/w/cpp/utility/optional>std::optional</a>），编译器会抱怨一些内存布局相关的警告。</p><h3 id=初始化和析构>初始化和析构</h3><p><code>MyClass_new</code> 方法只为 <code>MyClassObject</code> 提供一些初始值，并为其类型分配内存：</p><pre tabindex=0><code>PyObject *MyClass_new(PyTypeObject *type, PyObject *args, PyObject *kwds){
    std::cout &lt;&lt; &#34;MtClass_new() called!&#34; &lt;&lt; std::endl;

    MyClassObject *self;
    self = (MyClassObject*) type-&gt;tp_alloc(type, 0);
    if(self != NULL){ // -&gt; 分配成功
        // 赋初始值
        self-&gt;m_value   = 0;
        self-&gt;m_myclass = NULL; 
    }
    return (PyObject*) self;
}
</code></pre><p>实际的初始化发生在 <code>MyClass_init</code> 中，它对应于 Python 中的 <a href="https://docs.python.org/3/library/dataclasses.html?highlight=__init__">__init__()</a> 方法：</p><pre tabindex=0><code>int MyClass_init(PyObject *self, PyObject *args, PyObject *kwds){
    
    ((MyClassObject *)self)-&gt;m_value = 123;
    
    MyClassObject* m = (MyClassObject*)self;
    m-&gt;m_myclass = (MyClass*)PyObject_Malloc(sizeof(MyClass));

    if(!m-&gt;m_myclass){
        PyErr_SetString(PyExc_RuntimeError, &#34;Memory allocation failed&#34;);
        return -1;
    }

    try {
        new (m-&gt;m_myclass) MyClass();
    } catch (const std::exception&amp; ex) {
        PyObject_Free(m-&gt;m_myclass);
        m-&gt;m_myclass = NULL;
        m-&gt;m_value   = 0;
        PyErr_SetString(PyExc_RuntimeError, ex.what());
        return -1;
    } catch(...) {
        PyObject_Free(m-&gt;m_myclass);
        m-&gt;m_myclass = NULL;
        m-&gt;m_value   = 0;
        PyErr_SetString(PyExc_RuntimeError, &#34;Initialization failed&#34;);
        return -1;
    }

    return 0;
}
</code></pre><p>如果你想在初始化过程中传递参数，必须在此时调用 <a href=https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple>PyArg_ParseTuple</a>。简单起见，本例将忽略初始化过程中传递的所有参数。在函数的第一部分中，<code>PyObject</code> 指针（<code>self</code>）被强转为 <code>MyClassObject</code> 类型的指针，以便访问其他成员。此外，还分配了 C++ 类的内存，并执行了构造函数。</p><p>注意，为了防止内存泄漏，必须仔细执行异常处理和内存分配（还有释放）。当引用计数将为零时，<code>MyClass_dealloc</code> 函数负责释放所有相关的堆内存。在文档中有一个章节专门讲述关于 C 和 C++ 扩展的内存管理。</p><h3 id=包装方法>包装方法</h3><p>从 Python 类中调用相关的 C++ 类方法很简单：</p><pre tabindex=0><code>PyObject* MyClass_addOne(PyObject *self, PyObject *args){
    assert(self);

    MyClassObject* _self = reinterpret_cast&lt;MyClassObject*&gt;(self);
    unsigned long val = _self-&gt;m_myclass-&gt;addOne();
    return PyLong_FromUnsignedLong(val);
}
</code></pre><p>同样，<code>PyObject</code> 参数（<code>self</code>）被强转为 <code>MyClassObject</code> 类型以便访问 <code>m_myclass</code>，它指向 C++ 对应类实例的指针。有了这些信息，调用 <code>addOne()</code> 类方法，并且结果以 <a href=https://docs.python.org/3/c-api/long.html>Python 整数对象</a> 返回。</p><h3 id=3-种方法调试>3 种方法调试</h3><p>出于调试目的，在调试配置中编译 CPython 解释器是很有价值的。详细描述参阅 <a href=https://docs.python.org/3/c-api/intro.html#debugging-builds>官方文档</a>。只要下载了预安装的解释器的其他调试符号，就可以按照下面的步骤进行操作。</p><h4 id=gnu-调试器>GNU 调试器</h4><p>当然，老式的 <a href=https://opensource.com/article/21/3/debug-code-gdb>GNU 调试器（GDB）</a> 也可以派上用场。源码中包含了一个 <a href=https://github.com/hANSIc99/PythonCppExtension/blob/main/gdbinit>gdbinit</a> 文件，定义了一些选项和断点，另外还有一个 <a href=https://github.com/hANSIc99/PythonCppExtension/blob/main/gdb.sh>gdb.sh</a> 脚本，它会创建一个调试构建并启动一个 GDB 会话：</p><p><img src=https://img.linux.net.cn/data/attachment/album/202301/02/173519zsbmmmlmfbksttbo.png alt="Gnu 调试器（GDB）对于 Python C 和 C++ 扩展非常有用"></p><p>GDB 使用脚本文件 <a href=https://github.com/hANSIc99/PythonCppExtension/blob/main/main.py>main.py</a> 调用 CPython 解释器，它允许你轻松定义你想要使用 Python 扩展模块执行的所有操作。</p><h4 id=c-应用>C++ 应用</h4><p>另一种方法是将 CPython 解释器嵌入到一个单独的 C++ 应用程序中。可以在仓库的 <a href=https://github.com/hANSIc99/PythonCppExtension/blob/main/pydbg.cpp>pydbg.cpp</a> 文件中找到：</p><pre tabindex=0><code>int main(int argc, char *argv[], char *envp[])
{
    Py_SetProgramName(L&#34;DbgPythonCppExtension&#34;);
    Py_Initialize();

    PyObject *pmodule = PyImport_ImportModule(&#34;MyModule&#34;);
    if (!pmodule) {
        PyErr_Print();
        std::cerr &lt;&lt; &#34;Failed to import module MyModule&#34; &lt;&lt; std::endl;
        return -1;
    }

    PyObject *myClassType = PyObject_GetAttrString(pmodule, &#34;MyClass&#34;);
    if (!myClassType) {
        std::cerr &lt;&lt; &#34;Unable to get type MyClass from MyModule&#34; &lt;&lt; std::endl;
        return -1;
    }

    PyObject *myClassInstance = PyObject_CallObject(myClassType, NULL);

    if (!myClassInstance) {
        std::cerr &lt;&lt; &#34;Instantioation of MyClass failed&#34; &lt;&lt; std::endl;
        return -1;
    }

    Py_DecRef(myClassInstance); // invoke deallocation
    return 0;
}
</code></pre><p>使用 <a href=https://docs.python.org/3/extending/embedding.html#very-high-level-embedding>高级接口</a>，可以导入扩展模块并对其执行操作。它允许你在本地 IDE 环境中进行调试，还能让你更好地控制传递或来自扩展模块的变量。</p><p>缺点是创建一个额外的应用程序的成本很高。</p><h4 id=vscode-和-vscodium-lldb-扩展>VSCode 和 VSCodium LLDB 扩展</h4><p>使用像 <a href=https://github.com/vadimcn/vscode-lldb>CodeLLDB</a> 这样的调试器扩展可能是最方便的调试选项。仓库包含了一些 VSCode/VSCodium 的配置文件，用于构建扩展，如 <a href=https://github.com/hANSIc99/PythonCppExtension/blob/main/.vscode/tasks.json>task.json</a>、<a href=https://github.com/microsoft/vscode-cmake-tools>CMake Tools</a> 和调用调试器（<a href=https://github.com/hANSIc99/PythonCppExtension/blob/main/.vscode/launch.json>launch.json</a>）。这种方法结合了前面几种方法的优点：在图形 IDE 中调试，在 Python 脚本文件中定义操作，甚至在解释器提示符中动态定义操作。</p><p><img src=https://img.linux.net.cn/data/attachment/album/202301/02/173519c6idmm5m1inmim11.png alt="VSCodium 有一个集成的调试器。"></p><h3 id=用-c-扩展-python>用 C++ 扩展 Python</h3><p>Python 的所有功能也可以从 C 或 C++ 扩展中获得。虽然用 Python 写代码通常认为是一件容易的事情，但用 C 或 C++ 扩展 Python 代码是一件痛苦的事情。另一方面，虽然原生 Python 代码比 C++ 慢，但 C 或 C++ 扩展可以将计算密集型任务提升到原生机器码的速度。</p><p>你还必须考虑 ABI 的使用。稳定的 ABI 提供了一种方法来保持旧版本 CPython 的向后兼容性，如 <a href=https://docs.python.org/3/c-api/stable.html>文档</a> 所述。</p><p>最后，你必须自己权衡利弊。如果你决定使用 C 语言来扩展 Python 中的一些功能，你已经看到了如何实现它。</p><hr><p>via: <a href=https://opensource.com/article/22/11/extend-c-python>https://opensource.com/article/22/11/extend-c-python</a></p><p>作者：<a href=https://opensource.com/users/hansic99>Stephan Avenwedde</a> 选题：<a href=https://github.com/lkxed>lkxed</a> 译者：<a href=https://github.com/MjSeven>MjSeven</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/python/ rel=tag>Python</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E6%89%A9%E5%B1%95/ rel=tag>扩展</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>