<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>gdb 如何工作？ - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="gdb 如何工作？"><meta property="og:description" content="最近，我使用 gdb 来查看我的 Ruby 程序，所以，我们将对一个 Ruby 程序运行 gdb 。"><meta property="og:type" content="article"><meta property="og:url" content="/article-9491-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-03-29T09:39:45+00:00"><meta property="article:modified_time" content="2018-03-29T09:39:45+00:00"><meta itemprop=name content="gdb 如何工作？"><meta itemprop=description content="最近，我使用 gdb 来查看我的 Ruby 程序，所以，我们将对一个 Ruby 程序运行 gdb 。"><meta itemprop=datePublished content="2018-03-29T09:39:45+00:00"><meta itemprop=dateModified content="2018-03-29T09:39:45+00:00"><meta itemprop=wordCount content="511"><meta itemprop=keywords content="gdb,调试,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>gdb 如何工作？</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2018-03-29T09:39:45Z>March 29, 2018</time></div></div></header><div class="content post__content clearfix"><p><img src=/data/attachment/album/201803/29/093941ncwgktg4axyyxn4a.jpg alt></p><p>大家好！今天，我开始进行我的 <a href=http://jvns.ca/blog/2016/06/12/a-weird-system-call-process-vm-readv/>ruby 堆栈跟踪项目</a>，我发觉我现在了解了一些关于 <code>gdb</code> 内部如何工作的内容。</p><p>最近，我使用 <code>gdb</code> 来查看我的 Ruby 程序，所以，我们将对一个 Ruby 程序运行 <code>gdb</code> 。它实际上就是一个 Ruby 解释器。首先，我们需要打印出一个全局变量的地址：<code>ruby_current_thread</code>。</p><h3 id=获取全局变量>获取全局变量</h3><p>下面展示了如何获取全局变量 <code>ruby_current_thread</code> 的地址：</p><pre tabindex=0><code>$ sudo gdb -p 2983
(gdb) p &amp; ruby_current_thread
$2 = (rb_thread_t **) 0x5598a9a8f7f0 &lt;ruby_current_thread&gt;
</code></pre><p>变量能够位于的地方有 堆 heap 、 栈 stack 或者程序的 文本段 text 。全局变量是程序的一部分。某种程度上，你可以把它们想象成是在编译的时候分配的。因此，我们可以很容易的找出全局变量的地址。让我们来看看，<code>gdb</code> 是如何找出 <code>0x5598a9a87f0</code> 这个地址的。</p><p>我们可以通过查看位于 <code>/proc</code> 目录下一个叫做 <code>/proc/$pid/maps</code> 的文件，来找到这个变量所位于的大致区域。</p><pre tabindex=0><code>$ sudo cat /proc/2983/maps | grep bin/ruby
5598a9605000-5598a9886000 r-xp 00000000 00:32 323508                     /home/bork/.rbenv/versions/2.1.6/bin/ruby
5598a9a86000-5598a9a8b000 r--p 00281000 00:32 323508                     /home/bork/.rbenv/versions/2.1.6/bin/ruby
5598a9a8b000-5598a9a8d000 rw-p 00286000 00:32 323508                     /home/bork/.rbenv/versions/2.1.6/bin/ruby
</code></pre><p>所以，我们看到，起始地址 <code>5598a9605000</code> 和 <code>0x5598a9a8f7f0</code> 很像，但并不一样。哪里不一样呢，我们把两个数相减，看看结果是多少：</p><pre tabindex=0><code>(gdb) p/x 0x5598a9a8f7f0 - 0x5598a9605000
$4 = 0x48a7f0
</code></pre><p>你可能会问，这个数是什么？让我们使用 <code>nm</code> 来查看一下程序的符号表。</p><pre tabindex=0><code>sudo nm /proc/2983/exe | grep ruby_current_thread
000000000048a7f0 b ruby_current_thread
</code></pre><p>我们看到了什么？能够看到 <code>0x48a7f0</code> 吗？是的，没错。所以，如果我们想找到程序中一个全局变量的地址，那么只需在符号表中查找变量的名字，然后再加上在 <code>/proc/whatever/maps</code> 中的起始地址，就得到了。</p><p>所以现在，我们知道 <code>gdb</code> 做了什么。但是，<code>gdb</code> 实际做的事情更多，让我们跳过直接转到…</p><h3 id=解引用指针>解引用指针</h3><pre tabindex=0><code>(gdb) p ruby_current_thread
$1 = (rb_thread_t *) 0x5598ab3235b0
</code></pre><p>我们要做的下一件事就是解引用 <code>ruby_current_thread</code> 这一指针。我们想看一下它所指向的地址。为了完成这件事，<code>gdb</code> 会运行大量系统调用比如：</p><pre tabindex=0><code>ptrace(PTRACE_PEEKTEXT, 2983, 0x5598a9a8f7f0, [0x5598ab3235b0]) = 0
</code></pre><p>你是否还记得 <code>0x5598a9a8f7f0</code> 这个地址？<code>gdb</code> 会问：“嘿，在这个地址中的实际内容是什么？”。<code>2983</code> 是我们运行 gdb 这个进程的 ID。gdb 使用 <code>ptrace</code> 这一系统调用来完成这一件事。</p><p>好极了！因此，我们可以解引用内存并找出内存地址中存储的内容。有一些有用的 <code>gdb</code> 命令，比如 <code>x/40w 变量</code> 和 <code>x/40b 变量</code> 分别会显示给定地址的 40 个字/字节。</p><h3 id=描述结构>描述结构</h3><p>一个内存地址中的内容可能看起来像下面这样。可以看到很多字节！</p><pre tabindex=0><code>(gdb) x/40b ruby_current_thread
0x5598ab3235b0: 16  -90 55  -85 -104    85  0   0
0x5598ab3235b8: 32  47  50  -85 -104    85  0   0
0x5598ab3235c0: 16  -64 -55 115 -97 127 0   0
0x5598ab3235c8: 0   0   2   0   0   0   0   0
0x5598ab3235d0: -96 -83 -39 115 -97 127 0   0
</code></pre><p>这很有用，但也不是非常有用！如果你是一个像我一样的人类并且想知道它代表什么，那么你需要更多内容，比如像这样：</p><pre tabindex=0><code>(gdb) p *(ruby_current_thread)
$8 = {self = 94114195940880, vm = 0x5598ab322f20, stack = 0x7f9f73c9c010,
    stack_size = 131072, cfp = 0x7f9f73d9ada0, safe_level = 0,    raised_flag = 0,
    last_status = 8, state = 0, waiting_fd = -1, passed_block = 0x0,
    passed_bmethod_me = 0x0, passed_ci = 0x0,    top_self = 94114195612680,
    top_wrapper = 0, base_block = 0x0, root_lep = 0x0, root_svar = 8, thread_id =
    140322820187904,
</code></pre><p>太好了。现在就更加有用了。<code>gdb</code> 是如何知道这些所有域的，比如 <code>stack_size</code> ？是从 <code>DWARF</code> 得知的。<code>DWARF</code> 是存储额外程序调试数据的一种方式，从而像 <code>gdb</code> 这样的调试器能够工作的更好。它通常存储为二进制的一部分。如果我对我的 Ruby 二进制文件运行 <code>dwarfdump</code> 命令，那么我将会得到下面的输出：</p><p>（我已经重新编排使得它更容易理解）</p><pre tabindex=0><code>DW_AT_name                  &#34;rb_thread_struct&#34;
DW_AT_byte_size             0x000003e8
DW_TAG_member
  DW_AT_name                  &#34;self&#34;
  DW_AT_type                  &lt;0x00000579&gt;
  DW_AT_data_member_location  DW_OP_plus_uconst 0
DW_TAG_member
  DW_AT_name                  &#34;vm&#34;
  DW_AT_type                  &lt;0x0000270c&gt;
  DW_AT_data_member_location  DW_OP_plus_uconst 8
DW_TAG_member
  DW_AT_name                  &#34;stack&#34;
  DW_AT_type                  &lt;0x000006b3&gt;
  DW_AT_data_member_location  DW_OP_plus_uconst 16
DW_TAG_member
  DW_AT_name                  &#34;stack_size&#34;
  DW_AT_type                  &lt;0x00000031&gt;
  DW_AT_data_member_location  DW_OP_plus_uconst 24
DW_TAG_member
  DW_AT_name                  &#34;cfp&#34;
  DW_AT_type                  &lt;0x00002712&gt;
  DW_AT_data_member_location  DW_OP_plus_uconst 32
DW_TAG_member
  DW_AT_name                  &#34;safe_level&#34;
  DW_AT_type                  &lt;0x00000066&gt;
</code></pre><p>所以，<code>ruby_current_thread</code> 的类型名为 <code>rb_thread_struct</code>，它的大小为 <code>0x3e8</code> （即 1000 字节），它有许多成员项，<code>stack_size</code> 是其中之一，在偏移为 <code>24</code> 的地方，它有类型 <code>31</code> 。<code>31</code> 是什么？不用担心，我们也可以在 DWARF 信息中查看。</p><pre tabindex=0><code>&lt; 1&gt;&lt;0x00000031&gt;    DW_TAG_typedef
                      DW_AT_name                  &#34;size_t&#34;
                      DW_AT_type                  &lt;0x0000003c&gt;
&lt; 1&gt;&lt;0x0000003c&gt;    DW_TAG_base_type
                      DW_AT_byte_size             0x00000008
                      DW_AT_encoding              DW_ATE_unsigned
                      DW_AT_name                  &#34;long unsigned int&#34;
</code></pre><p>所以，<code>stack_size</code> 具有类型 <code>size_t</code>，即 <code>long unsigned int</code>，它是 8 字节的。这意味着我们可以查看该栈的大小。</p><p>如果我们有了 DWARF 调试数据，该如何分解：</p><ol><li>查看 <code>ruby_current_thread</code> 所指向的内存区域</li><li>加上 <code>24</code> 字节来得到 <code>stack_size</code></li><li>读 8 字节（以小端的格式，因为是在 x86 上）</li><li>得到答案！</li></ol><p>在上面这个例子中是 <code>131072</code>（即 128 kb）。</p><p>对我来说，这使得调试信息的用途更加明显。如果我们不知道这些所有变量所表示的额外的元数据，那么我们无法知道存储在 <code>0x5598ab325b0</code> 这一地址的字节是什么。</p><p>这就是为什么你可以为你的程序单独安装程序的调试信息，因为 <code>gdb</code> 并不关心从何处获取这些额外的调试信息。</p><h3 id=dwarf-令人迷惑>DWARF 令人迷惑</h3><p>我最近阅读了大量的 DWARF 知识。现在，我使用 libdwarf，使用体验不是很好，这个 API 令人迷惑，你将以一种奇怪的方式初始化所有东西，它真的很慢（需要花费 0.3 秒的时间来读取我的 Ruby 程序的所有调试信息，这真是可笑）。有人告诉我，来自 elfutils 的 libdw 要好一些。</p><p>同样，再提及一点，你可以查看 <code>DW_AT_data_member_location</code> 来查看结构成员的偏移。我在 Stack Overflow 上查找如何完成这件事，并且得到<a href=https://stackoverflow.com/questions/25047329/how-to-get-struct-member-offset-from-dwarf-info>这个答案</a>。基本上，以下面这样一个检查开始：</p><pre tabindex=0><code>dwarf_whatform(attrs[i], &amp;form, &amp;error);
    if (form == DW_FORM_data1 || form == DW_FORM_data2
        form == DW_FORM_data2 || form == DW_FORM_data4
        form == DW_FORM_data8 || form == DW_FORM_udata) {
</code></pre><p>继续往前。为什么会有 800 万种不同的 <code>DW_FORM_data</code> 需要检查？发生了什么？我没有头绪。</p><p>不管怎么说，我的印象是，DWARF 是一个庞大而复杂的标准（可能是人们用来生成 DWARF 的库稍微不兼容），但是我们有的就是这些，所以我们只能用它来工作。</p><p>我能够编写代码并查看 DWARF ，这就很酷了，并且我的代码实际上大多数能够工作。除了程序崩溃的时候。我就是这样工作的。</p><h3 id=展开栈路径>展开栈路径</h3><p>在这篇文章的早期版本中，我说过，<code>gdb</code> 使用 libunwind 来展开栈路径，这样说并不总是对的。</p><p>有一位对 <code>gdb</code> 有深入研究的人发了大量邮件告诉我，为了能够做得比 libunwind 更好，他们花费了大量时间来尝试如何展开栈路径。这意味着，如果你在程序的一个奇怪的中间位置停下来了，你所能够获取的调试信息又很少，那么你可以对栈做一些奇怪的事情，<code>gdb</code> 会尝试找出你位于何处。</p><h3 id=gdb-能做的其他事>gdb 能做的其他事</h3><p>我在这儿所描述的一些事请（查看内存，理解 DWARF 所展示的结构）并不是 <code>gdb</code> 能够做的全部事情。阅读 Brendan Gregg 的<a href=http://www.brendangregg.com/blog/2016-08-09/gdb-example-ncurses.html>昔日 gdb 例子</a>，我们可以知道，<code>gdb</code> 也能够完成下面这些事情：</p><ul><li>反汇编</li><li>查看寄存器内容</li></ul><p>在操作程序方面，它可以：</p><ul><li>设置断点，单步运行程序</li><li>修改内存（这是一个危险行为）</li></ul><p>了解 <code>gdb</code> 如何工作使得当我使用它的时候更加自信。我过去经常感到迷惑，因为 <code>gdb</code> 有点像 C，当你输入 <code>ruby_current_thread->cfp->iseq</code>，就好像是在写 C 代码。但是你并不是在写 C 代码。我很容易遇到 <code>gdb</code> 的限制，不知道为什么。</p><p>知道使用 DWARF 来找出结构内容给了我一个更好的心智模型和更加正确的期望！这真是极好的！</p><hr><p>via: <a href=https://jvns.ca/blog/2016/08/10/how-does-gdb-work/>https://jvns.ca/blog/2016/08/10/how-does-gdb-work/</a></p><p>作者：<a href=https://jvns.ca/>Julia Evans</a> 译者：<a href=https://github.com/ucasFL>ucasFL</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/gdb/ rel=tag>gdb</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E8%B0%83%E8%AF%95/ rel=tag>调试</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>