<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>使用 Python 的 urllib.parse 库解析 URL - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="使用 Python 的 urllib.parse 库解析 URL"><meta property="og:description" content="Python 中的 urllib.parse 模块提供了很多解析和组建 URL 的函数。"><meta property="og:type" content="article"><meta property="og:url" content="/article-9372-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-02-22T23:51:00+00:00"><meta property="article:modified_time" content="2018-02-22T23:51:00+00:00"><meta itemprop=name content="使用 Python 的 urllib.parse 库解析 URL"><meta itemprop=description content="Python 中的 urllib.parse 模块提供了很多解析和组建 URL 的函数。"><meta itemprop=datePublished content="2018-02-22T23:51:00+00:00"><meta itemprop=dateModified content="2018-02-22T23:51:00+00:00"><meta itemprop=wordCount content="373"><meta itemprop=keywords content="Python,URL,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>使用 Python 的 urllib.parse 库解析 URL</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2018-02-22T23:51:00Z>February 22, 2018</time></div></div></header><div class="content post__content clearfix"><p><img src=/data/attachment/album/201802/22/235511q1pbibaabi5cx6xf.jpg alt></p><p>Python 中的 <code>urllib.parse</code> 模块提供了很多解析和组建 URL 的函数。</p><h3 id=解析url>解析url</h3><p><code>urlparse()</code> 函数可以将 URL 解析成 <code>ParseResult</code> 对象。对象中包含了六个元素，分别为：</p><ul><li>协议（scheme）</li><li>域名（netloc）</li><li>路径（path）</li><li>路径参数（params）</li><li>查询参数（query）</li><li>片段（fragment）</li></ul><pre tabindex=0><code>from urllib.parse import urlparse

url=&#39;http://user:pwd@domain:80/path;params?query=queryarg#fragment&#39;

parsed_result=urlparse(url)

print(&#39;parsed_result 包含了&#39;,len(parsed_result),&#39;个元素&#39;)
print(parsed_result)
</code></pre><p>结果为:</p><pre tabindex=0><code>parsed_result 包含了 6 个元素
ParseResult(scheme=&#39;http&#39;, netloc=&#39;user:pwd@domain:80&#39;, path=&#39;/path&#39;, params=&#39;params&#39;, query=&#39;query=queryarg&#39;, fragment=&#39;fragment&#39;)
</code></pre><p><code>ParseResult</code> 继承于 <code>namedtuple</code>，因此可以同时通过索引和命名属性来获取 URL 中各部分的值。</p><p>为了方便起见， <code>ParseResult</code> 还提供了 <code>username</code>、 <code>password</code>、 <code>hostname</code>、 <code>port</code> 对 <code>netloc</code> 进一步进行拆分。</p><pre tabindex=0><code>print(&#39;scheme  :&#39;, parsed_result.scheme)
print(&#39;netloc  :&#39;, parsed_result.netloc)
print(&#39;path    :&#39;, parsed_result.path)
print(&#39;params  :&#39;, parsed_result.params)
print(&#39;query   :&#39;, parsed_result.query)
print(&#39;fragment:&#39;, parsed_result.fragment)
print(&#39;username:&#39;, parsed_result.username)
print(&#39;password:&#39;, parsed_result.password)
print(&#39;hostname:&#39;, parsed_result.hostname)
print(&#39;port    :&#39;, parsed_result.port)
</code></pre><p>结果为：</p><pre tabindex=0><code>scheme  : http
netloc  : user:pwd@domain:80
path    : /path
params  : params
query   : query=queryarg
fragment: fragment
username: user
password: pwd
hostname: domain
port    : 80
</code></pre><p>除了 <code>urlparse()</code> 之外，还有一个类似的 <code>urlsplit()</code> 函数也能对 URL 进行拆分，所不同的是， <code>urlsplit()</code> 并不会把 <code>路径参数(params)</code> 从 <code>路径(path)</code> 中分离出来。</p><p>当 URL 中路径部分包含多个参数时，使用 <code>urlparse()</code> 解析是有问题的：</p><pre tabindex=0><code>url=&#39;http://user:pwd@domain:80/path1;params1/path2;params2?query=queryarg#fragment&#39;

parsed_result=urlparse(url)

print(parsed_result)
print(&#39;parsed.path    :&#39;, parsed_result.path)
print(&#39;parsed.params  :&#39;, parsed_result.params)
</code></pre><p>结果为：</p><pre tabindex=0><code>ParseResult(scheme=&#39;http&#39;, netloc=&#39;user:pwd@domain:80&#39;, path=&#39;/path1;params1/path2&#39;, params=&#39;params2&#39;, query=&#39;query=queryarg&#39;, fragment=&#39;fragment&#39;)
parsed.path    : /path1;params1/path2
parsed.params  : params2
</code></pre><p>这时可以使用 <code>urlsplit()</code> 来解析：</p><pre tabindex=0><code>from urllib.parse import urlsplit
split_result=urlsplit(url)

print(split_result)
print(&#39;split.path    :&#39;, split_result.path)
# SplitResult 没有 params 属性
</code></pre><p>结果为：</p><pre tabindex=0><code>SplitResult(scheme=&#39;http&#39;, netloc=&#39;user:pwd@domain:80&#39;, path=&#39;/path1;params1/path2;params2&#39;, query=&#39;query=queryarg&#39;, fragment=&#39;fragment&#39;)
split.path    : /path1;params1/path2;params2
</code></pre><p>若只是要将 URL 后的 <code>fragment</code> 标识拆分出来，可以使用 <code>urldefrag()</code> 函数：</p><pre tabindex=0><code>from urllib.parse import urldefrag

url = &#39;http://user:pwd@domain:80/path1;params1/path2;params2?query=queryarg#fragment&#39;

d = urldefrag(url)
print(d)
print(&#39;url     :&#39;, d.url)
print(&#39;fragment:&#39;, d.fragment)
</code></pre><p>结果为：</p><pre tabindex=0><code>DefragResult(url=&#39;http://user:pwd@domain:80/path1;params1/path2;params2?query=queryarg&#39;, fragment=&#39;fragment&#39;)
url     : http://user:pwd@domain:80/path1;params1/path2;params2?query=queryarg
fragment: fragment
</code></pre><h3 id=组建url>组建URL</h3><p><code>ParsedResult</code> 对象和 <code>SplitResult</code> 对象都有一个 <code>geturl()</code> 方法，可以返回一个完整的 URL 字符串。</p><pre tabindex=0><code>print(parsed_result.geturl())
print(split_result.geturl())
</code></pre><p>结果为：</p><pre tabindex=0><code>http://user:pwd@domain:80/path1;params1/path2;params2?query=queryarg#fragment
http://user:pwd@domain:80/path1;params1/path2;params2?query=queryarg#fragment
</code></pre><p>但是 <code>geturl()</code> 只在 <code>ParsedResult</code> 和 <code>SplitResult</code> 对象中有，若想将一个普通的元组组成 URL，则需要使用 <code>urlunparse()</code> 函数：</p><pre tabindex=0><code>from urllib.parse import urlunparse
url_compos = (&#39;http&#39;, &#39;user:pwd@domain:80&#39;, &#39;/path1;params1/path2&#39;, &#39;params2&#39;, &#39;query=queryarg&#39;, &#39;fragment&#39;)
print(urlunparse(url_compos))
</code></pre><p>结果为：</p><pre tabindex=0><code>http://user:pwd@domain:80/path1;params1/path2;params2?query=queryarg#fragment
</code></pre><h3 id=相对路径转换绝对路径>相对路径转换绝对路径</h3><p>除此之外，<code>urllib.parse</code> 还提供了一个 <code>urljoin()</code> 函数，来将相对路径转换成绝对路径的 URL。</p><pre tabindex=0><code>from urllib.parse import urljoin

print(urljoin(&#39;http://www.example.com/path/file.html&#39;, &#39;anotherfile.html&#39;))
print(urljoin(&#39;http://www.example.com/path/&#39;, &#39;anotherfile.html&#39;))
print(urljoin(&#39;http://www.example.com/path/file.html&#39;, &#39;../anotherfile.html&#39;))
print(urljoin(&#39;http://www.example.com/path/file.html&#39;, &#39;/anotherfile.html&#39;))
</code></pre><p>结果为：</p><pre tabindex=0><code>http://www.example.com/path/anotherfile.html
http://www.example.com/path/anotherfile.html
http://www.example.com/anotherfile.html
http://www.example.com/anotherfile.html
</code></pre><h3 id=查询参数的构造和解析>查询参数的构造和解析</h3><p>使用 <code>urlencode()</code> 函数可以将一个 dict 转换成合法的查询参数：</p><pre tabindex=0><code>from urllib.parse import urlencode

query_args = {
    &#39;name&#39;: &#39;dark sun&#39;,
    &#39;country&#39;: &#39;中国&#39;
}

query_args = urlencode(query_args)
print(query_args)
</code></pre><p>结果为：</p><pre tabindex=0><code>name=dark+sun&amp;country=%E4%B8%AD%E5%9B%BD
</code></pre><p>可以看到特殊字符也被正确地转义了。</p><p>相对的，可以使用 <code>parse_qs()</code> 来将查询参数解析成 dict。</p><pre tabindex=0><code>from urllib.parse import parse_qs
print(parse_qs(query_args))
</code></pre><p>结果为：</p><pre tabindex=0><code>{&#39;name&#39;: [&#39;dark sun&#39;], &#39;country&#39;: [&#39;中国&#39;]}
</code></pre><p>如果只是希望对特殊字符进行转义，那么可以使用 <code>quote</code> 或 <code>quote_plus</code> 函数，其中 <code>quote_plus</code> 比 <code>quote</code> 更激进一些，会把 <code>:</code>、<code>/</code> 一类的符号也给转义了。</p><pre tabindex=0><code>from urllib.parse import quote, quote_plus, urlencode

url = &#39;http://localhost:1080/~hello!/&#39;
print(&#39;urlencode :&#39;, urlencode({&#39;url&#39;: url}))
print(&#39;quote     :&#39;, quote(url))
print(&#39;quote_plus:&#39;, quote_plus(url))
</code></pre><p>结果为：</p><pre tabindex=0><code>urlencode : url=http%3A%2F%2Flocalhost%3A1080%2F%7Ehello%21%2F
quote     : http%3A//localhost%3A1080/%7Ehello%21/
quote_plus: http%3A%2F%2Flocalhost%3A1080%2F%7Ehello%21%2F
</code></pre><p>可以看到 <code>urlencode</code> 中应该是调用 <code>quote_plus</code> 来进行转义的。</p><p>逆向操作则使用 <code>unquote</code> 或 <code>unquote_plus</code> 函数：</p><pre tabindex=0><code>from urllib.parse import unquote, unquote_plus

encoded_url = &#39;http%3A%2F%2Flocalhost%3A1080%2F%7Ehello%21%2F&#39;
print(unquote(encoded_url))
print(unquote_plus(encoded_url))
</code></pre><p>结果为：</p><pre tabindex=0><code>http://localhost:1080/~hello!/
http://localhost:1080/~hello!/
</code></pre><p>你会发现 <code>unquote</code> 函数居然能正确地将 <code>quote_plus</code> 的结果转换回来。</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/python/ rel=tag>Python</a></li><li class=tags__item><a class="tags__link btn" href=/tags/url/ rel=tag>URL</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>