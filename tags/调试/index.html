<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>调试 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="调试"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="/tags/%E8%B0%83%E8%AF%95/"><meta itemprop=name content="调试"><meta itemprop=description content><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class="main list" role=main><header class=main__header><h1 class=main__title>调试</h1></header><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-16033-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/202307/26/062542j0picgf1fs6nd8qn.jpg.thumb.jpg alt="GDB 调试器如何通过调用帧信息来确定函数调用关系"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-16033-1.html rel=bookmark>GDB 调试器如何通过调用帧信息来确定函数调用关系</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2023-07-26T06:26:18Z>July 26, 2023</time></div></div></header><div class="content list__excerpt post__content clearfix">从调试器中获取函数调用关系。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-15395-1.html><img class=thumbnail__image src=/data/attachment/album/202212/30/103525xhhm9cl5xll3hhxs.jpg.thumb.jpg alt="以调试 Rust 的方式来学习 Rust"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-15395-1.html rel=bookmark>以调试 Rust 的方式来学习 Rust</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2022-12-30T10:34:00Z>December 30, 2022</time></div></div></header><div class="content list__excerpt post__content clearfix">Rustlings 是由 Rust 团队维护的开源项目，旨在帮助你通过调试代码的方式来学习 Rust。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-15362-1.html><img class=thumbnail__image src=/data/attachment/album/202212/19/093831nrjrmozx1mixmgii.jpg.thumb.jpg alt="GDB 的 7 个单步调试命令"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-15362-1.html rel=bookmark>GDB 的 7 个单步调试命令</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2022-12-19T09:38:32Z>December 19, 2022</time></div></div></header><div class="content list__excerpt post__content clearfix">即使是复杂的函数，也有几种方法可以单步调试，所以下次在排除代码故障时，可以尝试一下这些 GDB 技术。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-14991-1.html><img class=thumbnail__image src=/data/attachment/album/202209/01/222854m78u44otl68yxbyu.jpg.thumb.jpg alt=提高调试能力的一些方法></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-14991-1.html rel=bookmark>提高调试能力的一些方法</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2022-09-01T22:28:56Z>September 01, 2022</time></div></div></header><div class="content list__excerpt post__content clearfix">一篇论文（《建立一个调试教学的框架》）对我们有效调试所需的不同种类的知识/技能进行了分类</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-13795-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/202109/17/225018elcip4pii4qcknir.jpg.thumb.jpg alt="从命令行使用 wget 调试网页错误"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-13795-1.html rel=bookmark>从命令行使用 wget 调试网页错误</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2021-09-17T22:50:23Z>September 17, 2021</time></div></div></header><div class="content list__excerpt post__content clearfix">调试 Web 服务器的一种方法是使用 wget 命令行程序。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-13203-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/202103/14/210547k3q5lek8j9qspkks.jpg.thumb.jpg alt="学习使用 GDB 调试代码"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-13203-1.html rel=bookmark>学习使用 GDB 调试代码</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2021-03-14T21:06:00Z>March 14, 2021</time></div></div></header><div class="content list__excerpt post__content clearfix">使用 GNU 调试器来解决你的代码问题。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-12554-1.html><img class=thumbnail__image src=/data/attachment/album/202008/26/234535rhnwdc783swgsbqw.jpg.thumb.jpg alt="在 Linux 上创建并调试转储文件"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-12554-1.html rel=bookmark>在 Linux 上创建并调试转储文件</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2020-08-26T23:46:08Z>August 26, 2020</time></div></div></header><div class="content list__excerpt post__content clearfix">了解如何处理转储文件将帮你找到应用中难以重现的 bug。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-12533-1.html><img class=thumbnail__image src=/data/attachment/album/202008/20/095646k5wz7cd11vyc7lhr.jpg.thumb.jpg alt="使用微软的 ProcDump 调试 Linux"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-12533-1.html rel=bookmark>使用微软的 ProcDump 调试 Linux</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2020-08-20T09:57:30Z>August 20, 2020</time></div></div></header><div class="content list__excerpt post__content clearfix">用这个微软的开源工具，获取进程信息。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-12400-1.html><img class=thumbnail__image src=/data/attachment/album/202007/09/234357pavw88sbxab0makj.jpg.thumb.jpg alt="使用 Delve 代替 Println 来调试 Go 程序"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-12400-1.html rel=bookmark>使用 Delve 代替 Println 来调试 Go 程序</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2020-07-09T23:44:18Z>July 09, 2020</time></div></div></header><div class="content list__excerpt post__content clearfix">Delve 是能让调试变成轻而易举的事的万能工具包。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-11647-1.html><img class=thumbnail__image src=/data/attachment/album/201912/05/203701ss8onfvpsnvnsnn5.jpg.thumb.jpg alt="5 个鲜为人知 GNU 调试器（GDB）技巧"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-11647-1.html rel=bookmark>5 个鲜为人知 GNU 调试器（GDB）技巧</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2019-12-05T20:37:12Z>December 05, 2019</time></div></div></header><div class="content list__excerpt post__content clearfix">了解如何使用 gdb 的一些鲜为人知的功能来检查和修复代码。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-11073-1.html><img class=thumbnail__image src=/data/attachment/album/201907/08/133450i18fp2p011bs5pu6.jpg.thumb.jpg alt="Undo 发布用于 Linux 调试的 Live Recorder 5.0"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-11073-1.html rel=bookmark>Undo 发布用于 Linux 调试的 Live Recorder 5.0</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2019-07-08T13:35:23Z>July 08, 2019</time></div></div></header><div class="content list__excerpt post__content clearfix">随着 Undo 发布 Live Recorder 5.0，这使得在多进程系统上的调试变得更加轻松。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-10603-1.html><img class=thumbnail__image src=/data/attachment/album/201903/10/112119edsn4hvcxwfdg42v.jpg.thumb.jpg alt="Python 七步捉虫法"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-10603-1.html rel=bookmark>Python 七步捉虫法</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2019-03-10T11:21:00Z>March 10, 2019</time></div></div></header><div class="content list__excerpt post__content clearfix">了解一些技巧助你减少代码查错时间。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-9942-1.html><img class=thumbnail__image src=/data/attachment/album/201808/22/133757z7896qpkfrdfg25z.jpg.thumb.jpg alt="使用 Ptrace 去拦截和仿真 Linux 系统调用"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-9942-1.html rel=bookmark>使用 Ptrace 去拦截和仿真 Linux 系统调用</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2018-08-22T13:38:00Z>August 22, 2018</time></div></div></header><div class="content list__excerpt post__content clearfix">ptrace(2)（“进程跟踪”）系统调用通常都与调试有关。它是类 Unix 系统上通过原生调试器监测被调试进程的主要机制。它也是实现 strace（系统调用跟踪）的常见方法。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-9849-1.html><img class=thumbnail__image src=/data/attachment/album/201807/18/230247sopnnhcu2uepgnae.jpg.thumb.jpg alt=调试器到底怎样工作></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-9849-1.html rel=bookmark>调试器到底怎样工作</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2018-07-19T08:57:00Z>July 19, 2018</time></div></div></header><div class="content list__excerpt post__content clearfix">你也许用过调速器检查过你的代码，但你知道它们是如何做到的吗？</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-9834-1.html><img class=thumbnail__image src=/data/attachment/album/201807/13/221835y0g3m1gmbj7zg781.jpg.thumb.jpg alt="在 Linux 上如何得到一个段错误的核心转储"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-9834-1.html rel=bookmark>在 Linux 上如何得到一个段错误的核心转储</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2018-07-13T22:19:22Z>July 13, 2018</time></div></div></header><div class="content list__excerpt post__content clearfix">在看完这篇博客后，你应该知道如何从“哦，我的程序出现段错误，但我不知道正在发生什么”到“我知道它出现段错误时的堆栈、行号了！ ”。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-9797-1.html><img class=thumbnail__image src=/data/attachment/album/201807/02/085733el0oe0s9adjsdz2j.jpg.thumb.jpg alt="Python 调试技巧"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-9797-1.html rel=bookmark>Python 调试技巧</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2018-07-02T08:57:40Z>July 02, 2018</time></div></div></header><div class="content list__excerpt post__content clearfix">这里有一些我最喜欢的 Python 调试技巧。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-9663-1.html><img class=thumbnail__image src=/data/attachment/album/201805/21/075502mmzlyfwlllbb1ffl.jpg.thumb.jpg alt="一个可以更好地调试的 Perl 模块"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-9663-1.html rel=bookmark>一个可以更好地调试的 Perl 模块</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2018-05-21T07:55:10Z>May 21, 2018</time></div></div></header><div class="content list__excerpt post__content clearfix">这个简单优雅的模块可以让你包含调试或仅用于开发环境的代码，而在产品环境中隐藏它们。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-9588-1.html><img class=thumbnail__image src=/data/attachment/album/201804/29/093812hpupdpdmp0dwh55u.jpg.thumb.jpg alt="gdb 如何调用函数？"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-9588-1.html rel=bookmark>gdb 如何调用函数？</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2018-04-29T09:38:16Z>April 29, 2018</time></div></div></header><div class="content list__excerpt post__content clearfix">我发现我可以从 gdb 上调用 C 函数。这看起来很酷，因为在过去我认为 gdb 最多只是一个只读调试工具。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-9491-1.html><img class=thumbnail__image src=/data/attachment/album/201803/29/093941ncwgktg4axyyxn4a.jpg.thumb.jpg alt="gdb 如何工作？"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-9491-1.html rel=bookmark>gdb 如何工作？</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2018-03-29T09:39:45Z>March 29, 2018</time></div></div></header><div class="content list__excerpt post__content clearfix">最近，我使用 gdb 来查看我的 Ruby 程序，所以，我们将对一个 Ruby 程序运行 gdb 。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-9302-1.html><img class=thumbnail__image src=/data/attachment/album/201802/01/151311iy411omf3kfwy2wy.jpg.thumb.jpg alt="如何在 Linux 或者 UNIX 下调试 Bash Shell 脚本"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-9302-1.html rel=bookmark>如何在 Linux 或者 UNIX 下调试 Bash Shell 脚本</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2018-02-01T15:13:09Z>February 01, 2018</time></div></div></header><div class="content list__excerpt post__content clearfix">我写了一个 hello world 小脚本。我如何能调试运行在 Linux 或者类 UNIX 的系统上的 bash shell 脚本呢？</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-9276-1.html><img class=thumbnail__image src=/data/attachment/album/201801/25/134655pdy41fvu7f6ln61k.jpg.thumb.jpg alt="三步上手 GDB"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-9276-1.html rel=bookmark>三步上手 GDB</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2018-01-25T13:48:07Z>January 25, 2018</time></div></div></header><div class="content list__excerpt post__content clearfix">调试 C 程序，曾让我很困扰。然而当我之前在写我的操作系统时，我有很多的 Bug 需要调试。我很幸运的使用上了 qemu 模拟器，它允许我将调试器附加到我的操作系统。这个调试器就是 gdb。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-9089-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201711/28/230423v9yp293hhfafy0vf.jpg.thumb.jpg alt="用 coredumpctl 更好地记录 bug"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-9089-1.html rel=bookmark>用 coredumpctl 更好地记录 bug</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-11-28T23:04:18Z>November 28, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">通常开发者要求提供 “回溯（backtrace）” 形式的数据，以显示导致崩溃的指令流。开发人员可以使用它来修复 bug 以改进系统。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8943-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201710/08/223932vag1ajxuusf9zjfo.jpg.thumb.jpg alt="开发一个 Linux 调试器（十）：高级主题"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8943-1.html rel=bookmark>开发一个 Linux 调试器（十）：高级主题</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-10-12T10:38:00Z>October 12, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">我将对调试中的一些更高级的概念进行高层的概述：远程调试、共享库支持、表达式计算和多线程支持。这些想法实现起来比较复杂，所以我不会详细说明如何做</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8936-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201710/06/180943lioqi6q6ortjfur0.jpg.thumb.jpg alt="开发一个 Linux 调试器（九）：处理变量"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8936-1.html rel=bookmark>开发一个 Linux 调试器（九）：处理变量</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-10-06T18:10:00Z>October 06, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">变量是偷偷摸摸的。有时，它们会很高兴地呆在寄存器中，但是一转头就会跑到堆栈中。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8930-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201710/04/165839gmb9iqdiee2bh3m5.jpg.thumb.jpg alt="开发一个 Linux 调试器（八）：堆栈展开"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8930-1.html rel=bookmark>开发一个 Linux 调试器（八）：堆栈展开</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-10-04T16:59:47Z>October 04, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">有一个 backtrace 命令，它给你提供了程序当前的函数调用链。这篇文章将向你展示如何在 x86_64 上实现堆栈展开以生成这样的回溯。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8900-1.html><img class=thumbnail__image src=/data/attachment/album/201709/24/150421z8qnabqpphbs1a8o.jpg.thumb.jpg alt="常用 GDB 命令中文速览"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8900-1.html rel=bookmark>常用 GDB 命令中文速览</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-09-24T15:04:31Z>September 24, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">本文整理自《Debugging with GDB: the GNU Source-Level Debugger for GDB (GDB)》</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8663-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201707/03/231153g7abc3nedej477u8.jpg.thumb.jpg alt="开发一个 Linux 调试器（三）：寄存器和内存"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8663-1.html rel=bookmark>开发一个 Linux 调试器（三）：寄存器和内存</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-07-04T08:08:00Z>July 04, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">上一篇博文中我们给调试器添加了一个简单的地址断点。这次，我们将添加读写寄存器和内存的功能，这将使我们能够使用我们的程序计数器、观察状态和改变程序的行为。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8618-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201706/17/192220edbv9q876588685v.jpg.thumb.jpg alt="Linux 中高效编写 Bash 脚本的 10 个技巧"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8618-1.html rel=bookmark>Linux 中高效编写 Bash 脚本的 10 个技巧</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-06-17T19:22:00Z>June 17, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">Shell 脚本编程 是你在 Linux 下学习或练习编程的最简单的方式。尤其对 系统管理员要处理着自动化任务，且要开发新的简单的实用程序或工具等（这里只是仅举几例）更是必备技能。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8418-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201704/17/211733w083ii0mgwnyyi0d.jpg.thumb.jpg alt=调试器工作原理（一）：基础篇></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8418-1.html rel=bookmark>调试器工作原理（一）：基础篇</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-04-18T09:04:00Z>April 18, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">我将为大家展示 Linux 中调试器的主要构成模块 - ptrace 系统调用。这篇文章所有代码都是基于 32 位 Ubuntu 操作系统。值得注意的是，尽管这些代码是平台相关的，将它们移植到其它平台应该并不困难。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8120-1.html><img class=thumbnail__image src=/data/attachment/album/201701/15/172501x3lrwwqio266pq29.jpg.thumb.jpg alt="如何在 Shell 脚本中跟踪调试命令的执行"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8120-1.html rel=bookmark>如何在 Shell 脚本中跟踪调试命令的执行</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-01-15T17:25:07Z>January 15, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">本文将解释第三种 shell 脚本调试模式，即 shell 跟踪，并查看一些示例来演示它如何工作以及如何使用它。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8045-1.html><img class=thumbnail__image src=/data/attachment/album/201612/19/091411hx24y6u67y7xv258.jpg.thumb.jpg alt="如何在 Shell 脚本中执行语法检查调试模式"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8045-1.html rel=bookmark>如何在 Shell 脚本中执行语法检查调试模式</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-12-19T09:19:23Z>December 19, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">在本系列的这一部分，我们将了解如何使用语法检查调试模式。记住我们之前在本系列的第一部分中解释了不同的调试选项，在这里，我们将使用它们来执行脚本调试。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8032-1.html><img class=thumbnail__image src=/data/attachment/album/201612/13/084321p0tmmzbm0x8xlcyk.jpg.thumb.jpg alt="不常见但是很有用的 GCC 命令行选项（二）"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8032-1.html rel=bookmark>不常见但是很有用的 GCC 命令行选项（二）</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-12-13T08:43:34Z>December 13, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">开发者们通常用来生成警告的 -Wall 选项，并不包括一些特殊的警告。如果你不了解这些特殊警告，并且不知道如何生成它们，不用担心，我将在这篇文章中详细讲解关于它们所有的细节。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8028-1.html><img class=thumbnail__image src=/data/attachment/album/201612/11/123710ekugnqneekklrbn6.jpg.thumb.jpg alt="如何在 Linux 中启用 Shell 脚本的调试模式"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8028-1.html rel=bookmark>如何在 Linux 中启用 Shell 脚本的调试模式</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-12-11T12:37:17Z>December 11, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">在 Linux 系列中这篇介绍 Shell 脚本调试， 我们将看看如何启用 Shell 脚本调试，然后在之后的系列中解释不同的 Shell 脚本调试模式以及如何使用它们。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8025-1.html><img class=thumbnail__image src=/data/attachment/album/201612/08/205506mhw6nic6wsfihehe.jpeg.thumb.jpg alt="不常见但是很有用的 gcc 命令行选项（一）"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8025-1.html rel=bookmark>不常见但是很有用的 gcc 命令行选项（一）</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-12-09T09:51:00Z>December 09, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">你知道，你可以让 gcc 保存每个编译阶段的输出吗？你知道用于生成警告的 -Wall 选项，它并不会包含一些特殊的警告吗？gcc 的很多命令行选项都不会经常用到，但是它们在某些特定的情况下会变得非常有用，例如，当你在调试代码的时候。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-7354-1.html><img class=thumbnail__image src=/data/attachment/album/201605/18/094209j2djdcataqiri0cz.jpg.thumb.jpg alt="点评五款用于 Linux 编程的内存调试器"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-7354-1.html rel=bookmark>点评五款用于 Linux 编程的内存调试器</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-05-19T09:36:00Z>May 19, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">在这些工具集中，我评估了五款支持 Linux 的、流行的、自由开源的内存调试器： Dmalloc 、 Electric Fence 、 Memcheck 、 Memwatch 以及 Mtrace 。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-5107-1.html><img class=thumbnail__image src=/data/attachment/album/201503/22/214604nkc33p2pv33ps392.jpg.thumb.jpg alt="使用Nemiver调试器来调试 C/C++ 程序"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-5107-1.html rel=bookmark>使用Nemiver调试器来调试 C/C++ 程序</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2015-03-24T11:44:00Z>March 24, 2015</time></div></div></header><div class="content list__excerpt post__content clearfix">如果你读过我写的使用GDB命令行调试器调试C/C++程序，你就会明白一个调试器对一段C/C++程序来说有多么的重要和有用。然而，如果一个像GDB这样的命令行对你而言听起来更像一个问题而不是一个解决方案的话，那么你也许会对Nemiver更感兴趣。Nemiver 是一款基于 GTK+ 的用于C/C++程序的图形化的独立调试器，它以GDB作为其后端。最令人赞赏的是其速度和稳定性，Nemiver是一个非常可靠，具备许多优点的调试工具。 Nemiver的安装 基于Debian发行版，它的安装时非常直接简单，如下： $ sudo apt-get install nemiver 在Arch Linux中安装如下： $</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-5047-1.html><img class=thumbnail__image src=/data/attachment/album/201503/12/164209hcc87ly78n05zsq8.jpg.thumb.jpg alt="五个 Linux 下用户空间的调试工具"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-5047-1.html rel=bookmark>五个 Linux 下用户空间的调试工具</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2015-03-13T10:37:00Z>March 13, 2015</time></div></div></header><div class="content list__excerpt post__content clearfix">根据定义，调试工具是那些那些使我们能够监测、控制和纠正其他程序的程序。我们为什么应该用调试工具呢? 在有些情况下，运行一些程序的时候我们会被卡住，我们需要明白究竟发生了什么。 例如，我们正在运行应用程序，它产生了一些错误消息。要修复这些错误，我们应该先找出为什么产生这些错误的消息和这些错误消息从哪里产生的。 一个应用程序可能突然挂起，我们必须了解其他什么进程同时在运行。我们可能还必须弄清楚某个进程挂起的时候在做什么。为了剖析这些细节， 我们需要调试工具的帮助。 （题图来自：axxomovies.org） 有几个Linu</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-4302-1.html><img class=thumbnail__image src=/data/attachment/album/201411/25/214812k9he3imidt9z1939.png.thumb.jpg alt=使用GDB命令行调试器调试C/C++程序></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-4302-1.html rel=bookmark>使用GDB命令行调试器调试C/C++程序</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-11-25T21:48:02Z>November 25, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">没有调试器的情况下编写程序时最糟糕的状况是什么？编译时跪着祈祷不要出错？用血祭召唤恶魔帮你运行程序？或者在每一行代码间添加printf("test")语句来定位错误点？如你所知，编写程序时不使用调试器的话是不方便的。幸好，linux下调试还是很方便的。大多数人使用的IDE都集成了调试器，但 linux 最著名的调试器是命令行形式的C/C++调试器GDB。然而，与其他命令行工具一致，DGB需要一定的练习才能完全掌握。这里，我会告诉你GDB的基本情况及使用方法。 安装GDB 大多数的发行版仓库中都有GDB Debian 或 Ubuntu $ sudo apt-get install gdb</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-3935-1.html><img class=thumbnail__image src=/data/attachment/album/201409/30/223014ib3pcwpywb63cp33.png.thumb.jpg alt="使用 Linux 的 strace 命令跟踪/调试程序的常用选项"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-3935-1.html rel=bookmark>使用 Linux 的 strace 命令跟踪/调试程序的常用选项</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-09-30T22:30:00Z>September 30, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">在调试的时候，strace能帮助你追踪到一个程序所执行的系统调用。当你想知道程序和操作系统如何交互的时候，这是极其方便的，比如你想知道执行了哪些系统调用，并且以何种顺序执行。 这个简单而又强大的工具几乎在所有的Linux操作系统上可用，并且可被用来调试大量的程序。 命令用法 让我们看看strace命令如何追踪一个程序的执行情况。 最简单的形式，strace后面可以跟任何命令。它将列出许许多多的系统调用。一开始，我们并不能理解所有的输出，但是如果你正在寻找一些特殊的东西，那么你应该能从输出中发现它。 让我们来看看简单命令ls</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-3684-1.html><img class=thumbnail__image src=/data/attachment/album/201408/26/000556ebol5zelbltiemy7.png.thumb.jpg alt="Linux 内核的测试和调试（6）"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-3684-1.html rel=bookmark>Linux 内核的测试和调试（6）</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-08-28T07:01:00Z>August 28, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">Linux 内核补丁测试 你试过自己写内核补丁吗？本节介绍在把你的补丁包提交到 Linux 邮箱列表之前，需要做哪些操作。另外我们还会介绍如何把它发送出去。 写好代码后，编译它。把 make 过程产生的输出保存到文档中，查看新代码有没有警告信息。找到所有的警告信息，处理掉。当你的代码编译过程没有任何不正常的输出，安装这个内核，然后启动测试。如果启动正常，查看 dmesg 里面有没于错误，与老内核生成的 dmesg 日志做个比较。运行一些压力测试，请参考我们以前讲过的测试内容。如果这个补丁用于修复某个 bug，请确保真的已经修复了。如</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-3683-1.html><img class=thumbnail__image src=/data/attachment/album/201408/26/000115uiv82zc6dvrdxpba.png.thumb.jpg alt="Linux 内核测试和调试（5）"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-3683-1.html rel=bookmark>Linux 内核测试和调试（5）</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-08-27T08:57:00Z>August 27, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">仿真环境下进行 Linux 电源管理子系统测试 Linux 电源管理子系统在仿真环境下提供5种测试方式。这些方式仅仅在内核各层之间运行休眠的代码而不是真正的让系统进入休眠状态。有些平台不能挂起系统，比如说我们需要模拟飞机的飞行环境，这时候使用这种仿真环境就非常有用处了。 freezer - 测试停掉处理器： echo freezer /sys/power/pm_test echo platform /sys/power/disk echo disk /sys/power/state devices - 测试停掉处理器以及挂起设备： echo devices /sys/power/pm_test echo platform /sys/power/disk echo disk /sys/powe</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-3682-1.html><img class=thumbnail__image src=/data/attachment/album/201408/25/235728nl3i7772sll1v6xz.png.thumb.jpg alt="Linux 内核测试和调试（4）"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-3682-1.html rel=bookmark>Linux 内核测试和调试（4）</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-08-26T07:49:00Z>August 26, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">自动测试工具 这里列出一些能满足不同需求的测试工具供你选择。本小节只是简单介绍个大概，并不提供详细操作指南。 AuToTest AuToTest 是一个全自动测试框架，存在的主要目的就是测试 Linux 内核，当然也可以用来测试其他东西，比如测试一块新硬件是否能稳定工作。AuToTest 是开源软件，以 GPL 方式授权，运行于 server-client 架构（即 C/S 架构）。你可以通过配置 server 端来对运行了 client 端的系统执行初始化、运行与监测工作，也可以自己在目标系统上让 client 运行起来。另外你可以为这个测试框架添加测试用例，详情请参考AuToTe</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-3630-1.html><img class=thumbnail__image src=/data/attachment/album/201408/13/004057sc3n1gf5if5431iq.png.thumb.jpg alt="Linux 内核测试与调试（3）"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-3630-1.html rel=bookmark>Linux 内核测试与调试（3）</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-08-19T10:01:00Z>August 19, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">基本测试 安装好内核后，试试能不能启动它。能启动的话，检查 dmesg 看看有没有隐藏的错误。试试下面的功能： 网络（Wifi 或者网线）是否可用？ ssh 是否可用？ 使用 ssh 远程传输文件。 使用 git clone 和 git pull 命令。 用用网络浏览器。 查看 email。 使用 ftp, wget 等软件下载文件。 播放音频视频文件。 连上 USB 鼠标等设备。 检查内核日志 使用 dmesg 查看隐藏的问题，对于定位新代码带来的 bug 是一个好方法。一般来说，dmesg 不会输出新的 crit, alert, emerg 级别的错误信息，也不应该出现新的 err 级别的信息。你要注意的</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-3629-1.html><img class=thumbnail__image src=/data/attachment/album/201408/13/004057sc3n1gf5if5431iq.png.thumb.jpg alt="Linux 内核测试与调试（2）"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-3629-1.html rel=bookmark>Linux 内核测试与调试（2）</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-08-18T13:50:00Z>August 18, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">编译安装稳定版内核 如果你用 git 下载源码，就执行以下命令： cd linux-stable git checkout linux-3.x.y 如果是直接下载压缩文件，用以下命令进入源码目录： cd linux-3.x.y 如果你想把内核安装到自己的系统上，最安全的方法是使用你安装好的发行版拥有的配置文件。你可以在 /boot 目录找到当前发行版的内核配置文件： cp /boot/config-3.x.y-z-generic .config 运行下面的命令，可以在当前内核配置的基础上修改一些小地方，然后产生新的内核配置文件。比如说新的内核比你的 Ubuntu 发行版自带的内核多了些新功能，而你正好需要用到</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-3593-1.html><img class=thumbnail__image src=/data/attachment/album/201408/13/004057sc3n1gf5if5431iq.png.thumb.jpg alt="Linux 内核的测试和调试（1）"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-3593-1.html rel=bookmark>Linux 内核的测试和调试（1）</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-08-14T08:00:00Z>August 14, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">Linux 内核测试哲学 不管是开源还是闭源，所有软件的开发流程中，测试是一个重要的、不可或缺的环节，Linux 内核也不例外。开发人员自测、系统测试、回归测试、压力测试，都有各自不同的目的，但是从更高一个层次上看，这些测试的最终目的又是一样的：保证软件能一直运行下去，当有新功能加进去时，要保证新功能可以正常工作。 在软件释出 release 版之前，不用回归测试就能保证稳定性，并且尽量避免在软件发布后被用户发现 bug。调试被用户发现的 bug 是一项非常浪费时间和精力的工作。因此测试是一项非常重要的工作。不像闭源和专有的操</div></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>