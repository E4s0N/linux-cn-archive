<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>戴文 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="戴文"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="/tags/%E6%88%B4%E6%96%87/"><meta itemprop=name content="戴文"><meta itemprop=description content><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class="main list" role=main><header class=main__header><h1 class=main__title>戴文</h1></header><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-3287-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201406/28/214802qlnlnlzuuumzl91l.jpg.thumb.jpg alt="戴文的Linux内核专题：28 编译与安装"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-3287-1.html rel=bookmark>戴文的Linux内核专题：28 编译与安装</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-06-28T21:48:00Z>June 28, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">你好！在花费了大量的时间在配置你需要的内核后，你现在可以编译它了。源代码是纯文本形式的C代码。这对人来可读但是对机器可不是这样。编译会将代码转换成计算机可理解的一种称之为二进制码的形式(1是 ，0 是 )。编译同样会将所有内核代码文件变成一个内核的文件。 为了编译内核，在内核源代码相同目录下，在终端内输入"make"。这会花费一些时间。完成之后，必须通过"make modules"来编译模块。为了从一开始就简化编译过程，输入"make; make modules"。这会先编译接着是模块，而不用用户再回来输入"make modules"。 警告：在你安装一个</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-3286-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201406/28/213250uf0u0fvzftj4zuh6.jpg.thumb.jpg alt="戴文的Linux内核专题：27 配置内核 (23)"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-3286-1.html rel=bookmark>戴文的Linux内核专题：27 配置内核 (23)</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-06-28T21:32:44Z>June 28, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">欢迎来到内核配置的下一章！本篇中我们会配置密码API，虚拟化和运行库。密码学指的是在需要的计算机之间加密和安全通信的科学。用户可能加密数据以保证是收件人而不是黑客收到数据。 Linux内核需要在内核中启用"Cryptographic algorithm manager"(密码算法管理器)。这个特性提供了操作内核的加密特性所需的软件。 当启用这个它，用户空间提供了配置加密特性(Userspace cryptographic algorithm configuration)。注意:这个配置指的是内核运行时的加密设置，不是编译内核的工具。 为了加强性能，启用这个会在加密算法中停止自我检测的特性 (</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-3280-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201406/27/125303gilsxif9s88oroop.jpg.thumb.jpg alt="戴文的Linux内核专题：16 配置内核 (12)"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-3280-1.html rel=bookmark>戴文的Linux内核专题：16 配置内核 (12)</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-06-27T12:53:01Z>June 27, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">欢迎来享受Linux内核配置系列下一部分。如你所猜到的那样，内核支持大量不同的硬件、协议和特性。 下一组我们要讨论的特性是"EEPROM support"。电可擦除可编程只读存储器(Electrically Erasable Programmable Read-Only Memory)是一种掉电或者意外关闭后不会擦除内容的存储器。 内核支持在I2C卡上的EEPROM芯片包括FRAMs、ROMs和SRAMs (I2C EEPROMs / RAMs / ROMs 来自多数供货商)。FRAM(同样也称作FeRAM是一种使用铁电原理而不是电介质存储数据的随机访问存储芯片)。ROM芯片是只读(Read Only Memory)芯片。SRAM是静态而不是动态存储器就像</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-3272-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201406/26/230940l4l4t10acs4cir4i.jpg.thumb.jpg alt="戴文的Linux内核专题：26 配置内核 (22)"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-3272-1.html rel=bookmark>戴文的Linux内核专题：26 配置内核 (22)</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-06-26T23:09:00Z>June 26, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">你好！本篇我们将继续配置"kernel hacks",接着我们会配置整个安全系统。 Alpha和s390处理器需要配置下一个特性(Force weak per-cpu definitions)。这个特性修复了一个在这类处理器中普遍存在的寻址问题。其他的处理器无需启用这个特性。 内核转储可以用这个特殊的调试工具测试(Linux Kernel Dump Test Tool Module)。这个软件会允许内核开发者触发一个假错误来导致内核转储。内核开发者可以保证转储成功执行。 内核提供了不同的错误注射模块来允许内核开发者测试通知(CPU notifier error injection module)、 (PM notifier error injectio</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-3100-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201405/27/221424bfjjg3uzlxbg9uqb.jpg.thumb.jpg alt="戴文的Linux内核专题：24 配置内核 (20)"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-3100-1.html rel=bookmark>戴文的Linux内核专题：24 配置内核 (20)</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-05-27T22:14:23Z>May 27, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">欢迎进入Linux内核系列文章的下一篇!本篇我们继续配置文件系统。 首先，我们启用"General filesystem local caching manager"，它允许内核存储文件系统缓存。这可以增加在存储空间开销上的性能。 为了调试目的，缓存系统可以通过统计信息监控(Gather statistical information on local caching)。通常上，这个特性应该只在你计划调试的时候启用。 下面的特性很像上面的，但是这个特性存储延迟信息(Gather latency information on local caching)。再说一次，这是个调试特性。 "Debug FS-Cache"提供了很多其他的缓存系统的调试功能。 下面</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-3099-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201405/27/220253wslmuoot588qmqza.jpg.thumb.jpg alt="戴文的Linux内核专题：23 配置内核 (19)"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-3099-1.html rel=bookmark>戴文的Linux内核专题：23 配置内核 (19)</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-05-27T22:02:45Z>May 27, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">欢迎进入Linux内核系列文章的下一篇！我们正在接近配置过程的终点。在这篇文章中，我们将会讨论固件驱动和文件系统驱动。 这个分类中的第一个驱动是寻找启动盘(BIOS Enhanced Disk Drive calls determine boot disk)。有时，Linux不会知道哪个盘是启动盘。这个驱动允许内核询问BIOS。Linux接着在sysfs上存储信息。Linux需要知道这些来设置bootloader。 即使BIOS EDD服务被编译进了内核，这个选项可以设置这些服务不激活(Sets default behavior for EDD detection to off )。EDD代表的是"Enhanced Disk Drive"(增强磁盘驱动器)。 当使用kex</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-3081-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201405/24/212323zqp97m90x474xxcq.jpg.thumb.jpg alt="戴文的Linux内核专题：22 配置内核 (18)"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-3081-1.html rel=bookmark>戴文的Linux内核专题：22 配置内核 (18)</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-05-24T21:13:00Z>May 24, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">你好！准备好阅读下一篇文章了么？在本篇中，我们将会讨论辅助显示。辅助显示是一些小的LCD屏幕；大多数小于或等于128x64。接着，我们会讨论用户空间IO驱动，一些虚拟驱动，Hyper-V，开发中驱动，IOMMU，和其他一些内核特性。 第一个配置辅助显示的驱动是"KS0108 LCD Controller"。KS0108 LCD Controller是由三星制造的图形控制器。 下面可以设置LCD并口地址(Parallel port where the LCD is connected)。第一个并口地址是0x378，下一个是0x278，第三个是0x3BC。这些不是地址唯一的选择。大多数人不需要改变这个。shell命令"cat /proc/iop</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-2817-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201404/07/224944wul9qzqzarko5nn9.jpg.thumb.jpg alt="戴文的Linux内核专题：21 配置内核 (17)"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-2817-1.html rel=bookmark>戴文的Linux内核专题：21 配置内核 (17)</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-04-07T22:38:00Z>April 07, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">你好！这篇文章会覆盖不同的驱动。 首先"virtio console"是一种用于hypervisors的虚拟控制台驱动。 "IPMI top-level message handler"是用于IPMI系统的消息管理器。IPMI代表的是"Intelligent Platform Management Interface"(智能平台管理系统)。IPMI是一种不需要shell通过网络管理系统的接口。 "/dev/nvram support"允许系统读取和写入实时时钟的内存。通常上，这个特性用于在掉电时保存数据。 下面一个驱动支持Siemens R3964包驱动(Siemens R3964 line discipline)。这个是设备对设备协议 现在，我们可以进入PCMCIA字符设备驱动。然而，</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-2816-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201404/07/225004ekp4w9c744cyws0g.jpg.thumb.jpg alt="戴文的Linux内核专题：20 配置内核 (16)"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-2816-1.html rel=bookmark>戴文的Linux内核专题：20 配置内核 (16)</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-04-07T22:35:00Z>April 07, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">欢迎来到下一篇Linux内核文章。在本篇里，我们将讨论输入/输出端口。 首先，PS/2鼠标和AT键盘需要"i8042 PC Keyboard controller"驱动。在USB之前，鼠标和键盘使用圆形端口的PS/2端口。AT键盘是一种84键使用AT端口的IBM键盘。AT端口有5针而PS/2口有六针。 使用COM口(有时也称RS232串口)的输入设备需要这个驱动(Serial port line discipline)。COM是一种串口，意味着每次传输一位。 TravelMate笔记本需要这个特殊的驱动来使用连接到QuickPort的鼠标(ct82c710 Aux port controller)。 对于PS/2 mice、AT keyboards 和 XT keyboards的并口适</div></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>