<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Rust 基础系列 #2: 在 Rust 程序中使用变量和常量 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="Rust 基础系列 #2: 在 Rust 程序中使用变量和常量"><meta property="og:description" content="推进你的 Rust 学习，熟悉 Rust 程序的变量和常量。"><meta property="og:type" content="article"><meta property="og:url" content="/article-15771-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-05-01T14:50:31+00:00"><meta property="article:modified_time" content="2023-05-01T14:50:31+00:00"><meta itemprop=name content="Rust 基础系列 #2: 在 Rust 程序中使用变量和常量"><meta itemprop=description content="推进你的 Rust 学习，熟悉 Rust 程序的变量和常量。"><meta itemprop=datePublished content="2023-05-01T14:50:31+00:00"><meta itemprop=dateModified content="2023-05-01T14:50:31+00:00"><meta itemprop=wordCount content="960"><meta itemprop=keywords content="Rust,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>Rust 基础系列 #2: 在 Rust 程序中使用变量和常量</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2023-05-01T14:50:31Z>May 01, 2023</time></div></div></header><div class="content post__content clearfix"><p><img src=https://img.linux.net.cn/data/attachment/album/202305/01/144948gp13zdindx50ll0p.png alt></p><blockquote><p>推进你的 Rust 学习，熟悉 Rust 程序的变量和常量。</p></blockquote><p>在 <a href=/article-15709-1.html>该系列的第一章</a>中，我讲述了为什么 Rust 是一门越来越流行的编程语言。我还展示了如何 <a href=/article-15709-1.html>在 Rust 中编写 Hello World 程序</a>。</p><p>让我们继续 Rust 之旅。在本文中，我将向你介绍 Rust 编程语言中的变量和常量。</p><p>此外，我还将讲解一个称为“ 遮蔽 shadowing ”的新编程概念。</p><h3 id=rust-变量的独特之处>Rust 变量的独特之处</h3><p>在编程语言中，变量是指 <em>存储某些数据的内存地址的一个别名</em> 。</p><p>对 Rust 语言来讲也是如此。但是 Rust 有一个独特的“特性”。每个你声明的变量都是 <strong>默认 不可变的 immutable </strong>。这意味着一旦给变量赋值，就不能再改变它的值。</p><p>这个决定是为了确保默认情况下，你不需要使用 自旋锁 spin lock 或 互斥锁 mutex 等特殊机制来引入多线程。Rust <strong>会保证</strong> 安全的并发。由于所有变量（默认情况下）都是不可变的，因此你不需要担心线程会无意中更改变量值。</p><p>这并不是在说 Rust 中的变量就像常量一样，因为它们确实不是常量。变量可以被显式地定义为可变的。这样的变量称为 <strong>可变变量</strong> 。</p><p>这是在 Rust 中声明变量的语法：</p><pre tabindex=0><code>// 默认情况下不可变
// 初始化值是**唯一**的值
let variable_name = value;

// 使用 &#39;mut&#39; 关键字定义可变变量
// 初始化值可以被改变
let mut variable_name = value;
</code></pre><blockquote><p>? 尽管你可以改变可变变量的值，但你不能将另一种数据类型的值赋值给它。</p><p>这意味着，如果你有一个可变的浮点型变量，你不能在后面将一个字符赋值给它。</p></blockquote><h3 id=rust-数据类型概观>Rust 数据类型概观</h3><p>在上一篇文章中，你可能注意到了我提到 Rust 是一种强类型语言。但是在定义变量时，你不需要指定数据类型，而是使用一个通用的关键字 <code>let</code>。</p><p>Rust 编译器可以根据赋值给变量的值推断出变量的数据类型。但是如果你仍然希望明确指定数据类型并希望注释类型，那么可以这样做。以下是语法：</p><pre tabindex=0><code>let variable_name: data_type = value;
</code></pre><p>下面是 Rust 编程语言中一些常见的数据类型：</p><ul><li><strong>整数类型</strong>：分别用于有符号和无符号的 32 位整数的 <code>i32</code> 和 <code>u32</code></li><li><strong>浮点类型</strong>：分别用于 32 位和 64 位浮点数的 <code>f32</code> 和 <code>f64</code></li><li><strong>布尔类型</strong>：<code>bool</code></li><li><strong>字符类型</strong>：<code>char</code></li></ul><p>我会在下一篇文章中更详细地介绍 Rust 的数据类型。现在，这应该足够了。</p><blockquote><p>? Rust 并不支持隐式类型转换。因此，如果你将值 <code>8</code> 赋给一个浮点型变量，你将会遇到编译时错误。你应该赋的值是 <code>8.</code> 或 <code>8.0</code>。</p></blockquote><p>Rust 还强制要求在读取存储在其中的值之前初始化变量。</p><pre tabindex=0><code>{ // 该代码块不会被编译
    let a;
    println!(&#34;{}&#34;, a); // 本行报错
    // 读取一个**未初始化**变量的值是一个编译时错误
}

{ // 该代码块会被编译
    let a;
    a = 128;
    println!(&#34;{}&#34;, a); // 本行不会报错
    // 变量 &#39;a&#39; 有一个初始值
}
</code></pre><p>如果你在不初始化的情况下声明一个变量，并在给它赋值之前使用它，Rust 编译器将会抛出一个 <strong>编译时错误</strong> 。</p><p>虽然错误很烦人，但在这种情况下，Rust 编译器强制你不要犯写代码时常见的错误之一：未初始化的变量。</p><h3 id=rust-编译器的错误信息>Rust 编译器的错误信息</h3><p>来写几个程序，你将</p><ul><li>通过执行“正常”的任务来理解 Rust 的设计，这些任务实际上是内存相关问题的主要原因</li><li>阅读和理解 Rust 编译器的错误/警告信息</li></ul><h4 id=测试变量的不可变性>测试变量的不可变性</h4><p>让我们故意写一个试图修改不可变变量的程序，看看接下来会发生什么。</p><pre tabindex=0><code>fn main() {
    let mut a = 172;
    let b = 273;
    println!(&#34;a: {a}, b: {b}&#34;);

    a = 380;
    b = 420;
    println!(&#34;a: {}, b: {}&#34;, a, b);
}
</code></pre><p>直到第 4 行看起来都是一个简单的程序。但是在第 7 行，变量 <code>b</code> —— 一个不可变变量 —— 的值被修改了。</p><p>注意打印 Rust 变量值的两种方法。在第 4 行，我将变量括在花括号中，以便打印它们的值。在第 8 行，我保持括号为空，并使用 C 的风格将变量作为参数。这两种方法都是有效的。（除了修改不可变变量的值，这个程序中的所有内容都是正确的。）</p><p>来编译一下！如果你按照上一章的步骤做了，你已经知道该怎么做了。</p><pre tabindex=0><code>$ rustc main.rs
error[E0384]: cannot assign twice to immutable variable `b`
 --&gt; main.rs:7:5
  |
3 |     let b = 273;
  |         -
  |         |
  |         first assignment to `b`
  |         help: consider making this binding mutable: `mut b`
...
7 |     b = 420;
  |     ^^^^^^^ cannot assign twice to immutable variable

error: aborting due to previous error

For more information about this error, try `rustc --explain E0384`.
</code></pre><blockquote><p>? “binding” 一词是指变量名。但这只是一个简单的解释。</p></blockquote><p>这很好的展示了 Rust 强大的错误检查和信息丰富的错误信息。第一行展示了阻止上述代码编译的错误信息：</p><pre tabindex=0><code>error[E0384]: cannot assign twice to immutable variable b
</code></pre><p>这意味着，Rust 编译器注意到我试图给变量 <code>b</code> 重新赋值，但变量 <code>b</code> 是一个不可变变量。所以这就是导致这个错误的原因。</p><p>编译器甚至可以识别出错误发生的确切行和列号。</p><p>在显示 <code>first assignment to b</code> 的行下面，是提供帮助的行。因为我正在改变不可变变量 <code>b</code> 的值，所以我被告知使用 <code>mut</code> 关键字将变量 <code>b</code> 声明为可变变量。</p><blockquote><p>?️ 自己实现一个修复来更好地理解手头的问题。</p></blockquote><h4 id=使用未初始化的变量>使用未初始化的变量</h4><p>现在，让我们看看当我们尝试读取未初始化变量的值时，Rust 编译器会做什么。</p><pre tabindex=0><code>fn main() {
    let a: i32;
    a = 123;
    println!(&#34;a: {a}&#34;);

    let b: i32;
    println!(&#34;b: {b}&#34;);
    b = 123;
}
</code></pre><p>这里，我有两个不可变变量 <code>a</code> 和 <code>b</code>，在声明时都没有初始化。变量 <code>a</code> 在其值被读取之前被赋予了一个值。但是变量 <code>b</code> 的值在被赋予初始值之前被读取了。</p><p>来编译一下，看看结果。</p><pre tabindex=0><code>$ rustc main.rs
warning: value assigned to `b` is never read
 --&gt; main.rs:8:5
  |
8 |     b = 123;
  |     ^
  |
  = help: maybe it is overwritten before being read?
  = note: `#[warn(unused_assignments)]` on by default

error[E0381]: used binding `b` is possibly-uninitialized
 --&gt; main.rs:7:19
  |
6 |     let b: i32;
  |         - binding declared here but left uninitialized
7 |     println!(&#34;b: {b}&#34;);
  |                   ^ `b` used here but it is possibly-uninitialized
  |
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to previous error; 1 warning emitted

For more information about this error, try `rustc --explain E0381`.
</code></pre><p>这里，Rust 编译器抛出了一个编译时错误和一个警告。警告说变量 <code>b</code> 的值从来没有被读取过。</p><p>但是这是荒谬的！变量 <code>b</code> 的值在第 7 行被访问了。但是仔细看；警告是关于第 8 行的。这很令人困惑；让我们暂时跳过这个警告，继续看错误。</p><p>这个错误信息说 <code>used binding b is possibly-uninitialized</code>。和之前的例子一样，Rust 编译器指出错误是由于尝试在第 7 行读取变量 <code>b</code> 的值而引起的。读取变量 <code>b</code> 的值是错误的原因是它的值没有初始化。在 Rust 编程语言中，这是非法的。因此编译时错误出现。</p><blockquote><p>?️ 这个错误可以很容易地通过交换第 7 和第 8 行的代码来解决。试一下，看看错误是否消失了。</p></blockquote><h3 id=示例程序交换数字>示例程序：交换数字</h3><p>现在你已经熟悉了常见的变量相关问题，让我们来看一个交换两个变量值的程序。</p><pre tabindex=0><code>fn main() {
    let mut a = 7186932;
    let mut b = 1276561;

    println!(&#34;a: {a}, b: {b}&#34;);

    // 交换变量值
    let temp = a;
    a = b;
    b = temp;

    println!(&#34;a: {}, b: {}&#34;, a, b);
}
</code></pre><p>我在这里声明了两个变量 <code>a</code> 和 <code>b</code>。这两个变量都是可变的，因为我希望在后面改变它们的值。我赋予了一些随机值。最初，我打印了这些变量的值。</p><p>然后，在第 8 行，我创建了一个名为 <code>temp</code> 的不可变变量，并将存储在 <code>a</code> 中的值赋给它。之所以这个变量是不可变的，是因为 <code>temp</code> 的值不会改变。</p><p>要交换值，我将变量 <code>b</code> 的值赋给变量 <code>a</code>，在下一行，我将 <code>temp</code> 的值（它包含 <code>a</code> 的值）赋给变量 <code>b</code>。现在值已经交换了，我打印了变量 <code>a</code> 和 <code>b</code> 的值。</p><p>在编译并执行上面的代码后，我得到了以下输出：</p><pre tabindex=0><code>a: 7186932, b: 1276561
a: 1276561, b: 7186932
</code></pre><p>正如你所见，值已经交换了。完美。</p><h3 id=使用未使用的变量>使用未使用的变量</h3><p>当你声明了一些变量，打算在后面使用它们，但是还没有使用它们，然后编译你的 Rust 代码来检查一些东西时，Rust 编译器会警告你。</p><p>原因是显而易见的。不会被使用的变量占用了不必要的初始化时间（CPU 周期）和内存空间。如果不会被使用，为什么要在程序写上它呢？尽管编译器确实会优化这一点。但是它仍然是一个问题，因为它会以多余的代码的形式影响可读性。</p><p>但是，有的时候，你可能会面对这样的情况：创建一个变量与否不在你的控制之下。比如说，当一个函数返回多个值，而你只需要其中的一些值时。在这种情况下，你不能要求库维护者根据你的需要调整他们的函数。</p><p>所以，在这种情况下，你可以写一个以下划线开头的变量，Rust 编译器将不再显示这样的警告。如果你真的不需要使用存储在该未使用变量中的值，你可以简单地将其命名为 <code>_</code>（下划线），Rust 编译器也会忽略它！</p><p>接下来的程序不仅不会生成任何输出，而且也不会生成任何警告和/或错误消息：</p><pre tabindex=0><code>fn main() {
    let _unnecessary_var = 0; // 没有警告
    let _ = 0.0; // 完全忽略
}
</code></pre><h3 id=算术运算>算术运算</h3><p>数学就是数学，Rust 并没有在这方面创新。你可以使用在其他编程语言（如 C、C++ 和/或 Java）中使用过的所有算术运算符。</p><p>包含可以在 Rust 编程语言中使用的所有运算符和它们的含义的完整列表可以在 <a href="https://doc.rust-lang.org/book/appendix-02-operators.html?ref=itsfoss.com#operators">这里</a> 找到。</p><h4 id=示例程序一个生锈的温度计>示例程序：一个生锈的温度计</h4><p>（LCTT 译注：这里的温度计“生锈”了是因为它是使用 Rust（生锈）编写的，原作者在这里玩了一个双关。）</p><p>接下来是一个典型的程序，它将华氏度转换为摄氏度，反之亦然。</p><pre tabindex=0><code>fn main() {
    let boiling_water_f: f64 = 212.0;
    let frozen_water_c: f64 = 0.0;

    let boiling_water_c = (boiling_water_f - 32.0) * (5.0 / 9.0);
    let frozen_water_f = (frozen_water_c * (9.0 / 5.0)) + 32.0;

    println!(
        &#34;Water starts boiling at {}°C (or {}°F).&#34;,
        boiling_water_c, boiling_water_f
    );
    println!(
        &#34;Water starts freezing at {}°C (or {}°F).&#34;,
        frozen_water_c, frozen_water_f
    );
}
</code></pre><p>没什么大不了的……华氏温度转换为摄氏温度，反之亦然。</p><p>正如你在这里看到的，由于 Rust 不允许自动类型转换，我不得不在整数 32、9 和 5 后放一个小数点。除此之外，这与你在 C、C++ 和/或 Java 中所做的类似。</p><p>作为练习，尝试编写一个程序，找出给定数中有多少位数字。</p><h3 id=常量>常量</h3><p>如果你有一些编程知识，你可能知道这意味着什么。常量是一种特殊类型的变量，它的值<strong>永远不会改变</strong>。<em>它保持不变</em>。</p><p>在 Rust 编程语言中，使用以下语法声明常量：</p><pre tabindex=0><code>const CONSTANT_NAME: data_type = value;
</code></pre><p>如你所见，声明常量的语法与我们在 Rust 中看到的变量声明非常相似。但是有两个不同之处：</p><ul><li>常量的名字需要像 <code>SCREAMING_SNAKE_CASE</code> 这样。所有的大写字母和单词之间用下划线分隔。</li><li>常量的数据类型<strong>必须</strong>被显性定义。</li></ul><h4 id=变量与常量的对比>变量与常量的对比</h4><p>你可能在想，既然变量默认是不可变的，为什么语言还要包含常量呢？</p><p>接下来这个表格应该可以帮助你消除疑虑。（如果你好奇并且想更好地理解这些区别，你可以看看<a href="https://blog.thefossguy.com/posts/immutable-vars-vs-constants-rs.md?ref=itsfoss.com">我的博客</a>，它详细地展示了这些区别。）</p><p><img src=https://img.linux.net.cn/data/attachment/album/202305/01/145031yte8qc9cm85ytsut.png alt="一个展示 Rust 编程语言中变量和常量之间区别的表格"></p><h4 id=使用常量的示例程序计算圆的面积>使用常量的示例程序：计算圆的面积</h4><p>这是一个很直接的关于 Rust 中常量的简单程序。它计算圆的面积和周长。</p><pre tabindex=0><code>fn main() {
    const PI: f64 = 3.14;
    let radius: f64 = 50.0;

    let circle_area = PI * (radius * radius);
    let circle_perimeter = 2.0 * PI * radius;

    println!(&#34;有一个周长为 {radius} 厘米的圆&#34;);
    println!(&#34;它的面积是 {} 平方厘米&#34;, circle_area);
    println!(
        &#34;以及它的周长是 {} 厘米&#34;,
        circle_perimeter
    );
}
</code></pre><p>如果运行代码，将产生以下输出：</p><pre tabindex=0><code>有一个周长为 50 厘米的圆
它的面积是 7850 平方厘米
以及它的周长是 314 厘米
</code></pre><h3 id=rust-中的变量遮蔽>Rust 中的变量遮蔽</h3><p>如果你是一个 C++ 程序员，你可能已经知道我在说什么了。当程序员<strong>声明</strong>一个与已经声明的变量同名的新变量时，这就是变量遮蔽。</p><p>与 C++ 不同，Rust 允许你在同一作用域中执行变量遮蔽！</p><blockquote><p>? 当程序员遮蔽一个已经存在的变量时，新变量会被分配一个新的内存地址，但是使用与现有变量相同的名称引用。</p></blockquote><p>来看看它在 Rust 中是如何工作的。</p><pre tabindex=0><code>fn main() {
    let a = 108;
    println!(&#34;a 的地址: {:p}, a 的值 {a}&#34;, &amp;a);
    let a = 56;
    println!(&#34;a 的地址: {:p}, a 的值: {a} // 遮蔽后&#34;, &amp;a);

    let mut b = 82;
    println!(&#34;\nb 的地址: {:p}, b 的值: {b}&#34;, &amp;b);
    let mut b = 120;
    println!(&#34;b的地址: {:p}, b的值: {b} // 遮蔽后&#34;, &amp;b);

    let mut c = 18;
    println!(&#34;\nc 的地址: {:p}, c的值: {c}&#34;, &amp;c);
    c = 29;
    println!(&#34;c 的地址: {:p}, c的值: {c} // 遮蔽后&#34;, &amp;c);
}
</code></pre><p><code>println</code> 语句中花括号内的 <code>:p</code> 与 C 中的 <code>%p</code> 类似。它指定值的格式为内存地址（指针）。</p><p>我在这里使用了 3 个变量。变量 <code>a</code> 是不可变的，并且在第 4 行被遮蔽。变量 <code>b</code> 是可变的，并且在第 9 行也被遮蔽。变量 <code>c</code> 是可变的，但是在第 14 行，只有它的值被改变了。它没有被遮蔽。</p><p>现在，让我们看看输出。</p><pre tabindex=0><code>a 的地址: 0x7ffe954bf614, a 的值 108
a 的地址: 0x7ffe954bf674, a 的值: 56 // 遮蔽后

b 的地址: 0x7ffe954bf6d4, b 的值: 82
b 的地址: 0x7ffe954bf734, b 的值: 120 // 遮蔽后

c 的地址: 0x7ffe954bf734, c 的值: 18
c 的地址: 0x7ffe954bf734, c 的值: 29 // 遮蔽后
</code></pre><p>来看看输出，你会发现不仅所有三个变量的值都改变了，而且被遮蔽的变量的地址也不同（检查十六进制的最后几个字符）。</p><p>变量 <code>a</code> 和 <code>b</code> 的内存地址改变了。这意味着变量的可变性或不可变性并不是遮蔽变量的限制。</p><h3 id=总结>总结</h3><p>本文介绍了 Rust 编程语言中的变量和常量。还介绍了算术运算。</p><p>做个总结：</p><ul><li>Rust 中的变量默认是不可变的，但是可以引入可变性。</li><li>程序员需要显式地指定变量的可变性。</li><li>常量总是不可变的，无论如何都需要类型注释。</li><li>变量遮蔽是指使用与现有变量相同的名称声明一个 <em>新</em> 变量。</li></ul><p>很好！我相信和 Rust 一起的进展不错。在下一章中，我将讨论 Rust 中的数据类型。敬请关注。</p><p>与此同时，如果你有任何问题，请告诉我。</p><p><em>（题图：MJ/7c5366b8-f926-487e-9153-0a877145ca5）</em></p><hr><p>via: <a href=https://itsfoss.com/rust-variables/>https://itsfoss.com/rust-variables/</a></p><p>作者：<a href=https://itsfoss.com/author/pratham/>Pratham Patel</a> 选题：<a href=https://github.com/lkxed/>lkxed</a> 译者：<a href=https://github.com/Cubik65536>Cubik</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/rust/ rel=tag>Rust</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>