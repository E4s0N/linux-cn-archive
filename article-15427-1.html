<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>在 Linux 中创建定时器 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="在 Linux 中创建定时器"><meta property="og:description" content="这是一个演示如何创建 POSIX 兼容的间隔定时器的教程。"><meta property="og:type" content="article"><meta property="og:url" content="/article-15427-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-01-09T15:02:00+00:00"><meta property="article:modified_time" content="2023-01-09T15:02:00+00:00"><meta itemprop=name content="在 Linux 中创建定时器"><meta itemprop=description content="这是一个演示如何创建 POSIX 兼容的间隔定时器的教程。"><meta itemprop=datePublished content="2023-01-09T15:02:00+00:00"><meta itemprop=dateModified content="2023-01-09T15:02:00+00:00"><meta itemprop=wordCount content="542"><meta itemprop=keywords content="定时器,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>在 Linux 中创建定时器</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2023-01-09T15:02:00Z>January 09, 2023</time></div></div></header><div class="content post__content clearfix"><blockquote><p>这是一个演示如何创建 POSIX 兼容的间隔定时器的教程。</p></blockquote><p><img src=https://img.linux.net.cn/data/attachment/album/202301/09/150238f1d60cmvssr9d0js.jpg alt title="Team checklist"></p><p>对开发人员来说，定时某些事件是一项常见任务。定时器的常见场景是看门狗、任务的循环执行，或在特定时间安排事件。在这篇文章中，我将演示如何使用 <a href=https://linux.die.net/man/2/timer_create>timer_create(&mldr;)</a> 创建一个 POSIX 兼容的间隔定时器。</p><p>你可以从 <a href=https://github.com/hANSIc99/posix_timers>GitHub</a> 下载下面样例的源代码。</p><h3 id=准备-qt-creator>准备 Qt Creator</h3><p>我使用 <a href=https://www.qt.io/product/development-tools>Qt Creator</a> 作为该样例的 IDE。为了在 Qt Creator 运行和调试样例代码，请克隆 <a href=https://github.com/hANSIc99/posix_timers>GitHub</a> 上的仓库，打开 Qt Creator，在 “ 文件 File -> 打开文件或项目…… Open File or Project&mldr; ” 并选择 “CMakeLists.txt”：</p><p><img src=https://img.linux.net.cn/data/attachment/album/202301/09/150241nah3nv2w72w4hay4.png alt="Qt Creator open project"></p><p><em>在 Qt Creator 中打开项目</em></p><p>选择工具链之后，点击 “ 配置项目 Configure Project ”。这个项目包括三个独立的样例（我们在这篇文章中将只会用到其中的两个）。使用绿色标记出来的菜单，可以在每个样例的配置之间切换，并为每个样例激活在终端运行 “ 在终端中运行 Run in terminal ”（用黄色标记）。当前用于构建和调试的活动示例可以通过左下角的“ 调试 Debug ” 按钮进行选择（参见下面的橙色标记）。</p><p><img src=https://img.linux.net.cn/data/attachment/album/202301/09/150242kt4m9zhlkkbh4da3.png alt="Project configuration"></p><p><em>项目配置</em></p><h3 id=线程定时器>线程定时器</h3><p>让我们看看 <code>simple_threading_timer.c</code> 样例。这是最简单的一个。它展示了一个调用了超时函数 <code>expired</code> 的间隔定时器是如何被创建的。在每次过期时，都会创建一个新的线程，在其中调用函数 <code>expired</code>：</p><pre tabindex=0><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
#include &lt;signal.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;

void expired(union sigval timer_data);

pid_t gettid(void);

struct t_eventData{
    int myData;
};

int main()
{
    int res = 0;
    timer_t timerId = 0;

    struct t_eventData eventData = { .myData = 0 };

    /*  sigevent 指定了过期时要执行的操作  */
    struct sigevent sev = { 0 };

    /* 指定启动延时时间和间隔时间 
    * it_value和it_interval 不能为零 */

    struct itimerspec its = {   .it_value.tv_sec  = 1,
                                .it_value.tv_nsec = 0,
                                .it_interval.tv_sec  = 1,
                                .it_interval.tv_nsec = 0
                            };

    printf(&#34;Simple Threading Timer - thread-id: %d\n&#34;, gettid());

    sev.sigev_notify = SIGEV_THREAD;
    sev.sigev_notify_function = &amp;amp;expired;
    sev.sigev_value.sival_ptr = &amp;amp;eventData;

    /* 创建定时器 */
    res = timer_create(CLOCK_REALTIME, &amp;amp;sev, &amp;amp;timerId);

    if (res != 0){
        fprintf(stderr, &#34;Error timer_create: %s\n&#34;, strerror(errno));
        exit(-1);
    }

    /* 启动定时器 */
    res = timer_settime(timerId, 0, &amp;amp;its, NULL);

    if (res != 0){
        fprintf(stderr, &#34;Error timer_settime: %s\n&#34;, strerror(errno));
        exit(-1);
    }

    printf(&#34;Press ETNER Key to Exit\n&#34;);
    while(getchar()!=&#39;\n&#39;){}
    return 0;
}

void expired(union sigval timer_data){
    struct t_eventData *data = timer_data.sival_ptr;
    printf(&#34;Timer fired %d - thread-id: %d\n&#34;, ++data-&gt;myData, gettid());
}
</code></pre><p>这种方法的优点是在代码和简单调试方面用量小。缺点是由于到期时创建新线程而增加额外的开销，因此行为不太确定。</p><h3 id=中断信号定时器>中断信号定时器</h3><p>超时定时器通知的另一种可能性是基于 <a href=https://man7.org/linux/man-pages/man3/signal.3p.html>内核信号</a>。内核不是在每次定时器过期时创建一个新线程，而是向进程发送一个信号，进程被中断，并调用相应的信号处理程序。</p><p>由于接收信号时的默认操作是终止进程（参考 <a href=https://linux.die.net/man/7/signal>signal</a> 手册页），我们必须要提前设置好 Qt Creator，以便进行正确的调试。</p><p>当被调试对象接收到一个信号时，Qt Creator 的默认行为是：</p><ul><li>中断执行并切换到调试器上下文。</li><li>显示一个弹出窗口，通知用户接收到信号。</li></ul><p>这两种操作都不需要，因为信号的接收是我们应用程序的一部分。</p><p>Qt Creator 在后台使用 GDB。为了防止 GDB 在进程接收到信号时停止执行，进入 “ 工具 （ Tools ） -> 选项 Options ” 菜单，选择 “ 调试器 Debugger ”，并导航到 “ 本地变量和表达式 Locals & Expressions ”。添加下面的表达式到 “ 定制调试助手 Debugging Helper Customization ”：</p><pre tabindex=0><code>handle SIG34 nostop pass
</code></pre><p><img src=https://img.linux.net.cn/data/attachment/album/202301/09/150243k77a3mel2h3acqa8.png alt="Signal no stop with error"></p><p><em>Sig 34 时不停止</em></p><p>你可以在 <a href=https://sourceware.org/gdb/onlinedocs/gdb/Signals.html>GDB 文档</a> 中找到更多关于 GDB 信号处理的信息。</p><p>接下来，当我们在信号处理程序中停止时，我们要抑制每次接收到信号时通知我们的弹出窗口:</p><p><img src=https://img.linux.net.cn/data/attachment/album/202301/09/150243bjuu46jvuyv6jl21.png alt="Signal 34 pop up box"></p><p><em>Signal 34 弹出窗口</em></p><p>为此，导航到 “GDB” 标签并取消勾选标记的复选框:</p><p><img src=https://img.linux.net.cn/data/attachment/album/202301/09/150244fpygi1i419yz4kyy.png alt="Timer signal windows"></p><p><em>定时器信号窗口</em></p><p>现在你可以正确的调试 <code>signal_interrupt_timer</code>。真正的信号定时器的实施会更复杂一些：</p><pre tabindex=0><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;signal.h&gt;
#include &lt;unistd.h&gt;
#include &lt;signal.h&gt;
#include &lt;time.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;

#define UNUSED(x) (void)(x)

static void handler(int sig, siginfo_t *si, void *uc);
pid_t gettid(void);

struct t_eventData{
    int myData;
};

int main()
{
    int res = 0;
    timer_t timerId = 0;

    struct sigevent sev = { 0 };
    struct t_eventData eventData = { .myData = 0 };

    /* 指定收到信号时的操作 */
    struct sigaction sa = { 0 };

    /* 指定启动延时的时间和间隔时间 */
    struct itimerspec its = {   .it_value.tv_sec  = 1,
                                .it_value.tv_nsec = 0,
                                .it_interval.tv_sec  = 1,
                                .it_interval.tv_nsec = 0
                            };

    printf(&#34;Signal Interrupt Timer - thread-id: %d\n&#34;, gettid());

    sev.sigev_notify = SIGEV_SIGNAL; // Linux-specific
    sev.sigev_signo = SIGRTMIN;
    sev.sigev_value.sival_ptr = &amp;amp;eventData;

    /* 创建定时器 */
    res = timer_create(CLOCK_REALTIME, &amp;amp;sev, &amp;amp;timerId);

    if ( res != 0){
        fprintf(stderr, &#34;Error timer_create: %s\n&#34;, strerror(errno));
        exit(-1);
    }

    /* 指定信号和处理程序 */
    sa.sa_flags = SA_SIGINFO;
    sa.sa_sigaction = handler;

    /* 初始化信号 */
    sigemptyset(&amp;amp;sa.sa_mask);

    printf(&#34;Establishing handler for signal %d\n&#34;, SIGRTMIN);

    /* 注册信号处理程序 */
    if (sigaction(SIGRTMIN, &amp;amp;sa, NULL) == -1){
        fprintf(stderr, &#34;Error sigaction: %s\n&#34;, strerror(errno));
        exit(-1);
    }

    /* 启动定时器 */
    res = timer_settime(timerId, 0, &amp;amp;its, NULL);

    if ( res != 0){
        fprintf(stderr, &#34;Error timer_settime: %s\n&#34;, strerror(errno));
        exit(-1);
    }

    printf(&#34;Press ENTER to Exit\n&#34;);
    while(getchar()!=&#39;\n&#39;){}
    return 0;
}

static void
handler(int sig, siginfo_t *si, void *uc)
{
    UNUSED(sig);
    UNUSED(uc);
    struct t_eventData *data = (struct t_eventData *) si-&gt;_sifields._rt.si_sigval.sival_ptr;
    printf(&#34;Timer fired %d - thread-id: %d\n&#34;, ++data-&gt;myData, gettid());
}
</code></pre><p>与线程定时器相比，我们必须初始化信号并注册一个信号处理程序。这种方法性能更好，因为它不会导致创建额外的线程。因此，信号处理程序的执行也更加确定。缺点显然是正确调试需要额外的配置工作。</p><h3 id=总结>总结</h3><p>本文中描述的两种方法都是接近内核的定时器的实现。不过，即使 <a href=https://linux.die.net/man/2/timer_create>timer_create(&mldr;)</a> 函数是 POSIX 规范的一部分，由于数据结构的细微差别，也不可能在 FreeBSD 系统上编译样例代码。除了这个缺点之外，这种实现还为通用计时应用程序提供了细粒度控制。</p><hr><p>via: <a href=https://opensource.com/article/21/10/linux-timers>https://opensource.com/article/21/10/linux-timers</a></p><p>作者：<a href=https://opensource.com/users/hansic99>Stephan Avenwedde</a> 选题：<a href=https://github.com/lujun9972>lujun9972</a> 译者：<a href=https://github.com/FigaroCao>FigaroCao</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/%E5%AE%9A%E6%97%B6%E5%99%A8/ rel=tag>定时器</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>