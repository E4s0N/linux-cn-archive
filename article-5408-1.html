<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>自动化部署基于 Docker 的 Rails 应用 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="自动化部署基于 Docker 的 Rails 应用"><meta property="og:description" content="这是系列文章的第三篇，讲述了我的公司是如何将基础设施从PaaS移植到Docker上的。  第一部分:谈论了我接触Docker之前的经历； 第二部分:一步步搭建一个安全而又私有的registry。   在系列文章的最后一篇里，我们将用一个实例来学习如何自动化整个部署过程。 基本的Rails应用程序 现在让我们启动一个基本的Rails应用。为了更好的展示，我使用Ruby 2.2.0和Rails 4.1.1 在终端运行： $ rvm use 2.2.0 $ rails new  cd docker-test  创建一个基本的控制器： $ rails g controller welcome index  ，然后编辑 routes.rb ，以便让该项目的根指向"><meta property="og:type" content="article"><meta property="og:url" content="/article-5408-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2015-05-08T09:12:00+00:00"><meta property="article:modified_time" content="2015-05-08T09:12:00+00:00"><meta itemprop=name content="自动化部署基于 Docker 的 Rails 应用"><meta itemprop=description content="这是系列文章的第三篇，讲述了我的公司是如何将基础设施从PaaS移植到Docker上的。  第一部分:谈论了我接触Docker之前的经历； 第二部分:一步步搭建一个安全而又私有的registry。   在系列文章的最后一篇里，我们将用一个实例来学习如何自动化整个部署过程。 基本的Rails应用程序 现在让我们启动一个基本的Rails应用。为了更好的展示，我使用Ruby 2.2.0和Rails 4.1.1 在终端运行： $ rvm use 2.2.0 $ rails new  cd docker-test  创建一个基本的控制器： $ rails g controller welcome index  ，然后编辑 routes.rb ，以便让该项目的根指向"><meta itemprop=datePublished content="2015-05-08T09:12:00+00:00"><meta itemprop=dateModified content="2015-05-08T09:12:00+00:00"><meta itemprop=wordCount content="407"><meta itemprop=keywords content><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>自动化部署基于 Docker 的 Rails 应用</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2015-05-08T09:12:00Z>May 08, 2015</time></div></div></header><div class="content post__content clearfix"><p><img src=/data/attachment/album/201505/08/011441atgttbjg9yengpbp.jpeg alt></p><p>[TL;DR] 这是系列文章的第三篇，讲述了我的公司是如何将基础设施从PaaS移植到Docker上的。</p><ul><li><a href=/article-5339-1.html>第一部分</a>:谈论了我接触Docker之前的经历；</li><li><a href=/article-5379-1.html>第二部分</a>:一步步搭建一个安全而又私有的registry。</li></ul><hr><p>在系列文章的最后一篇里，我们将用一个实例来学习如何自动化整个部署过程。</p><h3 id=基本的rails应用程序>基本的Rails应用程序</h3><p>现在让我们启动一个基本的Rails应用。为了更好的展示，我使用Ruby 2.2.0和Rails 4.1.1</p><p>在终端运行：</p><pre tabindex=0><code>$ rvm use 2.2.0
$ rails new  &amp;&amp; cd docker-test
</code></pre><p>创建一个基本的控制器：</p><pre tabindex=0><code>$ rails g controller welcome index
</code></pre><p>……，然后编辑 <code>routes.rb</code> ，以便让该项目的根指向我们新创建的welcome#index方法：</p><pre tabindex=0><code>root &#39;welcome#index&#39;  
</code></pre><p>在终端运行 <code>rails s</code> ，然后打开浏览器，登录<a href=http://localhost:3000/>http://localhost:3000</a>，你会进入到索引界面当中。我们不准备给应用加上多么神奇的东西，这只是一个基础的实例，当我们将要创建并部署容器的时候，用它来验证一切是否运行正常。</p><h3 id=安装webserver>安装webserver</h3><p>我们打算使用Unicorn当做我们的webserver。在Gemfile中添加 <code>gem 'unicorn'</code>和 <code>gem 'foreman'</code>然后将它bundle起来(运行 <code>bundle install</code>命令）。</p><p>启动Rails应用时，需要先配置好Unicorn，所以我们将一个<strong>unicorn.rb</strong>文件放在<strong>config</strong>目录下。<a href=https://gist.github.com/chasseurmic/0dad4d692ff499761b20>这里有一个Unicorn配置文件的例子</a>，你可以直接复制粘贴Gist的内容。</p><p>接下来，在项目的根目录下添加一个Procfile，以便可以使用foreman启动应用，内容为下：</p><pre tabindex=0><code>web: bundle exec unicorn -p $PORT -c ./config/unicorn.rb  
</code></pre><p>现在运行<strong>foreman start</strong>命令启动应用，一切都将正常运行，并且你将能够在<a href=http://localhost:5000/>http://localhost:5000</a>上看到一个正在运行的应用。</p><h3 id=构建一个docker镜像>构建一个Docker镜像</h3><p>现在我们构建一个镜像来运行我们的应用。在这个Rails项目的根目录下，创建一个名为<strong>Dockerfile</strong>的文件，然后粘贴进以下内容：</p><pre tabindex=0><code># 基于镜像 ruby 2.2.0
FROM ruby:2.2.0

# 安装所需的库和依赖
RUN apt-get update &amp;&amp; apt-get install -qy nodejs postgresql-client sqlite3 --no-install-recommends &amp;&amp; rm -rf /var/lib/apt/lists/*

# 设置 Rails 版本
ENV RAILS_VERSION 4.1.1

# 安装 Rails
RUN gem install rails --version &#34;$RAILS_VERSION&#34;

# 创建代码所运行的目录 
RUN mkdir -p /usr/src/app  
WORKDIR /usr/src/app

# 使 webserver 可以在容器外面访问
EXPOSE 3000

# 设置环境变量
ENV PORT=3000

# 启动 web 应用
CMD [&#34;foreman&#34;,&#34;start&#34;]

# 安装所需的 gems 
ADD Gemfile /usr/src/app/Gemfile  
ADD Gemfile.lock /usr/src/app/Gemfile.lock  
RUN bundle install --without development test

# 将 rails 项目（和 Dockerfile 同一个目录）添加到项目目录
ADD ./ /usr/src/app

# 运行 rake 任务
RUN RAILS_ENV=production rake db:create db:migrate  
</code></pre><p>使用上述Dockerfile，执行下列命令创建一个镜像（确保<strong>boot2docker</strong>已经启动并在运行当中）:</p><pre tabindex=0><code>$ docker build -t localhost:5000/your_username/docker-test .
</code></pre><p>然后，如果一切正常，长长的日志输出的最后一行应该类似于：</p><pre tabindex=0><code>Successfully built 82e48769506c  
$ docker images
REPOSITORY                                       TAG                 IMAGE ID            CREATED              VIRTUAL SIZE  
localhost:5000/your_username/docker-test         latest              82e48769506c        About a minute ago   884.2 MB  
</code></pre><p>让我们运行一下容器试试！</p><pre tabindex=0><code>$ docker run -d -p 3000:3000 --name docker-test localhost:5000/your_username/docker-test
</code></pre><p>通过你的boot2docker虚拟机的3000号端口（我的是<a href=http://192.168.59.103:3000/>http://192.168.59.103:3000</a>），你可以观察你的Rails应用。（如果不清楚你的boot2docker虚拟地址，输入<code>$ boot2docker ip</code>命令查看。）</p><h3 id=使用shell脚本进行自动化部署>使用shell脚本进行自动化部署</h3><p>前面的文章（指文章1和文章2）已经告诉了你如何将新创建的镜像推送到私有registry中，并将其部署在服务器上，所以我们跳过这一部分直接开始自动化进程。</p><p>我们将要定义3个shell脚本，然后最后使用rake将它们捆绑在一起。</p><h3 id=清除>清除</h3><p>每当我们创建镜像的时候，</p><ul><li>停止并重启boot2docker；</li><li>去除Docker孤儿镜像（那些没有标签，并且不再被容器所使用的镜像们）。</li></ul><p>在你的工程根目录下的<strong>clean.sh</strong>文件中输入下列命令。</p><pre tabindex=0><code>echo Restarting boot2docker...  
boot2docker down  
boot2docker up

echo Exporting Docker variables...  
sleep 1  
export DOCKER_HOST=tcp://192.168.59.103:2376  
export DOCKER_CERT_PATH=/Users/user/.boot2docker/certs/boot2docker-vm  
export DOCKER_TLS_VERIFY=1

sleep 1  
echo Removing orphaned images without tags...  
docker images | grep &#34;&lt;none&gt;&#34; | awk &#39;{print $3}&#39; | xargs docker rmi  
</code></pre><p>给脚本加上执行权限：</p><pre tabindex=0><code>$ chmod +x clean.sh
</code></pre><h3 id=构建>构建</h3><p>构建的过程基本上和之前我们所做的（docker build）内容相似。在工程的根目录下创建一个<strong>build.sh</strong>脚本，填写如下内容：</p><pre tabindex=0><code>docker build -t localhost:5000/your_username/docker-test .  
</code></pre><p>记得给脚本执行权限。</p><h3 id=部署>部署</h3><p>最后，创建一个<strong>deploy.sh</strong>脚本，在里面填进如下内容：</p><pre tabindex=0><code># 打开 boot2docker 到私有注册库的 SSH 连接
boot2docker ssh &#34;ssh -o &#39;StrictHostKeyChecking no&#39; -i /Users/username/.ssh/id_boot2docker -N -L 5000:localhost:5000 root@your-registry.com &amp;&#34; &amp;

# 在推送前先确认该 SSH 通道是开放的。
echo Waiting 5 seconds before pushing image.

echo 5...  
sleep 1  
echo 4...  
sleep 1  
echo 3...  
sleep 1  
echo 2...  
sleep 1  
echo 1...  
sleep 1

# Push image onto remote registry / repo
echo Starting push!  
docker push localhost:5000/username/docker-test  
</code></pre><p>如果你不理解这其中的含义，请先仔细阅读这部分<a href=/article-5379-1.html>第二部分</a>。</p><p>给脚本加上执行权限。</p><h3 id=使用rake将以上所有绑定>使用rake将以上所有绑定</h3><p>现在的情况是，每次你想要部署你的应用时，你都需要单独运行这三个脚本。</p><ol><li>clean</li><li>build</li><li>deploy / push</li></ol><p>这一点都不费工夫，可是事实上开发者比你想象的要懒得多！那么咱们就索性再懒一点！</p><p>我们最后再把工作好好整理一番，我们现在要将三个脚本通过rake捆绑在一起。</p><p>为了更简单一点，你可以在工程根目录下已经存在的Rakefile中添加几行代码，打开Rakefile文件，把下列内容粘贴进去。</p><pre tabindex=0><code>namespace :docker do  
  desc &#34;Remove docker container&#34;
  task :clean do
    sh &#39;./clean.sh&#39;
  end

  desc &#34;Build Docker image&#34;
  task :build =&gt; [:clean] do
    sh &#39;./build.sh&#39;
  end

  desc &#34;Deploy Docker image&#34;
  task :deploy =&gt; [:build] do
    sh &#39;./deploy.sh&#39;
  end
end  
</code></pre><p>即使你不清楚rake的语法（其实你真应该去了解一下，这玩意太酷了！），上面的内容也是很显然的吧。我们在一个命名空间（docker）里声明了三个任务。</p><p>三个任务是：</p><ul><li>rake docker:clean</li><li>rake docker:build</li><li>rake docker:deploy</li></ul><p>Deploy独立于build，build独立于clean。所以每次我们输入命令运行的时候。</p><pre tabindex=0><code>$ rake docker:deploy
</code></pre><p>所有的脚本都会按照顺序执行。</p><h3 id=测试>测试</h3><p>现在我们来看看是否一切正常，你只需要在app的代码里做一个小改动：</p><pre tabindex=0><code>$ rake docker:deploy
</code></pre><p>接下来就是见证奇迹的时刻了。一旦镜像文件被上传（第一次可能花费较长的时间），你就可以ssh登录产品服务器，并且（通过SSH管道）把docker镜像拉取到服务器并运行了。多么简单！</p><p>也许你需要一段时间来习惯，但是一旦成功，它几乎与用Heroku部署一样简单。</p><p>备注：像往常一样，请让我了解到你的意见。我不敢保证这种方法是最好，最快，或者最安全的Docker开发的方法，但是这东西对我们确实奏效。</p><hr><p>via: <a href=http://cocoahunter.com/2015/01/23/docker-3/>http://cocoahunter.com/2015/01/23/docker-3/</a></p><p>作者：<a href=http://cocoahunter.com/author/michelangelo/>Michelangelo Chasseur</a> 译者：<a href=https://github.com/DongShuaike>DongShuaike</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创翻译，<a href=http://linux.cn/>Linux中国</a> 荣誉推出</p></div></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>