<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>LXD 2.0 系列（七）：LXD 中的 Docker - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="LXD 2.0 系列（七）：LXD 中的 Docker"><meta property="og:description" content="我们的确看到使用 Docker 容器来分发应用程序的价值。这就是为什么我们在过去一年中努力工作以便让 LXD 中运行 Docker 成为可能。"><meta property="og:type" content="article"><meta property="og:url" content="/article-8235-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-02-24T08:14:00+00:00"><meta property="article:modified_time" content="2017-02-24T08:14:00+00:00"><meta itemprop=name content="LXD 2.0 系列（七）：LXD 中的 Docker"><meta itemprop=description content="我们的确看到使用 Docker 容器来分发应用程序的价值。这就是为什么我们在过去一年中努力工作以便让 LXD 中运行 Docker 成为可能。"><meta itemprop=datePublished content="2017-02-24T08:14:00+00:00"><meta itemprop=dateModified content="2017-02-24T08:14:00+00:00"><meta itemprop=wordCount content="434"><meta itemprop=keywords content="容器,LXD,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>LXD 2.0 系列（七）：LXD 中的 Docker</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-02-24T08:14:00Z>February 24, 2017</time></div></div></header><div class="content post__content clearfix"><p>这是 LXD 2.0 系列介绍文章的第七篇。</p><ol><li><a href=/article-7618-1.html>LXD 入门</a></li><li><a href=/article-7687-1.html>安装与配置</a></li><li><a href=/article-7706-1.html>你的第一个 LXD 容器</a></li><li><a href=/article-8072-1.html>资源控制</a></li><li><a href=/article-8107-1.html>镜像管理</a></li><li><a href=/article-8169-1.html>远程主机及容器迁移</a></li><li><a href=/article-8235-1.html>LXD 中的 Docker</a></li><li><a href=/article-8257-1.html>LXD 中的 LXD</a></li><li><a href=/article-8263-1.html>实时迁移</a></li><li><a href=/article-8273-1.html>LXD 和 Juju</a></li><li><a href=/article-8274-1.html>LXD 和 OpenStack</a></li><li><a href=/article-8282-1.html>调试，及给 LXD 做贡献</a></li></ol><p><img src=/data/attachment/album/201702/24/041605t4p22tzivy20mwmy.jpg alt></p><h3 id=为什么在-lxd-中运行-docker>为什么在 LXD 中运行 Docker</h3><p>正如我在<a href=/article-7618-1.html>系列的第一篇</a>中简要介绍的，LXD 的重点是系统容器，也就是我们在容器中运行一个完全未经修改的 Linux 发行版。LXD 的所有意图和目的并不在乎容器中的负载是什么。它只是设置容器命名空间和安全策略，然后运行 <code>/sbin/init</code> 来生成容器，接着等待容器停止。</p><p>应用程序容器，例如由 Docker 或 Rkt 所实现的应用程序容器是非常不同的，因为它们用于分发应用程序，通常在它们内部运行单个主进程，并且比 LXD 容器生命期更短暂。</p><p>这两种容器类型不是相互排斥的，我们的确看到使用 Docker 容器来分发应用程序的价值。这就是为什么我们在过去一年中努力工作以便让 LXD 中运行 Docker 成为可能。</p><p>这意味着，使用 Ubuntu 16.04 和 LXD 2.0，您可以为用户创建容器，然后可以像正常的 Ubuntu 系统一样连接到这些容器，然后运行 Docker 来安装他们想要的服务和应用程序。</p><h3 id=要求>要求</h3><p>要让它正常工作要做很多事情，Ubuntu 16.04 上已经包含了这些：</p><ul><li>支持 CGroup 命名空间的内核（4.4 Ubuntu 或 4.6 主线内核）</li><li>使用 LXC 2.0 和 LXCFS 2.0 的 LXD 2.0</li><li>一个自定义版本的 Docker（或一个用我们提交的所有补丁构建的）</li><li>Docker 镜像，其受限于用户命名空间限制，或者使父 LXD 容器成为特权容器（<code>security.privileged = true</code>）</li></ul><h3 id=运行一个基础的-docker-载荷>运行一个基础的 Docker 载荷</h3><p>说完这些，让我们开始运行 Docker 容器！</p><p>首先你可以用下面的命令得到一个 Ubuntu 16.04 的容器：</p><pre tabindex=0><code>lxc launch ubuntu-daily:16.04 docker -p default -p docker
</code></pre><p><code>-p default -p docker</code> 表示 LXD 将 <code>default</code> 和 <code>docker</code> 配置文件应用于容器。<code>default</code> 配置文件包含基本网络配置，而 <code>docker</code> 配置文件告诉 LXD 加载几个必需的内核模块并为容器设置一些挂载。 <code>docker</code> 配置文件还支持容器嵌套。</p><p>现在让我们确保容器是最新的并安装 docker：</p><pre tabindex=0><code>lxc exec docker -- apt update
lxc exec docker -- apt dist-upgrade -y
lxc exec docker -- apt install docker.io -y
</code></pre><p>就是这样！你已经安装并运行了一个 Docker 容器。</p><p>现在让我们用两个 Docker 容器开启一个基础的 web 服务：</p><pre tabindex=0><code>stgraber@dakara:~$ lxc exec docker -- docker run --detach --name app carinamarina/hello-world-app
Unable to find image &#39;carinamarina/hello-world-app:latest&#39; locally
latest: Pulling from carinamarina/hello-world-app
efd26ecc9548: Pull complete 
a3ed95caeb02: Pull complete 
d1784d73276e: Pull complete 
72e581645fc3: Pull complete 
9709ddcc4d24: Pull complete 
2d600f0ec235: Pull complete 
c4cf94f61cbd: Pull complete 
c40f2ab60404: Pull complete 
e87185df6de7: Pull complete 
62a11c66eb65: Pull complete 
4c5eea9f676d: Pull complete 
498df6a0d074: Pull complete 
Digest: sha256:6a159db50cb9c0fbe127fb038ed5a33bb5a443fcdd925ec74bf578142718f516
Status: Downloaded newer image for carinamarina/hello-world-app:latest
c8318f0401fb1e119e6c5bb23d1e706e8ca080f8e44b42613856ccd0bf8bfb0d

stgraber@dakara:~$ lxc exec docker -- docker run --detach --name web --link app:helloapp -p 80:5000 carinamarina/hello-world-web
Unable to find image &#39;carinamarina/hello-world-web:latest&#39; locally
latest: Pulling from carinamarina/hello-world-web
efd26ecc9548: Already exists 
a3ed95caeb02: Already exists 
d1784d73276e: Already exists 
72e581645fc3: Already exists 
9709ddcc4d24: Already exists 
2d600f0ec235: Already exists 
c4cf94f61cbd: Already exists 
c40f2ab60404: Already exists 
e87185df6de7: Already exists 
f2d249ff479b: Pull complete 
97cb83fe7a9a: Pull complete 
d7ce7c58a919: Pull complete 
Digest: sha256:c31cf04b1ab6a0dac40d0c5e3e64864f4f2e0527a8ba602971dab5a977a74f20
Status: Downloaded newer image for carinamarina/hello-world-web:latest
d7b8963401482337329faf487d5274465536eebe76f5b33c89622b92477a670f
</code></pre><p>现在这两个 Docker 容器已经运行了，我们可以得到 LXD 容器的 IP 地址，并且访问它的服务了！</p><pre tabindex=0><code>stgraber@dakara:~$ lxc list
+--------+---------+----------------------+----------------------------------------------+------------+-----------+
|  NAME  |  STATE  |         IPV4         |                      IPV6                    |    TYPE    | SNAPSHOTS |
+--------+---------+----------------------+----------------------------------------------+------------+-----------+
| docker | RUNNING | 172.17.0.1 (docker0) | 2001:470:b368:4242:216:3eff:fe55:45f4 (eth0) | PERSISTENT | 0         |
|        |         | 10.178.150.73 (eth0) |                                              |            |           |
+--------+---------+----------------------+----------------------------------------------+------------+-----------+

stgraber@dakara:~$ curl http://10.178.150.73
The linked container said... &#34;Hello World!&#34;
</code></pre><h3 id=总结>总结</h3><p>就是这样了！在 LXD 容器中运行 Docker 容器真的很简单。</p><p>现在正如我前面提到的，并不是所有的 Docker 镜像都会像我的示例一样，这通常是因为 LXD 带来了额外的限制，特别是用户命名空间。</p><p>在这种模式下只有 Docker 的 overlayfs 存储驱动可以工作。该存储驱动有一组自己的限制，这进一步限制了在该环境中可以有多少镜像工作。</p><p>如果您的负载无法正常工作，并且您信任该 LXD 容器中的用户，你可以试下：</p><pre tabindex=0><code>lxc config set docker security.privileged true
lxc restart docker
</code></pre><p>这将取消激活用户命名空间，并以特权模式运行容器。</p><p>但是请注意，在这种模式下，容器内的 root 与主机上的 root 是相同的 uid。现在有许多已知的方法让用户脱离容器，并获得主机上的 root 权限，所以你应该只有在信任你的 LXD 容器中的用户可以具有主机上的 root 权限才这样做。</p><h3 id=额外信息>额外信息</h3><p>LXD 的主站在： <a href=https://linuxcontainers.org/lxd>https://linuxcontainers.org/lxd</a></p><p>LXD 的 GitHub 仓库： <a href=https://github.com/lxc/lxd>https://github.com/lxc/lxd</a></p><p>LXD 的邮件列表： <a href=https://lists.linuxcontainers.org>https://lists.linuxcontainers.org</a></p><p>LXD 的 IRC 频道： #lxcontainers on irc.freenode.net</p><hr><p>作者简介：我是 Stéphane Graber。我是 LXC 和 LXD 项目的领导者，目前在加拿大魁北克蒙特利尔的家所在的Canonical 有限公司担任 LXD 的技术主管。</p><hr><p>via: <a href=https://www.stgraber.org/2016/04/13/lxd-2-0-docker-in-lxd-712/>https://www.stgraber.org/2016/04/13/lxd-2-0-docker-in-lxd-712/</a></p><p>作者：<a href=https://www.stgraber.org/author/stgraber/>Stéphane Graber</a> 译者：<a href=https://github.com/geekpi>geekpi</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 组织翻译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/%E5%AE%B9%E5%99%A8/ rel=tag>容器</a></li><li class=tags__item><a class="tags__link btn" href=/tags/lxd/ rel=tag>LXD</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>