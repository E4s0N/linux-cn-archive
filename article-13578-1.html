<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>像查询数据库一样查询你的 Linux 操作系统信息 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="像查询数据库一样查询你的 Linux 操作系统信息"><meta property="og:description" content="使用数据库查询操作轻松获取系统信息。"><meta property="og:type" content="article"><meta property="og:url" content="/article-13578-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-07-14T09:58:31+00:00"><meta property="article:modified_time" content="2021-07-14T09:58:31+00:00"><meta itemprop=name content="像查询数据库一样查询你的 Linux 操作系统信息"><meta itemprop=description content="使用数据库查询操作轻松获取系统信息。"><meta itemprop=datePublished content="2021-07-14T09:58:31+00:00"><meta itemprop=dateModified content="2021-07-14T09:58:31+00:00"><meta itemprop=wordCount content="877"><meta itemprop=keywords content="数据库,ps,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>像查询数据库一样查询你的 Linux 操作系统信息</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2021-07-14T09:58:31Z>July 14, 2021</time></div></div></header><div class="content post__content clearfix"><blockquote><p>使用数据库查询操作轻松获取系统信息。</p></blockquote><p><img src=https://img.linux.net.cn/data/attachment/album/202107/14/095820zywm2m2tzz5otfh5.jpg alt title="Magnifying glass on code"></p><p>Linux 提供了很多帮助用户收集主机操作系统信息的命令：列出文件或者目录的属性信息；查询安装的软件包、正在执行的命令、开机时启动的服务；或者了解系统的硬件。</p><p>每个命令使用自己的输出格式列出系统的信息。你需要使用 <code>grep</code>、<code>sed</code>、<code>awk</code> 这样的工具过滤命令输出的结果，以便找到特定的信息。此外，很多这样的信息会频繁变动，导致系统状态的改变。</p><p>将所有的信息格式化为一个数据库的 SQL 查询的输出进行查看将会十分有益。想象一下，你能够像查询具有类似名称的 SQL 数据库表一样查询 <code>ps</code> 和 <code>rpm</code> 命令的输出。</p><p>幸运的是，有一个工具刚好实现了这个功能，而且功能更多：<a href=https://osquery.io/>Osquery</a> 是一个 <a href=https://github.com/osquery/osquery>开源的</a> “由 SQL 驱动的操作系统仪表、监控和分析框架”。</p><p>许多处理安全、DevOps、合规性的应用，以及仓储管理管理（仅举几例）在内部依赖 Osquery 提供的核心功能。</p><h3 id=安装-osquery>安装 Osquery</h3><p>Osquery 适用于 Linux、macOS、Windows、FreeBSD。请按照 <a href=https://osquery.io/downloads/official>指南</a> 为你的操作系统安装最新版本。（我会在下面的例子中使用 4.7.0 版本。）</p><p>安装完成后，确保 Osquery 可以工作：</p><pre tabindex=0><code>$ rpm -qa | grep osquery
osquery-4.7.0-1.linux.x86_64
$
$ osqueryi --version
osqueryi version 4.7.0
$
</code></pre><h3 id=osquery-组件>Osquery 组件</h3><p>Osquery 有两个主要组件：</p><ul><li><code>osqueri</code> 是一个交互式的 SQL 查询控制台，可以独立运行，不需要超级用户权限（除非要查询的表格需要访问权限）。</li><li><code>osqueryd</code> 像一个安装在主机的监控守护进程，可以定期调度查询操作执行，从底层架构收集信息。</li></ul><p>可以在不运行 <code>osqueryd</code> 的情况下执行 <code>osqueri</code>。另一个工具，<code>osqueryctl</code>，控制守护进程的启动、停止，并检查其状态。</p><pre tabindex=0><code>$ rpm -ql osquery-4.8.0-1.linux.x86_64 | grep bin
/usr/bin/osqueryctl
/usr/bin/osqueryd
/usr/bin/osqueryi
$
</code></pre><h3 id=使用-osqueryi-交互式命令提示符>使用 osqueryi 交互式命令提示符</h3><p>你和 Osquery 的交互与使用 SQL 数据库十分相似。事实上，<code>osqueryi</code> 是 SQList shell 的一个修改版。执行 <code>osqueryi</code> 命令进入交互式命令提示符 ，就可以执行 Osquery 的命令，通常以 <code>.</code> 开始：</p><pre tabindex=0><code>$ osqueryi
Using a virtual database. Need help, type &#39;.help&#39;
osquery&gt;
</code></pre><p>要退出交互式命令提示符，执行 <code>.quit</code> 命令回到操作系统的命令提示符：</p><pre tabindex=0><code>osquery&gt;
osquery&gt; .quit
$
</code></pre><h3 id=找出可用的表>找出可用的表</h3><p>如前所述，Osquery 像 SQL 查询一样输出数据，数据库中的信息通常保存在表中。但是如何在不知道表名的情况下查询这些表呢？你可以运行 <code>.tables</code> 命令列出所有可以查询的表。如果你是一个 Linux 长期用户或者一个系统管理员 ，就会对表名十分熟悉，因为你一直在使用操作系统命令获取同样的信息：</p><pre tabindex=0><code>osquery&gt; .tables
  =&gt; acpi_tables
  =&gt; apparmor_events
  =&gt; apparmor_profiles
  =&gt; apt_sources

&lt;&lt;裁剪&gt;&gt;

  =&gt; arp_cache
  =&gt; user_ssh_keys
  =&gt; users
  =&gt; yara
  =&gt; yara_events
  =&gt; ycloud_instance_metadata
  =&gt; yum_sources
osquery&gt;
</code></pre><h3 id=检查各个表的模式>检查各个表的模式</h3><p>知道表名后，可以查看每个表提供的信息。既然 <code>ps</code> 命令经常用于获取进程信息，就以 <code>processes</code> 为例。执行 <code>.schema</code> 命令加上表名查看表中保存的信息。如果要验证命令返回的结果，可以快速执行 <code>ps -ef</code> 或 <code>ps aux</code>，对比命令的输出和表中的内容：</p><pre tabindex=0><code>osquery&gt; .schema processes
CREATE TABLE processes(`pid` BIGINT, `name` TEXT, `path` TEXT, `cmdline` TEXT, `state` TEXT, `cwd` TEXT, `root` TEXT, `uid` BIGINT, `gid` BIGINT, `euid` BIGINT, `egid` BIGINT, `suid` BIGINT, `sgid` BIGINT, `on_disk` INTEGER, `wired_size` BIGINT, `resident_size` BIGINT, `total_size` BIGINT, `user_time` BIGINT, `system_time` BIGINT, `disk_bytes_read` BIGINT, `disk_bytes_written` BIGINT, `start_time` BIGINT, `parent` BIGINT, `pgroup` BIGINT, `threads` INTEGER, `nice` INTEGER, `is_elevated_token` INTEGER HIDDEN, `elapsed_time` BIGINT HIDDEN, `handle_count` BIGINT HIDDEN, `percent_processor_time` BIGINT HIDDEN, `upid` BIGINT HIDDEN, `uppid` BIGINT HIDDEN, `cpu_type` INTEGER HIDDEN, `cpu_subtype` INTEGER HIDDEN, `phys_footprint` BIGINT HIDDEN, PRIMARY KEY (`pid`)) WITHOUT ROWID;
osquery&gt;
</code></pre><p>要进一步确认，可以使用下面的命令查看 RPM 包的结构信息，然后与操作系统命令 <code>rpm -qa</code> 和 <code>rpm -qi</code> 的输出比较：</p><pre tabindex=0><code>osquery&gt;
osquery&gt; .schema rpm_packages
CREATE TABLE rpm_packages(`name` TEXT, `version` TEXT, `release` TEXT, `source` TEXT, `size` BIGINT, `sha1` TEXT, `arch` TEXT, `epoch` INTEGER, `install_time` INTEGER, `vendor` TEXT, `package_group` TEXT, `pid_with_namespace` INTEGER HIDDEN, `mount_namespace_id` TEXT HIDDEN, PRIMARY KEY (`name`, `version`, `release`, `arch`, `epoch`, `pid_with_namespace`)) WITHOUT ROWID;
osquery&gt;
</code></pre><p>从 Osquery 的 <a href=https://osquery.io/schema/4.8.0/>表格文档</a> 获取更多信息。</p><h3 id=使用-pragma-命令>使用 PRAGMA 命令</h3><p>或许模式信息对你来说太难看懂，还有另一种途径能够以详细的表格格式打印表中的信息：<code>PRAGMA</code> 命令。例如，我想通过 <code>PRAGMA</code> 用一种易于理解的格式查看 <code>rpm_packages</code> 表的信息：</p><pre tabindex=0><code>osquery&gt; PRAGMA table_info(rpm_packages);
</code></pre><p>这种表格式信息的一个好处是你可以关注想要查询的字段，查看命令提供的类型信息：</p><pre tabindex=0><code>osquery&gt; PRAGMA table_info(users);
+-----+-------------+--------+---------+------------+----+
| cid | name        | type   | notnull | dflt_value | pk |
+-----+-------------+--------+---------+------------+----+
| 0   | uid         | BIGINT | 1       |            | 1  |
| 1   | gid         | BIGINT | 0       |            | 0  |
| 2   | uid_signed  | BIGINT | 0       |            | 0  |
| 3   | gid_signed  | BIGINT | 0       |            | 0  |
| 4   | username    | TEXT   | 1       |            | 2  |
| 5   | description | TEXT   | 0       |            | 0  |
| 6   | directory   | TEXT   | 0       |            | 0  |
| 7   | shell       | TEXT   | 0       |            | 0  |
| 8   | uuid        | TEXT   | 1       |            | 3  |
+-----+-------------+--------+---------+------------+----+
osquery&gt;
</code></pre><h3 id=进行你的第一次查询>进行你的第一次查询</h3><p>在你从表、模式、条目中获取到所有进行查询所需要的信息后，进行你的第一次 SQL 查询查看其中的信息。下面的查询返回系统中的用户和每个用户的用户 ID、组 ID、主目录和默认的命令行解释器。Linux 用户通过查看 <code>/etc/passwd</code> 文件的内容并执行 <code>grep</code>、<code>sed</code>、<code>awk</code> 命令获取同样的信息。</p><pre tabindex=0><code>osquery&gt;
osquery&gt; select uid,gid,directory,shell,uuid FROM users LIMIT 7;
+-----+-----+----------------+----------------+------+
| uid | gid | directory      | shell          | uuid |
+-----+-----+----------------+----------------+------+
| 0   | 0   | /root          | /bin/bash      |      |
| 1   | 1   | /bin           | /sbin/nologin  |      |
| 2   | 2   | /sbin          | /sbin/nologin  |      |
| 3   | 4   | /var/adm       | /sbin/nologin  |      |
| 4   | 7   | /var/spool/lpd | /sbin/nologin  |      |
| 5   | 0   | /sbin          | /bin/sync      |      |
| 6   | 0   | /sbin          | /sbin/shutdown |      |
+-----+-----+----------------+----------------+------+
osquery&gt;
</code></pre><h3 id=不进入交互模式的查询>不进入交互模式的查询</h3><p>如果你想要在不进入 <code>osqueri</code> 交互模式的情况下进行查询，该怎么办？要用查询操作写命令行解释器脚本，这种方式可能十分有用。这种情况下，可以直接从 Bash 解释器 <code>echo</code> SQL 查询，通过管道输出到 <code>osqueri</code> ：</p><pre tabindex=0><code>$ echo &#34;select uid,gid,directory,shell,uuid FROM users LIMIT 7;&#34; | osqueryi
+-----+-----+----------------+----------------+------+
| uid | gid | directory      | shell          | uuid |
+-----+-----+----------------+----------------+------+
| 0   | 0   | /root          | /bin/bash      |      |
| 1   | 1   | /bin           | /sbin/nologin  |      |
| 2   | 2   | /sbin          | /sbin/nologin  |      |
| 3   | 4   | /var/adm       | /sbin/nologin  |      |
| 4   | 7   | /var/spool/lpd | /sbin/nologin  |      |
| 5   | 0   | /sbin          | /bin/sync      |      |
| 6   | 0   | /sbin          | /sbin/shutdown |      |
+-----+-----+----------------+----------------+------+
$
</code></pre><h3 id=获悉系统启动时开始的服务>获悉系统启动时开始的服务</h3><p>Osquery 还可以列出系统启动时开始的所有服务。例如，可以查询 <code>startup_items</code> 表获取启动时开始的前五项服务的名称、状态和路径：</p><pre tabindex=0><code>osquery&gt; SELECT name,type,status,path FROM startup_items LIMIT 5;
  name = README
  type = Startup Item
status = enabled
  path = /etc/rc.d/init.d/README

  name = anamon
  type = Startup Item
status = enabled
  path = /etc/rc.d/init.d/anamon

  name = functions
  type = Startup Item
status = enabled
  path = /etc/rc.d/init.d/functions

  name = osqueryd
  type = Startup Item
status = enabled
  path = /etc/rc.d/init.d/osqueryd

  name = AT-SPI D-Bus Bus
  type = Startup Item
status = enabled
  path = /usr/libexec/at-spi-bus-launcher --launch-immediately
osquery&gt;
</code></pre><h3 id=查阅二进制文件的-elf-信息>查阅二进制文件的 ELF 信息</h3><p>假如你想要弄清 <code>ls</code> 二进制文件的更多细节，通常会通过 <code>readelf -h</code> 命令，加上 <code>ls</code> 命令的路径。查询 Osquery 的 <code>elf_info</code> 表你可以得到同样的信息：</p><pre tabindex=0><code>osquery&gt; SELECT * FROM elf_info WHERE path=&#34;/bin/ls&#34;;
      class = 64
        abi = sysv
abi_version = 0
       type = dyn
    machine = 62
    version = 1
      entry = 24064
      flags = 0
       path = /bin/ls
osquery&gt;
</code></pre><p>现在你应该初步了解如何使用 <code>osqueri</code> 查询自己想要的信息。然而，这些信息保存在数量巨大的表中；我查询过的一个系统中，有 156 个不同的表，这个数字可能是十分惊人的：</p><pre tabindex=0><code>$ echo &#34;.tables&#34; | osqueryi | wc -l
156
$
</code></pre><p>要让事情变得更容易，可以从这些表开始获取你的 Linux 系统的信息：</p><p><strong>系统信息表：</strong></p><pre tabindex=0><code>osquery&gt; select * from system_info;
</code></pre><p><strong>系统限制信息：</strong></p><pre tabindex=0><code>osquery&gt; select * from ulimit_info;
</code></pre><p><strong>由各种进程打开的文件：</strong></p><pre tabindex=0><code>osquery&gt; select * from process_open_files;
</code></pre><p><strong>系统上开放的端口：</strong></p><pre tabindex=0><code>osquery&gt; select * from listening_ports;
</code></pre><p><strong>运行中的进程信息：</strong></p><pre tabindex=0><code>osquery&gt; select * from processes;
</code></pre><p><strong>已安装的包信息：</strong></p><pre tabindex=0><code>osquery&gt; select * from rpm_packages;
</code></pre><p><strong>用户登录信息：</strong></p><pre tabindex=0><code>osquery&gt; select * from last;
</code></pre><p><strong>系统日志信息：</strong></p><pre tabindex=0><code>osquery&gt; select * from syslog_events;
</code></pre><h3 id=了解更多>了解更多</h3><p>Osquery 是一个强大的工具，提供了许多可以用于解决各种使用案例的主机信息。你可以阅读 <a href=https://osquery.readthedocs.io/en/latest/>文档</a> 了解更多 Osquery 的信息。</p><hr><p>via: <a href=https://opensource.com/article/21/6/osquery-linux>https://opensource.com/article/21/6/osquery-linux</a></p><p>作者：<a href=https://opensource.com/users/gkamathe>Gaurav Kamathe</a> 选题：<a href=https://github.com/lujun9972>lujun9972</a> 译者：<a href=https://github.com/YungeG>YungeG</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/ rel=tag>数据库</a></li><li class=tags__item><a class="tags__link btn" href=/tags/ps/ rel=tag>ps</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>