<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>抽丝剥茧 Linux 浮点运算的原理 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="抽丝剥茧 Linux 浮点运算的原理"><meta property="og:description" content="最近我们有一个需求，需要把用户态的浮点数运算全部放到内核态运行，以提高运行速度，移植的过程中发现问题没有这么简单，然后我们抽丝剥茧，揭开 Linux 对浮点处理的原理。"><meta property="og:type" content="article"><meta property="og:url" content="/article-13474-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-06-10T21:56:00+00:00"><meta property="article:modified_time" content="2021-06-10T21:56:00+00:00"><meta itemprop=name content="抽丝剥茧 Linux 浮点运算的原理"><meta itemprop=description content="最近我们有一个需求，需要把用户态的浮点数运算全部放到内核态运行，以提高运行速度，移植的过程中发现问题没有这么简单，然后我们抽丝剥茧，揭开 Linux 对浮点处理的原理。"><meta itemprop=datePublished content="2021-06-10T21:56:00+00:00"><meta itemprop=dateModified content="2021-06-10T21:56:00+00:00"><meta itemprop=wordCount content="460"><meta itemprop=keywords content="内核,浮点运算,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>抽丝剥茧 Linux 浮点运算的原理</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2021-06-10T21:56:00Z>June 10, 2021</time></div></div></header><div class="content post__content clearfix"><p><img src=https://img.linux.net.cn/data/attachment/album/202106/10/215454au2bbgvqbnqceg75.jpg alt></p><blockquote><p>编者按：本文来自华辰连科技术团队，分享了他们在将浮点运算放到内核态时的探索。</p></blockquote><p>最近我们有一个需求，需要把用户态的浮点数运算全部放到内核态运行，以提高运行速度，移植的过程中发现问题没有这么简单，然后我们抽丝剥茧，揭开 Linux 对浮点处理的原理。</p><p>此文章的代码基于 x86 64 位 CPU，Linux 4.14 内核。</p><h3 id=一-linux-内核添加浮点运算出现的问题>一、 Linux 内核添加浮点运算出现的问题</h3><p>我们以一个简单的浮点运算例子来说明：</p><pre tabindex=0><code>#include &lt;linux/module.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/debugfs.h&gt;
#include &lt;asm/fpu/api.h&gt;
#include &lt;linux/delay.h&gt;

static noinline double float_divide(double float1, double float2)
{
    return float1 / float2;
}

static int __init test_float_init(void)
{
  double result, float1 = 4.9, float2 = 0.49;
​
  result = float_divide(float1, float2);
  printk(&#34;result = %d\n&#34;, (int)result);
​
  return 0;
}
​
static void __exit test_float_exit(void)
{
  ;
}
​
module_init(test_float_init);
module_exit(test_float_exit);
MODULE_LICENSE(&#34;GPL&#34;);
</code></pre><p><em>test_float.c</em></p><pre tabindex=0><code>obj-m := test_float.o
KDIR := /lib/modules/$(shell uname -r)/build
​
all:
make -C $(KDIR) M=$(PWD) modules
</code></pre><p><em>Makefile</em></p><p>这个内核模块就是计算了两个浮点数除的结果，然后将结果打印出来 。但是我们执行 <code>make</code> 编译的时候发现报错：</p><p><img src=https://img.linux.net.cn/data/attachment/album/202106/10/212535snn8q7eku7vk4q4w.png alt></p><p>提示 SSE 寄存器返回的报错信息为 “SSE disabled”。我们执行 <code>make V=1</code> 查看关键的编译信息：</p><p><img src=https://img.linux.net.cn/data/attachment/album/202106/10/212628agc1h95055h7i1h0.png alt></p><p>我们发现在 <code>gcc</code> 的参数中有 <code>-mno-sse -mno-mmx -mno-sse2</code> 选项，原来 <code>gcc</code> 默认的编译选项禁用了 sse、mmx、sse2 等浮点运算指令。</p><h3 id=二通过添加-gcc-编译参数和-kernel_fpu_beginkernel_fpu_end-来解决问题>二、通过添加 gcc 编译参数和 kernel_fpu_begin/kernel_fpu_end 来解决问题</h3><p>为了让内核支持浮点运算，我们在 <code>Makefile</code> 中添加支持 sse 等选项，源码中添加 <code>kernel_fpu_begin</code>/<code>kernel_fpu_end</code> 函数，修改后的源码如下所示：</p><pre tabindex=0><code>#include &lt;linux/module.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/debugfs.h&gt;
#include &lt;asm/fpu/api.h&gt;
#include &lt;linux/delay.h&gt;

static noinline double float_divide(double float1, double float2)
{
    return float1 / float2;
}

static int __init test_float_init(void)
{
  double result, float1 = 4.9, float2 = 0.49;
​
  kernel_fpu_begin();
  result = float_divide(float1, float2);
  kernel_fpu_end();
  printk(&#34;result = %d\n&#34;, (int)result);
​
  return 0;
}
​
static void __exit test_float_exit(void)
{
  ;
}
​
module_init(test_float_init);
module_exit(test_float_exit);
MODULE_LICENSE(&#34;GPL&#34;);
</code></pre><p><em>test_float.c</em></p><pre tabindex=0><code>obj-m := test_float.o
KDIR := /lib/modules/$(shell uname -r)/build
​
FPU_CFLAGS += -mhard-float
FPU_CFLAGS += -msse -msse2
CFLAGS_test_float.o += $(FPU_CFLAGS)
​
all:
make -C $(KDIR) M=$(PWD) modules
</code></pre><p><em>Makefile</em></p><p>此时执行 <code>make</code>，发现编译正确通过了：</p><p><img src=https://img.linux.net.cn/data/attachment/album/202106/10/212903ut3g2tbre61e6tuk.png alt></p><p>然后 <code>insmod test_float.ko</code>，观察 <code>dmesg</code> 的输出：</p><p><img src=https://img.linux.net.cn/data/attachment/album/202106/10/212940pulwj8knknhwvzzh.png alt></p><p>从上面的例子，结合内核源码中 <code>arch/x86/Makefile</code> 中的 <code>KBUILD_CFLAGS</code>，可以看到编译内核及内核模块时，<code>gcc</code> 选项继承 Linux 中的规则，指定了 <code>-mno-sse -mno-mmx -mno-sse2</code>，也就是禁用了 FPU 。所以，要想内核模组支持浮点运算，编译选项需要显式的指定 <code>-msse -msse2</code>。</p><h3 id=三-linux-内核态对浮点运算处理方式的分析>三、 Linux 内核态对浮点运算处理方式的分析</h3><p>从上面可以看到，我们为了实现一个内核模块的浮点运算，添加了编译参数 <code>-mhard-float和-msse -msse2</code>，对于编译参数来说，<code>-mhard-float</code> 是告诉编译器直接生成浮点运算的指令，而 <code>-msse -msse2</code> 则是告诉编译器可以使用 sse/sse2 指令集来编译代码。</p><p><code>kernel_fpu_begin</code> 和 <code>kernel_fpu_end</code> 也是必须的，因为 Linux 内核为了提高系统的运行速率，在任务上下文切换时，只会保存/恢复普通寄存器的值，并不包括 FPU 浮点寄存器的值，而调用 <code>kernel_fpu_begin</code> 主要作用是关掉系统抢占，浮点计算结束后调用 <code>kernel_fpu_end</code> 开启系统抢占，这使得代码不会被中断，从而安全的进行浮点运算，并且要求这之间的代码不能有休眠或调度操作，另外不得有嵌套的情况出现（将会覆盖原始保存的状态，然后执行 <code>kernel_fpu_end()</code> 最终将恢复错误的 FPU 状态）。</p><pre tabindex=0><code>void kernel_fpu_begin(void)
{
  preempt_disable();
  __kernel_fpu_begin();
}
</code></pre><h3 id=四三角函数在-linux-内核态的实现>四、三角函数在 Linux 内核态的实现</h3><p>由于内核态不支持浮点运算，所以像三角函数之类浮点运算都没有实现，如果需要，可以将用户态 glibc 中相关的三角函数的实现移植到内核态。</p><h3 id=五-linux-用户态对浮点运算处理方式的分析>五、 Linux 用户态对浮点运算处理方式的分析</h3><p>为什么用户态浮点运算就不需要指定编译选项以及显式调用 <code>kernel_fpu_begin</code> 和 <code>kernel_fpu_end</code> 函数呢？我们在用户态下写一个简单的带浮点运算的例子：</p><pre tabindex=0><code>#include &lt;stdio.h&gt;
​
int main(int argc, char **argv)
{
  int result, float1=4.9, float2=0.49;
​
  result = float1 / float2;
  printf(&#34;result = %d\n&#34;, result);
​
  return 0;
}
</code></pre><p><em>user_float.c</em></p><p>我们分别使用下面四条编译指令查看编译出来的汇编：</p><ol><li><code>gcc -S user_float.c</code></li><li><code>gcc -S user_float.c -msoft-float</code></li><li><code>gcc -S user_float.c -mhard-float</code></li><li><code>gcc -S user_float.c -msoft-float -mno-sse -mno-mmx -mno-sse2</code></li></ol><p>前三条命令编译成功。依次查看编译生成的汇编代码，发现生成的汇编代码是完全一样的，都是用到了 sse 指令中的 mmx 寄存器，也就是使用到了 FPU。</p><p>第四条命令编译失败 ，提示 <code>error: SSE register return with SSE disabled</code>。从上面的现象中我们可以得出结论，系统默认使用 <code>gcc</code> 编译用户态程序时，<code>gcc</code> 默认使用 FPU，也就是使用硬浮点来编译。</p><p>经过查阅各种文档和分析代码，x86 CPU 提供如下特性：CPU 提供的 TS 寄存器的第三个位是 任务已切换标志 （ Task Switched bit ） ，CPU 在每次任务切换时会设置这个位。而且 TS 的这个位被设置时，当进程使用 FPU 指令时 CPU 会产生一个 DNA（Device Not Availabel）异常。Linux 使用此特性，当用户态应用程序进行浮点运算时（SSE 等指令），触发 DNA 异常，同时使用 FPU 专用寄存器和指令来执行浮点数功能，此时 <code>TS_USEDFPU</code> 标志为 1，表示用户态进程使用了 FPU。</p><pre tabindex=0><code>void fpu__restore(struct fpu *fpu)
{
  fpu__initialize(fpu);

  /* Avoid __kernel_fpu_begin() right after fpregs_activate() */
  kernel_fpu_disable();
  trace_x86_fpu_before_restore(fpu);
  fpregs_activate(fpu);
  copy_kernel_to_fpregs(&amp;fpu-&gt;state);
  trace_x86_fpu_after_restore(fpu);
  kernel_fpu_enable();
}
EXPORT_SYMBOL_GPL(fpu__restore);
</code></pre><p>假设用户态进程 A 使用到了 FPU 执行浮点运算，此时用户态进程 B 被调度执行，那么当进程 A 被调度出去的时候，内核设置 TS 并调用 <code>fpu__restore</code> 将 FPU 的内容保存。当进程 A 恢复浮点运算执行时，触发 DNA 异常，相应的异常处理程序会恢复 FPU 之前保存的状态。</p><p>假设用户态进程 A 使用到了 FPU 执行浮点运算（<code>TS_USEDFPU</code> 标志为 1），此时内核态进程 C 调度并使用 FPU，由于内核只会保存普通的寄存器的值，并不包括 FP 等寄存器的值，所以内核会主动调用 <code>kernel_fpu_begin</code> 函数保存寄存器内容，使用完之后调用 <code>kernel_fpu_end</code>。当用户态进程 A 恢复浮点运算执行时，触发 DNA 异常，相应的异常处理程序会恢复 FPU 寄存器的内容。</p><h3 id=六-结论>六、 结论</h3><ol><li>Linux 中当任务切换时，缺省不保存浮点器寄存器。</li><li>如果需要内核态支持浮点运算，需要增加支持浮点的编译选项和使用 <code>kernel_fpu_begin</code> 和 <code>kernel_fpu_end</code> 函数手动处理上下文。</li><li>用户态缺省支持浮点运算，但是需要内核来辅助。</li></ol></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/%E5%86%85%E6%A0%B8/ rel=tag>内核</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E6%B5%AE%E7%82%B9%E8%BF%90%E7%AE%97/ rel=tag>浮点运算</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>