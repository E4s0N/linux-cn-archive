<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Go 语言在极小硬件上的运用（一） - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="Go 语言在极小硬件上的运用（一）"><meta property="og:description" content="Go 语言，能在多低下的配置上运行并发挥作用呢？"><meta property="og:type" content="article"><meta property="og:url" content="/article-11383-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-09-24T21:03:09+00:00"><meta property="article:modified_time" content="2019-09-24T21:03:09+00:00"><meta itemprop=name content="Go 语言在极小硬件上的运用（一）"><meta itemprop=description content="Go 语言，能在多低下的配置上运行并发挥作用呢？"><meta itemprop=datePublished content="2019-09-24T21:03:09+00:00"><meta itemprop=dateModified content="2019-09-24T21:03:09+00:00"><meta itemprop=wordCount content="940"><meta itemprop=keywords content="Go,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>Go 语言在极小硬件上的运用（一）</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2019-09-24T21:03:09Z>September 24, 2019</time></div></div></header><div class="content post__content clearfix"><p><img src=/data/attachment/album/201909/24/210256yihkuy8kcigugr2h.png alt></p><p>Go 语言，能在多低下的配置上运行并发挥作用呢？</p><p>我最近购买了一个特别便宜的开发板：</p><p><img src=/data/attachment/album/201909/24/210325sk2snn6u6hs82tu7.jpg alt=STM32F030F4P6></p><p>我购买它的理由有三个。首先，我（作为程序员）从未接触过 STM320 系列的开发板。其次，STM32F10x 系列使用也有点少了。STM320 系列的 MCU 很便宜，有更新一些的外设，对系列产品进行了改进，问题修复也做得更好了。最后，为了这篇文章，我选用了这一系列中最低配置的开发板，整件事情就变得有趣起来了。</p><h3 id=硬件部分>硬件部分</h3><p><a href=http://www.st.com/content/st_com/en/products/microcontrollers/stm32-32-bit-arm-cortex-mcus/stm32-mainstream-mcus/stm32f0-series/stm32f0x0-value-line/stm32f030f4.html>STM32F030F4P6</a> 给人留下了很深的印象：</p><ul><li>CPU: <a href=https://en.wikipedia.org/wiki/ARM_Cortex-M#Cortex-M0>Cortex M0</a> 48 MHz（最低配置，只有 12000 个逻辑门电路）</li><li>RAM: 4 KB，</li><li>Flash: 16 KB，</li><li>ADC、SPI、I2C、USART 和几个定时器</li></ul><p>以上这些采用了 TSSOP20 封装。正如你所见，这是一个很小的 32 位系统。</p><h3 id=软件部分>软件部分</h3><p>如果你想知道如何在这块开发板上使用 <a href=https://golang.org/>Go</a> 编程，你需要反复阅读硬件规范手册。你必须面对这样的真实情况：在 Go 编译器中给 Cortex-M0 提供支持的可能性很小。而且，这还仅仅只是第一个要解决的问题。</p><p>我会使用 <a href=https://github.com/ziutek/emgo>Emgo</a>，但别担心，之后你会看到，它如何让 Go 在如此小的系统上尽可能发挥作用。</p><p>在我拿到这块开发板之前，对 <a href=https://github.com/ziutek/emgo/tree/master/egpath/src/stm32/hal>stm32/hal</a> 系列下的 F0 MCU 没有任何支持。在简单研究<a href=http://www.st.com/resource/en/reference_manual/dm00091010.pdf>参考手册</a>后，我发现 STM32F0 系列是 STM32F3 削减版，这让在新端口上开发的工作变得容易了一些。</p><p>如果你想接着本文的步骤做下去，需要先安装 Emgo</p><pre tabindex=0><code>cd $HOME
git clone https://github.com/ziutek/emgo/
cd emgo/egc
go install
</code></pre><p>然后设置一下环境变量</p><pre tabindex=0><code>export EGCC=path_to_arm_gcc      # eg. /usr/local/arm/bin/arm-none-eabi-gcc
export EGLD=path_to_arm_linker   # eg. /usr/local/arm/bin/arm-none-eabi-ld
export EGAR=path_to_arm_archiver # eg. /usr/local/arm/bin/arm-none-eabi-ar

export EGROOT=$HOME/emgo/egroot
export EGPATH=$HOME/emgo/egpath

export EGARCH=cortexm0
export EGOS=noos
export EGTARGET=f030x6
</code></pre><p>更详细的说明可以在 <a href=https://github.com/ziutek/emgo>Emgo</a> 官网上找到。</p><p>要确保 <code>egc</code> 在你的 <code>PATH</code> 中。 你可以使用 <code>go build</code> 来代替 <code>go install</code>，然后把 <code>egc</code> 复制到你的 <code>$HOME/bin</code> 或 <code>/usr/local/bin</code> 中。</p><p>现在，为你的第一个 Emgo 程序创建一个新文件夹，随后把示例中链接器脚本复制过来：</p><pre tabindex=0><code>mkdir $HOME/firstemgo
cd $HOME/firstemgo
cp $EGPATH/src/stm32/examples/f030-demo-board/blinky/script.ld .
</code></pre><h3 id=最基本程序>最基本程序</h3><p>在 <code>main.go</code> 文件中创建一个最基本的程序：</p><pre tabindex=0><code>package main

func main() {
}
</code></pre><p>文件编译没有出现任何问题：</p><pre tabindex=0><code>$ egc
$ arm-none-eabi-size cortexm0.elf
   text    data     bss     dec     hex filename
   7452     172     104    7728    1e30 cortexm0.elf
</code></pre><p>第一次编译可能会花点时间。编译后产生的二进制占用了 7624 个字节的 Flash 空间（文本 + 数据）。对于一个什么都没做的程序来说，占用的空间有些大。还剩下 8760 字节，可以用来做些有用的事。</p><p>不妨试试传统的 “Hello, World!” 程序：</p><pre tabindex=0><code>package main

import &#34;fmt&#34;

func main() {
    fmt.Println(&#34;Hello, World!&#34;)
}
</code></pre><p>不幸的是，这次结果有些糟糕：</p><pre tabindex=0><code>$ egc
/usr/local/arm/bin/arm-none-eabi-ld: /home/michal/P/go/src/github.com/ziutek/emgo/egpath/src/stm32/examples/f030-demo-board/blog/cortexm0.elf section `.text&#39; will not fit in region `Flash&#39;
/usr/local/arm/bin/arm-none-eabi-ld: region `Flash&#39; overflowed by 10880 bytes
exit status 1
</code></pre><p>“Hello, World!” 需要 STM32F030x6 上至少 32KB 的 Flash 空间。</p><p><code>fmt</code> 包强制包含整个 <code>strconv</code> 和 <code>reflect</code> 包。这三个包，即使在精简版本中的 Emgo 中，占用空间也很大。我们不能使用这个例子了。有很多的应用不需要好看的文本输出。通常，一个或多个 LED，或者七段数码管显示就足够了。不过，在第二部分，我会尝试使用 <code>strconv</code> 包来格式化，并在 UART 上显示一些数字和文本。</p><h3 id=闪烁>闪烁</h3><p>我们的开发板上有一个与 PA4 引脚和 VCC 相连的 LED。这次我们的代码稍稍长了一些：</p><pre tabindex=0><code>package main

import (
    &#34;delay&#34;

    &#34;stm32/hal/gpio&#34;
    &#34;stm32/hal/system&#34;
    &#34;stm32/hal/system/timer/systick&#34;
)

var led gpio.Pin

func init() {
    system.SetupPLL(8, 1, 48/8)
    systick.Setup(2e6)

    gpio.A.EnableClock(false)
    led = gpio.A.Pin(4)

    cfg := &amp;gpio.Config{Mode: gpio.Out, Driver: gpio.OpenDrain}
    led.Setup(cfg)
}

func main() {
    for {
        led.Clear()
        delay.Millisec(100)
        led.Set()
        delay.Millisec(900)
    }
}
</code></pre><p>按照惯例，<code>init</code> 函数用来初始化和配置外设。</p><p><code>system.SetupPLL(8, 1, 48/8)</code> 用来配置 RCC，将外部的 8 MHz 振荡器的 PLL 作为系统时钟源。PLL 分频器设置为 1，倍频数设置为 48/8 =6，这样系统时钟频率为 48MHz。</p><p><code>systick.Setup(2e6)</code> 将 Cortex-M SYSTICK 时钟作为系统时钟，每隔 2e6 次纳秒运行一次（每秒钟 500 次）。</p><p><code>gpio.A.EnableClock(false)</code> 开启了 GPIO A 口的时钟。<code>False</code> 意味着这一时钟在低功耗模式下会被禁用，但在 STM32F0 系列中并未实现这一功能。</p><p><code>led.Setup(cfg)</code> 设置 PA4 引脚为开漏输出。</p><p><code>led.Clear()</code> 将 PA4 引脚设为低，在开漏设置中，打开 LED。</p><p><code>led.Set()</code> 将 PA4 设为高电平状态，关掉LED。</p><p>编译这个代码：</p><pre tabindex=0><code>$ egc
$ arm-none-eabi-size cortexm0.elf
   text    data     bss     dec     hex filename
   9772     172     168   10112    2780 cortexm0.elf
</code></pre><p>正如你所看到的，这个闪烁程序占用了 2320 字节，比最基本程序占用空间要大。还有 6440 字节的剩余空间。</p><p>看看代码是否能运行：</p><pre tabindex=0><code>$ openocd -d0 -f interface/stlink.cfg -f target/stm32f0x.cfg -c &#39;init; program cortexm0.elf; reset run; exit&#39;
Open On-Chip Debugger 0.10.0+dev-00319-g8f1f912a (2018-03-07-19:20)
Licensed under GNU GPL v2
For bug reports, read
        http://openocd.org/doc/doxygen/bugs.html
debug_level: 0
adapter speed: 1000 kHz
adapter_nsrst_delay: 100
none separate
adapter speed: 950 kHz
target halted due to debug-request, current mode: Thread 
xPSR: 0xc1000000 pc: 0x0800119c msp: 0x20000da0
adapter speed: 4000 kHz
** Programming Started **
auto erase enabled
target halted due to breakpoint, current mode: Thread 
xPSR: 0x61000000 pc: 0x2000003a msp: 0x20000da0
wrote 10240 bytes from file cortexm0.elf in 0.817425s (12.234 KiB/s)
** Programming Finished **
adapter speed: 950 kHz
</code></pre><p>在这篇文章中，这是我第一次，将一个短视频转换成<a href=https://en.wikipedia.org/wiki/APNG>动画 PNG</a>。我对此印象很深，再见了 YouTube。 对于 IE 用户，我很抱歉，更多信息请看 <a href=http://apngasm.sourceforge.net/>apngasm</a>。我本应该学习 HTML5，但现在，APNG 是我最喜欢的，用来播放循环短视频的方法了。</p><p><img src=/data/attachment/album/201909/24/210408vdq9h6qh6cwxtu0z.png alt=STM32F030F4P6></p><h3 id=更多的-go-语言编程>更多的 Go 语言编程</h3><p>如果你不是一个 Go 程序员，但你已经听说过一些关于 Go 语言的事情，你可能会说：“Go 语法很好，但跟 C 比起来，并没有明显的提升。让我看看 Go 语言的通道和协程！”</p><p>接下来我会一一展示:</p><pre tabindex=0><code>import (
    &#34;delay&#34;

    &#34;stm32/hal/gpio&#34;
    &#34;stm32/hal/system&#34;
    &#34;stm32/hal/system/timer/systick&#34;
)

var led1, led2 gpio.Pin

func init() {
    system.SetupPLL(8, 1, 48/8)
    systick.Setup(2e6)

    gpio.A.EnableClock(false)
    led1 = gpio.A.Pin(4)
    led2 = gpio.A.Pin(5)

    cfg := &amp;gpio.Config{Mode: gpio.Out, Driver: gpio.OpenDrain}
    led1.Setup(cfg)
    led2.Setup(cfg)
}

func blinky(led gpio.Pin, period int) {
    for {
        led.Clear()
        delay.Millisec(100)
        led.Set()
        delay.Millisec(period - 100)
    }
}

func main() {
    go blinky(led1, 500)
    blinky(led2, 1000)
}
</code></pre><p>代码改动很小: 添加了第二个 LED，上一个例子中的 <code>main</code> 函数被重命名为 <code>blinky</code> 并且需要提供两个参数。 <code>main</code> 在新的协程中先调用 <code>blinky</code>，所以两个 LED 灯在并行使用。值得一提的是，<code>gpio.Pin</code> 可以同时访问同一 GPIO 口的不同引脚。</p><p>Emgo 还有很多不足。其中之一就是你需要提前规定 <code>goroutines(tasks)</code> 的最大执行数量。是时候修改 <code>script.ld</code> 了:</p><pre tabindex=0><code>ISRStack = 1024;
MainStack = 1024;
TaskStack = 1024;
MaxTasks = 2;

INCLUDE stm32/f030x4
INCLUDE stm32/loadflash
INCLUDE noos-cortexm
</code></pre><p>栈的大小需要靠猜，现在还不用关心这一点。</p><pre tabindex=0><code>$ egc
$ arm-none-eabi-size cortexm0.elf
   text    data     bss     dec     hex filename
  10020     172     172   10364    287c cortexm0.elf
</code></pre><p>另一个 LED 和协程一共占用了 248 字节的 Flash 空间。</p><p><img src=/data/attachment/album/201909/24/210519jkopyikil0z2al7r.png alt=STM32F030F4P6></p><h3 id=通道>通道</h3><p>通道是 Go 语言中协程之间相互通信的一种<a href=https://blog.golang.org/share-memory-by-communicating>推荐方式</a>。Emgo 甚至能允许通过<em>中断处理</em>来使用缓冲通道。下一个例子就展示了这种情况。</p><pre tabindex=0><code>package main

import (
    &#34;delay&#34;
    &#34;rtos&#34;

    &#34;stm32/hal/gpio&#34;
    &#34;stm32/hal/irq&#34;
    &#34;stm32/hal/system&#34;
    &#34;stm32/hal/system/timer/systick&#34;
    &#34;stm32/hal/tim&#34;
)

var (
    leds  [3]gpio.Pin
    timer *tim.Periph
    ch    = make(chan int, 1)
)

func init() {
    system.SetupPLL(8, 1, 48/8)
    systick.Setup(2e6)

    gpio.A.EnableClock(false)
    leds[0] = gpio.A.Pin(4)
    leds[1] = gpio.A.Pin(5)
    leds[2] = gpio.A.Pin(9)

    cfg := &amp;gpio.Config{Mode: gpio.Out, Driver: gpio.OpenDrain}
    for _, led := range leds {
        led.Set()
        led.Setup(cfg)
    }

    timer = tim.TIM3
    pclk := timer.Bus().Clock()
    if pclk &lt; system.AHB.Clock() {
        pclk *= 2
    }
    freq := uint(1e3) // Hz
    timer.EnableClock(true)
    timer.PSC.Store(tim.PSC(pclk/freq - 1))
    timer.ARR.Store(700) // ms
    timer.DIER.Store(tim.UIE)
    timer.CR1.Store(tim.CEN)

    rtos.IRQ(irq.TIM3).Enable()
}

func blinky(led gpio.Pin, period int) {
    for range ch {
        led.Clear()
        delay.Millisec(100)
        led.Set()
        delay.Millisec(period - 100)
    }
}

func main() {
    go blinky(leds[1], 500)
    blinky(leds[2], 500)
}

func timerISR() {
    timer.SR.Store(0)
    leds[0].Set()
    select {
    case ch &lt;- 0:
        // Success
    default:
        leds[0].Clear()
    }
}

//c:__attribute__((section(&#34;.ISRs&#34;)))
var ISRs = [...]func(){
    irq.TIM3: timerISR,
}
</code></pre><p>与之前例子相比较下的不同:</p><ol><li>添加了第三个 LED，并连接到 PA9 引脚（UART 头的 TXD 引脚）。</li><li>时钟（<code>TIM3</code>）作为中断源。</li><li>新函数 <code>timerISR</code> 用来处理 <code>irq.TIM3</code> 的中断。</li><li>新增容量为 1 的缓冲通道是为了 <code>timerISR</code> 和 <code>blinky</code> 协程之间的通信。</li><li><code>ISRs</code> 数组作为<em>中断向量表</em>，是更大的<em>异常向量表</em>的一部分。</li><li><code>blinky</code> 中的 <code>for</code> 语句被替换成 <code>range</code> 语句。</li></ol><p>为了方便起见，所有的 LED，或者说它们的引脚，都被放在 <code>leds</code> 这个数组里。另外，所有引脚在被配置为输出之前，都设置为一种已知的初始状态（高电平状态）。</p><p>在这个例子里，我们想让时钟以 1 kHz 的频率运行。为了配置 TIM3 预分频器，我们需要知道它的输入时钟频率。通过参考手册我们知道，输入时钟频率在 <code>APBCLK = AHBCLK</code> 时，与 <code>APBCLK</code> 相同，反之等于 2 倍的 <code>APBCLK</code>。</p><p>如果 CNT 寄存器增加 1 kHz，那么 ARR 寄存器的值等于<em>更新事件</em>（重载事件）在毫秒中的计数周期。 为了让更新事件产生中断，必须要设置 DIER 寄存器中的 UIE 位。CEN 位能启动时钟。</p><p>时钟外设在低功耗模式下必须启用，为了自身能在 CPU 处于休眠时保持运行: <code>timer.EnableClock(true)</code>。这在 STM32F0 中无关紧要，但对代码可移植性却十分重要。</p><p><code>timerISR</code> 函数处理 <code>irq.TIM3</code> 的中断请求。<code>timer.SR.Store(0)</code> 会清除 SR 寄存器里的所有事件标志，无效化向 <a href=http://infocenter.arm.com/help/topic/com.arm.doc.ddi0432c/Cihbecee.html>NVIC</a> 发出的所有中断请求。凭借经验，由于中断请求无效的延时性，需要在程序一开始马上清除所有的中断标志。这避免了无意间再次调用处理。为了确保万无一失，需要先清除标志，再读取，但是在我们的例子中，清除标志就已经足够了。</p><p>下面的这几行代码：</p><pre tabindex=0><code>select {
case ch &lt;- 0:
    // Success
default:
    leds[0].Clear()
}
</code></pre><p>是 Go 语言中，如何在通道上非阻塞地发送消息的方法。中断处理程序无法一直等待通道中的空余空间。如果通道已满，则执行 <code>default</code>，开发板上的LED就会开启，直到下一次中断。</p><p><code>ISRs</code> 数组包含了中断向量表。<code>//c:__attribute__((section(".ISRs")))</code> 会导致链接器将数组插入到 <code>.ISRs</code> 节中。</p><p><code>blinky</code> 的 <code>for</code> 循环的新写法：</p><pre tabindex=0><code>for range ch {
    led.Clear()
    delay.Millisec(100)
    led.Set()
    delay.Millisec(period - 100)
}
</code></pre><p>等价于：</p><pre tabindex=0><code>for {
    _, ok := &lt;-ch
    if !ok {
        break // Channel closed.
    }
    led.Clear()
    delay.Millisec(100)
    led.Set()
    delay.Millisec(period - 100)
}
</code></pre><p>注意，在这个例子中，我们不在意通道中收到的值，我们只对其接受到的消息感兴趣。我们可以在声明时，将通道元素类型中的 <code>int</code> 用空结构体 <code>struct{}</code> 来代替，发送消息时，用 <code>struct{}{}</code> 结构体的值代替 0，但这部分对新手来说可能会有些陌生。</p><p>让我们来编译一下代码:</p><pre tabindex=0><code>$ egc
$ arm-none-eabi-size cortexm0.elf
   text    data     bss     dec     hex filename
  11096     228     188   11512    2cf8 cortexm0.elf
</code></pre><p>新的例子占用了 11324 字节的 Flash 空间，比上一个例子多占用了 1132 字节。</p><p>采用现在的时序，两个闪烁协程从通道中获取数据的速度，比 <code>timerISR</code> 发送数据的速度要快。所以它们在同时等待新数据，你还能观察到 <code>select</code> 的随机性，这也是 <a href=https://golang.org/ref/spec#Select_statements>Go 规范</a>所要求的。</p><p><img src=/data/attachment/album/201909/24/210528f1226mspt6m61642.png alt=STM32F030F4P6></p><p>开发板上的 LED 一直没有亮起，说明通道从未出现过溢出。</p><p>我们可以加快消息发送的速度，将 <code>timer.ARR.Store(700)</code> 改为 <code>timer.ARR.Store(200)</code>。 现在 <code>timerISR</code> 每秒钟发送 5 条消息，但是两个接收者加起来，每秒也只能接受 4 条消息。</p><p><img src=/data/attachment/album/201909/24/210533bwf6oxaokxwtiwk6.png alt=STM32F030F4P6></p><p>正如你所看到的，<code>timerISR</code> 开启黄色 LED 灯，意味着通道上已经没有剩余空间了。</p><p>第一部分到这里就结束了。你应该知道，这一部分并未展示 Go 中最重要的部分，接口。</p><p>协程和通道只是一些方便好用的语法。你可以用自己的代码来替换它们，这并不容易，但也可以实现。接口是Go 语言的基础。这是文章中 <a href=https://ziutek.github.io/2018/04/14/go_on_very_small_hardware2.html>第二部分</a>所要提到的.</p><p>在 Flash 上我们还有些剩余空间。</p><hr><p>via: <a href=https://ziutek.github.io/2018/03/30/go_on_very_small_hardware.html>https://ziutek.github.io/2018/03/30/go_on_very_small_hardware.html</a></p><p>作者：<a href=https://ziutek.github.io/>Michał Derkacz</a> 译者：<a href=https://github.com/wenwensnow>wenwensnow</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/go/ rel=tag>Go</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>