<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>安卓平台上的依赖注入（一） - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="安卓平台上的依赖注入（一）"><meta property="og:description" content="第一种情况是我们在构造器里创建了依赖对象，但在第二种情况下，它作为参数被传递给构造器，这就是我们所说的依赖注入（dependency injection）。"><meta property="og:type" content="article"><meta property="og:url" content="/article-8066-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2016-12-27T08:43:00+00:00"><meta property="article:modified_time" content="2016-12-27T08:43:00+00:00"><meta itemprop=name content="安卓平台上的依赖注入（一）"><meta itemprop=description content="第一种情况是我们在构造器里创建了依赖对象，但在第二种情况下，它作为参数被传递给构造器，这就是我们所说的依赖注入（dependency injection）。"><meta itemprop=datePublished content="2016-12-27T08:43:00+00:00"><meta itemprop=dateModified content="2016-12-27T08:43:00+00:00"><meta itemprop=wordCount content="317"><meta itemprop=keywords content="Java,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>安卓平台上的依赖注入（一）</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-12-27T08:43:00Z>December 27, 2016</time></div></div></header><div class="content post__content clearfix"><p><img src=/data/attachment/album/201612/26/204426ezi9djn59j9jiizn.jpg alt></p><p>刚开始学习软件工程的时候，我们经常会碰到像这样的事情：</p><blockquote><p>软件应该符合 SOLID 原则。</p></blockquote><p>但这句话实际是什么意思？让我们看看 SOLID 中每个字母在架构里所代表的重要含义，例如：</p><ul><li><a href=https://en.wikipedia.org/wiki/Single_responsibility_principle>S - 单职责原则</a></li><li><a href=https://en.wikipedia.org/wiki/Open/closed_principle>O - 开闭原则</a></li><li><a href=http://liskov_substitution_principle/>L - Liskov 替换原则</a></li><li><a href=https://en.wikipedia.org/wiki/Interface_segregation_principle>I - 接口分离原则</a></li><li><a href=https://en.wikipedia.org/wiki/Dependency_inversion_principle>D - 依赖反转原则</a> 这也是 依赖注入 （ dependency injection ） 的核心概念。</li></ul><p>简单来说，我们需要提供一个类，这个类有它所需要的所有对象，以便实现其功能。</p><h3 id=概述>概述</h3><p>依赖注入听起来像是描述非常复杂的东西的一个术语，但实际上它很简单，看下面这个例子你就明白了：</p><pre tabindex=0><code>class NoDependencyInjection {
  private Dependency d;

  public NoDependencyInjection() {
    d = new Dependency();
  }
}

class DependencyInjection {
  private Dependency d;

  public DependencyInjection(Dependency d) {
    this.d = d;
  }
}
</code></pre><p>正如我们所见，第一种情况是我们在构造器里创建了依赖对象，但在第二种情况下，它作为参数被传递给构造器，这就是我们所说的 依赖注入 （ dependency injection ） 。这样做是为了让我们所写的类不依靠特定依赖关系的实现，却能直接使用它。</p><p>参数传递的目标是构造器，我们就称之为构造器依赖注入；或者是某个方法，就称之为方法依赖注入：</p><pre tabindex=0><code>class Example {
  private ConstructorDependency cd;
  private MethodDependency md;
  Example(ConstructorDependency cd) {
    this.cd = cd; //Constructor Dependency Injection
  }

  public setMethodDependency(MethodDependency md) {
    this.md = md; //Method Dependency Injection
  }
}
</code></pre><p>要是你想总体深入地了解依赖注入，可以看看由 <a href=https://twitter.com/danlew42>Dan Lew</a> 发表的<a href=https://realm.io/news/daniel-lew-dependency-injection-dagger/>精彩的演讲</a>，事实上是这个演讲启迪了这篇概述。</p><p>在 Android 平台，当需要框架来处理依赖注入这个特殊的问题时，我们有不同的选择，其中最有名的框架就是 <a href=http://google.github.io/dagger/>Dagger 2</a>。它最开始是由 Square 公司（LCTT 译注：Square 是美国一家移动支付公司）的一些很棒的开发者开发出来的，然后慢慢发展成由 Google 自己开发。首先开发出来的是 Dagger 1，然后 Big G 接手这个项目发布了第二个版本，做了很多改动，比如以 注解 （ annotation ） 为基础，在编译的时候完成其任务。</p><h3 id=导入框架>导入框架</h3><p>安装 Dagger 并不难，但需要导入 <code>android-apt</code> 插件，通过向项目的根目录下的 <code>build.gradle</code> 文件中添加它的依赖关系：</p><pre tabindex=0><code>buildscript{
  ...
  dependencies{
    ...
    classpath ‘com.neenbedankt.gradle.plugins:android-apt:1.8’
  }
}
</code></pre><p>然后，我们需要将 <code>android-apt</code> 插件应用到项目 <code>build.gradle</code> 文件，放在文件顶部 Android application 那一句的下一行：</p><pre tabindex=0><code>apply plugin: ‘com.neenbedankt.android-apt’
</code></pre><p>这个时候，我们只用添加依赖关系，然后就能使用库及其 注解 （ annotation ） 了：</p><pre tabindex=0><code>dependencies{
    ...
    compile ‘com.google.dagger:dagger:2.6’ 
    apt ‘com.google.dagger:dagger-compiler:2.6’
    provided ‘javax.annotation:jsr250-api:1.0’
}
</code></pre><blockquote><p>需要加上最后一个依赖关系是因为 @Generated 注解在 Android 里还不可用，但它是<a href=https://docs.oracle.com/javase/7/docs/api/javax/annotation/Generated.html>原生的 Java 注解</a>。</p></blockquote><h3 id=dagger-模块>Dagger 模块</h3><p>要注入依赖，首先需要告诉框架我们能提供什么（比如说上下文）以及特定的对象应该怎样创建。为了完成注入，我们用 <code>@Module</code> 注释对一个特殊的类进行了注解（这样 Dagger 就能识别它了），寻找 <code>@Provide</code> 注解的方法，生成图表，能够返回我们所请求的对象。</p><p>看下面的例子，这里我们创建了一个模块，它会返回给我们 <code>ConnectivityManager</code>，所以我们要把 <code>Context</code> 对象传给这个模块的构造器。</p><pre tabindex=0><code>@Module
public class ApplicationModule {
  private final Context context;

  public ApplicationModule(Context context) {
    this.context = context;
  }

  @Provides @Singleton
  public Context providesContext() {
    return context;
  }

  @Provides @Singleton
  public ConnectivityManager providesConnectivityManager(Context context) {
    return (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
  }
}
</code></pre><blockquote><p>Dagger 中十分有意思的一点是简单地注解一个方法来提供一个单例（Singleton），就能处理所有从 Java 中继承过来的问题。</p></blockquote><h3 id=组件>组件</h3><p>当我们有一个模块的时候，我们需要告诉 Dagger 想把依赖注入到哪里：我们在一个 组件 （ Component ） 里完成依赖注入，这是一个我们特别创建的特殊注解接口。我们在这个接口里创造不同的方法，而接口的参数是我们想注入依赖关系的类。</p><p>下面给出一个例子并告诉 Dagger 我们想要 <code>MainActivity</code> 类能够接受 <code>ConnectivityManager</code>（或者在图表里的其它依赖对象）。我们只要做类似以下的事：</p><pre tabindex=0><code>@Singleton
@Component(modules = {ApplicationModule.class})
public interface ApplicationComponent {

  void inject(MainActivity activity);
}
</code></pre><blockquote><p>正如我们所见，@Component 注解有几个参数，一个是所支持的模块的数组，代表它能提供的依赖。这里既可以是 <code>Context</code> 也可以是 <code>ConnectivityManager</code>，因为它们在 <code>ApplicationModule</code> 类中有声明。</p></blockquote><h3 id=用法>用法</h3><p>这时，我们要做的是尽快创建组件（比如在应用的 <code>onCreate</code> 阶段）并返回它，那么类就能用它来注入依赖了：</p><blockquote><p>为了让框架自动生成 <code>DaggerApplicationComponent</code>，我们需要构建项目以便 Dagger 能够扫描我们的代码，并生成我们需要的部分。</p></blockquote><p>在 <code>MainActivity</code> 里，我们要做的两件事是用 <code>@Inject</code> 注解符对想要注入的属性进行注解，调用我们在 <code>ApplicationComponent</code> 接口中声明的方法（请注意后面一部分会因我们使用的注入类型的不同而变化，但这里简单起见我们不去管它），然后依赖就被注入了，我们就能自由使用他们：</p><pre tabindex=0><code>public class MainActivity extends AppCompatActivity {
  @Inject
  ConnectivityManager manager;

  @Override
  protected void onCreate(Bundle savedInstanceState) {
    ...
    ((App) getApplication()).getComponent().inject(this);
  }
}
</code></pre><h3 id=总结>总结</h3><p>当然了，我们可以手动注入依赖，管理所有不同的对象，但 Dagger 消除了很多比如模板这样的“噪声”，给我们提供有用的附加品（比如 <code>Singleton</code>），而仅用 Java 处理将会很糟糕。</p><hr><p>via: <a href=https://medium.com/di-101/di-101-part-1-81896c2858a0#.3hg0jj14o>https://medium.com/di-101/di-101-part-1-81896c2858a0#.3hg0jj14o</a></p><p>作者:<a href=https://medium.com/@_tiwiz>Roberto Orgiu</a> 译者:<a href=https://github.com/GitFuture>GitFuture</a> 校对:<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/java/ rel=tag>Java</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>