<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>在 Go 中实现一个支持并发的 TCP 服务端 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="在 Go 中实现一个支持并发的 TCP 服务端"><meta property="og:description" content="仅用大约 65 行代码，开发一个用于生成随机数、支持并发的 TCP 服务端。"><meta property="og:type" content="article"><meta property="og:url" content="/article-14623-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-05-22T11:55:00+00:00"><meta property="article:modified_time" content="2022-05-22T11:55:00+00:00"><meta itemprop=name content="在 Go 中实现一个支持并发的 TCP 服务端"><meta itemprop=description content="仅用大约 65 行代码，开发一个用于生成随机数、支持并发的 TCP 服务端。"><meta itemprop=datePublished content="2022-05-22T11:55:00+00:00"><meta itemprop=dateModified content="2022-05-22T11:55:00+00:00"><meta itemprop=wordCount content="344"><meta itemprop=keywords content="Go,并发,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>在 Go 中实现一个支持并发的 TCP 服务端</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2022-05-22T11:55:00Z>May 22, 2022</time></div></div></header><div class="content post__content clearfix"><p><img src=/data/attachment/album/202205/22/115536nkfuuf4dklgg7fsx.jpg alt></p><blockquote><p>仅用大约 65 行代码，开发一个用于生成随机数、支持并发的 TCP 服务端。</p></blockquote><p>TCP 和 UDP 服务端随处可见，它们基于 TCP/IP 协议栈，通过网络为客户端提供服务。在这篇文章中，我将介绍如何使用 <a href=https://golang.org/>Go 语言</a> 开发一个用于返回随机数、支持并发的 TCP 服务端。对于每一个来自 TCP 客户端的连接，它都会启动一个新的 goroutine（轻量级线程）来处理相应的请求。</p><p>你可以在 GitHub 上找到本项目的源码：<a href=https://github.com/mactsouk/opensource.com>concTcp.go</a>。</p><h3 id=处理-tcp-连接>处理 TCP 连接</h3><p>这个程序的主要逻辑在 <code>handleConnection()</code> 函数中，具体实现如下：</p><pre tabindex=0><code>func handleConnection(c net.Conn) {
        fmt.Printf(&#34;Serving %s\n&#34;, c.RemoteAddr().String())
        for {
                netData, err := bufio.NewReader(c).ReadString(&#39;\n&#39;)
                if err != nil {
                        fmt.Println(err)
                        return
                }

                temp := strings.TrimSpace(string(netData))
                if temp == &#34;STOP&#34; {
                        break
                }

                result := strconv.Itoa(random()) + &#34;\n&#34;
                c.Write([]byte(string(result)))
        }
        c.Close()
}
</code></pre><p>如果 TCP 客户端发送了一个 “STOP” 字符串，为它提供服务的 goroutine 就会终止；否则，TCP 服务端就会返回一个随机数给它。只要客户端不主动终止，服务端就会一直提供服务，这是由 <code>for</code> 循环保证的。具体来说，<code>for</code> 循环中的代码使用了 <code>bufio.NewReader(c).ReadString('\n')</code> 来逐行读取客户端发来的数据，并使用 <code>c.Write([]byte(string(result)))</code> 来返回数据（生成的随机数）。你可以在 Go 的 net 标准包 <a href=https://golang.org/pkg/net/>文档</a> 中了解更多。</p><h3 id=支持并发>支持并发</h3><p>在 <code>main()</code> 函数的实现部分，每当 TCP 服务端收到 TCP 客户端的连接请求，它都会启动一个新的 goroutine 来为这个请求提供服务。</p><pre tabindex=0><code>func main() {
        arguments := os.Args
        if len(arguments) == 1 {
                fmt.Println(&#34;Please provide a port number!&#34;)
                return
        }

        PORT := &#34;:&#34; + arguments[1]
        l, err := net.Listen(&#34;tcp4&#34;, PORT)
        if err != nil {
                fmt.Println(err)
                return
        }
        defer l.Close()
        rand.Seed(time.Now().Unix())

        for {
                c, err := l.Accept()
                if err != nil {
                        fmt.Println(err)
                        return
                }
                go handleConnection(c)
        }
}
</code></pre><p>首先，<code>main()</code> 确保程序至少有一个命令行参数。注意，现有代码并没有检查这个参数是否为有效的 TCP 端口号。不过，如果它是一个无效的 TCP 端口号，<code>net.Listen()</code> 就会调用失败，并返回一个错误信息，类似下面这样：</p><pre tabindex=0><code>$ go run concTCP.go 12a
listen tcp4: lookup tcp4/12a: nodename nor servname provided, or not known
$ go run concTCP.go -10
listen tcp4: address -10: invalid port
</code></pre><p><code>net.Listen()</code> 函数用于告诉 Go 接受网络连接，因而承担了服务端的角色。它的返回值类型是 <code>net.Conn</code>，后者实现了 <code>io.Reader</code> 和 <code>io.Writer</code> 接口。此外，<code>main()</code> 函数中还调用了 <code>rand.Seed()</code> 函数，用于初始化随机数生成器。最后，<code>for</code> 循环允许程序一直使用 <code>Accept()</code> 函数来接受 TCP 客户端的连接请求，并以 goroutine 的方式来运行 <code>handleConnection(c)</code> 函数，处理客户端的后续请求。</p><h3 id=netlisten-的第一个参数>net.Listen() 的第一个参数</h3><p><code>net.Listen()</code> 函数的第一个参数定义了使用的网络类型，而第二个参数定义了服务端监听的地址和端口号。第一个参数的有效值为 <code>tcp</code>、<code>tcp4</code>、<code>tcp6</code>、<code>udp</code>、<code>udp4</code>、<code>udp6</code>、<code>ip</code>、<code>ip4</code>、<code>ip6</code>、<code>Unix</code>（Unix 套接字）、<code>Unixgram</code> 和 <code>Unixpacket</code>，其中：<code>tcp4</code>、<code>udp4</code> 和 <code>ip4</code> 只接受 IPv4 地址，而 <code>tcp6</code>、<code>udp6</code> 和 <code>ip6</code> 只接受 IPv6 地址。</p><h3 id=服务端并发测试>服务端并发测试</h3><p><code>concTCP.go</code> 需要一个命令行参数，来指定监听的端口号。当它开始服务 TCP 客户端时，你会得到类似下面的输出：</p><pre tabindex=0><code>$ go run concTCP.go 8001
Serving 127.0.0.1:62554
Serving 127.0.0.1:62556
</code></pre><p><code>netstat</code> 的输出可以确认 <code>congTCP.go</code> 正在为多个 TCP 客户端提供服务，并且仍在继续监听建立连接的请求：</p><pre tabindex=0><code>$ netstat -anp TCP | grep 8001
tcp4       0      0  127.0.0.1.8001         127.0.0.1.62556        ESTABLISHED
tcp4       0      0  127.0.0.1.62556        127.0.0.1.8001         ESTABLISHED
tcp4       0      0  127.0.0.1.8001         127.0.0.1.62554        ESTABLISHED
tcp4       0      0  127.0.0.1.62554        127.0.0.1.8001         ESTABLISHED
tcp4       0      0  *.8001                 *.*                    LISTEN
</code></pre><p>在上面输出中，最后一行显示了有一个进程正在监听 8001 端口，这意味着你可以继续连接 TCP 的 8001 端口。第一行和第二行显示了有一个已建立的 TCP 网络连接，它占用了 8001 和 62556 端口。相似地，第三行和第四行显示了有另一个已建立的 TCP 连接，它占用了 8001 和 62554 端口。</p><p>下面这张图片显示了 <code>concTCP.go</code> 在服务多个 TCP 客户端时的输出：</p><p><img src=/data/attachment/album/202205/22/115539cgdpwgnnmm2g5oon.png alt="concTCP.go TCP 服务端测试"></p><p>类似地，下面这张图片显示了两个 TCP 客户端的输出（使用了 <code>nc</code> 工具）：</p><p><img src=/data/attachment/album/202205/22/115539qumyxr7rmks3yrws.png alt="是用 nc 工具作为 concTCP.go 的 TCP 客户端"></p><p>你可以在 <a href=https://en.wikipedia.org/wiki/Netcat>维基百科</a> 上找到更多关于 <code>nc</code>（即 <code>netcat</code>）的信息。</p><h3 id=总结>总结</h3><p>现在，你学会了如何用大约 65 行 Go 代码来开发一个生成随机数、支持并发的 TCP 服务端，这真是太棒了！如果你想要让你的 TCP 服务端执行别的任务，只需要修改 <code>handleConnection()</code> 函数即可。</p><hr><p>via: <a href=https://opensource.com/article/18/5/building-concurrent-tcp-server-go>https://opensource.com/article/18/5/building-concurrent-tcp-server-go</a></p><p>作者：<a href=https://opensource.com/users/mtsouk>Mihalis Tsoukalos</a> 选题：<a href=https://github.com/lkxed>lkxed</a> 译者：<a href=https://github.com/lkxed>lkxed</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/go/ rel=tag>Go</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E5%B9%B6%E5%8F%91/ rel=tag>并发</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>