<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>容器如何工作：OverlayFS - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="容器如何工作：OverlayFS"><meta property="og:description" content="你可以运行一条 mount 咒语，而实际上并没有做任何与容器相关的其他事情，看看叠加层是如何工作的！"><meta property="og:type" content="article"><meta property="og:url" content="/article-11605-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-11-23T10:25:32+00:00"><meta property="article:modified_time" content="2019-11-23T10:25:32+00:00"><meta itemprop=name content="容器如何工作：OverlayFS"><meta itemprop=description content="你可以运行一条 mount 咒语，而实际上并没有做任何与容器相关的其他事情，看看叠加层是如何工作的！"><meta itemprop=datePublished content="2019-11-23T10:25:32+00:00"><meta itemprop=dateModified content="2019-11-23T10:25:32+00:00"><meta itemprop=wordCount content="314"><meta itemprop=keywords content="容器,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>容器如何工作：OverlayFS</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2019-11-23T10:25:32Z>November 23, 2019</time></div></div></header><div class="content post__content clearfix"><p>今天早上，我为未来潜在容器<a href=https://wizardzines.com>杂志</a>画了一幅 OverlayFS 的漫画，我对这个主题感到兴奋，想写一篇关于它的博客来提供更多详细信息。</p><p><img src=/data/attachment/album/201911/23/102537d50a06jizddcc0c8.jpg alt></p><h3 id=容器镜像很大>容器镜像很大</h3><p>容器镜像可能会很大（尽管有些很小，例如 <a href="https://hub.docker.com/_/alpine?tab=tags">alpine linux 才 2.5MB</a>）。Ubuntu 16.04 约为 27 MB，<a href=https://hub.docker.com/r/continuumio/anaconda3/tags>Anaconda Python 发行版为 800MB 至 1.5GB</a>。</p><p>你以镜像启动的每个容器都是原始空白状态，仿佛它只是为使用容器而复制的一份镜像拷贝一样。但是对于大的容器镜像，像 800MB 的 Anaconda 镜像，复制一份拷贝既浪费磁盘空间也很慢。因此 Docker 不会复制，而是采用<strong>叠加</strong>。</p><h3 id=叠加如何工作>叠加如何工作</h3><p>OverlayFS，也被称为 <strong>联合文件系统</strong>或 <strong>联合挂载</strong>，它可让你使用 2 个目录挂载文件系统：“下层”目录和“上层”目录。</p><p>基本上：</p><ul><li>文件系统的<strong>下层</strong>目录是只读的</li><li>文件系统的<strong>上层</strong>目录可以读写</li></ul><p>当进程“读取”文件时，OverlayFS 文件系统驱动将在上层目录中查找并从该目录中读取文件（如果存在）。否则，它将在下层目录中查找。</p><p>当进程“写入”文件时，OverlayFS 会将其写入上层目录。</p><h3 id=让我们使用-mount-制造一个叠加层>让我们使用 mount 制造一个叠加层！</h3><p>这有点抽象，所以让我们制作一个 OverlayFS 并尝试一下！这将只包含一些文件：我将创建上、下层目录，以及用来挂载合并的文件系统的 <code>merged</code> 目录：</p><pre tabindex=0><code>$ mkdir upper lower merged work
$ echo &#34;I&#39;m from lower!&#34; &gt; lower/in_lower.txt
$ echo &#34;I&#39;m from upper!&#34; &gt; upper/in_upper.txt
$ # `in_both` is in both directories
$ echo &#34;I&#39;m from lower!&#34; &gt; lower/in_both.txt
$ echo &#34;I&#39;m from upper!&#34; &gt; upper/in_both.txt
</code></pre><p>合并上层目录和下层目录非常容易：我们可以通过 <code>mount</code> 来完成！</p><pre tabindex=0><code>$ sudo mount -t overlay overlay
    -o lowerdir=/home/bork/test/lower,upperdir=/home/bork/test/upper,workdir=/home/bork/test/work
    /home/bork/test/merged
</code></pre><p>在执行此操作时，我不断收到一条非常烦人的错误消息，内容为：<code>mount: /home/bork/test/merged: special device overlay does not exist.</code>。这条消息是错误的，实际上只是意味着我指定的一个目录缺失（我写成了 <code>~/test/merged</code>，但它没有被展开）。</p><p>让我们尝试从 OverlayFS 中读取其中一个文件！文件 <code>in_both.txt</code> 同时存在于 <code>lower/</code> 和 <code>upper/</code> 中，因此应从 <code>upper/</code> 目录中读取该文件。</p><pre tabindex=0><code>$ cat merged/in_both.txt
&#34;I&#39;m from upper!
</code></pre><p>可以成功！</p><p>目录的内容就是我们所期望的：</p><pre tabindex=0><code>find lower/ upper/ merged/
lower/
lower/in_lower.txt
lower/in_both.txt
upper/
upper/in_upper.txt
upper/in_both.txt
merged/
merged/in_lower.txt
merged/in_both.txt
merged/in_upper.txt
</code></pre><h3 id=创建新文件时会发生什么>创建新文件时会发生什么？</h3><pre tabindex=0><code>$ echo &#39;new file&#39; &gt; merged/new_file
$ ls -l */new_file
-rw-r--r-- 1 bork bork 9 Nov 18 14:24 merged/new_file
-rw-r--r-- 1 bork bork 9 Nov 18 14:24 upper/new_file
</code></pre><p>这是有作用的，新文件会在 <code>upper</code> 目录创建。</p><h3 id=删除文件时会发生什么>删除文件时会发生什么？</h3><p>读写似乎很简单。但是删除会发生什么？开始试试！</p><pre tabindex=0><code>$ rm merged/in_both.txt
</code></pre><p>发生了什么？让我们用 <code>ls</code> 看下：</p><pre tabindex=0><code>ls -l upper/in_both.txt  lower/lower1.txt  merged/lower1.txt
ls: cannot access &#39;merged/in_both.txt&#39;: No such file or directory
-rw-r--r-- 1 bork bork    6 Nov 18 14:09 lower/in_both.txt
c--------- 1 root root 0, 0 Nov 18 14:19 upper/in_both.txt
</code></pre><p>所以：</p><ul><li><code>in_both.txt</code> 仍在 <code>lower</code> 目录中，并且保持不变</li><li>它不在 <code>merged</code> 目录中。到目前为止，这就是我们所期望的。</li><li>但是在 <code>upper</code> 中发生的事情有点奇怪：有一个名为 <code>upper/in_both.txt</code> 的文件，但是它是字符设备？我想这就是 overlayfs 驱动表示删除的文件的方式。</li></ul><p>如果我们尝试复制这个奇怪的字符设备文件，会发生什么？</p><pre tabindex=0><code>$ sudo cp upper/in_both.txt upper/in_lower.txt
cp: cannot open &#39;upper/in_both.txt&#39; for reading: No such device or address
</code></pre><p>好吧，这似乎很合理，复制这个奇怪的删除信号文件并没有任何意义。</p><h3 id=你可以挂载多个下层目录>你可以挂载多个“下层”目录</h3><p>Docker 镜像通常由 25 个“层”组成。OverlayFS 支持具有多个下层目录，因此你可以运行：</p><pre tabindex=0><code>mount -t overlay overlay
      -o lowerdir:/dir1:/dir2:/dir3:...:/dir25,upperdir=...
</code></pre><p>因此，我假设这是有多个 Docker 层的容器的工作方式，它只是将每个层解压缩到一个单独的目录中，然后要求 OverlayFS 将它们全部合并在一起，并使用一个空的上层目录，容器将对其进行更改。</p><h3 id=docker-也可以使用-btrfs-快照>Docker 也可以使用 btrfs 快照</h3><p>现在，我使用的是 ext4，而 Docker 使用 OverlayFS 快照来运行容器。但是我曾经用过 btrfs，接着 Docker 将改为使用 btrfs 的写时复制快照。（这是 Docker 何时使用哪种<a href=https://docs.docker.com/storage/storagedriver/select-storage-driver/>存储驱动</a>的列表）</p><p>以这种方式使用 btrfs 快照会产生一些有趣的结果：去年某个时候，我在笔记本上运行了数百个临时的 Docker 容器，这导致我用尽了 btrfs 元数据空间（像<a href=https://www.reddit.com/r/archlinux/comments/5jrmfe/btrfs_metadata_and_docker/>这个人</a>一样）。这真的很令人困惑，因为我以前从未听说过 btrfs 元数据，而且弄清楚如何清理文件系统以便再次运行 Docker 容器非常棘手。（<a href=https://github.com/moby/moby/issues/27653>这个 docker github 上的提案</a>描述了 Docker 和 btrfs 的类似问题）</p><h3 id=以简单的方式尝试容器功能很有趣>以简单的方式尝试容器功能很有趣！</h3><p>我认为容器通常看起来像是在做“复杂的”事情，我认为将它们分解成这样很有趣。你可以运行一条 <code>mount</code> 咒语，而实际上并没有做任何与容器相关的其他事情，看看叠加层是如何工作的！</p><hr><p>via: <a href=https://jvns.ca/blog/2019/11/18/how-containers-work--overlayfs/>https://jvns.ca/blog/2019/11/18/how-containers-work–overlayfs/</a></p><p>作者：<a href=https://jvns.ca/>Julia Evans</a> 选题：<a href=https://github.com/lujun9972>lujun9972</a> 译者：<a href=https://github.com/geekpi>geekpi</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/%E5%AE%B9%E5%99%A8/ rel=tag>容器</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>