<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>8 个基本的 Docker 容器管理命令 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="8 个基本的 Docker 容器管理命令"><meta property="og:description" content="利用这 8 个命令可以学习 Docker 容器的基本管理方式。这是一个为 Docker 初学者准备的，带有示范命令输出的指南。"><meta property="og:type" content="article"><meta property="og:url" content="/article-9768-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-06-21T18:53:54+00:00"><meta property="article:modified_time" content="2018-06-21T18:53:54+00:00"><meta itemprop=name content="8 个基本的 Docker 容器管理命令"><meta itemprop=description content="利用这 8 个命令可以学习 Docker 容器的基本管理方式。这是一个为 Docker 初学者准备的，带有示范命令输出的指南。"><meta itemprop=datePublished content="2018-06-21T18:53:54+00:00"><meta itemprop=dateModified content="2018-06-21T18:53:54+00:00"><meta itemprop=wordCount content="612"><meta itemprop=keywords content="容器,Docker,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>8 个基本的 Docker 容器管理命令</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2018-06-21T18:53:54Z>June 21, 2018</time></div></div></header><div class="content post__content clearfix"><blockquote><p>利用这 8 个命令可以学习 Docker 容器的基本管理方式。这是一个为 Docker 初学者准备的，带有示范命令输出的指南。</p></blockquote><p><img src=/data/attachment/album/201806/21/185359izqkkd1d1lc1c1ys.png alt="Docker 容器管理命令"></p><p>在这篇文章中，我们将带你学习 8 个基本的 Docker 容器命令，它们操控着 Docker 容器的基本活动，例如 运行 run 、 列举 list 、 停止 stop 、 查看 历史纪录 logs 、 删除 delete 等等。如果你对 Docker 的概念很陌生，推荐你看看我们的 <a href=https://kerneltalks.com/virtualization/what-is-docker-introduction-guide-to-docker/>介绍指南</a>，来了解 Docker 的基本内容以及 <a href=https://kerneltalks.com/virtualization/how-to-install-docker-in-linux/>如何</a> 在 Linux 上安装 Docker。 现在让我们赶快进入要了解的命令：</p><h3 id=如何运行-docker-容器>如何运行 Docker 容器？</h3><p>众所周知，Docker 容器只是一个运行于 宿主操作系统 host OS 上的应用进程，所以你需要一个镜像来运行它。Docker 镜像以进程的方式运行时就叫做 Docker 容器。你可以加载本地 Docker 镜像，也可以从 Docker Hub 上下载。Docker Hub 是一个提供公有和私有镜像来进行 拉取 pull 操作的集中仓库。官方的 Docker Hub 位于 <a href=https://hub.docker.com/>hub.docker.com</a>。 当你指示 Docker 引擎运行容器时，它会首先搜索本地镜像，如果没有找到，它会从 Docker Hub 上拉取相应的镜像。</p><p>让我们运行一个 Apache web 服务器的 Docker 镜像，比如 httpd 进程。你需要运行 <code>docker container run</code> 命令。旧的命令为 <code>docker run</code>， 但后来 Docker 添加了子命令部分，所以新版本支持下列命令：</p><pre tabindex=0><code>root@kerneltalks # docker container run -d -p 80:80 httpd
Unable to find image &#39;httpd:latest&#39; locally
latest: Pulling from library/httpd
3d77ce4481b1: Pull complete
73674f4d9403: Pull complete
d266646f40bd: Pull complete
ce7b0dda0c9f: Pull complete
01729050d692: Pull complete
014246127c67: Pull complete
7cd2e04cf570: Pull complete
Digest: sha256:f4610c3a1a7da35072870625733fd0384515f7e912c6223d4a48c6eb749a8617
Status: Downloaded newer image for httpd:latest
c46f2e9e4690f5c28ee7ad508559ceee0160ac3e2b1688a61561ce9f7d99d682
</code></pre><p>Docker 的 <code>run</code> 命令将镜像名作为强制参数，另外还有很多可选参数。常用的参数有：</p><ul><li><code>-d</code>：从当前 shell 脱离容器</li><li><code>-p X:Y</code>：绑定容器的端口 Y 到宿主机的端口 X</li><li><code>--name</code>：命名你的容器。如果未指定，它将被赋予随机生成的名字</li><li><code>-e</code>：当启动容器时传递环境编辑及其值</li></ul><p>通过以上输出你可以看到，我们将 <code>httpd</code> 作为镜像名来运行容器。接着，本地镜像没有找到，Docker 引擎从 Docker Hub 拉取了它。注意，它下载了镜像 <code>httpd:latest</code>， 其中 <code>:</code> 后面跟着版本号。如果你需要运行特定版本的容器，你可以在镜像名后面注明版本名。如果不提供版本名，Docker 引擎会自动拉取最新的版本。</p><p>输出的最后一行显示了你新运行的 httpd 容器的唯一 ID。</p><h3 id=如何列出所有运行中的-docker-容器>如何列出所有运行中的 Docker 容器？</h3><p>现在，你的容器已经运行起来了，你可能想要确认这一点，或者你想要列出你的机器上运行的所有容器。你可以使用 <code>docker container ls</code> 命令。在旧的 Docker 版本中，对应的命令为 <code>docker ps</code>。</p><pre tabindex=0><code>root@kerneltalks # docker container ls
CONTAINER ID        IMAGE               COMMAND              CREATED             STATUS              PORTS                NAMES
c46f2e9e4690        httpd               &#34;httpd-foreground&#34;   11 minutes ago      Up 11 minutes       0.0.0.0:80-&gt;80/tcp   cranky_cori
</code></pre><p>列出的结果是按列显示的。每一列的值分别为：</p><ol><li>Container ID ：一开始的几个字符对应你的容器的唯一 ID</li><li>Image ：你运行容器的镜像名</li><li>Command ：容器启动后运行的命令</li><li>Created ：创建时间</li><li>Status ：容器当前状态</li><li>Ports ：与宿主端口相连接的端口信息</li><li>Names ：容器名（如果你没有命名你的容器，那么会随机创建）</li></ol><h3 id=如何查看-docker-容器的历史纪录>如何查看 Docker 容器的历史纪录？</h3><p>在第一步我们使用了 <code>-d</code> 参数来将容器，在它一开始运行的时候，就从当前的 shell 中脱离出来。在这种情况下，我们不知道容器里面发生了什么。所以为了查看容器的历史纪录，Docker 提供了 <code>logs</code> 命令。它采用容器名称或 ID 作为参数。</p><pre tabindex=0><code>root@kerneltalks # docker container logs cranky_cori
AH00558: httpd: Could not reliably determine the server&#39;s fully qualified domain name, using 172.17.0.2. Set the &#39;ServerName&#39; directive globally to suppress this message
AH00558: httpd: Could not reliably determine the server&#39;s fully qualified domain name, using 172.17.0.2. Set the &#39;ServerName&#39; directive globally to suppress this message
[Thu May 31 18:35:07.301158 2018] [mpm_event:notice] [pid 1:tid 139734285989760] AH00489: Apache/2.4.33 (Unix) configured -- resuming normal operations
[Thu May 31 18:35:07.305153 2018] [core:notice] [pid 1:tid 139734285989760] AH00094: Command line: &#39;httpd -D FOREGROUND&#39;
</code></pre><p>这里我使用了容器名称作为参数。你可以看到在我们的 httpd 容器中与 Apache 相关的历史纪录。</p><h3 id=如何确定-docker-容器的进程>如何确定 Docker 容器的进程？</h3><p>容器是一个使用宿主资源来运行的进程。这样，你可以在宿主系统的进程表中定位容器的进程。让我们在宿主系统上确定容器进程。</p><p>Docker 使用著名的 <code>top</code> 命令作为子命令的名称，来查看容器产生的进程。它采用容器的名称或 ID 作为参数。在旧版本的 Docker 中，只可运行 <code>docker top</code> 命令。在新版本中，<code>docker top</code> 和 <code>docker container top</code> 命令都可以生效。</p><pre tabindex=0><code>root@kerneltalks # docker container top  cranky_cori
UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD
root                15702               15690               0                   18:35               ?                   00:00:00            httpd -DFOREGROUND
bin                 15729               15702               0                   18:35               ?                   00:00:00            httpd -DFOREGROUND
bin                 15730               15702               0                   18:35               ?                   00:00:00            httpd -DFOREGROUND
bin                 15731               15702               0                   18:35               ?                   00:00:00            httpd -DFOREGROUND

root@kerneltalks # ps -ef |grep -i 15702
root     15702 15690  0 18:35 ?        00:00:00 httpd -DFOREGROUND
bin      15729 15702  0 18:35 ?        00:00:00 httpd -DFOREGROUND
bin      15730 15702  0 18:35 ?        00:00:00 httpd -DFOREGROUND
bin      15731 15702  0 18:35 ?        00:00:00 httpd -DFOREGROUND
root     15993 15957  0 18:59 pts/0    00:00:00 grep --color=auto -i 15702
</code></pre><p>在第一个输出中，列出了容器产生的进程的列表。它包含了所有细节，包括 用户号 uid 、 进程号 pid ， 父进程号 ppid 、开始时间、命令，等等。这里所有的进程号你都可以在宿主的进程表里搜索到。这就是我们在第二个命令里做得。这证明了容器确实是宿主系统中的进程。</p><h3 id=如何停止-docker-容器>如何停止 Docker 容器？</h3><p>只需要 <code>stop</code> 命令！同样，它采用容器名称或 ID 作为参数。</p><pre tabindex=0><code>root@kerneltalks # docker container stop cranky_cori
cranky_cori
</code></pre><h3 id=如何列出停止的或不活动的-docker-容器>如何列出停止的或不活动的 Docker 容器？</h3><p>现在我们停止了我们的容器，这时如果我们使用 <code>ls</code> 命令，它将不会出现在列表中。</p><pre tabindex=0><code>root@kerneltalks # docker container ls
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
</code></pre><p>所以，在这种情况下，如果想要查看停止的或不活动的容器，你需要在 <code>ls</code> 命令里同时使用 <code>-a</code> 参数。</p><pre tabindex=0><code>root@kerneltalks # docker container ls -a
CONTAINER ID        IMAGE               COMMAND              CREATED             STATUS                     PORTS               NAMES
c46f2e9e4690        httpd               &#34;httpd-foreground&#34;   33 minutes ago      Exited (0) 2 minutes ago                       cranky_cori
</code></pre><p>有了 <code>-a</code> 参数，现在我们可以查看已停止的容器。注意这些容器的状态被标注为 已退出 exited 。既然容器只是一个进程，那么用“退出”比“停止”更合适！</p><h3 id=如何重新启动-docker-容器>如何（重新）启动 Docker 容器？</h3><p>现在，我们来启动这个已停止的容器。这和运行一个容器有所区别。当你运行一个容器时，你将启动一个全新的容器。当你启动一个容器时，你将开始一个已经停止并保存了当时运行状态的容器。它将以停止时的状态重新开始运行。</p><pre tabindex=0><code>root@kerneltalks #  docker container start c46f2e9e4690
c46f2e9e4690

root@kerneltalks # docker container ls -a
CONTAINER ID        IMAGE               COMMAND              CREATED             STATUS              PORTS                NAMES
c46f2e9e4690        httpd               &#34;httpd-foreground&#34;   35 minutes ago      Up 8 seconds        0.0.0.0:80-&gt;80/tcp   cranky_cori
</code></pre><h3 id=如何移除-docker-容器>如何移除 Docker 容器？</h3><p>我们使用 <code>rm</code> 命令来移除容器。你不可以移除运行中的容器。移除之前需要先停止容器。你可以使用 <code>-f</code> 参数搭配 <code>rm</code> 命令来强制移除容器，但并不推荐这么做。</p><pre tabindex=0><code>root@kerneltalks # docker container rm cranky_cori
cranky_cori
root@kerneltalks # docker container ls -a
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
</code></pre><p>你看，一旦移除了容器，即使再使用 <code>ls -a</code> 命令也查看不到容器了。</p><hr><p>via: <a href=https://kerneltalks.com/virtualization/8-basic-docker-container-management-commands/>https://kerneltalks.com/virtualization/8-basic-docker-container-management-commands/</a></p><p>作者：<a href=https://kerneltalks.com>Shrikant Lavhate</a> 选题：<a href=https://github.com/lujun9972>lujun9972</a> 译者：<a href=https://github.com/lonaparte>lonaparte</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/%E5%AE%B9%E5%99%A8/ rel=tag>容器</a></li><li class=tags__item><a class="tags__link btn" href=/tags/docker/ rel=tag>Docker</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>