<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Git 中上下文切换的 4 种方式 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="Git 中上下文切换的 4 种方式"><meta property="og:description" content="比较 Git 中四种切换分支的方法的优缺点。"><meta property="og:type" content="article"><meta property="og:url" content="/article-13422-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-05-25T09:18:00+00:00"><meta property="article:modified_time" content="2021-05-25T09:18:00+00:00"><meta itemprop=name content="Git 中上下文切换的 4 种方式"><meta itemprop=description content="比较 Git 中四种切换分支的方法的优缺点。"><meta itemprop=datePublished content="2021-05-25T09:18:00+00:00"><meta itemprop=dateModified content="2021-05-25T09:18:00+00:00"><meta itemprop=wordCount content="306"><meta itemprop=keywords content="Git,分支,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>Git 中上下文切换的 4 种方式</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2021-05-25T09:18:00Z>May 25, 2021</time></div></div></header><div class="content post__content clearfix"><blockquote><p>比较 Git 中四种切换分支的方法的优缺点。</p></blockquote><p><img src=https://img.linux.net.cn/data/attachment/album/202105/25/091803a6ww3r7yo32oxdzx.jpg alt title="Computer screen with files or windows open"></p><p>所有大量使用 Git 的人都会用到某种形式的上下文切换。有时这只会给你的工作流程增加少量的开销，但有时，这可能是一段痛苦的经历。</p><p>让我们用以下这个例子来讨论一些常见的上下文切换策略的优缺点：</p><blockquote><p>假设你在一个名为 <code>feature-X</code> 的分支中工作。你刚刚发现你需要解决一个无关的问题。这不能在 <code>feature-X</code> 分支中完成。你需要在一个新的分支 <code>feature-Y</code> 中完成这项工作。</p></blockquote><h3 id=方案-1暂存--分支>方案 1：暂存 + 分支</h3><p>解决此问题最常见的工作流程可能如下所示：</p><ol><li>停止分支 <code>feature-X</code> 上的工作</li><li><code>git stash</code></li><li><code>git checkout -b feature-Y origin/main</code></li><li>一顿鼓捣，解决 <code>feature-Y</code> 的问题</li><li><code>git checkout feature-X</code> 或 <code>git switch -</code></li><li><code>git stash pop</code></li><li>继续在 <code>feature-X</code> 中工作</li></ol><p><strong>优点：</strong> 这种方法的优点在于，对于简单的更改，这是一个相当简单的工作流程。它可以很好地工作，特别是对于小型仓库。</p><p><strong>缺点：</strong> 使用此工作流程时，一次只能有一个工作区。另外，根据你的仓库的状态，使用暂存是一个麻烦的环节。</p><h3 id=方案-2wip-提交--分支>方案 2：WIP 提交 + 分支</h3><p>这个解决方案和前一个非常相似，但是它使用 WIP（ 正在进行的工作 Work in Progress ）提交而不是暂存。当你准备好切换回来，而不是弹出暂存时，<code>git reset HEAD~1</code> 会展开 WIP 提交，你可以自由地继续，就像之前的方案一样，但不会触及暂存。</p><ol><li>停止分支 <code>feature-X</code> 上的工作</li><li><code>git add -u</code>（仅仅添加修改和删除的文件）</li><li><code>git commit -m "WIP"</code></li><li><code>git checkout -b feature-Y origin/master</code></li><li>一顿鼓捣，解决 <code>feature-Y</code> 的问题</li><li><code>git checkout feature-X</code> 或 <code>git switch -</code></li><li><code>git reset HEAD~1</code></li></ol><p><strong>优点：</strong> 对于简单的更改，这是一个简单的工作流，也适合于小型仓库。你不需要使用暂存。</p><p><strong>缺点：</strong> 任何时候都只能有一个工作区。此外，如果你或你的代码审阅者不够谨慎，WIP 提交可能会合并到最终产品。</p><p>使用此工作流时，你<strong>永远</strong>不要想着将 <code>--hard</code> 添加到 <code>git reset</code>。如果你不小心这样做了，你应该能够使用 <code>git reflog</code> 恢复提交，但是你最好完全避免这种情况发生，否则你会听到心碎的声音。</p><h3 id=方案-3克隆一个新仓库>方案 3：克隆一个新仓库</h3><p>在这个解决方案中，不是创建新的分支，而是为每个新的功能分支创建存储库的新克隆。</p><p><strong>优点：</strong> 你可以同时在多个工作区中工作。你不需要 <code>git stash</code> 或者是 WIP 提交。</p><p><strong>缺点：</strong> 需要考虑仓库的大小，因为这可能会占用大量磁盘空间（浅层克隆可以帮助解决这种情况，但它们可能并不总是很合适。）此外，你的仓库克隆将互不可知。因为他们不能互相追踪，所以你必须手动追踪你的克隆的源仓库。如果需要 git 钩子，则需要为每个新克隆设置它们。</p><h3 id=方案-4git-工作树>方案 4：git 工作树</h3><p>要使用此解决方案，你可能需要了解 <code>git add worktree</code>。如果你不熟悉 Git 中的工作树，请不要难过。许多人多年来都对这个概念一无所知。</p><h4 id=什么是工作树>什么是工作树？</h4><p>将工作树视为仓库中属于项目的文件。本质上，这是一种工作区。你可能没有意识到你已经在使用工作树了。开始使用 Git 时，你将自动获得第一个工作树。</p><pre tabindex=0><code>$ mkdir /tmp/foo &amp;&amp; cd /tmp/foo
$ git init
$ git worktree list
/tmp  0000000 [master]
</code></pre><p>你可以在以上代码看到，甚至在第一次提交前你就有了一个工作树。接下来去尝试再添加一个工作树到你的项目中吧。</p><h4 id=添加一个工作树>添加一个工作树</h4><p>想要添加一个新的工作树你需要提供:</p><ol><li>硬盘上的一个位置</li><li>一个分支名</li><li>添加哪些分支</li></ol><pre tabindex=0><code>$ git clone https://github.com/oalders/http-browserdetect.git
$ cd http-browserdetect/
$ git worktree list
/Users/olaf/http-browserdetect  90772ae [master]

$ git worktree add ~/trees/oalders/feature-X -b oalders/feature-X origin/master
$ git worktree add ~/trees/oalders/feature-Y -b oalders/feature-Y e9df3c555e96b3f1

$ git worktree list
/Users/olaf/http-browserdetect       90772ae [master]
/Users/olaf/trees/oalders/feature-X  90772ae [oalders/feature-X]
/Users/olaf/trees/oalders/feature-Y  e9df3c5 [oalders/feature-Y]
</code></pre><p>与大多数其他 Git 命令一样，你需要在仓库路径下使用此命令。一旦创建了工作树，就有了隔离的工作环境。Git 仓库会跟踪工作树在磁盘上的位置。如果 Git 钩子已经在父仓库中设置好了，那么它们也可以在工作树中使用。</p><p>请注意到，每个工作树只使用父仓库磁盘空间的一小部分。在这种情况下，工作树需要只大约三分之一的原始磁盘空间。这这非常适合进行扩展。如果你的仓库达到了千兆字节的级别，你就会真正体会到工作树对硬盘空间的节省。</p><pre tabindex=0><code>$ du -sh /Users/olaf/http-browserdetect
2.9M

$ du -sh /Users/olaf/trees/oalders/feature-X
1.0M
</code></pre><p><strong>优点：</strong> 你可以同时在多个工作区中工作。你不需要使用暂存。Git 会跟踪所有的工作树。你不需要设置 Git 钩子。这也比 <code>git clone</code> 更快，并且可以节省网络流量，因为你可以在飞行模式下执行此操作。你还可以更高效地使用磁盘空间，而无需借助于浅层克隆。</p><p><strong>缺点：</strong> 这是个需要你额外学习和记忆的新东西，但是如果你能养成使用这个功能的习惯，它会给你丰厚的回报。</p><h4 id=额外的小技巧>额外的小技巧</h4><p>有很多方式可以清除工作树，最受欢迎的方式是使用 Git 来移除工作树：</p><pre tabindex=0><code>git worktree remove /Users/olaf/trees/oalders/feature-X
</code></pre><p>如果你喜欢 RM 大法，你也可以用 <code>rm -rf</code> 来删除工作树。</p><pre tabindex=0><code>rm -rf /Users/olaf/trees/oalders/feature-X
</code></pre><p>但是，如果执行此操作，则可能需要使用 <code>git worktree prune</code> 清理所有剩余的文件。或者你现在可以跳过清理，这将在将来的某个时候通过 <code>git gc</code> 自行完成。</p><h4 id=注意事项>注意事项</h4><p>如果你准备尝试 <code>git worktree</code>，请记住以下几点：</p><ul><li>删除工作树并不会删除该分支。</li><li>可以在工作树中切换分支。</li><li>你不能在多个工作树中同时签出同一个分支。</li><li>像其他命令一样，<code>git worktree</code> 需要从仓库内运行。</li><li>你可以同时拥有许多工作树。</li><li>要从同一个本地仓库签出创建工作树，否则它们将互不可知。</li></ul><h4 id=git-rev-parse>git rev-parse</h4><p>最后一点注意：在使用 <code>git worktree</code> 时，仓库根所在的位置可能取决于上下文。幸运的是，<code>git rev parse</code> 可以让你区分这两者。</p><ul><li>要查找父仓库的根目录，请执行以下操作：</li></ul><pre tabindex=0><code>git rev-parse --git-common-dir
</code></pre><ul><li>要查找你当前所在仓库的根目录，请执行：</li></ul><pre tabindex=0><code>git rev-parse --show-toplevel
</code></pre><h3 id=根据你的需要选择最好的方法>根据你的需要选择最好的方法</h3><p>就像很多事情一样，TIMTOWDI（ 条条大道通罗马 there&rsquo;s more than one way to do it ）。重要的是你要找到一个适合你需要的工作流程。你的需求可能因手头的问题而异。也许你偶尔会发现自己将 <code>git worktree</code> 作为版本控制工具箱中的一个方便工具。</p><hr><p>via: <a href=https://opensource.com/article/21/4/context-switching-git>https://opensource.com/article/21/4/context-switching-git</a></p><p>作者：<a href=https://opensource.com/users/oalders>Olaf Alders</a> 选题：<a href=https://github.com/lujun9972>lujun9972</a> 译者：<a href=https://github.com/Chao-zhi>Chao-zhi</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/git/ rel=tag>Git</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E5%88%86%E6%94%AF/ rel=tag>分支</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>