<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>已经会用Git了？不会这十招怎么行 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="已经会用Git了？不会这十招怎么行"><meta property="og:description" content="之前我们发了一些教程让你熟悉Git基础和在团队合作环境中使用Git.我们讨论的这些Git命令足够让一个开发者在Git的世界里生存下去。在这篇教程里，我们试着探索如何高效地管理你的时间以及如何充分利用Git提供的特性。   注意：这里介绍的命令中有的包含方括号(例如：git add -p )。在这些例子中，你应该用你自己的数字、标识符等替代方括号里的内容，并且去掉方括号。  1. Git自动补全 如果你在命令行环境中运行Git命令，每次都手动地逐个输入命令是一件很无聊的事。为此，你可以花几分钟时间配置一下Git命令的自动补全功能。 在*nix系统运"><meta property="og:type" content="article"><meta property="og:url" content="/article-3463-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2014-07-25T15:24:00+00:00"><meta property="article:modified_time" content="2014-07-25T15:24:00+00:00"><meta itemprop=name content="已经会用Git了？不会这十招怎么行"><meta itemprop=description content="之前我们发了一些教程让你熟悉Git基础和在团队合作环境中使用Git.我们讨论的这些Git命令足够让一个开发者在Git的世界里生存下去。在这篇教程里，我们试着探索如何高效地管理你的时间以及如何充分利用Git提供的特性。   注意：这里介绍的命令中有的包含方括号(例如：git add -p )。在这些例子中，你应该用你自己的数字、标识符等替代方括号里的内容，并且去掉方括号。  1. Git自动补全 如果你在命令行环境中运行Git命令，每次都手动地逐个输入命令是一件很无聊的事。为此，你可以花几分钟时间配置一下Git命令的自动补全功能。 在*nix系统运"><meta itemprop=datePublished content="2014-07-25T15:24:00+00:00"><meta itemprop=dateModified content="2014-07-25T15:24:00+00:00"><meta itemprop=wordCount content="164"><meta itemprop=keywords content="Git,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>已经会用Git了？不会这十招怎么行</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-07-25T15:24:00Z>July 25, 2014</time></div></div></header><div class="content post__content clearfix"><p>之前我们发了一些教程让你熟悉<a href=http://www.sitepoint.com/git-for-beginners/>Git基础</a>和<a href=http://www.sitepoint.com/getting-started-git-team-environment/>在团队合作环境中使用Git</a>.我们讨论的这些Git命令足够让一个开发者在Git的世界里生存下去。在这篇教程里，我们试着探索如何高效地管理你的时间以及如何充分利用Git提供的特性。</p><p><img src=/data/attachment/album/201407/25/152443ax2ruxfx1e04fr1g.png alt></p><blockquote><p>注意：这里介绍的命令中有的包含方括号(例如：git add -p [file_name])。在这些例子中，你应该用你自己的数字、标识符等替代方括号里的内容，并且去掉方括号。</p></blockquote><h3 id=1-git自动补全>1. Git自动补全</h3><p>如果你在命令行环境中运行Git命令，每次都手动地逐个输入命令是一件很无聊的事。为此，你可以花几分钟时间配置一下Git命令的自动补全功能。</p><p>在*nix系统运行下列命令下载自动补全脚本：</p><pre tabindex=0><code>cd ~
curl https://raw.github.com/git/git/master/contrib/completion/git-completion.bash -o ~/.git-completion.bash
</code></pre><p>然后，添加下面的行到你的~/.bash_profile文件：</p><pre tabindex=0><code>if [ -f ~/.git-completion.bash ]; then
    . ~/.git-completion.bash
fi
</code></pre><p>尽管我之前已经提到过，但我还是想再强调一下：如果你想使用完整的Git特性，你绝bi应该切换到命令行环境。</p><h3 id=2-在git中忽略文件>2. 在Git中忽略文件</h3><p>你是不是对出现在你Git库里面的编译生成文件（比如.pyc)感到很无语？或者你是不是很厌恶不小心将他们添加到了Git？直接看这里，这里有一个方法可以让你告诉Git忽略所有这些文件和目录。只需要创建一个名字为.gitignore的文件，里面列出你不想要Git跟踪的文件和目录。可以用感叹号(!)列出例外情况。</p><pre tabindex=0><code>*.pyc
*.exe
my_db_config/

!main.pyc
</code></pre><h3 id=3-谁动了我的代码>3. 谁动了我的代码？</h3><p>当事情出了乱子时立马责怪别人这是人类的天性。如果你的服务器程序不能正常工作了，要找出罪魁祸首是非常简单的&ndash;只需要执行git blame。这个命令告诉你文件里的每一行的作者是谁，最后改动那一行的提交，以及提交的时间戳。</p><pre tabindex=0><code>git blame [file_name]
</code></pre><p><img src=/data/attachment/album/201407/25/152454j21c8f0lq1d8oaft.png alt="git blame demonstration"></p><p>在下面的截图里，你可以看到在一个更大的库里这个命令的输出是什么样的：</p><p><img src=/data/attachment/album/201407/25/152455nmtyrim99x29pgbv.png alt="git blame on the ATutor repository"></p><h3 id=4-查看库的历史>4. 查看库的历史</h3><p>在之前的教程里，我们已经看过了如何使用git log命令。不管怎样，有3个选项你应该知道。</p><ul><li><strong>&ndash;oneline</strong> - 压缩每次的提交信息，只保留一个缩减的Hash值和说明文字，然后把这些都展示在一行里。</li><li><strong>&ndash;graph</strong> - 这个选项将在左边画出一个文字界面的提交历史图。如果你只有一个分支，用这个选项查看历史时是没什么意义的。</li><li><strong>&ndash;all</strong> - 显示所有分支历史。</li></ul><p>这是这3个选项合起来使用的效果：</p><p><img src=/data/attachment/album/201407/25/152457thz97ry9wvrlymva.png alt="Use of git log with all, graph and oneline"></p><h3 id=5-不要丢失对某个提交的跟踪>5. 不要丢失对某个提交的跟踪</h3><p>假设你提交了一些不需要的东西，然后你进行了hard重置回到之前的状态。后来，你发现在这个过程中你丢失了其他一些重要的信息，你想要把这些信息找回来，或者至少可以查看一下这些信息。这就需要git reflog帮忙。</p><p>简单的git log只能告诉你最近的提交，这个提交的父提交，父提交的父提交，等等。但是git reflog是一个HEAD指向的提交的列表。记住，这个列表依赖于你自己的本地操作环境，它不是库的一部分，也不包含在push或者merge中。</p><p>如果执行git log命令，可以看到提交历史，这是我的库的一部分：</p><p><img src=/data/attachment/album/201407/25/152458ml32qjhp2l92pbbl.png alt="Project history"></p><p>但是，git reflog命令显示了一个被我用hard重置丢掉的提交(b1b0ee9-HEAD@{4}).</p><p><img src=/data/attachment/album/201407/25/152459c0nnz0koew230f3f.png alt="Git reflog"></p><h3 id=6-暂存文件的一部分更改以便进行一次提交>6. 暂存文件的一部分更改以便进行一次提交</h3><p>通常依据特性来提交是一个好的实践方法，意思是说，每一个提交都只添加一个特性或者修复一个bug。想一下如果你一次修复了两个bug或者添加了两个特性但是都还没有逐个提交该怎么办。这种场景下，你可以将他们一起提交。但是有一个更好的办法：单独暂存这些文件，然后分开提交。</p><p>让我们假设你对一个文件做了多个更改，然后想让这些更改分开提交。这时，我们用带-p的添加命令。</p><pre tabindex=0><code>git add -p [file_name]
</code></pre><p>我们来试试这种用法。我添加了3个新行到file_name，但是我只想让第1行和第3行出现在我的提交里。让我们看看git diff的输出是什么样的。</p><p><img src=/data/attachment/album/201407/25/152501o1e42jzudqqvatov.png alt="Changes in repo"></p><p>然后，我们看看带-p选项的add命令会发生什么。</p><p><img src=/data/attachment/album/201407/25/152501xowhsrhs5os8o8cs.png alt="Running add with -p"></p><p>看起来Git认为所有的更改都是同一个目的的一部分，所以把他们分组到同一个块里。这时，你可以：</p><ul><li>输入 y 暂存块</li><li>输入 n 不暂存块</li><li>输入 e 手动编辑块</li><li>输入 d 退出或者跳转到下一个文件</li><li>输入 s 分割块</li></ul><p>在我们这个例子中，我们想把这个块分割成更小的部分，然后选择其中一些忽略另外一些。</p><p><img src=/data/attachment/album/201407/25/152502i8oqqez9qelq89hd.png alt="Adding all hunks"></p><p>如你所见，我们已经逐个添加了第1和第3行，忽略了第2行。你可以看到库的状态并且进行一次提交。</p><p><img src=/data/attachment/album/201407/25/152503y10h36hwh3g6ug60.png alt="Repository after selectively adding a file"></p><h3 id=7-合并多个提交>7. 合并多个提交</h3><p>为了进行核查或者发起一个合并请求（这经常发生在开源项目里），对代码进行了修改提交。但在最后代码被接受之前，你也许会需要修改你的代码。于是你修改代码，但是下一次核查的时候又一次需要进行修改。不知不觉中，你就已经有了好几个提交。理论上你应该用rebase命令把他们合并起来。</p><pre tabindex=0><code>git rebase -i HEAD~[number_of_commits]
</code></pre><p>如果你想合并最后的两次提交，你应该运行下面的命令。</p><pre tabindex=0><code>git rebase -i HEAD~2
</code></pre><p>一旦你运行这个命令，你将进入一个交互式界面，它将询问你想要合并哪些提交。你pick(拣选)最近的提交然后squash(合并)旧的提交。</p><p><img src=/data/attachment/album/201407/25/152505mqp4h0rn0qyrrlnu.png alt="Git squash interactive"></p><p>接着你应该提供一个对新提交的说明。这个过程会重写你的提交历史。</p><p><img src=/data/attachment/album/201407/25/152506c0bbw0xz39094vnb.png alt="Adding a commit message"></p><h3 id=8-储藏没有提交的更改>8. 储藏没有提交的更改</h3><p>假设你正在修复一个bug或者添加一个特性，突然你被要求展示一下你的工作成果。你现在的工作还没有完成，不够进行一次提交。这时，git stash命令可以用来急救一下。Stash命令跟踪你所有的更改，然后把他们储藏起来以便以后使用。命令如下-</p><pre tabindex=0><code>git stash
</code></pre><p>可以多次储藏更改，查看储藏列表，你可以运行下面的命令：</p><pre tabindex=0><code>git stash list
</code></pre><p><img src=/data/attachment/album/201407/25/152507n5fn0pfsnv3lvpv2.png alt="Stash list"></p><p>如果你想取消储藏，覆盖当前的更改，你可以通过下面的命令使用储藏：</p><pre tabindex=0><code>git stash apply
</code></pre><p>在最后的这个截图里，你可以看到每个储藏都有一个标识符，是一个唯一的数字（尽管在这里我们只有一个储藏）。如果你想使用某个储藏，你在apply命令后面加上这个唯一的标识符：</p><pre tabindex=0><code>git stash apply stash@{2}
</code></pre><p><img src=/data/attachment/album/201407/25/152508my1owq1wi0o54i1m.png alt="After un-stashing changes"></p><h3 id=9-检查丢失的提交>9. 检查丢失的提交</h3><p>尽管reflog是一种检查丢失提交的方法，大型的库里却不太实用。这个时候，应该用fsck（文件系统检查）命令。</p><pre tabindex=0><code>git fsck --lost-found
</code></pre><p><img src=/data/attachment/album/201407/25/152509v9ontu9t93889yuc.png alt="Git fsck results"></p><p>这里你可以看到一个丢失的提交。你可以通过git show [commit_hash] 查看提交的更改或者通过运行git merge [commit_hash]命令进行恢复。</p><p>git fsck跟reflog命令相比有一个优点。假设你删除了一个远程分支，然后clone了这个库。用fsck命令你可以找到并且恢复这个删除的远程分支。</p><h3 id=10-最佳选择>10. 最佳选择</h3><p>之前我已经存记下了那些最优雅的Git命令。但是目前为止，cherry-pick命令是我最喜欢的Git命令，因为它直白的名字和实用的功能！</p><p>最简单的情况下，cherry-pick从另一个分支里选出单独的一个提交，然后合并到当前分支。如果你正并行工作在两个或者更多的分支上，你也许会发现一个存在于所有分支上的bug。如果你解决了一个分支上的这个bug，你可以拣选这个对应的提交应用到其他分支上，而不会弄乱其他文件或者提交。</p><p>让我们来考虑一个可以使用这个命令的场景。我有两个分支，我想拣选b20fd14: Cleaned junk这个提交到另一个分支上。</p><p><img src=/data/attachment/album/201407/25/152510wicskwnd92svw9ez.png alt="Before cherry pick"></p><p>我切换到想要应用这个拣选出来的提交的分支，然后运行下面的命令：</p><pre tabindex=0><code>git cherry-pick [commit_hash]
</code></pre><p><img src=/data/attachment/album/201407/25/152511n7tjnt4jvhz070h7.png alt="After cherry pick"></p><p>尽管这次我们很干净的用了cherry-pick命令，但你应该知道这个命令经常会引起冲突，所以请小心使用。</p><h3 id=总结>总结</h3><p>到了这里，我们结束了这个能使你Git能力提升一个级别的列表。Git是最好的版本控制器，它能完成你能想象到的任何事情。所以，经常试着用Git挑战你自己。一不小心你就会学到很多新东西。</p><hr><p>via: <a href=http://www.sitepoint.com/10-tips-git-next-level/>http://www.sitepoint.com/10-tips-git-next-level/</a></p><p>译者：<a href=https://github.com/CNprober>love_daisy_love</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创翻译，<a href=http://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/git/ rel=tag>Git</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>