<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>开发一个 Linux 调试器（八）：堆栈展开 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="开发一个 Linux 调试器（八）：堆栈展开"><meta property="og:description" content="有一个 backtrace 命令，它给你提供了程序当前的函数调用链。这篇文章将向你展示如何在 x86_64 上实现堆栈展开以生成这样的回溯。"><meta property="og:type" content="article"><meta property="og:url" content="/article-8930-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-10-04T16:59:47+00:00"><meta property="article:modified_time" content="2017-10-04T16:59:47+00:00"><meta itemprop=name content="开发一个 Linux 调试器（八）：堆栈展开"><meta itemprop=description content="有一个 backtrace 命令，它给你提供了程序当前的函数调用链。这篇文章将向你展示如何在 x86_64 上实现堆栈展开以生成这样的回溯。"><meta itemprop=datePublished content="2017-10-04T16:59:47+00:00"><meta itemprop=dateModified content="2017-10-04T16:59:47+00:00"><meta itemprop=wordCount content="328"><meta itemprop=keywords content="调试,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>开发一个 Linux 调试器（八）：堆栈展开</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-10-04T16:59:47Z>October 04, 2017</time></div></div></header><div class="content post__content clearfix"><p><img src=https://img.linux.net.cn/data/attachment/album/201710/04/165839gmb9iqdiee2bh3m5.jpg alt></p><p>有时你需要知道的最重要的信息是什么，你当前的程序状态是如何到达那里的。有一个 <code>backtrace</code> 命令，它给你提供了程序当前的函数调用链。这篇文章将向你展示如何在 x86_64 上实现堆栈展开以生成这样的回溯。</p><h3 id=系列索引>系列索引</h3><p>这些链接将会随着其他帖子的发布而上线。</p><ol><li><a href=/article-8626-1.html>准备环境</a></li><li><a href=/article-8645-1.html>断点</a></li><li><a href=/article-8663-1.html>寄存器和内存</a></li><li><a href=/article-8719-1.html>ELF 和 DWARF</a></li><li><a href=/article-8812-1.html>源码和信号</a></li><li><a href=/article-8813-1.html>源码级逐步执行</a></li><li><a href=/article-8890-1.html>源码级断点</a></li><li><a href=https://blog.tartanllama.xyz/c++/2017/06/24/writing-a-linux-debugger-unwinding/>堆栈展开</a></li><li>读取变量</li><li>之后步骤</li></ol><p>用下面的程序作为例子：</p><pre tabindex=0><code>void a() {
    //stopped here
}

void b() {
     a();
}

void c() {
     a();
}

int main() {
    b();
    c();
}
</code></pre><p>如果调试器停在 <code>//stopped here' 这行，那么有两种方法可以达到：</code>main->b->a<code>或</code>main->c->a`。如果我们用 LLDB 设置一个断点，继续执行并请求一个回溯，那么我们将得到以下内容：</p><pre tabindex=0><code>* frame #0: 0x00000000004004da a.out`a() + 4 at bt.cpp:3
  frame #1: 0x00000000004004e6 a.out`b() + 9 at bt.cpp:6
  frame #2: 0x00000000004004fe a.out`main + 9 at bt.cpp:14
  frame #3: 0x00007ffff7a2e830 libc.so.6`__libc_start_main + 240 at libc-start.c:291
  frame #4: 0x0000000000400409 a.out`_start + 41
</code></pre><p>这说明我们目前在函数 <code>a</code> 中，<code>a</code> 从函数 <code>b</code> 中跳转，<code>b</code> 从 <code>main</code> 中跳转等等。最后两个帧是编译器如何引导 <code>main</code> 函数的。</p><p>现在的问题是我们如何在 x86_64 上实现。最稳健的方法是解析 ELF 文件的 <code>.eh_frame</code> 部分，并解决如何从那里展开堆栈，但这会很痛苦。你可以使用 <code>libunwind</code> 或类似的来做，但这很无聊。相反，我们假设编译器以某种方式设置了堆栈，我们将手动遍历它。为了做到这一点，我们首先需要了解堆栈的布局。</p><pre tabindex=0><code>            High
        |   ...   |
        +---------+
     +24|  Arg 1  |
        +---------+
     +16|  Arg 2  |
        +---------+
     + 8| Return  |
        +---------+
EBP+--&gt; |Saved EBP|
        +---------+
     - 8|  Var 1  |
        +---------+
ESP+--&gt; |  Var 2  |
        +---------+
        |   ...   |
            Low
</code></pre><p>如你所见，最后一个堆栈帧的帧指针存储在当前堆栈帧的开始处，创建一个链接的指针列表。堆栈依据这个链表解开。我们可以通过查找 DWARF 信息中的返回地址来找出列表中下一帧的函数。一些编译器将忽略跟踪 <code>EBP</code> 的帧基址，因为这可以表示为 <code>ESP</code> 的偏移量，并可以释放一个额外的寄存器。即使启用了优化，传递 <code>-fno-omit-frame-pointer</code> 到 GCC 或 Clang 会强制它遵循我们依赖的约定。</p><p>我们将在 <code>print_backtrace</code> 函数中完成所有的工作：</p><pre tabindex=0><code>void debugger::print_backtrace() {
</code></pre><p>首先要决定的是使用什么格式打印出帧信息。我用了一个 lambda 来推出这个方法：</p><pre tabindex=0><code>    auto output_frame = [frame_number = 0] (auto&amp;&amp; func) mutable {
        std::cout &lt;&lt; &#34;frame #&#34; &lt;&lt; frame_number++ &lt;&lt; &#34;: 0x&#34; &lt;&lt; dwarf::at_low_pc(func)
                  &lt;&lt; &#39; &#39; &lt;&lt; dwarf::at_name(func) &lt;&lt; std::endl;
    };
</code></pre><p>打印输出的第一帧是当前正在执行的帧。我们可以通过查找 DWARF 中的当前程序计数器来获取此帧的信息：</p><pre tabindex=0><code>    auto current_func = get_function_from_pc(get_pc());
    output_frame(current_func);
</code></pre><p>接下来我们需要获取当前函数的帧指针和返回地址。帧指针存储在 <code>rbp</code> 寄存器中，返回地址是从帧指针堆栈起的 8 字节。</p><pre tabindex=0><code>    auto frame_pointer = get_register_value(m_pid, reg::rbp);
    auto return_address = read_memory(frame_pointer+8);
</code></pre><p>现在我们拥有了展开堆栈所需的所有信息。我只需要继续展开，直到调试器命中 <code>main</code>，但是当帧指针为 <code>0x0</code> 时，你也可以选择停止，这些是你在调用 <code>main</code> 函数之前调用的函数。我们将从每帧抓取帧指针和返回地址，并打印出信息。</p><pre tabindex=0><code>    while (dwarf::at_name(current_func) != &#34;main&#34;) {
        current_func = get_function_from_pc(return_address);
        output_frame(current_func);
        frame_pointer = read_memory(frame_pointer);
        return_address = read_memory(frame_pointer+8);
    }
}
</code></pre><p>就是这样！以下是整个函数：</p><pre tabindex=0><code>void debugger::print_backtrace() {
    auto output_frame = [frame_number = 0] (auto&amp;&amp; func) mutable {
        std::cout &lt;&lt; &#34;frame #&#34; &lt;&lt; frame_number++ &lt;&lt; &#34;: 0x&#34; &lt;&lt; dwarf::at_low_pc(func)
                  &lt;&lt; &#39; &#39; &lt;&lt; dwarf::at_name(func) &lt;&lt; std::endl;
    };

    auto current_func = get_function_from_pc(get_pc());
    output_frame(current_func);

    auto frame_pointer = get_register_value(m_pid, reg::rbp);
    auto return_address = read_memory(frame_pointer+8);

    while (dwarf::at_name(current_func) != &#34;main&#34;) {
        current_func = get_function_from_pc(return_address);
        output_frame(current_func);
        frame_pointer = read_memory(frame_pointer);
        return_address = read_memory(frame_pointer+8);
    }
}
</code></pre><h3 id=添加命令>添加命令</h3><p>当然，我们必须向用户公开这个命令。</p><pre tabindex=0><code>    else if(is_prefix(command, &#34;backtrace&#34;)) {
        print_backtrace();
    }
</code></pre><h3 id=测试>测试</h3><p>测试此功能的一个方法是通过编写一个测试程序与一堆互相调用的小函数。设置几个断点，跳到代码附近，并确保你的回溯是准确的。</p><p>我们已经从一个只能产生并附加到其他程序的程序走了很长的路。本系列的倒数第二篇文章将通过支持读写变量来完成调试器的实现。在此之前，你可以在<a href=https://github.com/TartanLlama/minidbg/tree/tut_unwind>这里</a>找到这个帖子的代码。</p><hr><p>via: <a href=https://blog.tartanllama.xyz/c++/2017/06/24/writing-a-linux-debugger-unwinding/>https://blog.tartanllama.xyz/c++/2017/06/24/writing-a-linux-debugger-unwinding/</a></p><p>作者：<a href=https://twitter.com/TartanLlama>Simon Brand</a> 译者：<a href=https://github.com/geekpi>geekpi</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/%E8%B0%83%E8%AF%95/ rel=tag>调试</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>