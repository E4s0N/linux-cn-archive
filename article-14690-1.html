<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>编译代码时动态地链接库 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="编译代码时动态地链接库"><meta property="og:description" content="编译软件在你如何运行你的系统方面给你很大的灵活性。LD_LIBRARY_PATH 变量，以及 GCC 的 -L 和 -l 选项，是这种灵活性的组成部分。"><meta property="og:type" content="article"><meta property="og:url" content="/article-14690-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-06-09T09:46:35+00:00"><meta property="article:modified_time" content="2022-06-09T09:46:35+00:00"><meta itemprop=name content="编译代码时动态地链接库"><meta itemprop=description content="编译软件在你如何运行你的系统方面给你很大的灵活性。LD_LIBRARY_PATH 变量，以及 GCC 的 -L 和 -l 选项，是这种灵活性的组成部分。"><meta itemprop=datePublished content="2022-06-09T09:46:35+00:00"><meta itemprop=dateModified content="2022-06-09T09:46:35+00:00"><meta itemprop=wordCount content="221"><meta itemprop=keywords content="动态库,编译,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>编译代码时动态地链接库</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2022-06-09T09:46:35Z>June 09, 2022</time></div></div></header><div class="content post__content clearfix"><p><img src=/data/attachment/album/202206/09/094633ekluugjjzailicja.jpg alt></p><blockquote><p>编译软件在你如何运行你的系统方面给你很大的灵活性。<code>LD_LIBRARY_PATH</code> 变量，以及 GCC 的 <code>-L</code> 和 <code>-l</code> 选项，是这种灵活性的组成部分。</p></blockquote><p>编译软件是开发者经常做的事情，在开源世界中，一些用户甚至选择自己动手。Linux 播客 Dann Washko 称源码为“通用包格式”，因为它包含了使一个应用在任何平台上运行所需的所有组件。当然，并不是所有的源码都是为所有的系统编写的，所以它只是在目标系统的子集内是“通用”的，但问题是，源码是非常灵活的。有了开源，你可以决定代码的编译和运行方式。</p><p>当你在编译代码时，你通常要处理多个源文件。开发人员倾向于将不同的类或模块放在不同的文件中，这样它们可以被单独维护，甚至可能被不同的项目使用。但当你编译这些文件时，许多文件会被编译成一个可执行文件。</p><p>这通常是通过创建共享库来完成的，然后从可执行文件中动态链接回它们。这样可以通过保持模块化功能的外部性来保持可执行文件的小型化，并确保库可以独立于使用它们的应用而被更新。</p><h3 id=在编译过程中定位一个共享对象>在编译过程中定位一个共享对象</h3><p>当你 <a href=https://opensource.com/article/22/5/what-happens-behind-scenes-during-gcc-compilation-c-programs>用 GCC 编译</a> 时，你通常需要在你的工作站上安装一个库，以便 GCC 能够定位到它。默认情况下，GCC 假定库在系统库路径中，例如 <code>/lib64</code> 和 <code>/usr/lib64</code>。然而，如果你要链接到一个你自己的尚未安装的库，或者你需要链接到一个没有安装在标准位置的库，那么你必须帮助 GCC 找到这些文件。</p><p>有两个选项对于在 GCC 中寻找库很重要：</p><ul><li><code>-L</code>（大写字母 L）在 GCC 的搜索位置上增加一个额外的库路径。</li><li><code>-l</code>（小写字母 L）设置你要链接的库的名字。</li></ul><p>例如，假设你写了一个叫做 <code>libexample.so</code> 的库，并且你想在编译你的应用 <code>demo.c</code> 时使用它。首先，从 <code>demo.c</code> 创建一个对象文件：</p><pre tabindex=0><code>$ gcc -I ./include -c src/demo.c
</code></pre><p><code>-I</code> 选项在 GCC 搜索头文件的路径中增加了一个目录。在这个例子中，我假设自定义头文件在一个名为 <code>include</code> 的本地目录中。<code>-c</code> 选项防止 GCC 运行链接器，因为这个任务只是为了创建一个对象文件。结果如下：</p><pre tabindex=0><code>$ ls
demo.o   include/   lib/    src/
</code></pre><p>现在你可以使用 <code>-L</code> 选项为你的库设置一个路径，然后进行编译：</p><pre tabindex=0><code>$ gcc -L`pwd`/lib -o myDemo demo.o -lexample
</code></pre><p>注意，<code>-L</code> 选项在 <code>-l</code> 选项<em>之前</em>。这很重要，因为如果在你告诉 GCC 查找非默认库之前没有将 <code>-L</code> 添加到 GCC 的搜索路径中，GCC 就不知道要在你的自定义位置上搜索。编译成功了，但当你试图运行它时，却出现了问题：</p><pre tabindex=0><code>$ ./myDemo
./myDemo: error while loading shared libraries:
libexample.so: cannot open shared object file:
No such file or directory
</code></pre><h3 id=用-ldd-排除故障>用 ldd 排除故障</h3><p><code>ldd</code> 工具可以打印出共享对象的依赖关系，它在排除类似问题时很有用：</p><pre tabindex=0><code>$ ldd ./myDemo
        linux-vdso.so.1 (0x00007ffe151df000)
        libexample.so =&gt; not found
        libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f514b60a000)
        /lib64/ld-linux-x86-64.so.2 (0x00007f514b839000)
</code></pre><p>你已经知道定位不到 <code>libexample</code>，但 <code>ldd</code> 输出至少确认了它对<em>工作</em>库的期望位置。例如，<code>libc.so.6</code>已经被定位，<code>ldd</code> 显示其完整路径。</p><h3 id=ld_library_path>LD_LIBRARY_PATH</h3><p><code>LD_LIBRARY_PATH</code> <a href=https://opensource.com/article/19/8/what-are-environment-variables>环境变量</a> 定义了库的路径。如果你正在运行一个依赖于没有安装到标准目录的库的应用程，你可以使用 <code>LD_LIBRARY_PATH</code> 添加到系统的库搜索路径。</p><p>有几种设置环境变量的方法，但最灵活的是在运行命令前放置环境变量。看看设置 <code>LD_LIBRARY_PATH</code> 对 <code>ldd</code> 命令在分析一个“损坏”的可执行文件时的作用：</p><pre tabindex=0><code>$ LD_LIBRARY_PATH=`pwd`/lib ldd ./
   linux-vdso.so.1 (0x00007ffe515bb000)
   libexample.so =&gt; /tmp/Demo/lib/libexample.so (0x0000...
   libc.so.6 =&gt; /lib64/libc.so.6 (0x00007eff037ee000)
   /lib64/ld-linux-x86-64.so.2 (0x00007eff03a22000)
</code></pre><p>这也同样适用于你的自定义命令：</p><pre tabindex=0><code>$ LD_LIBRARY_PATH=`pwd`/lib myDemo
hello world!
</code></pre><p>然而，如果你移动库文件或可执行文件，它又会失效：</p><pre tabindex=0><code>$ mv lib/libexample.so ~/.local/lib64
$ LD_LIBRARY_PATH=`pwd`/lib myDemo
./myDemo: error while loading shared libraries...
</code></pre><p>要修复它，你必须调整 <code>LD_LIBRARY_PATH</code> 以匹配库的新位置：</p><pre tabindex=0><code>$ LD_LIBRARY_PATH=~/.local/lib64 myDemo
hello world!
</code></pre><h3 id=何时使用-ld_library_path>何时使用 LD_LIBRARY_PATH</h3><p>在大多数情况下，<code>LD_LIBRARY_PATH</code> 不是你需要设置的变量。按照设计，库安装到 <code>/usr/lib64</code> 中，因此应用自然会在其中搜索所需的库。在两种情况下，你可能需要使用 <code>LD_LIBRARY_PATH</code>：</p><ul><li>你正在编译的软件需要链接到本身刚刚编译但尚未安装的库。良好设计的构建系统，例如 <a href=https://opensource.com/article/19/7/introduction-gnu-autotools>Autotools</a> 和 <a href=https://opensource.com/article/21/5/cmake>CMake</a>，可以帮助处理这个问题。</li><li>你正在使用设计为在单个目录之外运行的软件，它没有安装脚本，或安装脚本将库放置在非标准目录中。一些应用具有 Linux 用户可以下载、复制到 <code>/opt</code> 并在“不安装”的情况下运行的版本。<code>LD_PATH_LIBRARY</code> 变量是通过封装脚本设置的，因此用户通常甚至不知道它已被设置。</li></ul><p>编译软件为你在运行系统方面提供了很大的灵活性。<code>LD_LIBRARY_PATH</code> 变量以及 <code>-L</code> 和 <code>-l</code> GCC 选项是这种灵活性的组成部分。</p><hr><p>via: <a href=https://opensource.com/article/22/5/compile-code-ldlibrarypath>https://opensource.com/article/22/5/compile-code-ldlibrarypath</a></p><p>作者：<a href=https://opensource.com/users/seth>Seth Kenlon</a> 选题：<a href=https://github.com/lkxed>lkxed</a> 译者：<a href=https://github.com/geekpi>geekpi</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/%E5%8A%A8%E6%80%81%E5%BA%93/ rel=tag>动态库</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E7%BC%96%E8%AF%91/ rel=tag>编译</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>