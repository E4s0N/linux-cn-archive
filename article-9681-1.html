<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>更深入的理解 Python 中的迭代 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="更深入的理解 Python 中的迭代"><meta property="og:description" content="在这篇文章中，我们将深入探讨 Python 的 for 循环来看看它们在底层如何工作，以及为什么它们会按照它们的方式工作。"><meta property="og:type" content="article"><meta property="og:url" content="/article-9681-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-05-26T08:04:00+00:00"><meta property="article:modified_time" content="2018-05-26T08:04:00+00:00"><meta itemprop=name content="更深入的理解 Python 中的迭代"><meta itemprop=description content="在这篇文章中，我们将深入探讨 Python 的 for 循环来看看它们在底层如何工作，以及为什么它们会按照它们的方式工作。"><meta itemprop=datePublished content="2018-05-26T08:04:00+00:00"><meta itemprop=dateModified content="2018-05-26T08:04:00+00:00"><meta itemprop=wordCount content="1403"><meta itemprop=keywords content="Python,循环,迭代,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>更深入的理解 Python 中的迭代</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2018-05-26T08:04:00Z>May 26, 2018</time></div></div></header><div class="content post__content clearfix"><blockquote><p>深入探讨 Python 的 <code>for</code> 循环来看看它们在底层如何工作，以及为什么它们会按照它们的方式工作。</p></blockquote><p><img src=/data/attachment/album/201805/26/080352ai3a6qticbnnbb8o.jpg alt></p><p>Python 的 <code>for</code> 循环不会像其他语言中的 <code>for</code> 循环那样工作。在这篇文章中，我们将深入探讨 Python 的 <code>for</code> 循环来看看它们在底层如何工作，以及为什么它们会按照它们的方式工作。</p><h3 id=循环的问题>循环的问题</h3><p>我们将通过看一些“陷阱”开始我们的旅程，在我们了解循环如何在 Python 中工作之后，我们将再次看看这些问题并解释发生了什么。</p><h4 id=问题-1循环两次>问题 1：循环两次</h4><p>假设我们有一个数字列表和一个生成器，生成器会返回这些数字的平方：</p><pre tabindex=0><code>&gt;&gt;&gt; numbers = [1, 2, 3, 5, 7]
&gt;&gt;&gt; squares = (n**2 for n in numbers)
</code></pre><p>我们可以将生成器对象传递给 <code>tuple</code> 构造器，从而使其变为一个元组：</p><pre tabindex=0><code>&gt;&gt;&gt; tuple(squares)
(1, 4, 9, 25, 49)
</code></pre><p>如果我们使用相同的生成器对象并将其传给 <code>sum</code> 函数，我们可能会期望得到这些数的和，即 <code>88</code>。</p><pre tabindex=0><code>&gt;&gt;&gt; sum(squares)
0
</code></pre><p>但是我们得到了 <code>0</code>。</p><h4 id=问题-2包含的检查>问题 2：包含的检查</h4><p>让我们使用相同的数字列表和相同的生成器对象：</p><pre tabindex=0><code>&gt;&gt;&gt; numbers = [1, 2, 3, 5, 7]

&gt;&gt;&gt; squares = (n**2 for n in numbers)
</code></pre><p>如果我们询问 <code>9</code> 是否在 <code>squares</code> 生成器中，Python 将会告诉我们 9 在 <code>squares</code> 中。但是如果我们再次询问相同的问题，Python 会告诉我们 9 不在 <code>squares</code> 中。</p><pre tabindex=0><code>&gt;&gt;&gt; 9 in squares
True
&gt;&gt;&gt; 9 in squares
False
</code></pre><p>我们询问相同的问题两次，Python 给了两个不同的答案。</p><h4 id=问题-3-拆包>问题 3 ：拆包</h4><p>这个字典有两个键值对：</p><pre tabindex=0><code>&gt;&gt;&gt; counts = {&#39;apples&#39;: 2, &#39;oranges&#39;: 1}
</code></pre><p>让我们使用多个变量来对这个字典进行拆包：</p><pre tabindex=0><code>&gt;&gt;&gt; x, y = counts
</code></pre><p>你可能会期望当我们对这个字典进行拆包时，我们会得到键值对或者得到一个错误。</p><p>但是解包字典不会引发错误，也不会返回键值对。当你解包一个字典时，你会得到键：</p><pre tabindex=0><code>&gt;&gt;&gt; x
&#39;apples&#39;
</code></pre><h3 id=回顾python-的-for-循环>回顾：Python 的 for 循环</h3><p>在我们了解一些关于这些 Python 片段的逻辑之后，我们将回到这些问题。</p><p>Python 没有传统的 <code>for</code> 循环。为了解释我的意思，让我们看一看另一种编程语言的 <code>for</code> 循环。</p><p>这是一种传统 C 风格的 <code>for</code> 循环，用 JavaScript 编写：</p><pre tabindex=0><code>let numbers = [1, 2, 3, 5, 7];
for (let i = 0; i &lt; numbers.length; i += 1) {
    print(numbers[i])
}
</code></pre><p>JavaScript、 C、 C++、 Java、 PHP 和一大堆其他编程语言都有这种风格的 <code>for</code> 循环，但是 Python <strong>确实没有</strong>。</p><p>Python <strong>确实没有</strong> 传统 C 风格的 <code>for</code> 循环。在 Python 中确实有一些我们称之为 <code>for</code> 循环的东西，但是它的工作方式类似于 <a href=https://en.wikipedia.org/wiki/Foreach_loop>foreach 循环</a>。</p><p>这是 Python 的 <code>for</code> 循环的风格：</p><pre tabindex=0><code>numbers = [1, 2, 3, 5, 7]
for n in numbers:
    print(n)
</code></pre><p>与传统 C 风格的 <code>for</code> 循环不同，Python 的 <code>for</code> 循环没有索引变量，没有索引变量初始化，边界检查，或者索引递增。Python 的 <code>for</code> 循环完成了对我们的 <code>numbers</code> 列表进行遍历的所有工作。</p><p>因此，当我们在 Python 中确实有 <code>for</code> 循环时，我们没有传统 C 风格的 <code>for</code> 循环。我们称之为 for 循环的东西的工作机制与之相比有很大的不同。</p><h3 id=定义可迭代和序列>定义：可迭代和序列</h3><p>既然我们已经解决了 Python 世界中无索引的 <code>for</code> 循环，那么让我们在此之外来看一些定义。</p><p><strong>可迭代</strong>是任何你可以用 Python 中的 <code>for</code> 循环遍历的东西。可迭代意味着可以遍历，任何可以遍历的东西都是可迭代的。</p><pre tabindex=0><code>for item in some_iterable:
    print(item)
</code></pre><p>序列是一种非常常见的可迭代类型，列表，元组和字符串都是序列。</p><pre tabindex=0><code>&gt;&gt;&gt; numbers = [1, 2, 3, 5, 7]
&gt;&gt;&gt; coordinates = (4, 5, 7)
&gt;&gt;&gt; words = &#34;hello there&#34;
</code></pre><p>序列是可迭代的，它有一些特定的特征集。它们可以从 <code>0</code> 开始索引，以小于序列的长度结束，它们有一个长度并且它们可以被切分。列表，元组，字符串和其他所有序列都是这样工作的。</p><pre tabindex=0><code>&gt;&gt;&gt; numbers[0]
1
&gt;&gt;&gt; coordinates[2]
7
&gt;&gt;&gt; words[4]
&#39;o&#39;
</code></pre><p>Python 中很多东西都是可迭代的，但不是所有可迭代的东西都是序列。集合、字典、文件和生成器都是可迭代的，但是它们都不是序列。</p><pre tabindex=0><code>&gt;&gt;&gt; my_set = {1, 2, 3}
&gt;&gt;&gt; my_dict = {&#39;k1&#39;: &#39;v1&#39;, &#39;k2&#39;: &#39;v2&#39;}
&gt;&gt;&gt; my_file = open(&#39;some_file.txt&#39;)
&gt;&gt;&gt; squares = (n**2 for n in my_set)
</code></pre><p>因此，任何可以用 <code>for</code> 循环遍历的东西都是可迭代的，序列只是一种可迭代的类型，但是 Python 也有许多其他种类的迭代器。</p><h3 id=python-的-for-循环不使用索引>Python 的 for 循环不使用索引</h3><p>你可能认为，Python 的 <code>for</code> 循环在底层使用了索引进行循环。在这里我们使用 <code>while</code> 循环和索引手动遍历：</p><pre tabindex=0><code>numbers = [1, 2, 3, 5, 7]
i = 0
while i &lt; len(numbers):
    print(numbers[i])
    i += 1
</code></pre><p>这适用于列表，但它不会对所有东西都起作用。这种循环方式<strong>只适用于序列</strong>。</p><p>如果我们尝试用索引去手动遍历一个集合，我们会得到一个错误：</p><pre tabindex=0><code>&gt;&gt;&gt; fruits = {&#39;lemon&#39;, &#39;apple&#39;, &#39;orange&#39;, &#39;watermelon&#39;}
&gt;&gt;&gt; i = 0
&gt;&gt;&gt; while i &lt; len(fruits):
...     print(fruits[i])
...     i += 1
...
Traceback (most recent call last):
File &#34;&lt;stdin&gt;&#34;, line 2, in &lt;module&gt;
TypeError: &#39;set&#39; object does not support indexing
</code></pre><p>集合不是序列，所以它们不支持索引。</p><p>我们不能使用索引手动对 Python 中的每一个迭代对象进行遍历。对于那些不是序列的迭代器来说，这是行不通的。</p><h3 id=迭代器驱动-for-循环>迭代器驱动 for 循环</h3><p>因此，我们已经看到，Python 的 <code>for</code> 循环在底层不使用索引。相反，Python 的 <code>for</code> 循环使用<strong>迭代器</strong>。</p><p>迭代器就是可以驱动可迭代对象的东西。你可以从任何可迭代对象中获得迭代器，你也可以使用迭代器来手动对它的迭代进行遍历。</p><p>让我们来看看它是如何工作的。</p><p>这里有三个可迭代对象：一个集合，一个元组和一个字符串。</p><pre tabindex=0><code>&gt;&gt;&gt; numbers = {1, 2, 3, 5, 7}
&gt;&gt;&gt; coordinates = (4, 5, 7)
&gt;&gt;&gt; words = &#34;hello there&#34;
</code></pre><p>我们可以使用 Python 的内置 <code>iter</code> 函数来访问这些迭代器，将一个迭代器传递给 <code>iter</code> 函数总会给我们返回一个迭代器，无论我们正在使用哪种类型的迭代器。</p><pre tabindex=0><code>&gt;&gt;&gt; iter(numbers)
&lt;set_iterator object at 0x7f2b9271c860&gt;
&gt;&gt;&gt; iter(coordinates)
&lt;tuple_iterator object at 0x7f2b9271ce80&gt;
&gt;&gt;&gt; iter(words)
&lt;str_iterator object at 0x7f2b9271c860&gt;
</code></pre><p>一旦我们有了迭代器，我们可以做的事情就是通过将它传递给内置的 <code>next</code> 函数来获取它的下一项。</p><pre tabindex=0><code>&gt;&gt;&gt; numbers = [1, 2, 3]
&gt;&gt;&gt; my_iterator = iter(numbers)
&gt;&gt;&gt; next(my_iterator)
1
&gt;&gt;&gt; next(my_iterator)
2
</code></pre><p>迭代器是有状态的，这意味着一旦你从它们中消耗了一项，它就消失了。</p><p>如果你从迭代器中请求 <code>next</code> 项，但是其中没有更多的项了，你将得到一个 <code>StopIteration</code> 异常：</p><pre tabindex=0><code>&gt;&gt;&gt; next(my_iterator)
3
&gt;&gt;&gt; next(my_iterator)
Traceback (most recent call last):
  File &#34;&lt;stdin&gt;&#34;, line 1, in &lt;module&gt;
StopIteration
</code></pre><p>所以你可以从每个迭代中获得一个迭代器，迭代器唯一能做的事情就是用 <code>next</code> 函数请求它们的下一项。如果你将它们传递给 <code>next</code>，但它们没有下一项了，那么就会引发 <code>StopIteration</code> 异常。</p><p>你可以将迭代器想象成 Pez 分配器（LCTT 译注：Pez 是一个结合玩具的独特复合式糖果），不能重新分配。你可以把 Pez 拿出去，但是一旦 Pez 被移走，它就不能被放回去，一旦分配器空了，它就没用了。</p><h3 id=没有-for-的循环>没有 for 的循环</h3><p>既然我们已经了解了迭代器和 <code>iter</code> 以及 <code>next</code> 函数，我们将尝试在不使用 <code>for</code> 循环的情况下手动遍历迭代器。</p><p>我们将通过尝试将这个 <code>for</code> 循环变为 <code>while</code> 循环：</p><pre tabindex=0><code>def funky_for_loop(iterable, action_to_do):
    for item in iterable:
        action_to_do(item)
</code></pre><p>为了做到这点，我们需要：</p><ol><li>从给定的可迭代对象中获得迭代器</li><li>反复从迭代器中获得下一项</li><li>如果我们成功获得下一项，就执行 <code>for</code> 循环的主体</li><li>如果我们在获得下一项时得到了一个 <code>StopIteration</code> 异常，那么就停止循环</li></ol><pre tabindex=0><code>def funky_for_loop(iterable, action_to_do):
    iterator = iter(iterable)
    done_looping = False
    while not done_looping:
        try:
            item = next(iterator)
        except StopIteration:
            done_looping = True
        else:
            action_to_do(item)
</code></pre><p>我们只是通过使用 <code>while</code> 循环和迭代器重新定义了 <code>for</code> 循环。</p><p>上面的代码基本上定义了 Python 在底层循环的工作方式。如果你理解内置的 <code>iter</code> 和 <code>next</code> 函数的遍历循环的工作方式，那么你就会理解 Python 的 <code>for</code> 循环是如何工作的。</p><p>事实上，你不仅仅会理解 <code>for</code> 循环在 Python 中是如何工作的，所有形式的遍历一个可迭代对象都是这样工作的。</p><p>迭代器协议 iterator protocol 是一种很好表示 “在 Python 中遍历迭代器是如何工作的”的方式。它本质上是对 <code>iter</code> 和 <code>next</code> 函数在 Python 中是如何工作的定义。Python 中所有形式的迭代都是由迭代器协议驱动的。</p><p>迭代器协议被 <code>for</code> 循环使用（正如我们已经看到的那样）：</p><pre tabindex=0><code>for n in numbers:
    print(n)
</code></pre><p>多重赋值也使用迭代器协议：</p><pre tabindex=0><code>x, y, z = coordinates
</code></pre><p>星型表达式也是用迭代器协议：</p><pre tabindex=0><code>a, b, *rest = numbers
print(*numbers)
</code></pre><p>许多内置函数依赖于迭代器协议：</p><pre tabindex=0><code>unique_numbers = set(numbers)
</code></pre><p>在 Python 中任何与迭代器一起工作的东西都可能以某种方式使用迭代器协议。每当你在 Python 中遍历一个可迭代对象时，你将依赖于迭代器协议。</p><h3 id=生成器是迭代器>生成器是迭代器</h3><p>所以你可能会想：迭代器看起来很酷，但它们看起来像一个实现细节，我们作为 Python 的使用者，可能不需要关心它们。</p><p>我有消息告诉你：在 Python 中直接使用迭代器是很常见的。</p><p>这里的 <code>squares</code> 对象是一个生成器：</p><pre tabindex=0><code>&gt;&gt;&gt; numbers = [1, 2, 3]
&gt;&gt;&gt; squares = (n**2 for n in numbers)
</code></pre><p>生成器是迭代器，这意味着你可以在生成器上调用 <code>next</code> 来获得它的下一项：</p><pre tabindex=0><code>&gt;&gt;&gt; next(squares)
1
&gt;&gt;&gt; next(squares)
4
</code></pre><p>但是如果你以前用过生成器，你可能也知道可以循环遍历生成器：</p><pre tabindex=0><code>&gt;&gt;&gt; squares = (n**2 for n in numbers)
&gt;&gt;&gt; for n in squares:
...     print(n)
...
1
4
9
</code></pre><p>如果你可以在 Python 中循环遍历某些东西，那么它就是<strong>可迭代的</strong>。</p><p>所以<strong>生成器是迭代器</strong>，但是生成器也是可迭代的，这又是怎么回事呢？</p><h3 id=我欺骗了你>我欺骗了你</h3><p>所以在我之前解释迭代器如何工作时，我跳过了它们的某些重要的细节。</p><h4 id=生成器是可迭代的>生成器是可迭代的</h4><p>我再说一遍：Python 中的每一个迭代器都是可迭代的，意味着你可以循环遍历迭代器。</p><p>因为迭代器也是可迭代的，所以你可以使用内置 <code>next</code> 函数从可迭代对象中获得迭代器：</p><pre tabindex=0><code>&gt;&gt;&gt; numbers = [1, 2, 3]
&gt;&gt;&gt; iterator1 = iter(numbers)
&gt;&gt;&gt; iterator2 = iter(iterator1)
</code></pre><p>请记住，当我们在可迭代对象上调用 <code>iter</code> 时，它会给我们返回一个迭代器。</p><p>当我们在迭代器上调用 <code>iter</code> 时，它会给我们返回它自己：</p><pre tabindex=0><code>&gt;&gt;&gt; iterator1 is iterator2
True
</code></pre><p>迭代器是可迭代的，所有的迭代器都是它们自己的迭代器。</p><pre tabindex=0><code>def is_iterator(iterable):
    return iter(iterable) is iterable
</code></pre><p>迷惑了吗？</p><p>让我们回顾一些这些措辞。</p><ul><li>一个<strong>可迭代对象</strong>是你可以迭代的东西</li><li>一个<strong>迭代对象器</strong>是一种实际上遍历可迭代对象的代理</li></ul><p>此外，在 Python 中迭代器也是可迭代的，它们充当它们自己的迭代器。</p><p>所以迭代器是可迭代的，但是它们没有一些可迭代对象拥有的各种特性。</p><p>迭代器没有长度，它们不能被索引：</p><pre tabindex=0><code>&gt;&gt;&gt; numbers = [1, 2, 3, 5, 7]
&gt;&gt;&gt; iterator = iter(numbers)
&gt;&gt;&gt; len(iterator)
TypeError: object of type &#39;list_iterator&#39; has no len()
&gt;&gt;&gt; iterator[0]
TypeError: &#39;list_iterator&#39; object is not subscriptable
</code></pre><p>从我们作为 Python 程序员的角度来看，你可以使用迭代器来做的唯一有用的事情是将其传递给内置的 <code>next</code> 函数，或者对其进行循环遍历：</p><pre tabindex=0><code>&gt;&gt;&gt; next(iterator)
1
&gt;&gt;&gt; list(iterator)
[2, 3, 5, 7]
</code></pre><p>如果我们第二次循环遍历迭代器，我们将一无所获：</p><pre tabindex=0><code>&gt;&gt;&gt; list(iterator)
[]
</code></pre><p>你可以把迭代器看作是<strong>惰性迭代器</strong>，它们是<strong>一次性使用</strong>，这意味着它们只能循环遍历一次。</p><p>正如你在下面的真值表中所看到的，可迭代对象并不总是迭代器，但是迭代器总是可迭代的：</p><table><thead><tr><th>对象</th><th>可迭代？</th><th>迭代器？</th></tr></thead><tbody><tr><td>可迭代对象</td><td>V</td><td>?</td></tr><tr><td>迭代器</td><td>V</td><td>V</td></tr><tr><td>生成器</td><td>V</td><td>V</td></tr><tr><td>列表</td><td>V</td><td>X</td></tr></tbody></table><h3 id=全部的迭代器协议>全部的迭代器协议</h3><p>让我们从 Python 的角度来定义迭代器是如何工作的。</p><p>可迭代对象可以被传递给 <code>iter</code> 函数，以便为它们获得迭代器。</p><p>迭代器：</p><ul><li>可以传递给 <code>next</code> 函数，它将给出下一项，如果没有下一项，那么它将会引发 <code>StopIteration</code> 异常</li><li>可以传递给 <code>iter</code> 函数，它会返回一个自身的迭代器</li></ul><p>这些语句反过来也是正确的：</p><ul><li>任何可以在不引发 <code>TypeError</code> 异常的情况下传递给 <code>iter</code> 的东西都是可迭代的</li><li>任何可以在不引发 <code>TypeError</code> 异常的情况下传递给 <code>next</code> 的东西都是一个迭代器</li><li>当传递给 <code>iter</code> 时，任何返回自身的东西都是一个迭代器</li></ul><p>这就是 Python 中的迭代器协议。</p><h4 id=迭代器的惰性>迭代器的惰性</h4><p>迭代器允许我们一起工作，创建<strong>惰性可迭代对象</strong>，即在我们要求它们提供下一项之前，它们不做任何事情。因为可以创建惰性迭代器，所以我们可以创建无限长的迭代器。我们可以创建对系统资源比较保守的迭代器，可以节省我们的内存，节省 CPU 时间。</p><h3 id=迭代器无处不在>迭代器无处不在</h3><p>你已经在 Python 中看到过许多迭代器，我也提到过生成器是迭代器。Python 的许多内置类型也是迭代器。例如，Python 的 <code>enumerate</code> 和 <code>reversed</code> 对象就是迭代器。</p><pre tabindex=0><code>&gt;&gt;&gt; letters = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
&gt;&gt;&gt; e = enumerate(letters)
&gt;&gt;&gt; e
&lt;enumerate object at 0x7f112b0e6510&gt;
&gt;&gt;&gt; next(e)
(0, &#39;a&#39;)
</code></pre><p>在 Python 3 中，<code>zip</code>, <code>map</code> 和 <code>filter</code> 也是迭代器。</p><pre tabindex=0><code>&gt;&gt;&gt; numbers = [1, 2, 3, 5, 7]
&gt;&gt;&gt; letters = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
&gt;&gt;&gt; z = zip(numbers, letters)
&gt;&gt;&gt; z
&lt;zip object at 0x7f112cc6ce48&gt;
&gt;&gt;&gt; next(z)
(1, &#39;a&#39;)
</code></pre><p>Python 中的文件对象也是迭代器。</p><pre tabindex=0><code>&gt;&gt;&gt; next(open(&#39;hello.txt&#39;))
&#39;hello world\n&#39;
</code></pre><p>在 Python 标准库和第三方库中内置了大量的迭代器。这些迭代器首先惰性迭代器一样，延迟工作直到你请求它们下一项。</p><h3 id=创建你自己的迭代器>创建你自己的迭代器</h3><p>知道你已经在使用迭代器是很有用的，但是我希望你也知道，你可以创建自己的迭代器和你自己的惰性迭代器。</p><p>下面这个类构造了一个迭代器接受一个可迭代的数字，并在循环结束时提供每个数字的平方。</p><pre tabindex=0><code>class square_all:
    def __init__(self, numbers):
        self.numbers = iter(numbers)
    def __next__(self):
        return next(self.numbers) * 2
    def __iter__(self):
        return self
</code></pre><p>但是在我们开始对该类的实例进行循环遍历之前，没有任何工作要做。</p><p>这里，我们有一个无限长的可迭代对象 <code>count</code>，你可以看到 <code>square_all</code> 接受 <code>count</code> 而不用完全循环遍历这个无限长的迭代：</p><pre tabindex=0><code>&gt;&gt;&gt; from itertools import count
&gt;&gt;&gt; numbers = count(5)
&gt;&gt;&gt; squares = square_all(numbers)
&gt;&gt;&gt; next(squares)
25
&gt;&gt;&gt; next(squares)
36
</code></pre><p>这个迭代器类是有效的，但我们通常不会这样做。通常，当我们想要做一个定制的迭代器时，我们会生成一个生成器函数：</p><pre tabindex=0><code>def square_all(numbers):
    for n in numbers:
        yield n**2
</code></pre><p>这个生成器函数等价于我们上面所做的类，它的工作原理是一样的。</p><p>这种 <code>yield</code> 语句似乎很神奇，但它非常强大：<code>yield</code> 允许我们在调用 <code>next</code> 函数之间暂停生成器函数。<code>yield</code> 语句是将生成器函数与常规函数分离的东西。</p><p>另一种实现相同迭代器的方法是使用生成器表达式。</p><pre tabindex=0><code>def square_all(numbers):
    return (n**2 for n in numbers)
</code></pre><p>这和我们的生成器函数确实是一样的，但是它使用的语法看起来<a href=http://treyhunner.com/2015/12/python-list-comprehensions-now-in-color/>像是一个列表推导一样</a>。如果你需要在代码中使用惰性迭代，请考虑迭代器，并考虑使用生成器函数或生成器表达式。</p><h3 id=迭代器如何改进你的代码>迭代器如何改进你的代码</h3><p>一旦你已经接受了在代码中使用惰性迭代器的想法，你就会发现有很多可能来发现或创建辅助函数，以此来帮助你循环遍历和处理数据。</p><h4 id=惰性求和>惰性求和</h4><p>这是一个 <code>for</code> 循环，它对 Django queryset 中的所有工作时间求和：</p><pre tabindex=0><code>hours_worked = 0
for event in events:
    if event.is_billable():
        hours_worked += event.duration
</code></pre><p>下面是使用生成器表达式进行惰性评估的代码：</p><pre tabindex=0><code>billable_times = (
    event.duration
    for event in events
    if event.is_billable()
)

hours_worked = sum(billable_times)
</code></pre><p>请注意，我们代码的形状发生了巨大变化。</p><p>将我们的计算工作时间变成一个惰性迭代器允许我们能够命名以前未命名（<code>billable_times</code>）的东西。这也允许我们使用 <code>sum</code> 函数，我们以前不能使用 <code>sum</code> 函数是因为我们甚至没有一个可迭代对象传递给它。迭代器允许你从根本上改变你组织代码的方式。</p><h4 id=惰性和打破循环>惰性和打破循环</h4><p>这段代码打印出日志文件的前 10 行：</p><pre tabindex=0><code>for i, line in enumerate(log_file):
    if i &gt;= 10:
        break
    print(line)
</code></pre><p>这段代码做了同样的事情，但是我们使用的是 <code>itertools.islice</code> 函数来惰性地抓取文件中的前 10 行：</p><pre tabindex=0><code>from itertools import islice
first_ten_lines = islice(log_file, 10)
for line in first_ten_lines:
    print(line)
</code></pre><p>我们定义的 <code>first_ten_lines</code> 变量是迭代器，同样，使用迭代器允许我们给以前未命名的东西命名(<code>first_ten_lines</code>)。命名事物可以使我们的代码更具描述性，更具可读性。</p><p>作为奖励，我们还消除了在循环中使用 <code>break</code> 语句的需要，因为 <code>islice</code> 实用函数为我们处理了中断。</p><p>你可以在标准库中的 <a href=https://docs.python.org/3/library/itertools.html>itertools</a> 中找到更多的迭代辅助函数，以及诸如 <a href=https://boltons.readthedocs.io>boltons</a> 和 <a href=https://more-itertools.readthedocs.io>more-itertools</a> 之类的第三方库。</p><h4 id=创建自己的迭代辅助函数>创建自己的迭代辅助函数</h4><p>你可以在标准库和第三方库中找到用于循环的辅助函数，但你也可以自己创建！</p><p>这段代码列出了序列中连续值之间的差值列表。</p><pre tabindex=0><code>current = readings[0]
for next_item in readings[1:]:
    differences.append(next_item - current)
    current = next_item
</code></pre><p>请注意，这段代码中有一个额外的变量，我们每次循环时都要指定它。还要注意，这段代码只适用于我们可以切片的东西，比如序列。如果 <code>readings</code> 是一个生成器，一个 zip 对象或其他任何类型的迭代器，那么这段代码就会失败。</p><p>让我们编写一个辅助函数来修复代码。</p><p>这是一个生成器函数，它为给定的迭代中的每个项目提供了当前项和下一项：</p><pre tabindex=0><code>def with_next(iterable):
    &#34;&#34;&#34;Yield (current, next_item) tuples for each item in iterable.&#34;&#34;&#34;
    iterator = iter(iterable)
    current = next(iterator)
    for next_item in iterator:
        yield current, next_item
        current = next_item
</code></pre><p>我们从可迭代对象中手动获取一个迭代器，在它上面调用 <code>next</code> 来获取第一项，然后循环遍历迭代器获取后续所有的项目，跟踪后一个项目。这个函数不仅适用于序列，而且适用于任何类型迭代。</p><p>这段代码和以前代码是一样的，但是我们使用的是辅助函数而不是手动跟踪 <code>next_item</code>：</p><pre tabindex=0><code>differences = []
for current, next_item in with_next(readings):
    differences.append(next_item - current)
</code></pre><p>请注意，这段代码不会挂在我们循环周围的 <code>next_item</code> 上，<code>with_next</code> 生成器函数处理跟踪 <code>next_item</code> 的工作。</p><p>还要注意，这段代码已足够紧凑，如果我们愿意，我们甚至可以<a href=http://treyhunner.com/2015/12/python-list-comprehensions-now-in-color/>将方法复制到列表推导中来</a>。</p><pre tabindex=0><code>differences = [
    (next_item - current)
    for current, next_item in with_next(readings)
]
</code></pre><h3 id=再次回顾循环问题>再次回顾循环问题</h3><p>现在我们准备回到之前看到的那些奇怪的例子并试着找出到底发生了什么。</p><h4 id=问题-1耗尽的迭代器>问题 1：耗尽的迭代器</h4><p>这里我们有一个生成器对象 <code>squares</code>：</p><pre tabindex=0><code>&gt;&gt;&gt; numbers = [1, 2, 3, 5, 7]
&gt;&gt;&gt; squares = (n**2 for n in numbers)
</code></pre><p>如果我们把这个生成器传递给 <code>tuple</code> 构造函数，我们将会得到它的一个元组：</p><pre tabindex=0><code>&gt;&gt;&gt; numbers = [1, 2, 3, 5, 7]
&gt;&gt;&gt; squares = (n**2 for n in numbers)
&gt;&gt;&gt; tuple(squares)
(1, 4, 9, 25, 49)
</code></pre><p>如果我们试着计算这个生成器中数字的和，使用 <code>sum</code>,我们就会得到 <code>0</code>：</p><pre tabindex=0><code>&gt;&gt;&gt; sum(squares)
0
</code></pre><p>这个生成器现在是空的：我们已经把它耗尽了。如果我们试着再次创建一个元组，我们会得到一个空元组：</p><pre tabindex=0><code>&gt;&gt;&gt; tuple(squares)
()
</code></pre><p>生成器是迭代器，迭代器是一次性的。它们就像 Hello Kitty Pez 分配器那样不能重新加载。</p><h4 id=问题-2部分消耗一个迭代器>问题 2：部分消耗一个迭代器</h4><p>再次使用那个生成器对象 <code>squares</code>：</p><pre tabindex=0><code>&gt;&gt;&gt; numbers = [1, 2, 3, 5, 7]
&gt;&gt;&gt; squares = (n**2 for n in numbers)
</code></pre><p>如果我们询问 <code>9</code> 是否在 <code>squares</code> 生成器中，我们会得到 <code>True</code>：</p><pre tabindex=0><code>&gt;&gt;&gt; 9 in squares
True
</code></pre><p>但是我们再次询问相同的问题，我们会得到 <code>False</code>：</p><pre tabindex=0><code>&gt;&gt;&gt; 9 in squares
False
</code></pre><p>当我们询问 <code>9</code> 是否在迭代器中时，Python 必须对这个生成器进行循环遍历来找到 <code>9</code>。如果我们在检查了 <code>9</code> 之后继续循环遍历，我们只会得到最后两个数字，因为我们已经在找到 9 之前消耗了这些数字：</p><pre tabindex=0><code>&gt;&gt;&gt; numbers = [1, 2, 3, 5, 7]
&gt;&gt;&gt; squares = (n**2 for n in numbers)
&gt;&gt;&gt; 9 in squares
True
&gt;&gt;&gt; list(squares)
[25, 49]
</code></pre><p>询问迭代器中是否包含某些东西将会部分地消耗迭代器。如果没有循环遍历迭代器，那么是没有办法知道某个东西是否在迭代器中。</p><h4 id=问题-3拆包是迭代>问题 3：拆包是迭代</h4><p>当你在字典上循环时，你会得到键：</p><pre tabindex=0><code>&gt;&gt;&gt; counts = {&#39;apples&#39;: 2, &#39;oranges&#39;: 1}
&gt;&gt;&gt; for key in counts:
...     print(key)
...
apples
oranges
</code></pre><p>当你对一个字典进行拆包时，你也会得到键：</p><pre tabindex=0><code>&gt;&gt;&gt; x, y = counts
&gt;&gt;&gt; x, y
(&#39;apples&#39;, &#39;oranges&#39;)
</code></pre><p>循环依赖于迭代器协议，可迭代对象拆包也依赖于有迭代器协议。拆包一个字典与在字典上循环遍历是一样的，两者都使用迭代器协议，所以在这两种情况下都得到相同的结果。</p><h3 id=回顾>回顾</h3><p>序列是迭代器，但是不是所有的迭代器都是序列。当有人说“迭代器”这个词时，你只能假设他们的意思是“你可以迭代的东西”。不要假设迭代器可以被循环遍历两次、询问它们的长度或者索引。</p><p>迭代器是 Python 中最基本的可迭代形式。如果你想在代码中做一个惰性迭代，请考虑迭代器，并考虑使用生成器函数或生成器表达式。</p><p>最后，请记住，Python 中的每一种迭代都依赖于迭代器协议，因此理解迭代器协议是理解 Python 中的循环的关键。</p><p>这里有一些我推荐的相关文章和视频：</p><ul><li><a href=https://nedbatchelder.com/text/iter.html>Loop Like a Native</a>， Ned Batchelder 在 PyCon 2013 的讲演</li><li><a href="https://www.youtube.com/watch?v=V2PkkMS2Ack">Loop Better</a> ，这篇文章是基于这个讲演的</li><li><a href=http://treyhunner.com/2016/12/python-iterator-protocol-how-for-loops-work/>The Iterator Protocol: How For Loops Work</a>，我写的关于迭代器协议的短文</li><li><a href="https://www.youtube.com/watch?v=5_cJIcgM7rw">Comprehensible Comprehensions</a>，关于推导和迭代器表达器的讲演</li><li><a href=http://treyhunner.com/2018/02/python-range-is-not-an-iterator/>Python: Range is Not an Iterator</a>，我关于范围和迭代器的文章</li><li><a href="https://www.youtube.com/watch?v=u8g9scXeAcI">Looping Like a Pro in Python</a>，DB 的 PyCon 2017 讲演</li></ul><p>本文是基于作者去年在 <a href="https://www.youtube.com/watch?v=JYuE8ZiDPl4">DjangoCon AU</a>、 <a href="https://www.youtube.com/watch?v=Wd7vcuiMhxU">PyGotham</a> 和 <a href="https://www.youtube.com/watch?v=V2PkkMS2Ack">North Bay Python</a> 中发表的 Loop Better 演讲。有关更多内容，请参加将于 2018 年 5 月 9 日至 17 日在 Columbus， Ohio 举办的 <a href=https://us.pycon.org/2018/>PYCON</a>。</p><hr><p>via: <a href=https://opensource.com/article/18/3/loop-better-deeper-look-iteration-python>https://opensource.com/article/18/3/loop-better-deeper-look-iteration-python</a></p><p>作者：<a href=https://opensource.com/users/treyhunner>Trey Hunner</a> 译者：<a href=https://github.com/MjSeven>MjSeven</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/python/ rel=tag>Python</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E5%BE%AA%E7%8E%AF/ rel=tag>循环</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E8%BF%AD%E4%BB%A3/ rel=tag>迭代</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>