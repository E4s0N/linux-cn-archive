<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Linux中命令链接操作符的十个最佳实例 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="Linux中命令链接操作符的十个最佳实例"><meta property="og:description" content="Linux命令中的链接的意思是，通过操作符的行为将几个命令组合执行。Linux中的链接命令，有些像你在shell中写短小的shell脚本，并直接在终端中执行。链接使得自动处理变得更方便。不仅如此，一个无人看管的机器在链接 &mldr;"><meta property="og:type" content="article"><meta property="og:url" content="/article-2469-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2014-01-13T09:39:00+00:00"><meta property="article:modified_time" content="2014-01-13T09:39:00+00:00"><meta itemprop=name content="Linux中命令链接操作符的十个最佳实例"><meta itemprop=description content="Linux命令中的链接的意思是，通过操作符的行为将几个命令组合执行。Linux中的链接命令，有些像你在shell中写短小的shell脚本，并直接在终端中执行。链接使得自动处理变得更方便。不仅如此，一个无人看管的机器在链接 &mldr;"><meta itemprop=datePublished content="2014-01-13T09:39:00+00:00"><meta itemprop=dateModified content="2014-01-13T09:39:00+00:00"><meta itemprop=wordCount content="302"><meta itemprop=keywords content="Linux,命令,链接,操作符,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>Linux中命令链接操作符的十个最佳实例</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-01-13T09:39:00Z>January 13, 2014</time></div></div></header><div class="content post__content clearfix"><p>Linux命令中的链接的意思是，通过操作符的行为将几个命令组合执行。Linux中的链接命令，有些像你在shell中写<a href=http://www.tecmint.com/category/bash-shell/>短小的shell脚本</a>，并直接在终端中执行。链接使得自动处理变得更方便。不仅如此，一个无人看管的机器在链接操作符的帮助下能够十分有条理地运行。</p><p><img src=/data/attachment/album/201401/11/213307jav4rv119l3kjhb9.png alt></p><p><em>Linux中的10个链接操作符</em></p><p>本文旨在介绍一些常用的<strong>链接操作符</strong>，通过简短的描述和相关的例子帮助读者提高生产力、降低系统负载、写出更加简短有意义的代码。</p><h3 id=1-和号操作符->1. 和号操作符 (&)</h3><p>‘<strong>&</strong>’的作用是使命令在后台运行。只要在命令后面跟上一个空格和 ‘<strong>&</strong>’。你可以一口气在后台运行多个命令。</p><p>在后台运行一个命令:</p><pre tabindex=0><code>tecmint@localhost:~$ ping ­c5 www.tecmint.com &amp;
</code></pre><p>同时在后台运行两个命令：</p><pre tabindex=0><code>root@localhost:/home/tecmint# apt-get update &amp; mkdit test &amp;
</code></pre><h3 id=2-分号操作符->2. 分号操作符 (;)</h3><p>分号操作符使你可以一口气运行几个命令，命令顺序执行。</p><pre tabindex=0><code>root@localhost:/home/tecmint# apt-get update ; apt-get upgrade ; mkdir test
</code></pre><p>上述命令先后执行了update和upgrade，最后在当前工作目录下创建了一个‘<strong>test</strong>’文件夹</p><h3 id=3-与操作符->3. 与操作符 (&&)</h3><p>如果第一个命令执行成功，<strong>与操作符 (&&)<strong>才会执行第二个命令，也就是说，第一个命令退出状态是</strong>0</strong>。（译注：原文的这里明显写错了，我们进行了改译，有兴趣的读者可以参看原文以及原文下面的评论。在UNIX里面，0表示无错误，而所有非0返回值都是各种错误）。这个命令在检查最后一个命令的执行状态时很有用。</p><p>比如，我想使用**<a href=http://www.tecmint.com/command-line-web-browsers/>links 命令</a><strong>在终端中访问网站</strong>tecmint.com**，但在这之前我需要检查主机是否<strong>在线</strong>或<strong>不在线</strong>。</p><pre tabindex=0><code>root@localhost:/home/tecmint# ping -c3 www.tecmint.com &amp;&amp; links www.tecmint.com
</code></pre><h3 id=4-或操作符->4. 或操作符 (||)</h3><p><strong>或操作符 (||)<strong>很像编程中的</strong>else</strong>语句。上面的操作符允许你在第一个命令失败的情况下执行第二个命令，比如，第一个命令的退出状态是<strong>1</strong>。</p><p>举例来说，我想要在非root帐户中执行‘<strong>apt-get update</strong>‘，如果第一个命令失败了，接着会执行第二个命令‘<strong>links <a href=http://www.tecmint.com>www.tecmint.com</a></strong>‘。</p><pre tabindex=0><code>tecmint@localhost:~$ apt-get update || links tecmint.com
</code></pre><p>上面的命令中，由于该<strong>用户</strong>不允许<strong>更新</strong>系统，这意味着第一个命令的退出状态是’<strong>1</strong>′,因此最后一个命令‘<strong>links tecmint.com</strong>‘会执行。</p><p>如果第一个命令成功执行并且退出状态是‘<strong>0</strong>‘呢？很明显的，第二个命令不会执行。</p><pre tabindex=0><code>tecmint@localhost:~$ mkdir test || links tecmint.com
</code></pre><p>这里，用户在家目录创建了一个‘<strong>test</strong>‘文件夹，这是被允许的。命令成功的执行，退出状态是‘<strong>0</strong>‘,因此，最后的命令不会执行。</p><h3 id=5-非操作符->5. 非操作符 (!)</h3><p><strong>非操作符 (!)<strong>很像</strong>except</strong>语句。这个命令会执行除了提供的条件外的所有的语句。要理解这点，在你的主目录创建一个目录‘<strong>tecmint</strong>’，并‘<strong>cd</strong>’到它这里。</p><pre tabindex=0><code>tecmint@localhost:~$ mkdir tecmint 
tecmint@localhost:~$ cd tecmint
</code></pre><p>接下来，在文件夹‘<strong>tecmint</strong>’下创建不同类型的文件。</p><pre tabindex=0><code>tecmint@localhost:~/tecmint$ touch a.doc b.doc a.pdf b.pdf a.xml b.xml a.html b.html
</code></pre><p>看一下我们在文件夹‘<strong>tecmint</strong>’创建的新文件。</p><pre tabindex=0><code>tecmint@localhost:~/tecmint$ ls 

a.doc  a.html  a.pdf  a.xml  b.doc  b.html  b.pdf  b.xml
</code></pre><p>用一种聪明的办法马上删除除了 ‘<strong>html</strong>’之外的所有文件。</p><pre tabindex=0><code>tecmint@localhost:~/tecmint$ rm -r !(*.html)
</code></pre><p>验证一下上次的执行结果，使用<a href=http://www.tecmint.com/15-basic-ls-command-examples-in-linux/>ls 命令</a>列出可见所有文件。</p><pre tabindex=0><code>tecmint@localhost:~/tecmint$ ls 

a.html  b.html
</code></pre><h3 id=6-与或操作符--->6. 与或操作符 (&& – ||)</h3><p>上面的操作符实际上是‘<strong>与</strong>’和‘<strong>或</strong>’操作符的组合。它很像‘<strong>if-else</strong>‘语句。</p><p>比如，我们ping <strong>tecmint.com</strong>，如果成功打印‘<strong>已验证</strong>’，否则打印‘<strong>主机故障</strong>’。</p><pre tabindex=0><code>tecmint@localhost:~/tecmint$ ping -c3 www.tecmint.com &amp;&amp; echo &#34;Verified&#34; || echo &#34;Host Down&#34;
</code></pre><h4 id=示例输出>示例输出</h4><pre tabindex=0><code>PING www.tecmint.com (212.71.234.61) 56(84) bytes of data. 
64 bytes from www.tecmint.com (212.71.234.61): icmp_req=1 ttl=55 time=216 ms 
64 bytes from www.tecmint.com (212.71.234.61): icmp_req=2 ttl=55 time=224 ms 
64 bytes from www.tecmint.com (212.71.234.61): icmp_req=3 ttl=55 time=226 ms 

--- www.tecmint.com ping statistics --- 
3 packets transmitted, 3 received, 0% packet loss, time 2001ms 
rtt min/avg/max/mdev = 216.960/222.789/226.423/4.199 ms 
Verified
</code></pre><p>现在，断开我们现在的网络连接诶，再试一下相同的命令。</p><pre tabindex=0><code>tecmint@localhost:~/tecmint$ ping -c3 www.tecmint.com &amp;&amp; echo &#34;verified&#34; || echo &#34;Host Down&#34;
</code></pre><h4 id=实例输出>实例输出</h4><pre tabindex=0><code>ping: unknown host www.tecmint.com 
Host Down
</code></pre><h3 id=7-管道操作符->7. 管道操作符 (|)</h3><p><strong>PIPE</strong>在将第一个命令的输出作为第二个命令的输入时很有用。比如，‘<strong>ls -l</strong>’的输出通过管道到‘<strong>less</strong>’，并看一下输出。</p><pre tabindex=0><code>tecmint@localhost:~$ ls -l | less
</code></pre><h3 id=8-命令合并操作符>8. 命令合并操作符</h3><p>合并两个或多个命令，第二个命令依赖于第一个命令的执行。</p><p>比如，检查一下文件‘<strong>xyz.txt</strong>’是否在<strong>Downloads</strong>目录下，如果不存在则创建之并输出提示信息。</p><pre tabindex=0><code>tecmint@localhost:~$ [ -f /home/tecmint/Downloads/xyz.txt ] || touch /home/tecmint/Downloads/xyz.txt; echo &#34;The file does not exist&#34;
</code></pre><p>但是这样的命令的运行结果并不如我们预期的运行，会始终都输出提示信息。因此需要使用{}操作符来合并命令：</p><pre tabindex=0><code>tecmint@localhost:~$ [ -f /home/tecmint/Downloads/xyz1.txt ] || {touch /home/tecmint/Downloads/xyz.txt; echo &#34;The file does not exist&#34;}

“The file does not exist”
</code></pre><p>（译注：原文这里应该也是复制或书写的时候，出现了一些问题，例子中并没有出现小标题中的"{}&ldquo;操作符，所以这里我们进行了修改）</p><h3 id=9-优先操作符->9. 优先操作符 ()</h3><p>这个操作符可以让命令以优先顺序执行。</p><pre tabindex=0><code>Command_x1 &amp;&amp;Command_x2 || Command_x3 &amp;&amp; Command_x4.
</code></pre><p>在上面的伪代码中，如果<strong>Command_x1</strong>执行失败了会怎么样，<strong>Command_x2</strong>, <strong>Command_x3</strong>, <strong>Command_x4</strong>没有一个会执行，对于这种情况，我们使用<strong>优先操作符</strong>。</p><pre tabindex=0><code>(Command_x1 &amp;&amp;Command_x2) || (Command_x3 &amp;&amp; Command_x4)
</code></pre><p>在上面的伪代码中，如果<strong>Command_x1</strong>执行失败，<strong>Command_x2</strong>不会执行，但是<strong>Command_x3</strong>会继续执行， <strong>Command_x4</strong>会依赖于 <strong>Command_x3</strong>的退出状态。</p><h3 id=10-连接符->10. 连接符 ()</h3><p><strong>连接符 ()<strong>如它名字所说，被用于连接shell中那些太长而需要分成多行的命令。可以在输入一个“\”之后就回车，然后继续输入命令行，直到输入完成。比如，下面的命令会打开文本文件</strong>test(1).txt</strong>。</p><pre tabindex=0><code>tecmint@localhost:~/Downloads$ nano test\
1.txt
</code></pre><p>今天就到这里，我会近日开始另外一个有趣的文章。不要走开，继续关注<strong>我们</strong>。不要忘记在评论栏里提出有价值的反馈。</p><hr><p>via: <a href=http://www.tecmint.com/chaining-operators-in-linux-with-practical-examples/>http://www.tecmint.com/chaining-operators-in-linux-with-practical-examples/</a></p><p>译者：<a href=https://github.com/geekpi>geekpi</a> 校对：<a href=http://blog.csdn.net/tinyeyeser>Mr小眼儿</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创翻译，<a href=http://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/linux/ rel=tag>Linux</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E5%91%BD%E4%BB%A4/ rel=tag>命令</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E9%93%BE%E6%8E%A5/ rel=tag>链接</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E6%93%8D%E4%BD%9C%E7%AC%A6/ rel=tag>操作符</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>