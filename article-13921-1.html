<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>使用 Rust 进行嵌入式开发 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="使用 Rust 进行嵌入式开发"><meta property="og:description" content="Rust 的高性能、高可靠性和高生产力使它适合于嵌入式系统。"><meta property="og:type" content="article"><meta property="og:url" content="/article-13921-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-10-26T10:38:56+00:00"><meta property="article:modified_time" content="2021-10-26T10:38:56+00:00"><meta itemprop=name content="使用 Rust 进行嵌入式开发"><meta itemprop=description content="Rust 的高性能、高可靠性和高生产力使它适合于嵌入式系统。"><meta itemprop=datePublished content="2021-10-26T10:38:56+00:00"><meta itemprop=dateModified content="2021-10-26T10:38:56+00:00"><meta itemprop=wordCount content="598"><meta itemprop=keywords content="Rust,嵌入式,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>使用 Rust 进行嵌入式开发</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2021-10-26T10:38:56Z>October 26, 2021</time></div></div></header><div class="content post__content clearfix"><blockquote><p>Rust 的高性能、高可靠性和高生产力使它适合于嵌入式系统。</p></blockquote><p><img src=https://img.linux.net.cn/data/attachment/album/202110/26/103848djcdhjk0d2z1hc52.jpg alt title="Ferris the crab under the sea, unofficial logo for Rust programming language"></p><p>在过去的几年里，Rust 在程序员中获得了热情的追捧。技术潮流来来去去，所以很难将仅仅因为某项新技术而产生的兴奋与对某项技术的优点的兴奋区分开来，但我认为 Rust 是一种真正设计良好的语言。它的目标是帮助开发者建立可靠和高效的软件，而且它从一开始就是为这个目的设计的。你可能听过一些 Rust 的关键特性，在这篇文章中，我会证明这些特性正是 Rust 也恰好适合嵌入式系统的原因。比如：</p><ul><li>高性能：它速度快，内存利用率高</li><li>可靠性：在编译过程中可以消除内存错误</li><li>生产力：很棒的文档，友好的编译器，有用的错误信息，以及一流的工具化。它有一个集成的包管理器和构建工具，智能的多编辑器支持自动补完和类型检查、自动格式化等等。</li></ul><h3 id=为什么使用-rust-进行嵌入式开发>为什么使用 Rust 进行嵌入式开发？</h3><p>Rust 的设计是为了保证安全和高性能。嵌入式软件会出现的问题主要是内存的问题。从某种程度上说，Rust 是一种面向编译器的语言，所以你可以确保在编译时安全使用内存。以下是使用 Rust 在嵌入式设备上开发的一些好处：</p><ul><li>强大的静态分析</li><li>灵活的内存</li><li>无畏的并发性</li><li>互操作性</li><li>可移植性</li><li>社区驱动</li></ul><p>在这篇文章中，我使用开源的 <a href=https://github.com/RT-Thread/rt-thread>RT-Thread 操作系统</a> 来演示如何使用 Rust 进行嵌入式开发。</p><h3 id=如何在-c-语言中调用-rust>如何在 C 语言中调用 Rust</h3><p>在 C 代码中调用 Rust 代码时，你必须将 Rust 源代码打包成静态库文件。当 C 代码编译时，将其链接进去。</p><h4 id=用-rust-创建一个静态库>用 Rust 创建一个静态库</h4><p>在这个过程中，有两个步骤：</p><p>1、使用 <code>cargo init --lib rust_to_c</code> 在 Clion 中建立一个 <code>lib</code> 库。在 <code>lib.rs</code> 中加入以下代码。下面的函数计算两个类型为 <code>i32</code> 的值的总和并返回结果：</p><pre tabindex=0><code>#![no_std]
use core::panic::PanicInfo;

#[no_mangle]
pub extern &#34;C&#34; fn sum(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[panic_handler]
fn panic(_info:&amp;PanicInfo) -&gt; !{
    loop{}
}
</code></pre><p>2、在你的 <code>Cargo.toml</code> 文件中添加以下代码，以告诉 Rustc 要生成什么类型的库：</p><pre tabindex=0><code>[lib]
name = &#34;sum&#34;
crate-type = [&#34;staticlib&#34;]
path = &#34;src/lib.rs&#34;
</code></pre><h4 id=交叉编译>交叉编译</h4><p>你可以针对你的目标平台进行交叉编译。假设你的嵌入式系统是基于 Arm 的，步骤很简单：</p><pre tabindex=0><code>$ rustup target add armv7a-none-eabi
</code></pre><p>生成静态库文件：</p><pre tabindex=0><code>$ cargo build --target=armv7a-none-eabi --release --verbose
Fresh rust_to_c v0.1.0
Finished release [optimized] target(s) in 0.01s
</code></pre><h4 id=生成头文件>生成头文件</h4><p>你也需要头文件：</p><p>1、安装 <a href=https://github.com/eqrion/cbindgen>cbindgen</a>。<code>cbindgen</code> 工具会从 Rust 库中生成一个 C 或 C++11 的头文件：</p><pre tabindex=0><code>$ cargo install --force cbindgen
</code></pre><p>2、在你的项目文件夹下创建一个新的 <code>cbindgen.toml</code> 文件。</p><p>3、生成一个头文件：</p><pre tabindex=0><code>$ cbindgen --config cbindgen.toml --crate rust_to_c --output sum.h
</code></pre><h4 id=调用-rust-库文件>调用 Rust 库文件</h4><p>现在你可以对你的 Rust 库进行调用了。</p><p>1、把生成的 <code>sum.h</code> 和 <code>sum.a</code> 文件放到 <code>rt-thread/bsp/qemu-vexpress-a9/applications</code> 目录下。</p><p>2、修改 <code>SConscript</code> 文件并添加一个静态库：</p><pre tabindex=0><code>   from building import *
   
   cwd     = GetCurrentDir()
   src     = Glob(&#39;*.c&#39;) + Glob(&#39;*.cpp&#39;)
   CPPPATH = [cwd]
   
   LIBS = [&#34;libsum.a&#34;]
   LIBPATH = [GetCurrentDir()]
   
   group = DefineGroup(&#39;Applications&#39;, src, depend = [&#39;&#39;], CPPPATH = CPPPATH, LIBS = LIBS, LIBPATH = LIBPATH)
   
   Return(&#39;group&#39;)
</code></pre><p>3、在主函数中调用 <code>sum</code> 函数，得到返回值，并 <code>printf</code> 该值：</p><pre tabindex=0><code>   #include &lt;stdint.h&gt;
   #include &lt;stdio.h&gt;
   #include &lt;stdlib.h&gt;
   #include &lt;rtthread.h&gt;
   #include &#34;sum.h&#34;
   
   int main(void)
   {
       int32_t tmp;
   
       tmp = sum(1, 2);
       printf(&#34;call rust sum(1, 2) = %d\n&#34;, tmp);
   
       return 0;
   }
</code></pre><p>4、在 RT-Thread <a href="https://www.rt-thread.io/download.html?download=Env">Env</a> 环境中，使用 <code>scons</code> 来编译项目并运行：</p><pre tabindex=0><code>$ scons -j6
scons: Reading SConscript files ...
scons: done reading SConscript files.
scons: Building targets ...
[...]
scons: done building targets.

$ qemu.sh
 \ | /
- RT -     Thread Operating System
 / | \     4.0.4 build Jul 28 2021
2006 - 2021 Copyright by rt-thread team
lwIP-2.1.2 initialized!
[...]
call rust sum(1, 2) = 3
</code></pre><h3 id=加减乘除>加、减、乘、除</h3><p>你可以在 Rust 中实现一些复杂的数学运算。在 <code>lib.rs</code> 文件中，使用 Rust 语言来实现加、减、乘、除：</p><pre tabindex=0><code>#![no_std]
use core::panic::PanicInfo;

#[no_mangle]
pub extern &#34;C&#34; fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[no_mangle]
pub extern &#34;C&#34; fn subtract(a: i32, b: i32) -&gt; i32 {
    a - b
}

#[no_mangle]
pub extern &#34;C&#34; fn multiply(a: i32, b: i32) -&gt; i32 {
    a * b
}

#[no_mangle]
pub extern &#34;C&#34; fn divide(a: i32, b: i32) -&gt; i32 {
    a / b
}

#[panic_handler]
fn panic(_info:&amp;PanicInfo) -&gt; !{
    loop{}
}
</code></pre><p>构建你的库文件和头文件，并把它们放在应用程序目录中。使用 <code>scons</code> 来编译。如果在链接过程中出现错误，请在官方 <a href=https://github.com/rust-lang/compiler-builtins/issues/353>Github 页面</a> 中找到解决方案。</p><p>修改 <code>rtconfig.py</code> 文件，并添加链接参数 <code>--allow-multiple-definition</code>：</p><pre tabindex=0><code>       DEVICE = &#39; -march=armv7-a -marm -msoft-float&#39;
       CFLAGS = DEVICE + &#39; -Wall&#39;
       AFLAGS = &#39; -c&#39; + DEVICE + &#39; -x assembler-with-cpp -D__ASSEMBLY__ -I.&#39;
       LINK_SCRIPT = &#39;link.lds&#39;
       LFLAGS = DEVICE + &#39; -nostartfiles -Wl,--gc-sections,-Map=rtthread.map,-cref,-u,system_vectors,--allow-multiple-definition&#39;+\
                         &#39; -T %s&#39; % LINK_SCRIPT
   
       CPATH = &#39;&#39;
       LPATH = &#39;&#39;
</code></pre><p>编译并运行 QEMU 来看看你的工作。</p><h3 id=在-rust-中调用-c-语言>在 Rust 中调用 C 语言</h3><p>Rust 可以在 C 代码中调用，但是如何在你的 Rust 代码中调用 C 呢？下面是一个在 Rust 代码中调用 <code>rt_kprintf</code> C 函数的例子。</p><p>首先，修改 <code>lib.rs</code> 文件：</p><pre tabindex=0><code>    // The imported rt-thread functions list
    extern &#34;C&#34; {
        pub fn rt_kprintf(format: *const u8, ...);
    }
   
    #[no_mangle]
    pub extern &#34;C&#34; fn add(a: i32, b: i32) -&gt; i32 {
        unsafe {
            rt_kprintf(b&#34;this is from rust\n&#34; as *const u8);
        }
        a + b
    }
</code></pre><p>接下来，生成库文件：</p><pre tabindex=0><code>$ cargo build --target=armv7a-none-eabi --release --verbose
Compiling rust_to_c v0.1.0
Running `rustc --crate-name sum --edition=2018 src/lib.rs --error-format=json --json=diagnostic-rendered-ansi --crate-type staticlib --emit=dep-info,link -C opt-level=3 -C embed-bitcode=no -C metadata=a
Finished release [optimized] target(s) in 0.11s
</code></pre><p>而现在，要运行代码，将 Rust 生成的库文件复制到应用程序目录中，然后重新构建：</p><pre tabindex=0><code>$ scons -j6 scons: Reading SConscript files ... scons: done reading SConscript files. [...]
scons: Building targets ... scons: done building targets.
</code></pre><p>再次运行 QEMU，可以在你的嵌入式镜像中看到结果。</p><h3 id=你可以拥有这一切>你可以拥有这一切</h3><p>在你的嵌入式开发中使用 Rust，你可以获得 Rust 的所有功能，而不需要牺牲灵活性或稳定性。今天就在你的嵌入式系统上试试 Rust 吧。关于嵌入式 Rust 的过程（以及 RT-Thread 本身）的更多信息，请查看 RT-Thread 项目的 <a href=https://www.youtube.com/channel/UCdDHtIfSYPq4002r27ffqP>YouTube 频道</a>。请记住，嵌入式也可以是开放的。</p><hr><p>via: <a href=https://opensource.com/article/21/10/rust-embedded-development>https://opensource.com/article/21/10/rust-embedded-development</a></p><p>作者：<a href=https://opensource.com/users/alansmithee>Alan Smithee</a> 选题：<a href=https://github.com/lujun9972>lujun9972</a> 译者：<a href=https://github.com/wxy>wxy</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/rust/ rel=tag>Rust</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/ rel=tag>嵌入式</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>