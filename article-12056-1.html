<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>构建一个即时消息应用（三）：对话 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="构建一个即时消息应用（三）：对话"><meta property="og:description" content="在我们的即时消息应用中，消息表现为两个参与者对话的堆叠。"><meta property="og:type" content="article"><meta property="og:url" content="/article-12056-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-03-30T19:40:01+00:00"><meta property="article:modified_time" content="2020-03-30T19:40:01+00:00"><meta itemprop=name content="构建一个即时消息应用（三）：对话"><meta itemprop=description content="在我们的即时消息应用中，消息表现为两个参与者对话的堆叠。"><meta itemprop=datePublished content="2020-03-30T19:40:01+00:00"><meta itemprop=dateModified content="2020-03-30T19:40:01+00:00"><meta itemprop=wordCount content="832"><meta itemprop=keywords content="即时消息,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>构建一个即时消息应用（三）：对话</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2020-03-30T19:40:01Z>March 30, 2020</time></div></div></header><div class="content post__content clearfix"><p><img src=/data/attachment/album/202003/30/193824w7xsj2ixs8frsal8.jpg alt></p><p>本文是该系列的第三篇。</p><ul><li><a href=/article-11396-1.html>第一篇：模式</a></li><li><a href=/article-11510-1.html>第二篇：OAuth</a></li></ul><p>在我们的即时消息应用中，消息表现为两个参与者对话的堆叠。如果你想要开始一场对话，就应该向应用提供你想要交谈的用户，而当对话创建后（如果该对话此前并不存在），就可以向该对话发送消息。</p><p>就前端而言，我们可能想要显示一份近期对话列表。并在此处显示对话的最后一条消息以及另一个参与者的姓名和头像。</p><p>在这篇帖子中，我们将会编写一些 端点 endpoint 来完成像“创建对话”、“获取对话列表”以及“找到单个对话”这样的任务。</p><p>首先，要在主函数 <code>main()</code> 中添加下面的路由。</p><pre tabindex=0><code>router.HandleFunc(&#34;POST&#34;, &#34;/api/conversations&#34;, requireJSON(guard(createConversation)))
router.HandleFunc(&#34;GET&#34;, &#34;/api/conversations&#34;, guard(getConversations))
router.HandleFunc(&#34;GET&#34;, &#34;/api/conversations/:conversationID&#34;, guard(getConversation))
</code></pre><p>这三个端点都需要进行身份验证，所以我们将会使用 <code>guard()</code> 中间件。我们也会构建一个新的中间件，用于检查请求内容是否为 JSON 格式。</p><h3 id=json-请求检查中间件>JSON 请求检查中间件</h3><pre tabindex=0><code>func requireJSON(handler http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        if ct := r.Header.Get(&#34;Content-Type&#34;); !strings.HasPrefix(ct, &#34;application/json&#34;) {
            http.Error(w, &#34;Content type of application/json required&#34;, http.StatusUnsupportedMediaType)
            return
        }
        handler(w, r)
    }
}
</code></pre><p>如果 请求 request 不是 JSON 格式，那么它会返回 <code>415 Unsupported Media Type</code>（不支持的媒体类型）错误。</p><h3 id=创建对话>创建对话</h3><pre tabindex=0><code>type Conversation struct {
    ID                string   `json:&#34;id&#34;`
    OtherParticipant  *User    `json:&#34;otherParticipant&#34;`
    LastMessage       *Message `json:&#34;lastMessage&#34;`
    HasUnreadMessages bool     `json:&#34;hasUnreadMessages&#34;`
}
</code></pre><p>就像上面的代码那样，对话中保持对另一个参与者和最后一条消息的引用，还有一个 <code>bool</code> 类型的字段，用来告知是否有未读消息。</p><pre tabindex=0><code>type Message struct {
    ID             string    `json:&#34;id&#34;`
    Content        string    `json:&#34;content&#34;`
    UserID         string    `json:&#34;-&#34;`
    ConversationID string    `json:&#34;conversationID,omitempty&#34;`
    CreatedAt      time.Time `json:&#34;createdAt&#34;`
    Mine           bool      `json:&#34;mine&#34;`
    ReceiverID     string    `json:&#34;-&#34;`
}
</code></pre><p>我们会在下一篇文章介绍与消息相关的内容，但由于我们这里也需要用到它，所以先定义了 <code>Message</code> 结构体。其中大多数字段与数据库表一致。我们需要使用 <code>Mine</code> 来断定消息是否属于当前已验证用户所有。一旦加入实时功能，<code>ReceiverID</code> 可以帮助我们过滤消息。</p><p>接下来让我们编写 HTTP 处理程序。尽管它有些长，但也没什么好怕的。</p><pre tabindex=0><code>func createConversation(w http.ResponseWriter, r *http.Request) {
    var input struct {
        Username string `json:&#34;username&#34;`
    }
    defer r.Body.Close()
    if err := json.NewDecoder(r.Body).Decode(&amp;input); err != nil {
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }

    input.Username = strings.TrimSpace(input.Username)
    if input.Username == &#34;&#34; {
        respond(w, Errors{map[string]string{
            &#34;username&#34;: &#34;Username required&#34;,
        }}, http.StatusUnprocessableEntity)
        return
    }

    ctx := r.Context()
    authUserID := ctx.Value(keyAuthUserID).(string)

    tx, err := db.BeginTx(ctx, nil)
    if err != nil {
        respondError(w, fmt.Errorf(&#34;could not begin tx: %v&#34;, err))
        return
    }
    defer tx.Rollback()

    var otherParticipant User
    if err := tx.QueryRowContext(ctx, `
        SELECT id, avatar_url FROM users WHERE username = $1
    `, input.Username).Scan(
        &amp;otherParticipant.ID,
        &amp;otherParticipant.AvatarURL,
    ); err == sql.ErrNoRows {
        http.Error(w, &#34;User not found&#34;, http.StatusNotFound)
        return
    } else if err != nil {
        respondError(w, fmt.Errorf(&#34;could not query other participant: %v&#34;, err))
        return
    }

    otherParticipant.Username = input.Username

    if otherParticipant.ID == authUserID {
        http.Error(w, &#34;Try start a conversation with someone else&#34;, http.StatusForbidden)
        return
    }

    var conversationID string
    if err := tx.QueryRowContext(ctx, `
        SELECT conversation_id FROM participants WHERE user_id = $1
        INTERSECT
        SELECT conversation_id FROM participants WHERE user_id = $2
    `, authUserID, otherParticipant.ID).Scan(&amp;conversationID); err != nil &amp;&amp; err != sql.ErrNoRows {
        respondError(w, fmt.Errorf(&#34;could not query common conversation id: %v&#34;, err))
        return
    } else if err == nil {
        http.Redirect(w, r, &#34;/api/conversations/&#34;+conversationID, http.StatusFound)
        return
    }

    var conversation Conversation
    if err = tx.QueryRowContext(ctx, `
        INSERT INTO conversations DEFAULT VALUES
        RETURNING id
    `).Scan(&amp;conversation.ID); err != nil {
        respondError(w, fmt.Errorf(&#34;could not insert conversation: %v&#34;, err))
        return
    }

    if _, err = tx.ExecContext(ctx, `
        INSERT INTO participants (user_id, conversation_id) VALUES
            ($1, $2),
            ($3, $2)
    `, authUserID, conversation.ID, otherParticipant.ID); err != nil {
        respondError(w, fmt.Errorf(&#34;could not insert participants: %v&#34;, err))
        return
    }

    if err = tx.Commit(); err != nil {
        respondError(w, fmt.Errorf(&#34;could not commit tx to create conversation: %v&#34;, err))
        return
    }

    conversation.OtherParticipant = &amp;otherParticipant

    respond(w, conversation, http.StatusCreated)
}
</code></pre><p>在此端点，你会向 <code>/api/conversations</code> 发送 POST 请求，请求的 JSON 主体中包含要对话的用户的用户名。</p><p>因此，首先需要将请求主体解析成包含用户名的结构。然后，校验用户名不能为空。</p><pre tabindex=0><code>type Errors struct {
    Errors map[string]string `json:&#34;errors&#34;`
}
</code></pre><p>这是错误消息的结构体 <code>Errors</code>，它仅仅是一个映射。如果输入空用户名，你就会得到一段带有 <code>422 Unprocessable Entity</code>（无法处理的实体）错误消息的 JSON 。</p><pre tabindex=0><code>{
    &#34;errors&#34;: {
        &#34;username&#34;: &#34;Username required&#34;
    }
}
</code></pre><p>然后，我们开始执行 SQL 事务。收到的仅仅是用户名，但事实上，我们需要知道实际的用户 ID 。因此，事务的第一项内容是查询另一个参与者的 ID 和头像。如果找不到该用户，我们将会返回 <code>404 Not Found</code>（未找到） 错误。另外，如果找到的用户恰好和“当前已验证用户”相同，我们应该返回 <code>403 Forbidden</code>（拒绝处理）错误。这是由于对话只应当在两个不同的用户之间发起，而不能是同一个。</p><p>然后，我们试图找到这两个用户所共有的对话，所以需要使用 <code>INTERSECT</code> 语句。如果存在，只需要通过 <code>/api/conversations/{conversationID}</code> 重定向到该对话并将其返回。</p><p>如果未找到共有的对话，我们需要创建一个新的对话并添加指定的两个参与者。最后，我们 <code>COMMIT</code> 该事务并使用新创建的对话进行响应。</p><h3 id=获取对话列表>获取对话列表</h3><p>端点 <code>/api/conversations</code> 将获取当前已验证用户的所有对话。</p><pre tabindex=0><code>func getConversations(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    authUserID := ctx.Value(keyAuthUserID).(string)

    rows, err := db.QueryContext(ctx, `
        SELECT
            conversations.id,
            auth_user.messages_read_at &lt; messages.created_at AS has_unread_messages,
            messages.id,
            messages.content,
            messages.created_at,
            messages.user_id = $1 AS mine,
            other_users.id,
            other_users.username,
            other_users.avatar_url
        FROM conversations
        INNER JOIN messages ON conversations.last_message_id = messages.id
        INNER JOIN participants other_participants
            ON other_participants.conversation_id = conversations.id
                AND other_participants.user_id != $1
        INNER JOIN users other_users ON other_participants.user_id = other_users.id
        INNER JOIN participants auth_user
            ON auth_user.conversation_id = conversations.id
                AND auth_user.user_id = $1
        ORDER BY messages.created_at DESC
    `, authUserID)
    if err != nil {
        respondError(w, fmt.Errorf(&#34;could not query conversations: %v&#34;, err))
        return
    }
    defer rows.Close()

    conversations := make([]Conversation, 0)
    for rows.Next() {
        var conversation Conversation
        var lastMessage Message
        var otherParticipant User
        if err = rows.Scan(
            &amp;conversation.ID,
            &amp;conversation.HasUnreadMessages,
            &amp;lastMessage.ID,
            &amp;lastMessage.Content,
            &amp;lastMessage.CreatedAt,
            &amp;lastMessage.Mine,
            &amp;otherParticipant.ID,
            &amp;otherParticipant.Username,
            &amp;otherParticipant.AvatarURL,
        ); err != nil {
            respondError(w, fmt.Errorf(&#34;could not scan conversation: %v&#34;, err))
            return
        }

        conversation.LastMessage = &amp;lastMessage
        conversation.OtherParticipant = &amp;otherParticipant
        conversations = append(conversations, conversation)
    }

    if err = rows.Err(); err != nil {
        respondError(w, fmt.Errorf(&#34;could not iterate over conversations: %v&#34;, err))
        return
    }

    respond(w, conversations, http.StatusOK)
}
</code></pre><p>该处理程序仅对数据库进行查询。它通过一些联接来查询对话表……首先，从消息表中获取最后一条消息。然后依据“ID 与当前已验证用户不同”的条件，从参与者表找到对话的另一个参与者。然后联接到用户表以获取该用户的用户名和头像。最后，再次联接参与者表，并以相反的条件从该表中找出参与对话的另一个用户，其实就是当前已验证用户。我们会对比消息中的 <code>messages_read_at</code> 和 <code>created_at</code> 两个字段，以确定对话中是否存在未读消息。然后，我们通过 <code>user_id</code> 字段来判定该消息是否属于“我”（指当前已验证用户）。</p><p>注意，此查询过程假定对话中只有两个用户参与，它也仅仅适用于这种情况。另外,该设计也不很适用于需要显示未读消息数量的情况。如果需要显示未读消息的数量，我认为可以在 <code>participants</code> 表上添加一个<code>unread_messages_count</code> <code>INT</code> 字段，并在每次创建新消息的时候递增它，如果用户已读则重置该字段。</p><p>接下来需要遍历每一条记录，通过扫描每一个存在的对话来建立一个 对话切片 slice of conversations 并在最后进行响应。</p><h3 id=找到单个对话>找到单个对话</h3><p>端点 <code>/api/conversations/{conversationID}</code> 会根据 ID 对单个对话进行响应。</p><pre tabindex=0><code>func getConversation(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    authUserID := ctx.Value(keyAuthUserID).(string)
    conversationID := way.Param(ctx, &#34;conversationID&#34;)

    var conversation Conversation
    var otherParticipant User
    if err := db.QueryRowContext(ctx, `
        SELECT
            IFNULL(auth_user.messages_read_at &lt; messages.created_at, false) AS has_unread_messages,
            other_users.id,
            other_users.username,
            other_users.avatar_url
        FROM conversations
        LEFT JOIN messages ON conversations.last_message_id = messages.id
        INNER JOIN participants other_participants
            ON other_participants.conversation_id = conversations.id
                AND other_participants.user_id != $1
        INNER JOIN users other_users ON other_participants.user_id = other_users.id
        INNER JOIN participants auth_user
            ON auth_user.conversation_id = conversations.id
                AND auth_user.user_id = $1
        WHERE conversations.id = $2
    `, authUserID, conversationID).Scan(
        &amp;conversation.HasUnreadMessages,
        &amp;otherParticipant.ID,
        &amp;otherParticipant.Username,
        &amp;otherParticipant.AvatarURL,
    ); err == sql.ErrNoRows {
        http.Error(w, &#34;Conversation not found&#34;, http.StatusNotFound)
        return
    } else if err != nil {
        respondError(w, fmt.Errorf(&#34;could not query conversation: %v&#34;, err))
        return
    }

    conversation.ID = conversationID
    conversation.OtherParticipant = &amp;otherParticipant

    respond(w, conversation, http.StatusOK)
}
</code></pre><p>这里的查询与之前有点类似。尽管我们并不关心最后一条消息的显示问题，并因此忽略了与之相关的一些字段，但是我们需要根据这条消息来判断对话中是否存在未读消息。此时，我们使用 <code>LEFT JOIN</code> 来代替 <code>INNER JOIN</code>，因为 <code>last_message_id</code> 字段是 <code>NULLABLE</code>（可以为空）的；而其他情况下，我们无法得到任何记录。基于同样的理由，我们在 <code>has_unread_messages</code> 的比较中使用了 <code>IFNULL</code> 语句。最后，我们按 ID 进行过滤。</p><p>如果查询没有返回任何记录，我们的响应会返回 <code>404 Not Found</code> 错误，否则响应将会返回 <code>200 OK</code> 以及找到的对话。</p><hr><p>本篇帖子以创建了一些对话端点结束。</p><p>在下一篇帖子中，我们将会看到如何创建并列出消息。</p><ul><li><a href=https://github.com/nicolasparada/go-messenger-demo>源代码</a></li></ul><hr><p>via: <a href=https://nicolasparada.netlify.com/posts/go-messenger-conversations/>https://nicolasparada.netlify.com/posts/go-messenger-conversations/</a></p><p>作者：<a href=https://nicolasparada.netlify.com/>Nicolás Parada</a> 选题：<a href=https://github.com/lujun9972>lujun9972</a> 译者：<a href=https://github.com/PsiACE>PsiACE</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/%E5%8D%B3%E6%97%B6%E6%B6%88%E6%81%AF/ rel=tag>即时消息</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>