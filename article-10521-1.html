<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Go 编程语言的简单介绍 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="Go 编程语言的简单介绍"><meta property="og:description" content="Go 有 C 风格的语法（没有预处理器）、垃圾回收机制，而且类似它在贝尔实验室里被开发出来的前辈们"><meta property="og:type" content="article"><meta property="og:url" content="/article-10521-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-02-09T00:07:53+00:00"><meta property="article:modified_time" content="2019-02-09T00:07:53+00:00"><meta itemprop=name content="Go 编程语言的简单介绍"><meta itemprop=description content="Go 有 C 风格的语法（没有预处理器）、垃圾回收机制，而且类似它在贝尔实验室里被开发出来的前辈们"><meta itemprop=datePublished content="2019-02-09T00:07:53+00:00"><meta itemprop=dateModified content="2019-02-09T00:07:53+00:00"><meta itemprop=wordCount content="557"><meta itemprop=keywords content="Go,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>Go 编程语言的简单介绍</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2019-02-09T00:07:53Z>February 09, 2019</time></div></div></header><div class="content post__content clearfix"><p><img src=/data/attachment/album/201902/09/000738div64l4tidkdv6vj.png alt></p><p>（以下内容是我的硕士论文的摘录，几乎是整个 2.1 章节，向具有 CS 背景的人快速介绍 Go）</p><p>Go 是一门用于并发编程的命令式编程语言，它主要由创造者 Google 进行开发，最初主要由 Robert Griesemer、Rob Pike 和 Ken Thompson 开发。这门语言的设计起始于 2007 年，并在 2009 年推出最初版本；而第一个稳定版本是 2012 年发布的 1.0 版本。 1</p><p>Go 有 C 风格的语法（没有预处理器）、垃圾回收机制，而且类似它在贝尔实验室里被开发出来的前辈们：Newsqueak（Rob Pike）、Alef（Phil Winterbottom）和 Inferno（Pike、Ritchie 等人），使用所谓的 Go 协程 goroutines 和 信道 channels （一种基于 Hoare 的“通信顺序进程”理论的协程）提供内建的并发支持。 2</p><p>Go 程序以包的形式组织。包本质是一个包含 Go 文件的文件夹。包内的所有文件共享相同的命名空间，而包内的符号有两种可见性：以大写字母开头的符号对于其他包是可见，而其他符号则是该包私有的：</p><pre tabindex=0><code>func PublicFunction() {
    fmt.Println(&#34;Hello world&#34;)
}

func privateFunction() {
    fmt.Println(&#34;Hello package&#34;)
}
</code></pre><h3 id=类型>类型</h3><p>Go 有一个相当简单的类型系统：没有子类型（但有类型转换），没有泛型，没有多态函数，只有一些基本的类型：</p><ol><li>基本类型：<code>int</code>、<code>int64</code>、<code>int8</code>、<code>uint</code>、<code>float32</code>、<code>float64</code> 等</li><li><code>struct</code></li><li><code>interface</code>：一组方法的集合</li><li><code>map[K, V]</code>：一个从键类型到值类型的映射</li><li><code>[number]Type</code>：一些 Type 类型的元素组成的数组</li><li><code>[]Type</code>：某种类型的切片（具有长度和功能的数组的指针）</li><li><code>chan Type</code>：一个线程安全的队列</li><li>指针 <code>*T</code> 指向其他类型</li><li>函数</li><li>具名类型：可能具有关联方法的其他类型的别名（LCTT 译注：这里的别名并非指 Go 1.9 中的新特性“类型别名”）：</li></ol><pre tabindex=0><code>  type T struct { foo int }
  type T *T
  type T OtherNamedType
</code></pre><p>具名类型完全不同于它们的底层类型，所以你不能让它们互相赋值，但一些操作符，例如 <code>+</code>，能够处理同一底层数值类型的具名类型对象们（所以你可以在上面的示例中把两个 <code>T</code> 加起来）。</p><p>映射、切片和信道是类似于引用的类型——它们实际上是包含指针的结构。包括数组（具有固定长度并可被拷贝）在内的其他类型则是值传递（拷贝）。</p><h4 id=类型转换>类型转换</h4><p>类型转换类似于 C 或其他语言中的类型转换。它们写成这样子：</p><pre tabindex=0><code>TypeName(value)
</code></pre><h4 id=常量>常量</h4><p>Go 有“无类型”字面量和常量。</p><pre tabindex=0><code>1 // 无类型整数字面量
const foo = 1 // 无类型整数常量
const foo int = 1 // int 类型常量
</code></pre><p>无类型值可以分为以下几类：<code>UntypedBool</code>、<code>UntypedInt</code>、<code>UntypedRune</code>、<code>UntypedFloat</code>、<code>UntypedComplex</code>、<code>UntypedString</code> 以及 <code>UntypedNil</code>（Go 称它们为基础类型，其他基础种类可用于具体类型，如 <code>uint8</code>）。一个无类型值可以赋值给一个从基础类型中派生的具名类型；例如：</p><pre tabindex=0><code>type someType int

const untyped = 2 // UntypedInt
const bar someType = untyped // OK: untyped 可以被赋值给 someType
const typed int = 2 // int
const bar2 someType = typed // error: int 不能被赋值给 someType
</code></pre><h3 id=接口和对象>接口和对象</h3><p>正如上面所说的，接口是一组方法的集合。Go 本身不是一种面向对象的语言，但它支持将方法关联到具名类型上：当声明一个函数时，可以提供一个接收者。接收者是函数的一个额外参数，可以在函数之前传递并参与函数查找，就像这样：</p><pre tabindex=0><code>type SomeType struct { ... }
type SomeType struct { ... }

func (s *SomeType) MyMethod() {
}

func main() {
    var s SomeType
    s.MyMethod()
}
</code></pre><p>如果对象实现了所有方法，那么它就实现了接口；例如，<code>*SomeType</code>（注意指针）实现了下面的接口 <code>MyMethoder</code>，因此 <code>*SomeType</code> 类型的值就能作为 <code>MyMethoder</code> 类型的值使用。最基本的接口类型是 <code>interface{}</code>，它是一个带空方法集的接口 —— 任何对象都满足该接口。</p><pre tabindex=0><code>type MyMethoder interface {
    MyMethod()
}
</code></pre><p>合法的接收者类型是有些限制的；例如，具名类型可以是指针类型（例如，<code>type MyIntPointer *int</code>），但这种类型不是合法的接收者类型。</p><h3 id=控制流>控制流</h3><p>Go 提供了三个主要的控制了语句：<code>if</code>、<code>switch</code> 和 <code>for</code>。这些语句同其他 C 风格语言内的语句非常类似，但有一些不同：</p><ul><li>条件语句没有括号，所以条件语句是 <code>if a == b {}</code> 而不是 <code>if (a == b) {}</code>。大括号是必须的。</li><li>所有的语句都可以有初始化，比如这个 <code>if result, err := someFunction(); err == nil { // use result }</code></li><li><code>switch</code> 语句在分支里可以使用任何表达式</li><li><code>switch</code> 语句可以处理空的表达式（等于 <code>true</code>）</li><li>默认情况下，Go 不会从一个分支进入下一个分支（不需要 <code>break</code> 语句），在程序块的末尾使用 <code>fallthrough</code> 则会进入下一个分支。</li><li>循环语句 <code>for</code> 不仅能循环值域：<code>for key, val := range map { do something }</code></li></ul><h3 id=go-协程>Go 协程</h3><p>关键词 <code>go</code> 会产生一个新的 Go 协程 goroutine ，这是一个可以并行执行的函数。它可以用于任何函数调用，甚至一个匿名函数：</p><pre tabindex=0><code>func main() {
    ...
    go func() {
        ...
    }()

    go some_function(some_argument)
}
</code></pre><h3 id=信道>信道</h3><p>Go 协程通常和信道channels结合，用来提供一种通信顺序进程的扩展。信道是一个并发安全的队列，而且可以选择是否缓冲数据：</p><pre tabindex=0><code>var unbuffered = make(chan int) // 直到数据被读取时完成数据块发送
var buffered = make(chan int, 5) // 最多有 5 个未读取的数据块
</code></pre><p>运算符 <code>&lt;-</code> 用于和单个信道进行通信。</p><pre tabindex=0><code>valueReadFromChannel := &lt;- channel
otherChannel &lt;- valueToSend
</code></pre><p>语句 <code>select</code> 允许多个信道进行通信：</p><pre tabindex=0><code>select {
    case incoming := &lt;- inboundChannel:
    // 一条新消息
    case outgoingChannel &lt;- outgoing:
    // 可以发送消息
}
</code></pre><h3 id=defer-声明>defer 声明</h3><p>Go 提供语句 <code>defer</code> 允许函数退出时调用执行预定的函数。它可以用于进行资源释放操作，例如：</p><pre tabindex=0><code>func myFunc(someFile io.ReadCloser) {
    defer someFile.close()
    /* 文件相关操作 */
}
</code></pre><p>当然，它允许使用匿名函数作为被调函数，而且编写被调函数时可以像平常一样使用任何变量。</p><h3 id=错误处理>错误处理</h3><p>Go 没有提供异常类或者结构化的错误处理。然而，它通过第二个及后续的返回值来返回错误从而处理错误：</p><pre tabindex=0><code>func Read(p []byte) (n int, err error)

// 内建类型：
type error interface {
    Error() string
}
</code></pre><p>必须在代码中检查错误或者赋值给 <code>_</code>：</p><pre tabindex=0><code>n0, _ := Read(Buffer) // 忽略错误
n, err := Read(buffer)
if err != nil {
    return err
}
</code></pre><p>有两个函数可以快速跳出和恢复调用栈：<code>panic()</code> 和 <code>recover()</code>。当 <code>panic()</code> 被调用时，调用栈开始弹出，同时每个 <code>defer</code> 函数都会正常运行。当一个 <code>defer</code> 函数调用 <code>recover()</code>时，调用栈停止弹出，同时返回函数 <code>panic()</code> 给出的值。如果我们让调用栈正常弹出而不是由于调用 <code>panic()</code> 函数，<code>recover()</code> 将只返回 <code>nil</code>。在下面的例子中，<code>defer</code> 函数将捕获 <code>panic()</code> 抛出的任何 <code>error</code> 类型的值并储存在错误返回值中。第三方库中有时会使用这个方法增强递归代码的可读性，如解析器，同时保持公有函数仍使用普通错误返回值。</p><pre tabindex=0><code>func Function() (err error) {
    defer func() {
        s := recover()
        switch s := s.(type) {  // type switch
            case error:
                err = s         // s has type error now
            default:
                panic(s)
        }
    }
}
</code></pre><h3 id=数组和切片>数组和切片</h3><p>正如前边说的，数组是值类型，而切片是指向数组的指针。切片可以由现有的数组切片产生，也可以使用 <code>make()</code> 创建切片，这会创建一个匿名数组以保存元素。</p><pre tabindex=0><code>slice1 := make([]int, 2, 5) // 分配 5 个元素，其中 2 个初始化为0
slice2 := array[:] // 整个数组的切片
slice3 := array[1:] // 除了首元素的切片
</code></pre><p>除了上述例子，还有更多可行的切片运算组合，但需要明了直观。</p><p>使用 <code>append()</code> 函数，切片可以作为一个变长数组使用。</p><pre tabindex=0><code>slice = append(slice, value1, value2)
slice = append(slice, arrayOrSlice...)
</code></pre><p>切片也可以用于函数的变长参数。</p><h3 id=映射>映射</h3><p>映射 maps 是简单的键值对储存容器，并支持索引和分配。但它们不是线程安全的。</p><pre tabindex=0><code>someValue := someMap[someKey]
someValue, ok := someMap[someKey] // 如果键值不在 someMap 中，变量 ok 会赋值为 `false`
someMap[someKey] = someValue
</code></pre><hr><p>via: <a href=https://blog.jak-linux.org/2018/12/24/introduction-to-go/>https://blog.jak-linux.org/2018/12/24/introduction-to-go/</a></p><p>作者：<a href=https://blog.jak-linux.org/>Julian Andres Klode</a> 选题：<a href=https://github.com/lujun9972>lujun9972</a> 译者：<a href=https://github.com/LazyWolfLin>LazyWolfLin</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p><hr><ol><li>Frequently Asked Questions (FAQ) - The Go Programming Language <a href=https://golang.org/doc/faq#history>https://golang.org/doc/faq#history</a> [return] <a href=#fnref1>↩</a></li><li>HOARE, Charles Antony Richard. Communicating sequential processes. Communications of the ACM, 1978, 21. Jg., Nr. 8, S. 666-677. [return] <a href=#fnref2>↩</a></li></ol></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/go/ rel=tag>Go</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>