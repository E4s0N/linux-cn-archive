<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>在 Linux 上使用 systemd 设置定时器 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="在 Linux 上使用 systemd 设置定时器"><meta property="og:description" content="学习使用 systemd 创建启动你的游戏服务器的定时器。"><meta property="og:type" content="article"><meta property="og:url" content="/article-10182-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-11-01T22:13:50+00:00"><meta property="article:modified_time" content="2018-11-01T22:13:50+00:00"><meta itemprop=name content="在 Linux 上使用 systemd 设置定时器"><meta itemprop=description content="学习使用 systemd 创建启动你的游戏服务器的定时器。"><meta itemprop=datePublished content="2018-11-01T22:13:50+00:00"><meta itemprop=dateModified content="2018-11-01T22:13:50+00:00"><meta itemprop=wordCount content="296"><meta itemprop=keywords content="systemd,定时器,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>在 Linux 上使用 systemd 设置定时器</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2018-11-01T22:13:50Z>November 01, 2018</time></div></div></header><div class="content post__content clearfix"><blockquote><p>学习使用 systemd 创建启动你的游戏服务器的定时器。</p></blockquote><p><img src=/data/attachment/album/201811/01/221408u4uar48ciu4bcidy.jpg alt></p><p>之前，我们看到了如何<a href=/article-9700-1.html>手动的</a>、<a href=/article-9703-1.html>在开机与关机时</a>、<a href=https://www.linux.com/blog/intro-to-linux/2018/6/systemd-services-reacting-change>在启用某个设备时</a>、<a href=https://www.linux.com/blog/learn/intro-to-linux/2018/6/systemd-services-monitoring-files-and-directories>在文件系统发生改变时</a> 启用与禁用 systemd 服务。</p><p>定时器增加了另一种启动服务的方式，基于……时间。尽管与定时任务很相似，但 systemd 定时器稍微地灵活一些。让我们看看它是怎么工作的。</p><h3 id=定时运行>“定时运行”</h3><p>让我们展开<a href=/article-9703-1.html>本系列前两篇文章</a>中<a href=/article-9700-1.html>你所设置的</a> <a href=https://www.minetest.net/>Minetest</a> 服务器作为如何使用定时器单元的第一个例子。如果你还没有读过那几篇文章，可以现在去看看。</p><p>你将通过创建一个定时器来“改进” Minetest 服务器，使得在服务器启动 1 分钟后运行游戏服务器而不是立即运行。这样做的原因可能是，在启动之前可能会用到其他的服务，例如发邮件给其他玩家告诉他们游戏已经准备就绪，你要确保其他的服务（例如网络）在开始前完全启动并运行。</p><p>最终，你的 <code>minetest.timer</code> 单元看起来就像这样：</p><pre tabindex=0><code># minetest.timer
[Unit]
Description=Runs the minetest.service 1 minute after boot up

[Timer]
OnBootSec=1 m
Unit=minetest.service

[Install]
WantedBy=basic.target
</code></pre><p>一点也不难吧。</p><p>如以往一般，开头是 <code>[Unit]</code> 和一段描述单元作用的信息，这儿没什么新东西。<code>[Timer]</code> 这一节是新出现的，但它的作用不言自明：它包含了何时启动服务，启动哪个服务的信息。在这个例子当中，<code>OnBootSec</code> 是告诉 systemd 在系统启动后运行服务的指令。</p><p>其他的指令有：</p><ul><li><code>OnActiveSec=</code>，告诉 systemd 在定时器启动后多长时间运行服务。</li><li><code>OnStartupSec=</code>，同样的，它告诉 systemd 在 systemd 进程启动后多长时间运行服务。</li><li><code>OnUnitActiveSec=</code>，告诉 systemd 在上次由定时器激活的服务启动后多长时间运行服务。</li><li><code>OnUnitInactiveSec=</code>，告诉 systemd 在上次由定时器激活的服务停用后多长时间运行服务。</li></ul><p>继续 <code>minetest.timer</code> 单元，<code>basic.target</code> 通常用作 后期引导服务 late boot services 的 同步点 synchronization point 。这就意味着它可以让 <code>minetest.timer</code> 单元运行在安装完 本地挂载点 local mount points 或交换设备，套接字、定时器、路径单元和其他基本的初始化进程之后。就像在<a href=/article-9703-1.html>第二篇文章中 systemd 单元</a>里解释的那样，<code>targets</code> 就像 旧的运行等级 old run levels 一样，可以将你的计算机置于某个状态，或像这样告诉你的服务在达到某个状态后开始运行。</p><p>在前两篇文章中你配置的 <code>minetest.service</code> 文件<a href=/article-9703-1.html>最终</a>看起来就像这样：</p><pre tabindex=0><code># minetest.service
[Unit]
Description= Minetest server
Documentation= https://wiki.minetest.net/Main_Page

[Service]
Type= simple
User=

ExecStart= /usr/games/minetest --server
ExecStartPost= /home//bin/mtsendmail.sh &#34;Ready to rumble?&#34; &#34;Minetest Starting up&#34;

TimeoutStopSec= 180
ExecStop= /home//bin/mtsendmail.sh &#34;Off to bed. Nightie night!&#34; &#34;Minetest Stopping in 2 minutes&#34;
ExecStop= /bin/sleep 120
ExecStop= /bin/kill -2 $MAINPID

[Install]
WantedBy= multi-user.target
</code></pre><p>这儿没什么需要修改的。但是你需要将 <code>mtsendmail.sh</code>（发送你的 email 的脚本）从：</p><pre tabindex=0><code>#!/bin/bash
# mtsendmail
sleep 20
echo $1 | mutt -F /home/&lt;username&gt;/.muttrc -s &#34;$2&#34; my_minetest@mailing_list.com
sleep 10
</code></pre><p>改成：</p><pre tabindex=0><code>#!/bin/bash
# mtsendmail.sh
echo $1 | mutt -F /home/paul/.muttrc -s &#34;$2&#34; pbrown@mykolab.com
</code></pre><p>你做的事是去除掉 Bash 脚本中那些蹩脚的停顿。Systemd 现在来做等待。</p><h3 id=让它运行起来>让它运行起来</h3><p>确保一切运作正常，禁用 <code>minetest.service</code>：</p><pre tabindex=0><code>sudo systemctl disable minetest
</code></pre><p>这使得系统启动时它不会一同启动；然后，相反地，启用 <code>minetest.timer</code>：</p><pre tabindex=0><code>sudo systemctl enable minetest.timer
</code></pre><p>现在你就可以重启服务器了，当运行 <code>sudo journalctl -u minetest.*</code> 后，你就会看到 <code>minetest.timer</code> 单元执行后大约一分钟，<code>minetest.service</code> 单元开始运行。</p><p><img src=/data/attachment/album/201811/01/221418yyzjjv5060jv0a5e.png alt="minetest timer" title="minetest timer"></p><p><em>图 1：minetest.timer 运行大约 1 分钟后 minetest.service 开始运行</em></p><h3 id=时间的问题>时间的问题</h3><p><code>minetest.timer</code> 在 systemd 的日志里显示的启动时间为 09:08:33 而 <code>minetest.service</code> 启动时间是 09:09:18，它们之间少于 1 分钟，关于这件事有几点需要说明一下：首先，请记住我们说过 <code>OnBootSec=</code> 指令是从引导完成后开始计算服务启动的时间。当 <code>minetest.timer</code> 的时间到来时，引导已经在几秒之前完成了。</p><p>另一件事情是 systemd 给自己设置了一个 误差幅度 margin of error （默认是 1 分钟）来运行东西。这有助于在多个 资源密集型进程 resource-intensive processes 同时运行时分配负载：通过分配 1 分钟的时间，systemd 可以等待某些进程关闭。这也意味着 <code>minetest.service</code> 会在引导完成后的 1~2 分钟之间启动。但精确的时间谁也不知道。</p><p>顺便一提，你可以用 <code>AccuracySec=</code> 指令<a href="https://www.freedesktop.org/software/systemd/man/systemd.timer.html#AccuracySec=">修改误差幅度</a>。</p><p>你也可以检查系统上所有的定时器何时运行或是上次运行的时间：</p><pre tabindex=0><code>systemctl list-timers --all
</code></pre><p><img src=/data/attachment/album/201811/01/221426vizdi0z11zjr42mu.png alt="check timer" title="check timer"></p><p><em>图 2：检查定时器何时运行或上次运行的时间</em></p><p>最后一件值得思考的事就是你应该用怎样的格式去表示一段时间。Systemd 在这方面非常灵活：<code>2 h</code>，<code>2 hours</code> 或 <code>2hr</code> 都可以用来表示 2 个小时。对于“秒”，你可以用 <code>seconds</code>，<code>second</code>，<code>sec</code> 和 <code>s</code>。“分”也是同样的方式：<code>minutes</code>，<code>minute</code>，<code>min</code> 和 <code>m</code>。你可以检查 <code>man systemd.time</code> 来查看 systemd 能够理解的所有时间单元。</p><h3 id=下一次>下一次</h3><p>下次你会看到如何使用日历中的日期和时间来定期运行服务，以及如何通过组合定时器与设备单元在插入某些硬件时运行服务。</p><p>回头见！</p><p>在 Linux 基金会和 edx 上通过免费课程 <a href=https://training.linuxfoundation.org/linux-courses/system-administration-training/introduction-to-linux>“Introduction to Linux”</a> 学习更多关于 Linux 的知识。</p><hr><p>via: <a href=https://www.linux.com/blog/learn/intro-to-linux/2018/7/setting-timer-systemd-linux>https://www.linux.com/blog/learn/intro-to-linux/2018/7/setting-timer-systemd-linux</a></p><p>作者：<a href=https://www.linux.com/users/bro66>Paul Brown</a> 选题：<a href=https://github.com/lujun9972>lujun9972</a> 译者：<a href=https://github.com/LuuMing>LuuMing</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/systemd/ rel=tag>systemd</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E5%AE%9A%E6%97%B6%E5%99%A8/ rel=tag>定时器</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>