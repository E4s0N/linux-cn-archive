<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>使用 trace-cmd 追踪内核 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="使用 trace-cmd 追踪内核"><meta property="og:description" content="trace-cmd 是一个易于使用，且特性众多、可用来追踪内核函数的命令。"><meta property="og:type" content="article"><meta property="og:url" content="/article-13852-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-10-05T14:58:24+00:00"><meta property="article:modified_time" content="2021-10-05T14:58:24+00:00"><meta itemprop=name content="使用 trace-cmd 追踪内核"><meta itemprop=description content="trace-cmd 是一个易于使用，且特性众多、可用来追踪内核函数的命令。"><meta itemprop=datePublished content="2021-10-05T14:58:24+00:00"><meta itemprop=dateModified content="2021-10-05T14:58:24+00:00"><meta itemprop=wordCount content="885"><meta itemprop=keywords content="追踪,内核,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>使用 trace-cmd 追踪内核</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2021-10-05T14:58:24Z>October 05, 2021</time></div></div></header><div class="content post__content clearfix"><blockquote><p>trace-cmd 是一个易于使用，且特性众多、可用来追踪内核函数的命令。</p></blockquote><p><img src=https://img.linux.net.cn/data/attachment/album/202110/05/145818d2i9tgjetzj8itqg.jpg alt title="Puzzle pieces coming together to form a computer screen"></p><p>在 <a href=/article-13752-1.html>之前的文章</a> 里，我介绍了如何利用 <code>ftrace</code> 来追踪内核函数。通过写入和读出文件来使用 <code>ftrace</code> 会变得很枯燥，所以我对它做了一个封装来运行带有选项的命令，以启用和禁用追踪、设置过滤器、查看输出、清除输出等等。</p><p><a href=https://lwn.net/Articles/410200/>trace-cmd</a> 命令是一个可以帮助你做到这一点的工具。在这篇文章中，我使用 <code>trace-cmd</code> 来执行我在 <code>ftrace</code> 文章中所做的相同任务。由于会经常参考那篇文章，建议在阅读这篇文章之前先阅读它。</p><h3 id=安装-trace-cmd>安装 trace-cmd</h3><p>本文中所有的命令都运行在 root 用户下。</p><p>因为 <code>ftrace</code> 机制被内置于内核中，因此你可以使用下面的命令进行验证它是否启用：</p><pre tabindex=0><code># mount | grep tracefs
none on /sys/kernel/tracing type tracefs (rw,relatime,seclabel)
</code></pre><p>不过，你需要手动尝试安装 <code>trace-cmd</code> 命令：</p><pre tabindex=0><code># dnf install trace-cmd -y
</code></pre><h3 id=列出可用的追踪器>列出可用的追踪器</h3><p>当使用 <code>ftrace</code> 时，你必须查看文件的内容以了解有哪些追踪器可用。但使用 <code>trace-cmd</code>，你可以通过以下方式获得这些信息:</p><pre tabindex=0><code># trace-cmd list -t
hwlat blk mmiotrace function_graph wakeup_dl wakeup_rt wakeup function nop
</code></pre><h3 id=启用函数追踪器>启用函数追踪器</h3><p>在我 <a href=/article-13752-1.html>之前的文章</a> 中，我使用了两个追踪器，在这里我也会这么做。用 <code>function</code> 启用你的第一个追踪器:</p><pre tabindex=0><code>$ trace-cmd start -p function
  plugin &#39;function&#39;
</code></pre><h3 id=查看追踪输出>查看追踪输出</h3><p>一旦追踪器被启用，你可以通过使用 <code>show</code> 参数来查看输出。这只显示了前 20 行以保持例子的简短（见我之前的文章对输出的解释）：</p><pre tabindex=0><code># trace-cmd show | head -20
## tracer: function
#
# entries-in-buffer/entries-written: 410142/3380032   #P:8
#
#                                _-----=&gt; irqs-off
#                               / _----=&gt; need-resched
#                              | / _---=&gt; hardirq/softirq
#                              || / _--=&gt; preempt-depth
#                              ||| /     delay
#           TASK-PID     CPU#  ||||   TIMESTAMP  FUNCTION
#              | |         |   ||||      |         |
           gdbus-2606    [004] ..s. 10520.538759: __msecs_to_jiffies &lt;-rebalance_domains
           gdbus-2606    [004] ..s. 10520.538760: load_balance &lt;-rebalance_domains
           gdbus-2606    [004] ..s. 10520.538761: idle_cpu &lt;-load_balance
           gdbus-2606    [004] ..s. 10520.538762: group_balance_cpu &lt;-load_balance
           gdbus-2606    [004] ..s. 10520.538762: find_busiest_group &lt;-load_balance
           gdbus-2606    [004] ..s. 10520.538763: update_group_capacity &lt;-update_sd_lb_stats.constprop.0
           gdbus-2606    [004] ..s. 10520.538763: __msecs_to_jiffies &lt;-update_group_capacity
           gdbus-2606    [004] ..s. 10520.538765: idle_cpu &lt;-update_sd_lb_stats.constprop.0
           gdbus-2606    [004] ..s. 10520.538766: __msecs_to_jiffies &lt;-rebalance_domains
</code></pre><h3 id=停止追踪并清除缓冲区>停止追踪并清除缓冲区</h3><p>追踪将会在后台继续运行，你可以继续用 <code>show</code> 查看输出。</p><p>要停止追踪，请运行带有 <code>stop</code> 参数的 <code>trace-cmd</code> 命令：</p><pre tabindex=0><code># trace-cmd stop
</code></pre><p>要清除缓冲区，用 <code>clear</code> 参数运行它：</p><pre tabindex=0><code># trace-cmd clear
</code></pre><h3 id=启用函数调用图追踪器>启用函数调用图追踪器</h3><p>运行第二个追踪器，通过 <code>function_graph</code> 参数来启用它。</p><pre tabindex=0><code># trace-cmd start -p function_graph
  Plugin &#39;function_graph&#39;
</code></pre><p>再次使用 <code>show</code> 参数查看输出。正如预期的那样，输出与第一次追踪输出略有不同。这一次，它包括一个<strong>函数调用</strong>链：</p><pre tabindex=0><code># trace-cmd show | head -20
## tracer: function_graph
#
# CPU  DURATION                  FUNCTION CALLS
# |     |   |                     |   |   |   |
 4)   0.079 us    |        } /* rcu_all_qs */
 4)   0.327 us    |      } /* __cond_resched */
 4)   0.081 us    |      rcu_read_unlock_strict();
 4)               |      __cond_resched() {
 4)   0.078 us    |        rcu_all_qs();
 4)   0.243 us    |      }
 4)   0.080 us    |      rcu_read_unlock_strict();
 4)               |      __cond_resched() {
 4)   0.078 us    |        rcu_all_qs();
 4)   0.241 us    |      }
 4)   0.080 us    |      rcu_read_unlock_strict();
 4)               |      __cond_resched() {
 4)   0.079 us    |        rcu_all_qs();
 4)   0.235 us    |      }
 4)   0.095 us    |      rcu_read_unlock_strict();
 4)               |      __cond_resched() {
</code></pre><p>使用 <code>stop</code> 和 <code>clear</code> 命令来停止追踪和清除缓存区：</p><pre tabindex=0><code># trace-cmd stop
# trace-cmd clear
</code></pre><h3 id=调整追踪以增加深度>调整追踪以增加深度</h3><p>如果你想在函数调用中看到更多的深度，你可以对追踪器进行调整：</p><pre tabindex=0><code># trace-cmd start -p function_graph --max-graph-depth 5
  plugin &#39;function_graph&#39;
</code></pre><p>现在，当你将这个输出与你之前看到的进行比较时，你应该看到更多的嵌套函数调用：</p><pre tabindex=0><code># trace-cmd show | head -20
## tracer: function_graph
#
# CPU  DURATION                  FUNCTION CALLS
# |     |   |                     |   |   |   |
 6)               |        __fget_light() {
 6)   0.804 us    |          __fget_files();
 6)   2.708 us    |        }
 6)   3.650 us    |      } /* __fdget */
 6)   0.547 us    |      eventfd_poll();
 6)   0.535 us    |      fput();
 6)               |      __fdget() {
 6)               |        __fget_light() {
 6)   0.946 us    |          __fget_files();
 6)   1.895 us    |        }
 6)   2.849 us    |      }
 6)               |      sock_poll() {
 6)   0.651 us    |        unix_poll();
 6)   1.905 us    |      }
 6)   0.475 us    |      fput();
 6)               |      __fdget() {
</code></pre><h3 id=了解可被追踪的函数>了解可被追踪的函数</h3><p>如果你想只追踪某些函数而忽略其他的，你需要知道确切的函数名称。你可以用 <code>list -f</code> 参数来得到它们。例如搜索常见的内核函数 <code>kmalloc</code>，它被用来在内核中分配内存：</p><pre tabindex=0><code># trace-cmd list -f | grep kmalloc
bpf_map_kmalloc_node
mempool_kmalloc
__traceiter_kmalloc
__traceiter_kmalloc_node
kmalloc_slab
kmalloc_order
kmalloc_order_trace
kmalloc_large_node
__kmalloc
__kmalloc_track_caller
__kmalloc_node
__kmalloc_node_track_caller
[...]
</code></pre><p>下面是我的测试系统中可被追踪的函数总数：</p><pre tabindex=0><code># trace-cmd list -f | wc -l
63165
</code></pre><h3 id=追踪内核模块相关的函数>追踪内核模块相关的函数</h3><p>你也可以追踪与特定内核模块相关的函数。假设你想追踪 <code>kvm</code> 内核模块相关的功能，你可以通过以下方式来实现。请确保该模块已经加载：</p><pre tabindex=0><code># lsmod | grep kvm_intel
kvm_intel 335872 0
kvm 987136 1 kvm_intel
</code></pre><p>再次运行 <code>trace-cmd</code>，使用 <code>list</code> 参数，并从输出结果中，<code>grep</code> 查找以 <code>]</code> 结尾的行。这将过滤掉内核模块。然后 <code>grep</code> 内核模块 <code>kvm_intel</code> ，你应该看到所有与该内核模块有关的函数。</p><pre tabindex=0><code># trace-cmd list -f | grep ]$  | grep kvm_intel
vmx_can_emulate_instruction [kvm_intel]
vmx_update_emulated_instruction [kvm_intel]
vmx_setup_uret_msr [kvm_intel]
vmx_set_identity_map_addr [kvm_intel]
handle_machine_check [kvm_intel]
handle_triple_fault [kvm_intel]
vmx_patch_hypercall [kvm_intel]

[...]

vmx_dump_dtsel [kvm_intel]
vmx_dump_sel [kvm_intel]
</code></pre><h3 id=追踪特定函数>追踪特定函数</h3><p>现在你知道了如何找到感兴趣的函数，请用一个例子把这些内容用于时间。就像前面的文章一样，试着追踪与文件系统相关的函数。我的测试系统上的文件系统是 <code>ext4</code>。</p><p>这个过程略有不同；你在运行命令时，不使用 <code>start</code> 参数，而是在 <code>record</code> 参数后面加上你想追踪的函数的“模式”。你还需要指定你想要的追踪器；在这种情况下，就是 <code>function_graph</code>。该命令会继续记录追踪，直到你用 <code>Ctrl+C</code> 停止它。所以几秒钟后，按 <code>Ctrl+C</code> 停止追踪：</p><pre tabindex=0><code># trace-cmd list -f | grep ^ext4_

# trace-cmd record -l ext4_* -p function_graph
  plugin &#39;function_graph&#39;
Hit Ctrl^C to stop recording
^C
CPU0 data recorded at offset=0x856000
    8192 bytes in size
[...]
</code></pre><h3 id=查看追踪记录>查看追踪记录</h3><p>要查看你之前的追踪记录，运行带有 <code>report</code> 参数的命令。从输出结果来看，很明显过滤器起作用了，你只看到 <code>ext4</code> 相关的函数追踪：</p><pre tabindex=0><code># trace-cmd report | head -20
[...]
cpus=8
       trace-cmd-12697 [000] 11303.928103: funcgraph_entry:                   |  ext4_show_options() {
       trace-cmd-12697 [000] 11303.928104: funcgraph_entry:        0.187 us   |    ext4_get_dummy_policy();
       trace-cmd-12697 [000] 11303.928105: funcgraph_exit:         1.583 us   |  }
       trace-cmd-12697 [000] 11303.928122: funcgraph_entry:                   |  ext4_create() {
       trace-cmd-12697 [000] 11303.928122: funcgraph_entry:                   |    ext4_alloc_inode() {
       trace-cmd-12697 [000] 11303.928123: funcgraph_entry:        0.101 us   |      ext4_es_init_tree();
       trace-cmd-12697 [000] 11303.928123: funcgraph_entry:        0.083 us   |      ext4_init_pending_tree();
       trace-cmd-12697 [000] 11303.928123: funcgraph_entry:        0.141 us   |      ext4_fc_init_inode();
       trace-cmd-12697 [000] 11303.928123: funcgraph_exit:         0.931 us   |    }
       trace-cmd-12697 [000] 11303.928124: funcgraph_entry:        0.081 us   |    ext4_get_dummy_policy();
       trace-cmd-12697 [000] 11303.928124: funcgraph_entry:        0.133 us   |    ext4_get_group_desc();
       trace-cmd-12697 [000] 11303.928124: funcgraph_entry:        0.115 us   |    ext4_free_inodes_count();
       trace-cmd-12697 [000] 11303.928124: funcgraph_entry:        0.114 us   |    ext4_get_group_desc();
</code></pre><h3 id=追踪一个特定的-pid>追踪一个特定的 PID</h3><p>假设你想追踪与一个进程（PID）有关的函数。打开另一个终端，注意运行中的 shell 的PID：</p><pre tabindex=0><code># echo $$
10885
</code></pre><p>再次运行 <code>record</code> 命令，用 <code>-P</code> 选项传递PID。这一次，让终端运行（也就是说，先不要按 <code>Ctrl+C</code> ）：</p><pre tabindex=0><code># trace-cmd record -P 10885 -p function_graph
  Plugin &#39;function_graph&#39;
Hit Ctrl^C to stop recording
</code></pre><h3 id=在-shell-上运行一些命令>在 shell 上运行一些命令</h3><p>移动到另一个终端，在那里你有一个以特定 PID 运行的 shell，并运行任何命令，例如，<code>ls</code> 命令用来列出文件：</p><pre tabindex=0><code># ls
Temp-9b61f280-fdc1-4512-9211-5c60f764d702
tracker-extract-3-files.1000
v8-compile-cache-1000
[...]
</code></pre><p>移动到你启用追踪的终端，按 <code>Ctrl+C</code> 停止追踪：</p><pre tabindex=0><code># trace-cmd record -P 10885 -p function_graph
  plugin &#39;function_graph&#39;
Hit Ctrl^C to stop recording
^C
CPU1 data recorded at offset=0x856000
    618496 bytes in size
[...]
</code></pre><p>在追踪的输出中，你可以看到左边是 PID 和 Bash shell，右边是与之相关的函数调用。这对于缩小你的追踪范围是非常方便的：</p><pre tabindex=0><code># trace-cmd report  | head -20

cpus=8
          &lt;idle&gt;-0     [001] 11555.380581: funcgraph_entry:                   |  switch_mm_irqs_off() {
          &lt;idle&gt;-0     [001] 11555.380583: funcgraph_entry:        1.703 us   |    load_new_mm_cr3();
          &lt;idle&gt;-0     [001] 11555.380586: funcgraph_entry:        0.493 us   |    switch_ldt();
          &lt;idle&gt;-0     [001] 11555.380587: funcgraph_exit:         7.235 us   |  }
            bash-10885 [001] 11555.380589: funcgraph_entry:        1.046 us   |  finish_task_switch.isra.0();
            bash-10885 [001] 11555.380591: funcgraph_entry:                   |  __fdget() {
            bash-10885 [001] 11555.380592: funcgraph_entry:        2.036 us   |    __fget_light();
            bash-10885 [001] 11555.380594: funcgraph_exit:         3.256 us   |  }
            bash-10885 [001] 11555.380595: funcgraph_entry:                   |  tty_poll() {
            bash-10885 [001] 11555.380597: funcgraph_entry:                   |    tty_ldisc_ref_wait() {
            bash-10885 [001] 11555.380598: funcgraph_entry:                   |      ldsem_down_read() {
            bash-10885 [001] 11555.380598: funcgraph_entry:                   |        __cond_resched() {
</code></pre><h3 id=试一试>试一试</h3><p>这些简短的例子显示了使用 <code>trace-cmd</code> 命令而不是底层的 <code>ftrace</code> 机制，是如何实现既容易使用又拥有丰富的功能，许多内容本文并没有涉及。要想了解更多信息并更好地使用它，请查阅它的手册，并尝试使用其他有用的命令。</p><hr><p>via: <a href=https://opensource.com/article/21/7/linux-kernel-trace-cmd>https://opensource.com/article/21/7/linux-kernel-trace-cmd</a></p><p>作者：<a href=https://opensource.com/users/gkamathe>Gaurav Kamathe</a> 选题：<a href=https://github.com/lujun9972>lujun9972</a> 译者：<a href=https://github.com/mengxinayan>萌新阿岩</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/%E8%BF%BD%E8%B8%AA/ rel=tag>追踪</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E5%86%85%E6%A0%B8/ rel=tag>内核</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>