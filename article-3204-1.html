<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Bash Getopts - 让你的脚本支持命令行参数 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="Bash Getopts - 让你的脚本支持命令行参数"><meta property="og:description" content="以前我总想知道如何为我的Bash脚本创建命令行参数。经过搜索，我发现了2个函数可以处理这个问题，getopt 函数和 getopts 函数。我无意争论哪一个函数更好的。getopts 是一个shell内建命令，而且似乎比 getopt 更容易实现这个功能，所以在这篇文章里我准备讲讲getopts。  bash getopts 开始的时候，我只试着处理传递给脚本的命令行参数。最后，我添加了另外一些有用的功能函数，使得这个脚本可以成为其他任何交互式脚本处理命令行的开始模板。我还添加了一个纯文本格式的帮助函数，让脚本更加容易阅读。 与其来一长段文字解释 getopts 在ba"><meta property="og:type" content="article"><meta property="og:url" content="/article-3204-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2014-06-16T12:55:00+00:00"><meta property="article:modified_time" content="2014-06-16T12:55:00+00:00"><meta itemprop=name content="Bash Getopts - 让你的脚本支持命令行参数"><meta itemprop=description content="以前我总想知道如何为我的Bash脚本创建命令行参数。经过搜索，我发现了2个函数可以处理这个问题，getopt 函数和 getopts 函数。我无意争论哪一个函数更好的。getopts 是一个shell内建命令，而且似乎比 getopt 更容易实现这个功能，所以在这篇文章里我准备讲讲getopts。  bash getopts 开始的时候，我只试着处理传递给脚本的命令行参数。最后，我添加了另外一些有用的功能函数，使得这个脚本可以成为其他任何交互式脚本处理命令行的开始模板。我还添加了一个纯文本格式的帮助函数，让脚本更加容易阅读。 与其来一长段文字解释 getopts 在ba"><meta itemprop=datePublished content="2014-06-16T12:55:00+00:00"><meta itemprop=dateModified content="2014-06-16T12:55:00+00:00"><meta itemprop=wordCount content="439"><meta itemprop=keywords content="bash,脚本,shell,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>Bash Getopts - 让你的脚本支持命令行参数</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-06-16T12:55:00Z>June 16, 2014</time></div></div></header><div class="content post__content clearfix"><p>以前我总想知道如何为我的Bash脚本创建命令行参数。经过搜索，我发现了2个函数可以处理这个问题，<strong>getopt</strong> 函数和 <strong>getopts</strong> 函数。我无意争论哪一个函数更好的。<strong>getopts</strong> 是一个shell内建命令，而且似乎比 <strong>getopt</strong> 更容易实现这个功能，所以在这篇文章里我准备讲讲getopts。</p><p><img src=/data/attachment/album/201406/16/144459khrh6o1s7m1kmjl4.png alt></p><h3 id=bash-getopts>bash getopts</h3><p>开始的时候，我只试着处理传递给脚本的命令行参数。最后，我添加了另外一些有用的功能函数，使得这个脚本可以成为其他任何交互式脚本处理命令行的开始模板。我还添加了一个纯文本格式的帮助函数，让脚本更加容易阅读。</p><p>与其来一长段文字解释 <strong>getopts</strong> 在bash中是如何工作的，我认为不如直接来一个能工作的脚本更让人觉得轻松一些。</p><pre tabindex=0><code>#!/bin/bash

######################################################################
#This is an example of using getopts in Bash. It also contains some
#other bits of code I find useful.
#Author: Linerd
#Website: http://tuxtweaks.com/
#Copyright 2014
#License: Creative Commons Attribution-ShareAlike 4.0
#http://creativecommons.org/licenses/by-sa/4.0/legalcode
######################################################################

#Set Script Name variable
SCRIPT=`basename ${BASH_SOURCE[0]}`

#Initialize variables to default values.
OPT_A=A
OPT_B=B
OPT_C=C
OPT_D=D

#Set fonts for Help.[译注: 这里tput用来更改终端文本属性,比如加粗，高亮等]
NORM=`tput sgr0`
BOLD=`tput bold`
REV=`tput smso`

#Help function
function HELP {
  echo -e \\n&#34;Help documentation for ${BOLD}${SCRIPT}.${NORM}&#34;\\n
  echo -e &#34;${REV}Basic usage:${NORM} ${BOLD}$SCRIPT file.ext${NORM}&#34;\\n
  echo &#34;Command line switches are optional. The following switches are recognized.&#34;
  echo &#34;${REV}-a${NORM}  --Sets the value for option ${BOLD}a${NORM}. Default is ${BOLD}A${NORM}.&#34;
  echo &#34;${REV}-b${NORM}  --Sets the value for option ${BOLD}b${NORM}. Default is ${BOLD}B${NORM}.&#34;
  echo &#34;${REV}-c${NORM}  --Sets the value for option ${BOLD}c${NORM}. Default is ${BOLD}C${NORM}.&#34;
  echo &#34;${REV}-d${NORM}  --Sets the value for option ${BOLD}d${NORM}. Default is ${BOLD}D${NORM}.&#34;
  echo -e &#34;${REV}-h${NORM}  --Displays this help message. No further functions are performed.&#34;\\n
  echo -e &#34;Example: ${BOLD}$SCRIPT -a foo -b man -c chu -d bar file.ext${NORM}&#34;\\n
  exit 1
}

#Check the number of arguments. If none are passed, print help and exit.
NUMARGS=$#
echo -e \\n&#34;Number of arguments: $NUMARGS&#34;
if [ $NUMARGS -eq 0 ]; then
  HELP
fi

### Start getopts code ###

#Parse command line flags
#如果选项需要后跟参数，在选项后面加&#34;:&#34;
#注意&#34;-h&#34;选项后面没有&#34;:&#34;，因为他不需要参数。选项字符串最开始的&#34;:&#34;是用来去掉来自getopts本身的报错的，同时获取不能识别的选项。（译注：如果选项字符串不以&#34;:&#34;开头，发生错误（非法的选项或者缺少参数）时，getopts会向错误输出打印错误信息；如果以&#34;:&#34;开头，则不会打印[在man中叫slient error reporting]，同时将出错的选项赋给OPTARG变量）

while getopts :a:b:c:d:h FLAG; do
  case $FLAG in
    a)  #set option &#34;a&#34;
      OPT_A=$OPTARG
      echo &#34;-a used: $OPTARG&#34;
      echo &#34;OPT_A = $OPT_A&#34;
      ;;
    b)  #set option &#34;b&#34;
      OPT_B=$OPTARG
      echo &#34;-b used: $OPTARG&#34;
      echo &#34;OPT_B = $OPT_B&#34;
      ;;
    c)  #set option &#34;c&#34;
      OPT_C=$OPTARG
      echo &#34;-c used: $OPTARG&#34;
      echo &#34;OPT_C = $OPT_C&#34;
      ;;
    d)  #set option &#34;d&#34;
      OPT_D=$OPTARG
      echo &#34;-d used: $OPTARG&#34;
      echo &#34;OPT_D = $OPT_D&#34;
      ;;
    h)  #show help
      HELP
      ;;
    \?) #unrecognized option - show help
      echo -e \\n&#34;Option -${BOLD}$OPTARG${NORM} not allowed.&#34;
      HELP
      #在这里如果你不想打印完整的帮助信息，只想显示简单的错误信息，去掉上面的两行，同时使用下面的两行。
      #echo -e &#34;Use ${BOLD}$SCRIPT -h${NORM} to see the help documentation.&#34;\\n
      #exit 2
      ;;
  esac
done

shift $((OPTIND-1))  #This tells getopts to move on to the next argument.

### End getopts code ###


### Main loop to process files ###

#这里你可以用你的脚本处理逻辑来替代。这个例子只是在终端中打印文件的文件名和后缀名。你可以把任意其他的文件处理任务放到这个while-do循环中。   

while [ $# -ne 0 ]; do
  FILE=$1
  TEMPFILE=`basename $FILE`
  #TEMPFILE=&#34;${FILE##*/}&#34;  #另外一种获取不带后缀的文件名的方法。
  FILE_BASE=`echo &#34;${TEMPFILE%.*}&#34;`  #file without extension
  FILE_EXT=&#34;${TEMPFILE##*.}&#34;  #file extension


  echo -e \\n&#34;Input file is: $FILE&#34;
  echo &#34;File withouth extension is: $FILE_BASE&#34;
  echo -e &#34;File extension is: $FILE_EXT&#34;\\n
  shift  #Move on to next input file.
done

### End main loop ###

exit 0
</code></pre><p>将上面的代码复制到你的文本编辑器里，然后保存到你的可执行路径下。我将这个脚本命名为 <strong>options</strong> 并保存到 <strong>/home/linerd/bin</strong> 路径下。保存之后记得给你的脚本添加可执行权限。</p><pre tabindex=0><code>chmod +x ~/bin/options
</code></pre><p>现在脚本已经可以运行了。试试用 <strong>-h</strong> 参数来打印帮助信息吧。</p><pre tabindex=0><code>options -h
</code></pre><p>遇到不支持的选项，脚本同样可以给出提示，并打印帮助信息。</p><pre tabindex=0><code>options -z
</code></pre><p>最后，getopts可以以任意的顺序处理你给的命令行参数。唯一的限制是你要处理的文件必须放在所有参数的最后。</p><pre tabindex=0><code>options -d bar -c chu -b man -a foo example1.txt example2.txt
</code></pre><p>现在你可以从这些例子里看到如何通过命令行参数给脚本里的变量赋值。这个脚本里除了getopts还有很多其他的东西，但是我认为这些就足以成为一个新脚本的开头模板了。如果你有兴趣更深入地学习bash的getopts，你可以找找深埋在man page的“Builtins”这一节里的文档，也可以从 <a href=http://tuxtweaks.com/2014/05/bash-getopts/www.gnu.org/software/bash/manual/html_node/Bourne-Shell-Builtins.html>Bash Reference Manual</a> 找到信息。</p><h3 id=接下来呢>接下来呢?</h3><p>你会用getops来干什么呢？在评论里告诉我吧。</p><hr><p>via: <a href=http://tuxtweaks.com/2014/05/bash-getopts/>http://tuxtweaks.com/2014/05/bash-getopts/</a></p><p>译者： CNprober &lt;<a href=mailto:travelwithheart@yeah.net>travelwithheart@yeah.net</a>, QQ619913541> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创翻译，<a href=http://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/bash/ rel=tag>bash</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E8%84%9A%E6%9C%AC/ rel=tag>脚本</a></li><li class=tags__item><a class="tags__link btn" href=/tags/shell/ rel=tag>shell</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>