<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>无密码验证：客户端 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="无密码验证：客户端"><meta property="og:description" content="上一篇文章中，我们用 Go 写了一个 HTTP 服务，用这个服务来做无密码验证 API。今天，我们为它再写一个 JavaScript 客户端。"><meta property="og:type" content="article"><meta property="og:url" content="/article-9830-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-07-12T11:41:37+00:00"><meta property="article:modified_time" content="2018-07-12T11:41:37+00:00"><meta itemprop=name content="无密码验证：客户端"><meta itemprop=description content="上一篇文章中，我们用 Go 写了一个 HTTP 服务，用这个服务来做无密码验证 API。今天，我们为它再写一个 JavaScript 客户端。"><meta itemprop=datePublished content="2018-07-12T11:41:37+00:00"><meta itemprop=dateModified content="2018-07-12T11:41:37+00:00"><meta itemprop=wordCount content="702"><meta itemprop=keywords content="无密码,验证,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>无密码验证：客户端</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2018-07-12T11:41:37Z>July 12, 2018</time></div></div></header><div class="content post__content clearfix"><p><img src=/data/attachment/album/201807/12/114131efzt9yrb5ggd93yr.jpg alt></p><p>我们继续 <a href=/article-9748-1.html>无密码验证</a> 的文章。上一篇文章中，我们用 Go 写了一个 HTTP 服务，用这个服务来做无密码验证 API。今天，我们为它再写一个 JavaScript 客户端。</p><p>我们将使用 <a href=/article-9815-1.html>这里的</a> 这个单页面应用程序（SPA）来展示使用的技术。如果你还没有读过它，请先读它。</p><p>记住流程：</p><ul><li>用户输入其 email。</li><li>用户收到一个带有魔法链接的邮件。</li><li>用户点击该链接、</li><li>用户验证成功。</li></ul><p>对于根 URL（<code>/</code>），我们将根据验证的状态分别使用两个不同的页面：一个是带有访问表单的页面，或者是已验证通过的用户的欢迎页面。另一个页面是验证回调的重定向页面。</p><h3 id=伺服>伺服</h3><p>我们将使用相同的 Go 服务器来为客户端提供服务，因此，在我们前面的 <code>main.go</code> 中添加一些路由：</p><pre tabindex=0><code>router.Handle(&#34;GET&#34;, &#34;/...&#34;, http.FileServer(SPAFileSystem{http.Dir(&#34;static&#34;)}))
</code></pre><pre tabindex=0><code>type SPAFileSystem struct {
    fs http.FileSystem
}

func (spa SPAFileSystem) Open(name string) (http.File, error) {
    f, err := spa.fs.Open(name)
    if err != nil {
        return spa.fs.Open(&#34;index.html&#34;)
    }
    return f, nil
}
</code></pre><p>这个伺服文件放在 <code>static</code> 下，配合 <code>static/index.html</code> 作为回调。</p><p>你可以使用你自己的服务器，但是你得在服务器上启用 <a href=https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS>CORS</a>。</p><h3 id=html>HTML</h3><p>我们来看一下那个 <code>static/index.html</code> 文件。</p><pre tabindex=0><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&#34;en&#34;&gt;
&lt;head&gt;
 &lt;meta charset=&#34;utf-8&#34;&gt;
 &lt;meta name=&#34;viewport&#34; content=&#34;width=device-width, initial-scale=1.0&#34;&gt;
 &lt;title&gt;Passwordless Demo&lt;/title&gt;
 &lt;link rel=&#34;shortcut icon&#34; href=&#34;data:,&#34;&gt;
 &lt;script src=&#34;/js/main.js&#34; type=&#34;module&#34;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>单页面应用程序的所有渲染由 JavaScript 来完成，因此，我们使用了一个空的 body 部分和一个 <code>main.js</code> 文件。</p><p>我们将使用 <a href=/article-9815-1.html>上篇文章</a> 中的 Router。</p><h3 id=渲染>渲染</h3><p>现在，我们使用下面的内容来创建一个 <code>static/js/main.js</code> 文件：</p><pre tabindex=0><code>import Router from &#39;https://unpkg.com/@nicolasparada/router&#39;
import { isAuthenticated } from &#39;./auth.js&#39;

const router = new Router()

router.handle(&#39;/&#39;, guard(view(&#39;home&#39;)))
router.handle(&#39;/callback&#39;, view(&#39;callback&#39;))
router.handle(/^\//, view(&#39;not-found&#39;))

router.install(async resultPromise =&gt; {
    document.body.innerHTML = &#39;&#39;
    document.body.appendChild(await resultPromise)
})

function view(name) {
    return (...args) =&gt; import(`/js/pages/${name}-page.js`)
        .then(m =&gt; m.default(...args))
}

function guard(fn1, fn2 = view(&#39;welcome&#39;)) {
    return (...args) =&gt; isAuthenticated()
        ? fn1(...args)
        : fn2(...args)
}
</code></pre><p>与上篇文章不同的是，我们实现了一个 <code>isAuthenticated()</code> 函数和一个 <code>guard()</code> 函数，使用它去渲染两种验证状态的页面。因此，当用户访问 <code>/</code> 时，它将根据用户是否通过了验证来展示主页或者是欢迎页面。</p><h3 id=验证>验证</h3><p>现在，我们来编写 <code>isAuthenticated()</code> 函数。使用下面的内容来创建一个 <code>static/js/auth.js</code> 文件：</p><pre tabindex=0><code>export function getAuthUser() {
    const authUserItem = localStorage.getItem(&#39;auth_user&#39;)
    const expiresAtItem = localStorage.getItem(&#39;expires_at&#39;)

    if (authUserItem !== null &amp;&amp; expiresAtItem !== null) {
        const expiresAt = new Date(expiresAtItem)

        if (!isNaN(expiresAt.valueOf()) &amp;&amp; expiresAt &gt; new Date()) {
            try {
                return JSON.parse(authUserItem)
            } catch (_) { }
        }
    }

    return null
}

export function isAuthenticated() {
    return localStorage.getItem(&#39;jwt&#39;) !== null &amp;&amp; getAuthUser() !== null
}
</code></pre><p>当有人登入时，我们将保存 JSON 格式的 web 令牌、它的过期日期，以及在 <code>localStorage</code> 上的当前已验证用户。这个模块就是这个用处。</p><ul><li><code>getAuthUser()</code> 用于从 <code>localStorage</code> 获取已认证的用户，以确认 JSON 格式的 Web 令牌没有过期。</li><li><code>isAuthenticated()</code> 在前面的函数中用于去检查它是否没有返回 <code>null</code>。</li></ul><h3 id=获取>获取</h3><p>在继续这个页面之前，我将写一些与服务器 API 一起使用的 HTTP 工具。</p><p>我们使用以下的内容去创建一个 <code>static/js/http.js</code> 文件：</p><pre tabindex=0><code>import { isAuthenticated } from &#39;./auth.js&#39;

function get(url, headers) {
    return fetch(url, {
        headers: Object.assign(getAuthHeader(), headers),
    }).then(handleResponse)
}

function post(url, body, headers) {
    return fetch(url, {
        method: &#39;POST&#39;,
        headers: Object.assign(getAuthHeader(), { &#39;content-type&#39;: &#39;application/json&#39; }, headers),
        body: JSON.stringify(body),
    }).then(handleResponse)
}

function getAuthHeader() {
    return isAuthenticated()
        ? { authorization: `Bearer ${localStorage.getItem(&#39;jwt&#39;)}` }
        : {}
}

export async function handleResponse(res) {
    const body = await res.clone().json().catch(() =&gt; res.text())
    const response = {
        statusCode: res.status,
        statusText: res.statusText,
        headers: res.headers,
        body,
    }
    if (!res.ok) {
        const message = typeof body === &#39;object&#39; &amp;&amp; body !== null &amp;&amp; &#39;message&#39; in body
            ? body.message
            : typeof body === &#39;string&#39; &amp;&amp; body !== &#39;&#39;
                ? body
                : res.statusText
        const err = new Error(message)
        throw Object.assign(err, response)
    }
    return response
}

export default {
    get,
    post,
}
</code></pre><p>这个模块导出了 <code>get()</code> 和 <code>post()</code> 函数。它们是 <code>fetch</code> API 的封装。当用户是已验证的，这二个函数注入一个 <code>Authorization: Bearer &lt;token_here></code> 头到请求中；这样服务器就能对我们进行身份验证。</p><h3 id=欢迎页>欢迎页</h3><p>我们现在来到欢迎页面。用如下的内容创建一个 <code>static/js/pages/welcome-page.js</code> 文件：</p><pre tabindex=0><code>const template = document.createElement(&#39;template&#39;)
template.innerHTML = `
    &lt;h1&gt;Passwordless Demo&lt;/h1&gt;
    &lt;h2&gt;Access&lt;/h2&gt;
    &lt;form id=&#34;access-form&#34;&gt;
        &lt;input type=&#34;email&#34; placeholder=&#34;Email&#34; autofocus required&gt;
        &lt;button type=&#34;submit&#34;&gt;Send Magic Link&lt;/button&gt;
    &lt;/form&gt;
`

export default function welcomePage() {
    const page = template.content.cloneNode(true)

    page.getElementById(&#39;access-form&#39;)
        .addEventListener(&#39;submit&#39;, onAccessFormSubmit)

    return page
}
</code></pre><p>这个页面使用一个 <code>HTMLTemplateElement</code> 作为视图。这只是一个输入用户 email 的简单表单。</p><p>为了避免干扰，我将跳过错误处理部分，只是将它们输出到控制台上。</p><p>现在，我们来写 <code>onAccessFormSubmit()</code> 函数。</p><pre tabindex=0><code>import http from &#39;../http.js&#39;

function onAccessFormSubmit(ev) {
    ev.preventDefault()

    const form = ev.currentTarget
    const input = form.querySelector(&#39;input&#39;)
    const email = input.value

    sendMagicLink(email).catch(err =&gt; {
        console.error(err)
        if (err.statusCode === 404 &amp;&amp; wantToCreateAccount()) {
            runCreateUserProgram(email)
        }
    })
}

function sendMagicLink(email) {
    return http.post(&#39;/api/passwordless/start&#39;, {
        email,
        redirectUri: location.origin + &#39;/callback&#39;,
    }).then(() =&gt; {
        alert(&#39;Magic link sent. Go check your email inbox.&#39;)
    })
}

function wantToCreateAccount() {
    return prompt(&#39;No user found. Do you want to create an account?&#39;)
}
</code></pre><p>它对 <code>/api/passwordless/start</code> 发起了 POST 请求，请求体中包含 <code>email</code> 和 <code>redirectUri</code>。在本例中它返回 <code>404 Not Found</code> 状态码时，我们将创建一个用户。</p><pre tabindex=0><code>function runCreateUserProgram(email) {
    const username = prompt(&#34;Enter username&#34;)
    if (username === null) return

    http.post(&#39;/api/users&#39;, { email, username })
        .then(res =&gt; res.body)
        .then(user =&gt; sendMagicLink(user.email))
        .catch(console.error)
}
</code></pre><p>这个用户创建程序，首先询问用户名，然后使用 email 和用户名做一个 <code>POST</code> 请求到 <code>/api/users</code>。成功之后，给创建的用户发送一个魔法链接。</p><h3 id=回调页>回调页</h3><p>这是访问表单的全部功能，现在我们来做回调页面。使用如下的内容来创建一个 <code>static/js/pages/callback-page.js</code> 文件：</p><pre tabindex=0><code>import http from &#39;../http.js&#39;

const template = document.createElement(&#39;template&#39;)
template.innerHTML = `
    &lt;h1&gt;Authenticating you&lt;/h1&gt;
`

export default function callbackPage() {
    const page = template.content.cloneNode(true)

    const hash = location.hash.substr(1)
    const fragment = new URLSearchParams(hash)
    for (const [k, v] of fragment.entries()) {
        fragment.set(decodeURIComponent(k), decodeURIComponent(v))
    }
    const jwt = fragment.get(&#39;jwt&#39;)
    const expiresAt = fragment.get(&#39;expires_at&#39;)

    http.get(&#39;/api/auth_user&#39;, { authorization: `Bearer ${jwt}` })
        .then(res =&gt; res.body)
        .then(authUser =&gt; {
            localStorage.setItem(&#39;jwt&#39;, jwt)
            localStorage.setItem(&#39;auth_user&#39;, JSON.stringify(authUser))
            localStorage.setItem(&#39;expires_at&#39;, expiresAt)

            location.replace(&#39;/&#39;)
        })
        .catch(console.error)

    return page
}
</code></pre><p>请记住……当点击魔法链接时，我们会来到 <code>/api/passwordless/verify_redirect</code>，它将把我们重定向到重定向 URI，我们将放在哈希中的 JWT 和过期日期传递给 <code>/callback</code>。</p><p>回调页面解码 URL 中的哈希，提取这些参数去做一个 <code>GET</code> 请求到 <code>/api/auth_user</code>，用 JWT 保存所有数据到 <code>localStorage</code> 中。最后，重定向到主页面。</p><h3 id=主页>主页</h3><p>创建如下内容的 <code>static/pages/home-page.js</code> 文件：</p><pre tabindex=0><code>import { getAuthUser } from &#39;../auth.js&#39;

export default function homePage() {
    const authUser = getAuthUser()

    const template = document.createElement(&#39;template&#39;)
    template.innerHTML = `
        &lt;h1&gt;Passwordless Demo&lt;/h1&gt;
        &lt;p&gt;Welcome back, ${authUser.username} 
</code></pre></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/%E6%97%A0%E5%AF%86%E7%A0%81/ rel=tag>无密码</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E9%AA%8C%E8%AF%81/ rel=tag>验证</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>