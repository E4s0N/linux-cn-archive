<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>如何在 Linux 上动态链接模块库 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="如何在 Linux 上动态链接模块库"><meta property="og:description" content="学习如何用动态链接库将多个 C 目标文件结合到一个单个的可执行文件之中。"><meta property="og:type" content="article"><meta property="og:url" content="/article-14813-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-07-10T18:26:07+00:00"><meta property="article:modified_time" content="2022-07-10T18:26:07+00:00"><meta itemprop=name content="如何在 Linux 上动态链接模块库"><meta itemprop=description content="学习如何用动态链接库将多个 C 目标文件结合到一个单个的可执行文件之中。"><meta itemprop=datePublished content="2022-07-10T18:26:07+00:00"><meta itemprop=dateModified content="2022-07-10T18:26:07+00:00"><meta itemprop=wordCount content="376"><meta itemprop=keywords content="动态链接,编译,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>如何在 Linux 上动态链接模块库</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2022-07-10T18:26:07Z>July 10, 2022</time></div></div></header><div class="content post__content clearfix"><blockquote><p>学习如何用动态链接库将多个 C 目标文件结合到一个单个的可执行文件之中。</p></blockquote><p><img src=/data/attachment/album/202207/10/182540caie7ldrefflffah.jpg alt></p><p>当使用 C 编程语言编写一个应用程序时，你的代码通常有多个源文件代码。</p><p>最终，这些文件必须被编译到一个单个的可执行文件之中。你可以通过创建静态或动态库（后者也被称为 共享 shared 库）来实现这一点。这两种类型的库在创建和链接的方式上有所不同。两者都有缺点和优点，这取决于你的使用情况。</p><p>动态链接是最常见的方法，尤其是在 Linux 系统上。动态链接会保持库模块化，因此，很多应用程序可以共享一个库。应用程序的模块化也允许单独更新其依赖的共享库。</p><p>在这篇文章中，我将演示动态链接是如何工作的。在后期的文章中，我将演示静态链接。</p><h3 id=链接器>链接器</h3><p>链接器 linker 是一个命令，它将一个程序的数个部分结合在一起，并为它们重新组织内存分配。</p><p>链接器的功能包括：</p><ul><li>整合一个程序的所有的部分</li><li>计算出一个新的内存组织结构，以便所有的部分组合在一起</li><li>恢复内存地址，以便程序可以在新的内存组织结构下运行</li><li>解析符号引用</li></ul><p>链接器通过这些功能，创建了一个名为 可执行文件 executable 的可以运行的程序。在你创建一个动态链接的可执行文件前，你需要一些用来链接的库，和一个用来编译的应用程序。准备好你 <a href=https://opensource.com/article/21/2/open-source-text-editors>最喜欢的文本编辑器</a> 并继续。</p><h3 id=创建目标文件>创建目标文件</h3><p>首先，创建带有这些函数签名的头文件 <code>mymath.h</code> ：</p><pre tabindex=0><code>int add(int a, int b);
int sub(int a, int b);
int mult(int a, int b);
int divi(int a, int b);
</code></pre><p>使用这些函数定义来创建 <code>add.c</code> 、<code>sub.c</code> 、<code>mult.c</code> 和 <code>divi.c</code> 文件。我将把所有的代码都放置到一个代码块中，请将其分为四个文件，如注释所示：</p><pre tabindex=0><code>// add.c
int add(int a, int b){
return (a+b);
}

//sub.c
int sub(int a, int b){
return (a-b);
}

//mult.c
int mult(int a, int b){
return (a*b);
}

//divi.c
int divi(int a, int b){
return (a/b);
}
</code></pre><p>现在，使用 GCC 来创建目标文件 <code>add.o</code>、<code>sub.o</code>、<code>mult.o</code> 和 <code>divi.o</code> ：</p><p>（LCTT 校注：关于“ 目标文件 object file ”，有时候也被称作“对象文件”，对此，存在一些译法混乱情形，称之为“目标文件”的译法比较流行，本文采用此译法。）</p><pre tabindex=0><code>$ gcc -c add.c sub.c mult.c divi.c
</code></pre><p><code>-c</code> 选项跳过链接步骤，并且只创建目标文件。</p><h3 id=创建一个共享的目标文件>创建一个共享的目标文件</h3><p>在最终的可执行文件的执行过程中将链接动态库。在最终的可执行文件中仅放置动态库的名称。实际上的链接过程发生在运行时，在此期间，可执行文件和库都被放置到了主内存中。</p><p>除了可共享外，动态库的另外一个优点是它减少了最终的可执行文件的大小。在一个应用程序最终的可执行文件生成时，其使用的库只包括该库的名称，而不是该库的一个多余的副本。</p><p>你可以从你现有的示例代码中创建动态库：</p><pre tabindex=0><code>$ gcc -Wall -fPIC -c add.c sub.c mult.c divi.c
</code></pre><p>选项 <code>-fPIC</code> 告诉 GCC 来生成 位置无关的代码 position-independent code （PIC）。<code>-Wall</code> 选项不是必需的，并且与代码的编译方式是无关的。不过，它却是一个有价值的选项，因为它会启用编译器警告，这在排除故障时是很有帮助的。</p><p>使用 GCC ，创建共享库 <code>libmymath.so</code> ：</p><pre tabindex=0><code>$ gcc -shared -o libmymath.so add.o sub.o mult.o divi.o
</code></pre><p>现在，你已经创建了一个简单的示例数学库 <code>libmymath.so</code> ，你可以在 C 代码中使用它。当然，也有非常复杂的 C 库，这就是他们这些开发者来生成最终产品的工艺流程，你和我可以安装这些库并在 C 代码中使用。</p><p>接下来，你可以在一些自定义代码中使用你的新数学库，然后链接它。</p><h3 id=创建一个动态链接的可执行文件>创建一个动态链接的可执行文件</h3><p>假设你已经为数学运算编写了一个命令。创建一个名称为 <code>mathDemo.c</code> 的文件，并将这些代码复制粘贴至其中：</p><pre tabindex=0><code>#include &lt;mymath.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
  int x, y;
  printf(&#34;Enter two numbers\n&#34;);
  scanf(&#34;%d%d&#34;,&amp;x,&amp;y);
 
  printf(&#34;\n%d + %d = %d&#34;, x, y, add(x, y));
  printf(&#34;\n%d - %d = %d&#34;, x, y, sub(x, y));
  printf(&#34;\n%d * %d = %d&#34;, x, y, mult(x, y));

  if(y==0){
    printf(&#34;\nDenominator is zero so can&#39;t perform division\n&#34;);
      exit(0);
  }else{
      printf(&#34;\n%d / %d = %d\n&#34;, x, y, divi(x, y));
      return 0;
  }
}
</code></pre><p>注意：第一行是一个 <code>include</code> 语句，通过名称来引用你自己的 <code>libmymath</code> 库。要使用一个共享库，你必须已经安装了它，如果你没有安装你将要使用的库，那么当你的可执行文件在运行并搜索其包含的库时，将找不到该共享库。如果你需要在不安装库到已知目录的情况下编译代码，这里有 <a href=https://opensource.com/article/22/5/compile-code-ldlibrarypath>一些方法可以覆盖默认设置</a>。不过，对于一般使用来说，我们希望库存在于已知的位置，因此，这就是我在这里演示的东西。</p><p>复制文件 <code>libmymath.so</code> 到一个标准的系统目录，例如：<code>/usr/lib64</code>， 然后运行 <code>ldconfig</code> 。<code>ldconfig</code> 命令创建所需的链接，并缓存到标准库目录中发现的最新共享库。</p><pre tabindex=0><code>$ sudo cp libmymath.so /usr/lib64/
$ sudo ldconfig
</code></pre><h3 id=编译应用程序>编译应用程序</h3><p>从你的应用程序源文件代码（<code>mathDemo.c</code>）中创建一个名称为 <code>mathDemo.o</code> 的目标文件：</p><pre tabindex=0><code>$ gcc -I . -c mathDemo.c
</code></pre><p><code>-I</code> 选项告诉 GCC 来在其后所列出的目录中搜索头文件（在这个示例中是 <code>mymath.h</code>）。在这个示例中，你指定的是当前目录，通过一个单点（<code>.</code>）来表示。创建一个可执行文件，使用 <code>-l</code> 选项来通过名称来引用你的共享数学库：</p><pre tabindex=0><code>$ gcc -o mathDynamic mathDemo.o -lmymath
</code></pre><p>GCC 会找到 <code>libmymath.so</code> ，因为它存在于一个默认的系统库目录中。使用 <code>ldd</code> 来查证所使用的共享库：</p><pre tabindex=0><code>$ ldd mathDemo
    linux-vdso.so.1 (0x00007fffe6a30000)
    libmymath.so =&gt; /usr/lib64/libmymath.so (0x00007fe4d4d33000)
    libc.so.6 =&gt; /lib64/libc.so.6 (0x00007fe4d4b29000)
    /lib64/ld-linux-x86-64.so.2 (0x00007fe4d4d4e000)
</code></pre><p>看看 <code>mathDemo</code> 可执行文件的大小：</p><pre tabindex=0><code>$ du ./mathDynamic
24   ./mathDynamic
</code></pre><p>当然，它是一个小的应用程序，它所占用的磁盘空间量也反映了这一点。相比之下，相同代码的一个静态链接版本（正如你将在我后期的文章所看到的一样）是 932K !</p><pre tabindex=0><code>$ ./mathDynamic
Enter two numbers
25
5

25 + 5 = 30
25 - 5 = 20
25 * 5 = 125
25 / 5 = 5
</code></pre><p>你可以使用 <code>file</code> 命令来查证它是动态链接的：</p><pre tabindex=0><code>$ file ./mathDynamic
./mathDynamic: ELF 64-bit LSB executable, x86-64,
dynamically linked,
interpreter /lib64/ld-linux-x86-64.so.2,
with debug_info, not stripped
</code></pre><p>成功！</p><h3 id=动态链接>动态链接</h3><p>因为链接发生在运行时，所以，使用一个共享库会产生一个轻量型的可执行文件。因为它在运行时解析引用，所以它会花费更多的执行时间。不过，因为在日常使用的 Linux 系统上绝大多数的命令是动态链接的，并且在现代硬件上，所能节省的时间是可以忽略不计的。对开发者和用户来说，它的固有模块性是一种强大的功能。</p><p>在这篇文章中，我描述了如何创建动态库，并将其链接到一个最终可执行文件。在我的下一篇文章中，我将使用相同的源文件代码来创建一个静态链接的可执行文件。</p><hr><p>via: <a href=https://opensource.com/article/22/5/dynamic-linking-modular-libraries-linux>https://opensource.com/article/22/5/dynamic-linking-modular-libraries-linux</a></p><p>作者：<a href=https://opensource.com/users/jayashree-huttanagoudar>Jayashree Huttanagoudar</a> 选题：<a href=https://github.com/lkxed>lkxed</a> 译者：<a href=https://github.com/robsean>robsean</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/ rel=tag>动态链接</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E7%BC%96%E8%AF%91/ rel=tag>编译</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>