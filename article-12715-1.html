<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>在脚本中使用 Bash 信号捕获 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="在脚本中使用 Bash 信号捕获"><meta property="og:description" content="无论你的脚本是否成功运行，信号捕获（trap）都能让它平稳结束。"><meta property="og:type" content="article"><meta property="og:url" content="/article-12715-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-10-13T18:22:31+00:00"><meta property="article:modified_time" content="2020-10-13T18:22:31+00:00"><meta itemprop=name content="在脚本中使用 Bash 信号捕获"><meta itemprop=description content="无论你的脚本是否成功运行，信号捕获（trap）都能让它平稳结束。"><meta itemprop=datePublished content="2020-10-13T18:22:31+00:00"><meta itemprop=dateModified content="2020-10-13T18:22:31+00:00"><meta itemprop=wordCount content="359"><meta itemprop=keywords content="信号,脚本,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>在脚本中使用 Bash 信号捕获</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2020-10-13T18:22:31Z>October 13, 2020</time></div></div></header><div class="content post__content clearfix"><blockquote><p>无论你的脚本是否成功运行， 信号捕获 trap 都能让它平稳结束。</p></blockquote><p><img src=/data/attachment/album/202010/13/182135f2nktcrnryncisg8.jpg alt></p><p>Shell 脚本的启动并不难被检测到，但 Shell 脚本的终止检测却并不容易，因为我们无法确定脚本会按照预期地正常结束，还是由于意外的错误导致失败。当脚本执行失败时，将正在处理的内容记录下来是非常有用的做法，但有时候这样做起来并不方便。而 <a href=https://opensource.com/resources/what-bash>Bash</a> 中 <code>trap</code> 命令的存在正是为了解决这个问题，它可以捕获到脚本的终止信号，并以某种预设的方式作出应对。</p><h3 id=响应失败>响应失败</h3><p>如果出现了一个错误，可能导致发生一连串错误。下面示例脚本中，首先在 <code>/tmp</code> 中创建一个临时目录，这样可以在临时目录中执行解包、文件处理等操作，然后再以另一种压缩格式进行打包：</p><pre tabindex=0><code>#!/usr/bin/env bash
CWD=`pwd`
TMP=${TMP:-/tmp/tmpdir}

## create tmp dir
mkdir &#34;${TMP}&#34;

## extract files to tmp
tar xf &#34;${1}&#34; --directory &#34;${TMP}&#34;

## move to tmpdir and run commands
pushd &#34;${TMP}&#34;
for IMG in *.jpg; do
  mogrify -verbose -flip -flop &#34;${IMG}&#34;
done
tar --create --file &#34;${1%.*}&#34;.tar *.jpg

## move back to origin
popd

## bundle with bzip2
bzip2 --compress &#34;${TMP}&#34;/&#34;${1%.*}&#34;.tar \
      --stdout &gt; &#34;${1%.*}&#34;.tbz

## clean up
/usr/bin/rm -r /tmp/tmpdir
</code></pre><p>一般情况下，这个脚本都可以按照预期执行。但如果归档文件中的文件是 PNG 文件而不是期望的 JPEG 文件，脚本就会在中途失败，这时候另一个问题就出现了：最后一步删除临时目录的操作没有被正常执行。如果你手动把临时目录删掉，倒是不会造成什么影响，但是如果没有手动把临时目录删掉，在下一次执行这个脚本的时候，它必须处理一个现有的临时目录，里面充满了不可预知的剩余文件。</p><p>其中一个解决方案是在脚本开头增加一个预防性删除逻辑用来处理这种情况。但这种做法显得有些暴力，而我们更应该从结构上解决这个问题。使用 <code>trap</code> 是一个优雅的方法。</p><h3 id=使用-trap-捕获信号>使用 trap 捕获信号</h3><p>我们可以通过 <code>trap</code> 捕捉程序运行时的信号。如果你使用过 <code>kill</code> 或者 <code>killall</code> 命令，那你就已经使用过名为 <code>SIGTERM</code> 的信号了。除此以外，还可以执行 <code>trap -l</code> 或 <code>trap --list</code> 命令列出其它更多的信号：</p><pre tabindex=0><code>$ trap --list
 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP
 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1
11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM
16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP
21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ
26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR
31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3
38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8
43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13
48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12
53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7
58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2
63) SIGRTMAX-1  64) SIGRTMAX
</code></pre><p>可以被 <code>trap</code> 识别的信号除了以上这些，还包括：</p><ul><li><code>EXIT</code>：进程退出时发出的信号</li><li><code>ERR</code>：进程以非 0 状态码退出时发出的信号</li><li><code>DEBUG</code>：表示调试模式的布尔值</li></ul><p>如果要在 Bash 中实现信号捕获，只需要在 <code>trap</code> 后加上需要执行的命令，再加上需要捕获的信号列表就可以了。</p><p>例如，下面的这行语句可以捕获到在进程运行时用户按下 <code>Ctrl + C</code> 组合键发出的 <code>SIGINT</code> 信号：</p><pre tabindex=0><code>trap &#34;{ echo &#39;Terminated with Ctrl+C&#39;; }&#34; SIGINT
</code></pre><p>因此，上文中脚本的缺陷可以通过使用 <code>trap</code> 捕获 <code>SIGINT</code>、<code>SIGTERM</code>、进程错误退出、进程正常退出等信号，并正确处理临时目录的方式来修复：</p><pre tabindex=0><code>#!/usr/bin/env bash
CWD=`pwd`
TMP=${TMP:-/tmp/tmpdir}

trap \
 &#34;{ /usr/bin/rm -r &#34;${TMP}&#34; ; exit 255; }&#34; \
 SIGINT SIGTERM ERR EXIT

## create tmp dir
mkdir &#34;${TMP}&#34;
tar xf &#34;${1}&#34; --directory &#34;${TMP}&#34;

## move to tmp and run commands
pushd &#34;${TMP}&#34;
for IMG in *.jpg; do
  mogrify -verbose -flip -flop &#34;${IMG}&#34;
done
tar --create --file &#34;${1%.*}&#34;.tar *.jpg

## move back to origin
popd

## zip tar
bzip2 --compress $TMP/&#34;${1%.*}&#34;.tar \
      --stdout &gt; &#34;${1%.*}&#34;.tbz
</code></pre><p>对于更复杂的功能，还可以用 <a href=https://opensource.com/article/20/6/how-write-functions-bash>Bash 函数</a>来简化 <code>trap</code> 语句。</p><h3 id=bash-中的信号捕获>Bash 中的信号捕获</h3><p>信号捕获可以让脚本在无论是否成功执行所有任务的情况下都能够正确完成清理工作，能让你的脚本更加可靠，这是一个很好的习惯。尽管尝试把信号捕获加入到你的脚本里看看能够起到什么作用吧。</p><hr><p>via: <a href=https://opensource.com/article/20/6/bash-trap>https://opensource.com/article/20/6/bash-trap</a></p><p>作者：<a href=https://opensource.com/users/seth>Seth Kenlon</a> 选题：<a href=https://github.com/lujun9972>lujun9972</a> 译者：<a href=https://github.com/HankChow>HankChow</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/%E4%BF%A1%E5%8F%B7/ rel=tag>信号</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E8%84%9A%E6%9C%AC/ rel=tag>脚本</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>