<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>在 GitLab 上构建 CI 流水线 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="在 GitLab 上构建 CI 流水线"><meta property="og:description" content="连续集成（CI）是指代码变更会被自动构建和测试。以下是我为自己的 C++ 项目构建 CI 流水线的过程。"><meta property="og:type" content="article"><meta property="og:url" content="/article-16105-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-08-18T09:45:11+00:00"><meta property="article:modified_time" content="2023-08-18T09:45:11+00:00"><meta itemprop=name content="在 GitLab 上构建 CI 流水线"><meta itemprop=description content="连续集成（CI）是指代码变更会被自动构建和测试。以下是我为自己的 C++ 项目构建 CI 流水线的过程。"><meta itemprop=datePublished content="2023-08-18T09:45:11+00:00"><meta itemprop=dateModified content="2023-08-18T09:45:11+00:00"><meta itemprop=wordCount content="306"><meta itemprop=keywords content="连续集成,CI,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>在 GitLab 上构建 CI 流水线</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2023-08-18T09:45:11Z>August 18, 2023</time></div></div></header><div class="content post__content clearfix"><blockquote><p>连续集成 continuous integration （CI）是指代码变更会被自动构建和测试。以下是我为自己的 C++ 项目构建 CI 流水线的过程。</p></blockquote><p><img src=https://img.linux.net.cn/data/attachment/album/202308/18/094419rahz9i5pk3n9fkkf.jpg alt></p><p>本文介绍如何在 <a href=https://gitlab.com/>GitLab</a> 上配置 CI 流水线。我在前面的文章中介绍了 <a href=/article-14249-1.html>基于 CMake 和 VSCodium 的构建系统</a> 和 <a href=/article-16055-1.html>基于 GoogleTest 和 CTest 的单元测试</a>。本文将在此基础上进一步配置 CI 流水线。我会先演示如何布设和运行 CI 流水线，然后再介绍如何配置它。</p><p>CI 是指提交到代码仓库的代码变更会被自动构建和测试。在开源领域，GitLab 是一个流行的 CI 流水线平台。除了作为中心 Git 仓库外，GitLab 还提供 CI/CD 流水线、 问题跟踪 issue tracking 和 容器注册表 container registry 功能。</p><h3 id=相关术语>相关术语</h3><p>在进入正题之前，我先介绍在本文和 <a href=https://docs.gitlab.com/>GitLab 文档</a> 中会遇到的常见术语。</p><ul><li>持续交付 continuous delivery （CD）：自动化供应软件，以供随时交付</li><li>持续部署 continuous deployment （CD）：自动化软件发布</li><li>流水线 pipeline : CI/CD 的直接构件，它由阶段和作业构成</li><li>阶段 stage ：一组作业</li><li>作业 job ：某项需要执行的具体任务，比如编译、单元测试等</li><li>执行器 runner ：实际执行作业的服务</li></ul><h3 id=布设-ci-流水线>布设 CI 流水线</h3><p>在下面的章节中，我将复用以前的 <a href=https://gitlab.com/hANSIc99/cpp_testing_sample>示例工程</a>。点击 GitLab 仓库页面右上角的 复刻 Fork 按钮复刻代码仓库。</p><p><img src=https://img.linux.net.cn/data/attachment/album/202308/18/094511lhmf7pofu4h3qpoq.png alt="Fork the project" title="Fork the project"></p><h4 id=设置执行器>设置执行器</h4><p>为了让你对整个流程有所了解，我们先从在本地安装执行器讲起。</p><p>参照执行器服务 <a href=https://docs.gitlab.com/runner/install/>安装指南</a> 安装好服务，然后注册执行器。</p><p>1、选择 GitLab 项目页面左侧的 设置 Settings ，再选择 <strong>CI/CD</strong>。</p><p><img src=https://img.linux.net.cn/data/attachment/album/202308/18/094511iu5kup3oztpqaeqx.png alt="Select CI/CD in Settings" title="Select CI/CD in Settings"></p><p>2、展开 执行器 Runners 区域，关闭 共享的执行器 Shared runners 选项（黄框处）。特别注意令牌和 URL（绿框处），下一步会用到它们。</p><p><img src=https://img.linux.net.cn/data/attachment/album/202308/18/094511djgq60t7a2209la2.png alt="Configure runner" title="Configure runner"></p><p>3、在终端中运行 <code>gitlab-runner register</code>，根据提示输入以下注册信息：</p><ul><li>GitLab 实例: <a href=https://gitlab.com/>https://gitlab.com/</a> （如上图）</li><li>注册令牌：从执行器区域中获取 （如上图）</li><li>描述：按需自由填写</li><li>标签：可以不填</li><li>执行环境：选 <strong>Shell</strong></li></ul><p>如果有需要，你可以在 <code>~/.gitlab-runner/config.toml</code> 中修改这些配置。</p><p>4、用命令 <code>gitlab-runner run</code> 启动执行器。你可以在 GitLab 的项目设置界面执行器区域看到执行器的状态：</p><p><img src=https://img.linux.net.cn/data/attachment/album/202308/18/094512cxejm3elepcqdj4q.png alt="Available specific runners" title="Available specific runners"></p><h3 id=运行流水线>运行流水线</h3><p>前面已经提过，流水线就是一组由执行器执行的作业。每个推送到 GitLab 的提交都会生成一个附加到该提交的流水线。如果多个提交被一起推送，那么只会为最后一个提交生成流水线。为了演示，我直接在 GitLab 在线编辑器中提交和推送修改。</p><p>打开 <code>README.md</code> 文件，添加一行数据：</p><p><img src=https://img.linux.net.cn/data/attachment/album/202308/18/094512s93ddz0m8dq9q9t5.png alt="Web editor" title="Web editor"></p><p>现在提交修改。</p><p>这里注意默认的行为是为提交新建一个分支，为了简便起见，我们择提交到主分支。</p><p><img src=https://img.linux.net.cn/data/attachment/album/202308/18/094513o2um2eq2ztxnteef.png alt="Commit changes" title="Commit changes"></p><p>提交后一会儿后，你就应该改能看到 GitLab 执行器执行的控制台中有输出消息：</p><pre tabindex=0><code>Checking for jobs... received job=1975932998 repo_url=&lt;https://gitlab.com/hANSIc99/cpp\_testing\_sample.git&gt; runner=Z7MyQsA6

Job succeeded duration_s=3.866619798 job=1975932998 project=32818130 runner=Z7MyQsA6
</code></pre><p>在 GitLab 项目概览界面左侧选择 CI/CD &ndash;> 管道 Pipelines ，查看最近执行的流水线：</p><p><img src=https://img.linux.net.cn/data/attachment/album/202308/18/094513k34ibi0gee9z069e.png alt="Pipeline overview" title="Pipeline overview"></p><p>选中流水线可以在详情界面看到哪些作业失败了，并能查看各个作业的输出。</p><p>当遇到非零返回值是就认为作业执行失败了。在下面的例子中我通过调用 <code>exit 1</code> 强制让作业执行失败：</p><p><img src=https://img.linux.net.cn/data/attachment/album/202308/18/094513cayxee5yhyyrhzh1.png alt="Job overview" title="Job overview"></p><h3 id=ci-配置>CI 配置</h3><p>阶段、流水线和作业的配置都在仓库根目录的 <a href=https://gitlab.com/hANSIc99/cpp_testing_sample/-/blob/main/.gitlab-ci.yml>.gitlab-ci.yml</a> 文件中。我建议使用 GitLab 内置的流水线编辑器，它会自动对配置进行检查。</p><pre tabindex=0><code>stages:
- build
- test

build:
  stage: build
  script:
    - cmake -B build -S .
    - cmake --build build --target Producer
  artifacts:
    paths:
      - build/Producer

RunGTest:
  stage: test
  script:
    - cmake -B build -S .
    - cmake --build build --target GeneratorTest
    - build/Generator/GeneratorTest

RunCTest:
  stage: test
  script:
    - cmake -B build -S .
    - cd build
    - ctest --output-on-failure -j6
</code></pre><p>文件中定义了两个阶段：<code>build</code> 和 <code>test</code>，以及三个作业：<code>build</code>、<code>RunGTest</code> 和 <code>RunCTest</code>。其中作业 <code>build</code> 属于一个同名的阶段，另外两个作业属于阶段 <code>test</code>。</p><p><code>script</code> 小节下的命令就是一般的 Shell 命令。你可以认为是将它们逐行输入到 Shell 中。</p><p>我要特别提及 产物artifact 这个特性。在示例中我定义了二进制的 <code>Producer</code> 为作业 <code>build</code> 的产物。产物会被上传到 GitLab 服务器，并且可以从服务器的这个页面上被下载：</p><p><img src=https://img.linux.net.cn/data/attachment/album/202308/18/094514rmjn5hm90m995ojz.png alt="Pipeline artifacts" title="Pipeline artifacts"></p><p>默认情况下，后续阶段的作业会自动下载先前阶段作业生成的所有产物。</p><p>你可以在 <a href=https://docs.gitlab.com/ee/ci/yaml/>docs.gitlab.com</a> 上查看 <code>gitlab-ci.yml</code> 参考指南。</p><h3 id=总结>总结</h3><p>上面只是一个最基本的例子，让你对持续集成的一般原则有一个了解。再演示中我禁用了共享执行器，然而这才是 GitLab 的优势所在。你可以在一个干净的容器化的环境中构架、测试和部署程序。除了使用 GitLab 提供的免费执行器，你也可以用自己的容器作为执行器。当然还有更高阶的用法：用 Kubernetes 来协调调度执行者容器，让流水线适应大规模使用的使用场景。如需进一步了解，可以查看 <a href=https://about.gitlab.com/solutions/kubernetes/>about.gitlab.com</a>。</p><p>如果你使用的是 Fedora，需要注意的一点是目前 GitLab 执行者还不支持用 Podman 作为容器引擎。（LCTT 译注：Podman 是 Fedora 自带的容器引擎。）根据 议题 issue <a href=https://gitlab.com/gitlab-org/gitlab-runner/-/issues/27119>#27119</a>，对 Podman 支持已将列上日程。（LCTT 译注：Podman 4.2 及以上版本增加了对于 GitLab 执行器的支持。）</p><p>把重复性的操作描述成作业，并将作业合并成流水线和阶段，可以让你跟踪它们的质量而不增加额外工作。。特别是在大型社区项目中，适当配置的 CI 可以告诉你提交的代码是否对项目有改善，为你接受或拒绝合并请求提供依据。</p><p><em>（题图：MJ/fb711c48-251a-4726-a41c-247370e5df25）</em></p><hr><p>via: <a href=https://opensource.com/article/22/2/setup-ci-pipeline-gitlab>https://opensource.com/article/22/2/setup-ci-pipeline-gitlab</a></p><p>作者：<a href=https://opensource.com/users/hansic99>Stephan Avenwedde</a> 选题：<a href=https://github.com/lujun9972>lujun9972</a> 译者：<a href=https://github.com/toknow-gh>toknow-gh</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/%E8%BF%9E%E7%BB%AD%E9%9B%86%E6%88%90/ rel=tag>连续集成</a></li><li class=tags__item><a class="tags__link btn" href=/tags/ci/ rel=tag>CI</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>