<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Git Rebase教程： 用Git Rebase让时光倒流 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="Git Rebase教程： 用Git Rebase让时光倒流"><meta property="og:description" content="想象一下你正在开发一个激进的新功能。这将是很灿烂的但它需要一段时间。您这几天也许是几个星期一直在做这个。  你的功能分支已经超前master有6个提交了。你是一个优秀的开发人员并做了有意义的语义提交。但有一件事情：你开始慢慢意识到，这个疯狂的东西仍需要更多的时间才能真的做好准备被合并回主分支。 m1-m2-m3-m4 (master) \ f1-f2-f3-f4-f5-f6(feature)  你也知道的是，一些地方实际上是交叉不大的新功能。它们可以更早地合并到主分支。不幸的是，你想将部分合并到主分支的内容存在于你六个提交中的某个地方。更糟糕的是，它也包"><meta property="og:type" content="article"><meta property="og:url" content="/article-4046-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2014-10-20T12:04:00+00:00"><meta property="article:modified_time" content="2014-10-20T12:04:00+00:00"><meta itemprop=name content="Git Rebase教程： 用Git Rebase让时光倒流"><meta itemprop=description content="想象一下你正在开发一个激进的新功能。这将是很灿烂的但它需要一段时间。您这几天也许是几个星期一直在做这个。  你的功能分支已经超前master有6个提交了。你是一个优秀的开发人员并做了有意义的语义提交。但有一件事情：你开始慢慢意识到，这个疯狂的东西仍需要更多的时间才能真的做好准备被合并回主分支。 m1-m2-m3-m4 (master) \ f1-f2-f3-f4-f5-f6(feature)  你也知道的是，一些地方实际上是交叉不大的新功能。它们可以更早地合并到主分支。不幸的是，你想将部分合并到主分支的内容存在于你六个提交中的某个地方。更糟糕的是，它也包"><meta itemprop=datePublished content="2014-10-20T12:04:00+00:00"><meta itemprop=dateModified content="2014-10-20T12:04:00+00:00"><meta itemprop=wordCount content="101"><meta itemprop=keywords content="git,git rebase,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>Git Rebase教程： 用Git Rebase让时光倒流</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-10-20T12:04:00Z>October 20, 2014</time></div></div></header><div class="content post__content clearfix"><p>想象一下你正在开发一个激进的新功能。这将是很灿烂的但它需要一段时间。您这几天也许是几个星期一直在做这个。</p><p><img src=/data/attachment/album/201410/20/120426xxp4qkbxm5vqylk4.jpg alt></p><p>你的功能分支已经超前master有6个提交了。你是一个优秀的开发人员并做了有意义的语义提交。但有一件事情：你开始慢慢意识到，这个疯狂的东西仍需要更多的时间才能真的做好准备被合并回主分支。</p><pre tabindex=0><code>m1-m2-m3-m4 (master)
     \ 
      f1-f2-f3-f4-f5-f6(feature)
</code></pre><p>你也知道的是，一些地方实际上是交叉不大的新功能。它们可以更早地合并到主分支。不幸的是，你想将部分合并到主分支的内容存在于你六个提交中的某个地方。更糟糕的是，它也包含了依赖于你的功能分支的之前的提交。有人可能会说，你应该在第一处地方做两次提交，但没有人是完美的。</p><pre tabindex=0><code>m1-m2-m3-m4 (master)
     \ 
      f1-f2-f3-f4-f5-f6(feature)
             ^
             |
        mixed commit
</code></pre><p>在你准备提交的时间，你没有预见到，你可能要逐步把该功能合并入主分支。哎呀！你不会想到这件事会有这么久。</p><p>你需要的是一种方法可以回溯历史，把它并分成两次提交，这样就可以把代码都安全地分离出来，并可以移植到master分支。</p><p>用图说话，就是我们需要这样。</p><pre tabindex=0><code>m1-m2-m3-m4 (master)
     \ 
      f1-f2-f3a-f3b-f4-f5-f6(feature)
</code></pre><p>在将工作分成两个提交后，我们就可以cherry-pick出前面的部分到主分支了。</p><p>原来Git自带了一个功能强大的命令git rebase -i ，它可以让我们这样做。它可以让我们改变历史。改变历史可能会产生问题，作为一个经验，应尽快避免历史与他人共享。不过在我们的例子中，我们只是改变我们的本地功能分支的历史。没有人会受到伤害。就这么做了！</p><p>好吧，让我们来仔细看看f3提交究竟修改了什么。原来我们共修改了两个文件：userService.js和wishlistService.js。比方说，userService.js的更改可以直接合入主分支而wishlistService.js不能。因为wishlistService.js甚至不存在在主分支里面。它是f1提交中引入的。</p><blockquote><p>专家提示：即使是在一个文件中更改，git也可以搞定。但这篇博客中我们先简化情况。</p></blockquote><p>我们已经建立了一个<a href=https://github.com/thoughtram/interactive-rebase-demo>公众演示仓库</a>，我们将使用这个来练习。为了便于跟踪，每一个提交信息的前缀是在上面的图表中使用的假的SHA。以下是git在分开提交f3时的分支图。</p><p><img src=/data/attachment/album/201410/20/120821pe9ozqp9xbiqnohd.png alt></p><p>现在，我们要做的第一件事就是使用git的checkout功能checkout出我们的功能分支。用git rebase -i master开始做rebase。</p><p>现在接下来git会用所配置的编辑器打开（默认为Vim）一个临时文件。</p><p><img src=/data/attachment/album/201410/20/120834wb2iizwkkkukaazz.png alt></p><p>该文件为您提供一些rebase选择，它带有一个提示（蓝色文字）。对于每一个提交，我们可以选择的动作有pick、rwork、edit、squash、fixup和exec。每一个动作也可以通过它的缩写形式p、r、e、s、f和e引用。描述每一个选项超出了本文范畴，所以让我们专注于我们的具体任务。</p><p>我们要为f3提交选择edit选项，因此我们把内容改变成这样。</p><p><img src=/data/attachment/album/201410/20/120848p8h8khxnupur0tt0.png alt></p><p>现在我们保存文件（在Vim中是按下后输入:wq,最后是按下回车）。接下来我们注意到git在编辑选项中选择的提交处停止了rebase。</p><p><img src=/data/attachment/album/201410/20/120859uhvo4634w33ww68e.jpg alt></p><p>这意味这git开始将f1、f2、f3生效仿佛它就是常规的rebase，但是在f3生效<strong>之后</strong>停止。事实上，我们可以看一眼停止的地方的日志就可以证明这一点。</p><p><img src=/data/attachment/album/201410/20/120912rbjdbljxtjadtesz.png alt></p><p>要将f3分成两个提交，我们所要做的是重置git的指针到先前的提交（f2）而保持工作目录和现在一样。这就是git reset在混合模式在做的。由于混合模式是git reset的默认模式，我们可以直接用git reset head~1。就这么做并在运行后用git status看下发生了什么。</p><p><img src=/data/attachment/album/201410/20/120926sk0cqui0iutzucic.png alt></p><p>git status告诉我们userService.js和wishlistService.js被修改了。如果我们运行 git diff 我们就可以看见在f3里面确切地做了哪些更改。</p><p><img src=/data/attachment/album/201410/20/120940o0ibunmo3nm49n3u.png alt></p><p>如果我们看一眼日志我们会发现f3已经消失了。</p><p><img src=/data/attachment/album/201410/20/120955eib8s88ic6bm8qzz.png alt></p><p>现在我们有了准备提交的先前的f3提交，而原先的f3提交已经消失了。记住虽然我们仍旧在rebase的中间过程。我们的f4、f5、f6提交还没有缺失，它们会在接下来回来。</p><p>让我们创建两个新的提交：首先让我们为可以提交到主分支的userService.js创建一个提交。运行git add userService.js 接着运行 git commit -m &ldquo;f3a: add updateUser method&rdquo;。</p><p>太棒了！让我们为wishlistService.js的改变创建另外一个提交。运行git add wishlistService.js，接着运行git commit -m &ldquo;f3b: add addItems method&rdquo;.</p><p>让我们在看一眼日志。</p><p><img src=/data/attachment/album/201410/20/121007qqd5ippt4a4zihth.png alt></p><p>这就是我们想要的，除了f4、f5、f6仍旧缺失。这是因为我们仍在rebase交互的中间，我们需要告诉git继续rebase。用下面的命令继续：git rebase &ndash;continue。</p><p>让我们再次检查一下日志。</p><p><img src=/data/attachment/album/201410/20/121019t1421s43bbv7yks4.png alt></p><p>就是这样。我们现在已经得到我们想要的历史了。先前的f3提交现在已经被分割成两个提交f3a和f3b。剩下的最后一件事是cherry-pick出f3a提交到主分支上。</p><p>为了完成最后一步，我们首先切换到主分支。我们用git checkout master。现在我们就可以用cherry-pick命令来拾取f3a commit了。本例中我们可以用它的SHA值bd47ee1来引用它。</p><p><img src=/data/attachment/album/201410/20/121042xwprfo2ileil8qzl.png alt></p><p>现在f3a这个提交就在主分支的最上面了。这就是我们需要的！</p><p><img src=/data/attachment/album/201410/20/121052f2c0o2lo7oqh2z9a.png alt></p><p>这篇文章的长度看起来需要花费很大的功夫，但实际上对于一个git高级用户而言这只是一会会。</p><blockquote><p>注：Christoph目前正在与Pascal Precht写一本关于<a href=https://leanpub.com/rebase-the-complete-guide-on-rebasing-in-git>Git rebase</a>的书，您可以在leanpub订阅它并在准备出版时获得通知。</p></blockquote><p><img src=/data/attachment/album/201410/20/121119uq7zdx4tbz7ohxfb.jpeg alt></p><p>本文作者 Christoph Burgdorf自10岁时就是一名程序员，他是HannoverJS Meetup网站的创始人，并且一直活跃在AngularJS社区。他也是非常了解gti的内内外外，在那里他举办一个<a href=http://thoughtram.io/>thoughtram</a>的工作室来帮助初学者掌握该技术。</p><p>本的教程最初发表在他的<a href=http://blog.thoughtram.io/posts/going-back-in-time-to-split-older-commits/>blog</a>。</p><hr><p>via: <a href=https://www.codementor.io/git-tutorial/git-rebase-split-old-commit-master>https://www.codementor.io/git-tutorial/git-rebase-split-old-commit-master</a></p><p>作者：<a href=https://www.codementor.io/cburgdorf>cburgdorf</a> 译者：<a href=https://github.com/geekpi>geekpi</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创翻译，<a href=http://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/git/ rel=tag>git</a></li><li class=tags__item><a class="tags__link btn" href=/tags/git-rebase/ rel=tag>git rebase</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>