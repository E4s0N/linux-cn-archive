<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>优化 Kubernetes 中的 Java 无服务器函数 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="优化 Kubernetes 中的 Java 无服务器函数"><meta property="og:description" content="在 Kubernetes 中运行无服务器函数时，实现更快的启动速度和更小的内存占用。"><meta property="og:type" content="article"><meta property="og:url" content="/article-15178-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-10-26T15:16:34+00:00"><meta property="article:modified_time" content="2022-10-26T15:16:34+00:00"><meta itemprop=name content="优化 Kubernetes 中的 Java 无服务器函数"><meta itemprop=description content="在 Kubernetes 中运行无服务器函数时，实现更快的启动速度和更小的内存占用。"><meta itemprop=datePublished content="2022-10-26T15:16:34+00:00"><meta itemprop=dateModified content="2022-10-26T15:16:34+00:00"><meta itemprop=wordCount content="415"><meta itemprop=keywords content="Kubernetes,无服务器,Quarkus,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>优化 Kubernetes 中的 Java 无服务器函数</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2022-10-26T15:16:34Z>October 26, 2022</time></div></div></header><div class="content post__content clearfix"><blockquote><p>在 Kubernetes 中运行无服务器函数时，实现更快的启动速度和更小的内存占用。</p></blockquote><p><img src=/data/attachment/album/202210/26/151603a4a44w1a71zk8b11.jpg alt title="Ship captain sailing the Kubernetes seas"></p><p>由于运行上千个应用程序 容器荚 Pod 所耗费的资源多，令它实现较少工作节点和资源占用所需成本也较高，所以在使用 <a href=https://opensource.com/article/19/6/reasons-kubernetes>Kubernetes</a> 时，快速启动和较少的内存占用是至关重要的。在 Kubernetes 平台运行容器化微服务时，内存占用是比吞吐量更重要的考量因素，这是因为：</p><ul><li>由于需要持续运行，所以耗费资源更多（不同于 CPU 占用）</li><li>微服务令开销成本成倍增加</li><li>一个单体应用程序变为若干个微服务的情况（例如 20 个微服务占用的存储空间约有 20GB）</li></ul><p>这些情况极大影响了无服务器函数的发展和 Java 部署模型。到目前为止，许多企业开发人员选择 Go、Python 或 Node.js 这些替代方案来解决性能瓶颈，直到出现了 <a href=https://quarkus.io/>Quarkus</a> 这种基于 kubernetes 的原生 Java 堆栈，才有所改观。本文介绍如何在使用了 Quarkus 的 kubernetes 平台上进行性能优化，以便运行无服务器函数。</p><h3 id=容器优先的设计理念>容器优先的设计理念</h3><p>由于 Java 生态系统中传统的框架都要进行框架的初始化，包括配置文件的处理、<code>classpath</code> 的扫描、类加载、注解的处理以及构建元模型，这些过程都是必不可少的，所以它们都比较耗费资源。如果使用了几种不同的框架，所耗费的资源也是成倍增加。</p><p>Quarkus 通过“ 左移 shifting left ”，把所有的资源开销大的操作都转移到构建阶段，解决了这些 Java 性能问题。在构建阶段进行代码和框架分析、字节码转换和动态元模型生成，而且只有一次，结果是：运行时可执行文件经过高度优化，启动非常快，不需要经过那些传统的启动过程，全过程只在构建阶段执行一次。</p><p><img src=/data/attachment/album/202210/26/151634r3l3gzbp27bkke0f.png alt="Quarkus Build phase" title="Quarkus Build phase"></p><p>更重要的是：Quarkus 支持构建原生可执行文件，它具有良好性能，包括快速启动和极小的 驻留集大小 resident set size （RSS）内存占用，跟传统的云原生 Java 栈相比，具备即时扩展的能力和高密度的内存利用。</p><p><img src=/data/attachment/album/202210/26/151635p95d33596ilju4rd.png alt="Quarkus RSS and Boot Time Metrics" title="Quarkus RSS and Boot Time Metrics"></p><p>这里有个例子，展示如何使用 Quarkus 将一个 <a href=https://opensource.com/article/21/5/what-serverless-java>Java 无服务器</a> 项目构建为本地可执行文件。</p><h3 id=1使用-quarkus-创建无服务器-maven-项目>1、使用 Quarkus 创建无服务器 Maven 项目</h3><p>以下命令生成一个 Quarkus 项目，（例如 <code>quarkus-serverless-native</code>）以此创建一个简单的函数：</p><pre tabindex=0><code>$ mvn io.quarkus:quarkus-maven-plugin:1.13.4.Final:create \
       -DprojectGroupId=org.acme \
       -DprojectArtifactId=quarkus-serverless-native \
       -DclassName=&#34;org.acme.getting.started.GreetingResource&#34;
</code></pre><h3 id=2构建一个本地可执行文件>2、构建一个本地可执行文件</h3><p>你需要使用 GraalVM 为 Java 程序构建一个本地可执行文件。你可以选择 GraalVM 的任何发行版，例如 <a href=https://www.graalvm.org/community/>Oracle GraalVM Community Edition (CE)</a> 或 <a href=https://github.com/graalvm/mandrel>Mandrel</a>（Oracle GraalVM CE 的下游发行版）。Mandrel 是为支持 OpenJDK 11 上的 Quarkus-native 可执行文件的构建而设计的。</p><p>打开 <code>pom.xml</code>，你将发现其中的 <code>native</code> 设置。你将使用它来构建本地可执行文件。</p><pre tabindex=0><code>&lt;profiles&gt;
    &lt;profile&gt;
        &lt;id&gt;native&lt;/id&gt;
        &lt;properties&gt;
            &lt;quarkus.package.type&gt;native&lt;/quarkus.package.type&gt;
        &lt;/properties&gt;
    &lt;/profile&gt;
&lt;/profiles&gt;
</code></pre><blockquote><p><strong>注意：</strong> 你可以在本地安装 GraalVM 或 Mandrel 发行版。你也可以下载 Mandrel 容器映像来构建它（像我那样），因此你还需要在本地运行一个容器引擎（例如 Docker）。</p></blockquote><p>假设你已经打开了容器运行时，此时需要运行一下 Maven 命令：</p><p>使用 <a href=https://www.docker.com/>Docker</a> 作为容器引擎：</p><pre tabindex=0><code>$ ./mvnw package -Pnative \
  -Dquarkus.native.container-build=true \
  -Dquarkus.native.container-runtime=docker
</code></pre><p>使用 <a href=https://podman.io/>Podman</a> 作为容器引擎：</p><pre tabindex=0><code>$ ./mvnw package -Pnative \
  -Dquarkus.native.container-build=true \
  -Dquarkus.native.container-runtime=podman
</code></pre><p>输出信息结尾应当是 <code>BUILD SUCCESS</code>。</p><p><img src=/data/attachment/album/202210/26/151635iuy2m9l5zul5zu5i.png alt="Native Build Logs" title="Native Build Logs"></p><p>不借助 JVM 直接运行本地可执行文件：</p><pre tabindex=0><code>$ target/quarkus-serverless-native-1.0.0-SNAPSHOT-runner
</code></pre><p>输出信息类似于：</p><pre tabindex=0><code>__  ____  __  _____   ___  __ ____  ______
 --/ __ \/ / / / _ | / _ \/ //_/ / / / __/
 -/ /_/ / /_/ / __ |/ , _/ ,&lt; / /_/ /\ \  
--\___\_\____/_/ |_/_/|_/_/|_|\____/___/  
INFO  [io.quarkus] (main) quarkus-serverless-native 1.0.0-SNAPSHOT native
(powered by Quarkus xx.xx.xx.) Started in 0.019s. Listening on: http://0.0.0.0:8080
INFO [io.quarkus] (main) Profile prod activated.
INFO [io.quarkus] (main) Installed features: [cdi, kubernetes, resteasy]
</code></pre><p>简直是超音速！启动只花了 19 毫秒。你的运行时间可能稍有不同。</p><p>使用 Linux 的 <code>ps</code> 工具检测一下，结果内存占用还是很低。检测的方法是：在应用程序运行期间，另外打开一个终端，运行如下命令：</p><pre tabindex=0><code>$ ps -o pid,rss,command -p $(pgrep -f runner)
</code></pre><p>输出结果类似于：</p><pre tabindex=0><code>  PID    RSS COMMAND
10246  11360 target/quarkus-serverless-native-1.0.0-SNAPSHOT-runner
</code></pre><p>该进程只占 11MB 内存。非常小！</p><blockquote><p><strong>注意:</strong> 各种应用程序（包括 Quarkus）的驻留集大小和内存占用，都因运行环境而异，并随着应用程序载入而上升。</p></blockquote><p>你也可以使用 REST API 访问这个函数。输出结果应该是 <code>Hello RESTEasy</code>:</p><pre tabindex=0><code>$ curl localhost:8080/hello
Hello RESTEasy
</code></pre><h3 id=3把函数部署到-knative-服务>3、把函数部署到 Knative 服务</h3><p>如果你还没有创建命名空间，现在就在 <a href=https://docs.okd.io/latest/welcome/index.html>OKD</a>（OpenShift Kubernetes 发行版）<a href=https://docs.okd.io/latest/applications/projects/configuring-project-creation.html>创建一个命名空间</a>（例如 <code>quarkus-serverless-native</code>），进而把这个本地可执行文件部署为无服务器函数。然后添加 <code>quarkus-openshift</code> 扩展：</p><pre tabindex=0><code>$ ./mvnw -q quarkus:add-extension -Dextensions=&#34;openshift&#34;
</code></pre><p>向 <code>src/main/resources/application.properties</code> 文件中添加以下内容，配置 Knative 和 Kubernetes 的相关资源：</p><pre tabindex=0><code>quarkus.container-image.group=quarkus-serverless-native
quarkus.container-image.registry=image-registry.openshift-image-registry.svc:5000
quarkus.native.container-build=true
quarkus.kubernetes-client.trust-certs=true
quarkus.kubernetes.deployment-target=knative
quarkus.kubernetes.deploy=true
quarkus.openshift.build-strategy=docker
</code></pre><p>构建本地可执行文件，并把它直接部署到 OKD 集群：</p><pre tabindex=0><code>$ ./mvnw clean package -Pnative
</code></pre><blockquote><p><strong>注意：</strong> 提前使用 <code>oc login</code> 命令，确保登录的是正确的项目（例如 <code>quarkus-serverless-native</code>）。</p></blockquote><p>输出信息结尾应当是 <code>BUILD SUCCESS</code>。完成一个本地二进制文件的构建并部署为 Knative 服务需要花费几分钟。成功创建服务后，使用 <code>kubectl</code> 或 <code>oc</code> 命令工具，可以查看 Knative 服务和版本信息：</p><pre tabindex=0><code>$ kubectl get ksvc
NAME                        URL   [...]
quarkus-serverless-native   http://quarkus-serverless-native-[...].SUBDOMAIN  True

$ kubectl get rev
NAME                              CONFIG NAME                 K8S SERVICE NAME                  GENERATION   READY   REASON
quarkus-serverless-native-00001   quarkus-serverless-native   quarkus-serverless-native-00001   1            True
</code></pre><h3 id=4访问本地可执行函数>4、访问本地可执行函数</h3><p>运行 <code>kubectl</code> 命令，搜索无服务器函数的节点：</p><pre tabindex=0><code>$ kubectl get rt/quarkus-serverless-native
</code></pre><p>输出信息类似于：</p><pre tabindex=0><code>NAME                         URL                                                                                                          READY   REASON
quarkus-serverless-native   http://quarkus-serverless-restapi-quarkus-serverless-native.SUBDOMAIN   True
</code></pre><p>用 <code>curl</code> 命令访问上述信息中的 <code>URL</code> 字段：</p><pre tabindex=0><code>$ curl http://quarkus-serverless-restapi-quarkus-serverless-native.SUBDOMAIN/hello
</code></pre><p>过了不超过一秒钟，你也会得到跟本地操作一样的结果：</p><pre tabindex=0><code>Hello RESTEasy
</code></pre><p>当你在 OKD 群集中访问 Quarkus 运行中的节点的日志，你会发现本地可执行文件正在以 Knative 服务的形式运行。</p><p><img src=/data/attachment/album/202210/26/151635hrov9o2fwvfwlrwl.png alt="Native Quarkus Log" title="Native Quarkus Log"></p><h3 id=下一步呢>下一步呢？</h3><p>你可以借助 GraalVM 发行版优化 Java 无服务器函数，从而在 Knative 中使用 Kubernetes 将它们部署为无服务器函数。Quarkus 支持在普通的微服务中使用简易配置进行性能优化。</p><p>本系列的下一篇文章将指导你在不更改代码的情况下跨多个无服务器平台实现可移植函数。</p><p><em>(Daniel Oh, <a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA 4.0</a>)</em></p><hr><p>via: <a href=https://opensource.com/article/21/6/java-serverless-functions-kubernetes>https://opensource.com/article/21/6/java-serverless-functions-kubernetes</a></p><p>作者：<a href=https://opensource.com/users/daniel-oh>Daniel Oh</a> 选题：<a href=https://github.com/lujun9972>lujun9972</a> 译者：<a href=https://github.com/cool-summer-021>cool-summer-021</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/kubernetes/ rel=tag>Kubernetes</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E6%97%A0%E6%9C%8D%E5%8A%A1%E5%99%A8/ rel=tag>无服务器</a></li><li class=tags__item><a class="tags__link btn" href=/tags/quarkus/ rel=tag>Quarkus</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>