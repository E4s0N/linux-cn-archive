<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Linux DNS 查询剖析（第四部分） - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="Linux DNS 查询剖析（第四部分）"><meta property="og:description" content="在第四部分中，我将介绍容器如何完成 DNS 查询。你想的没错，也不是那么简单。"><meta property="og:type" content="article"><meta property="og:url" content="/article-10056-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-09-27T22:02:33+00:00"><meta property="article:modified_time" content="2018-09-27T22:02:33+00:00"><meta itemprop=name content="Linux DNS 查询剖析（第四部分）"><meta itemprop=description content="在第四部分中，我将介绍容器如何完成 DNS 查询。你想的没错，也不是那么简单。"><meta itemprop=datePublished content="2018-09-27T22:02:33+00:00"><meta itemprop=dateModified content="2018-09-27T22:02:33+00:00"><meta itemprop=wordCount content="404"><meta itemprop=keywords content="DNS,容器,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>Linux DNS 查询剖析（第四部分）</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2018-09-27T22:02:33Z>September 27, 2018</time></div></div></header><div class="content post__content clearfix"><p><img src=/data/attachment/album/201809/27/220200ozwwbwyizwydadi0.jpeg alt></p><p>在 <a href=/article-9943-1.html>Linux DNS 查询剖析（第一部分）</a>，<a href=/article-9949-1.html>Linux DNS 查询剖析（第二部分）</a> 和 <a href=/article-9972-1.html>Linux DNS 查询剖析（第三部分）</a> 中，我们已经介绍了以下内容：</p><ul><li><code>nsswitch</code></li><li><code>/etc/hosts</code></li><li><code>/etc/resolv.conf</code></li><li><code>ping</code> 与 <code>host</code> 查询方式的对比</li><li><code>systemd</code> 和对应的 <code>networking</code> 服务</li><li><code>ifup</code> 和 <code>ifdown</code></li><li><code>dhclient</code></li><li><code>resolvconf</code></li><li><code>NetworkManager</code></li><li><code>dnsmasq</code></li></ul><p>在第四部分中，我将介绍容器如何完成 DNS 查询。你想的没错，也不是那么简单。</p><h3 id=1-docker-和-dns>1) Docker 和 DNS</h3><p>在 <a href=/article-9972-1.html>Linux DNS 查询剖析（第三部分）</a> 中，我们介绍了 <code>dnsmasq</code>，其工作方式如下：将 DNS 查询指向到 localhost 地址 <code>127.0.0.1</code>，同时启动一个进程监听 <code>53</code> 端口并处理查询请求。</p><p>在按上述方式配置 DNS 的主机上，如果运行了一个 Docker 容器，容器内的 <code>/etc/resolv.conf</code> 文件会是怎样的呢？</p><p>我们来动手试验一下吧。</p><p>按照默认 Docker 创建流程，可以看到如下的默认输出：</p><pre tabindex=0><code>$  docker run  ubuntu cat /etc/resolv.conf
# Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)
#     DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
# 127.0.0.53 is the systemd-resolved stub resolver.
# run &#34;systemd-resolve --status&#34; to see details about the actual nameservers.

search home
nameserver 8.8.8.8
nameserver 8.8.4.4
</code></pre><p>奇怪！</p><h4 id=地址-8888-和-8844-从何而来呢>地址 <code>8.8.8.8</code> 和 <code>8.8.4.4</code> 从何而来呢？</h4><p>当我思考容器内的 <code>/etc/resolv.conf</code> 配置时，我的第一反应是继承主机的 <code>/etc/resolv.conf</code>。但只要稍微进一步分析，就会发现这样并不总是有效的。</p><p>如果在主机上配置了 <code>dnsmasq</code>，那么 <code>/etc/resolv.conf</code> 文件总会指向 <code>127.0.0.1</code> 这个 回环地址 loopback address 。如果这个地址被容器继承，容器会在其本身的 网络上下文 networking context 中使用；由于容器内并没有运行（在 <code>127.0.0.1</code> 地址的）DNS 服务器，因此 DNS 查询都会失败。</p><p>“有了！”你可能有了新主意：将 主机的 的 IP 地址用作 DNS 服务器地址，其中这个 IP 地址可以从容器的 默认路由 default route 中获取：</p><pre tabindex=0><code>root@79a95170e679:/# ip route
default via 172.17.0.1 dev eth0
172.17.0.0/16 dev eth0 proto kernel scope link src 172.17.0.2
</code></pre><h4 id=使用主机-ip-地址真的可行吗>使用主机 IP 地址真的可行吗？</h4><p>从默认路由中，我们可以找到主机的 IP 地址 <code>172.17.0.1</code>，进而可以通过手动指定 DNS 服务器的方式进行测试（你也可以更新 <code>/etc/resolv.conf</code> 文件并使用 <code>ping</code> 进行测试；但我觉得这里很适合介绍新的 <code>dig</code> 工具及其 <code>@</code> 参数，后者用于指定需要查询的 DNS 服务器地址）：</p><pre tabindex=0><code>root@79a95170e679:/# dig @172.17.0.1 google.com | grep -A1 ANSWER.SECTION
;; ANSWER SECTION:
google.com.             112     IN      A       172.217.23.14
</code></pre><p>但是还有一个问题，这种方式仅适用于主机配置了 <code>dnsmasq</code> 的情况；如果主机没有配置 <code>dnsmasq</code>，主机上并不存在用于查询的 DNS 服务器。</p><p>在这个问题上，Docker 的解决方案是忽略所有可能的复杂情况，即无论主机中使用什么 DNS 服务器，容器内都使用 Google 的 DNS 服务器 <code>8.8.8.8</code> 和 <code>8.8.4.4</code> 完成 DNS 查询。</p><p>我的经历：在 2013 年，我遇到了使用 Docker 以来的第一个问题，与 Docker 的这种 DNS 解决方案密切相关。我们公司的网络屏蔽了 <code>8.8.8.8</code> 和 <code>8.8.4.4</code>，导致容器无法解析域名。</p><p>这就是 Docker 容器的情况，但对于包括 Kubernetes 在内的容器 编排引擎 orchestrators ，情况又有些不同。</p><h3 id=2-kubernetes-和-dns>2) Kubernetes 和 DNS</h3><p>在 Kubernetes 中，最小部署单元是 pod；它是一组相互协作的容器，共享 IP 地址（和其它资源）。</p><p>Kubernetes 面临的一个额外的挑战是，将 Kubernetes 服务请求（例如，<code>myservice.kubernetes.io</code>）通过对应的 解析器 resolver ，转发到具体服务地址对应的 内网地址 private network 。这里提到的服务地址被称为归属于“ 集群域 cluster domain ”。集群域可由管理员配置，根据配置可以是 <code>cluster.local</code> 或 <code>myorg.badger</code> 等。</p><p>在 Kubernetes 中，你可以为 pod 指定如下四种 pod 内 DNS 查询的方式。</p><p><strong>Default</strong></p><p>在这种（名称容易让人误解）的方式中，pod 与其所在的主机采用相同的 DNS 查询路径，与前面介绍的主机 DNS 查询一致。我们说这种方式的名称容易让人误解，因为该方式并不是默认选项！<code>ClusterFirst</code> 才是默认选项。</p><p>如果你希望覆盖 <code>/etc/resolv.conf</code> 中的条目，你可以添加到 <code>kubelet</code> 的配置中。</p><p><strong>ClusterFirst</strong></p><p>在 <code>ClusterFirst</code> 方式中，遇到 DNS 查询请求会做有选择的转发。根据配置的不同，有以下两种方式：</p><p>第一种方式配置相对古老但更简明，即采用一个规则：如果请求的域名不是集群域的子域，那么将其转发到 pod 所在的主机。</p><p>第二种方式相对新一些，你可以在内部 DNS 中配置选择性转发。</p><p>下面给出示例配置并从 <a href=https://kubernetes.io/docs/tasks/administer-cluster/dns-custom-nameservers/#impacts-on-pods>Kubernetes 文档</a>中选取一张图说明流程：</p><pre tabindex=0><code>apiVersion: v1
kind: ConfigMap
metadata:
  name: kube-dns
  namespace: kube-system
data:
  stubDomains: |
    {&#34;acme.local&#34;: [&#34;1.2.3.4&#34;]}
  upstreamNameservers: |
    [&#34;8.8.8.8&#34;, &#34;8.8.4.4&#34;]
</code></pre><p>在 <code>stubDomains</code> 条目中，可以为特定域名指定特定的 DNS 服务器；而 <code>upstreamNameservers</code> 条目则给出，待查询域名不是集群域子域情况下用到的 DNS 服务器。</p><p>这是通过在一个 pod 中运行我们熟知的 <code>dnsmasq</code> 实现的。</p><p><img src=/data/attachment/album/201809/27/220238y708309mckx80x8k.png alt=kubedns></p><p>剩下两种选项都比较小众：</p><p><strong>ClusterFirstWithHostNet</strong></p><p>适用于 pod 使用主机网络的情况，例如绕开 Docker 网络配置，直接使用与 pod 对应主机相同的网络。</p><p><strong>None</strong></p><p><code>None</code> 意味着不改变 DNS，但强制要求你在 <code>pod</code> 规范文件 specification 的 <code>dnsConfig</code> 条目中指定 DNS 配置。</p><h3 id=coredns-即将到来>CoreDNS 即将到来</h3><p>除了上面提到的那些，一旦 <code>CoreDNS</code> 取代 Kubernetes 中的 <code>kube-dns</code>，情况还会发生变化。<code>CoreDNS</code> 相比 <code>kube-dns</code> 具有可配置性更高、效率更高等优势。</p><p>如果想了解更多，参考<a href=https://coredns.io/>这里</a>。</p><p>如果你对 OpenShift 的网络感兴趣，我曾写过一篇<a href=https://zwischenzugs.com/2017/10/21/openshift-3-6-dns-in-pictures/>文章</a>可供你参考。但文章中 OpenShift 的版本是 3.6，可能有些过时。</p><h3 id=第四部分总结>第四部分总结</h3><p>第四部分到此结束，其中我们介绍了：</p><ul><li>Docker DNS 查询</li><li>Kubernetes DNS 查询</li><li>选择性转发（子域不转发）</li><li>kube-dns</li></ul><hr><p>via: <a href=https://zwischenzugs.com/2018/08/06/anatomy-of-a-linux-dns-lookup-part-iv/>https://zwischenzugs.com/2018/08/06/anatomy-of-a-linux-dns-lookup-part-iv/</a></p><p>作者：<a href=https://zwischenzugs.com/>zwischenzugs</a> 译者：<a href=https://github.com/pinewall>pinewall</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/dns/ rel=tag>DNS</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E5%AE%B9%E5%99%A8/ rel=tag>容器</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>