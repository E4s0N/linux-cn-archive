<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>如何在 C 语言中安全地读取用户输入 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="如何在 C 语言中安全地读取用户输入"><meta property="og:description" content="getline() 提供了一种更灵活的方法，可以在不破坏系统的情况下将用户数据读入程序。"><meta property="og:type" content="article"><meta property="og:url" content="/article-16009-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-07-18T10:44:30+00:00"><meta property="article:modified_time" content="2023-07-18T10:44:30+00:00"><meta itemprop=name content="如何在 C 语言中安全地读取用户输入"><meta itemprop=description content="getline() 提供了一种更灵活的方法，可以在不破坏系统的情况下将用户数据读入程序。"><meta itemprop=datePublished content="2023-07-18T10:44:30+00:00"><meta itemprop=dateModified content="2023-07-18T10:44:30+00:00"><meta itemprop=wordCount content="292"><meta itemprop=keywords content="输入,安全,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>如何在 C 语言中安全地读取用户输入</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2023-07-18T10:44:30Z>July 18, 2023</time></div></div></header><div class="content post__content clearfix"><p><img src=https://img.linux.net.cn/data/attachment/album/202307/18/104358pr5ergummii3f3le.jpg alt></p><blockquote><p><code>getline()</code> 提供了一种更灵活的方法，可以在不破坏系统的情况下将用户数据读入程序。</p></blockquote><p>在 C 语言中读取字符串是一件非常危险的事情。当读取用户输入时，程序员可能会尝试使用 C 标准库中的 <code>gets</code> 函数。它的用法非常简单：</p><pre tabindex=0><code>char *gets(char *string);
</code></pre><p><code>gets()</code> 从标准输入读取数据，然后将结果存储在一个字符串变量中。它会返回一个指向字符串的指针，如果没有读取到内容，返回 <code>NULL</code> 值。</p><p>举一个简单的例子，我们可能会问用户一个问题，然后将结果读入字符串中：</p><pre tabindex=0><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main()
{
  char city[10]; // 例如 &#34;Chicago&#34;

  // 这种方法很糟糕 .. 不要使用 gets

  puts(&#34;Where do you live?&#34;);
  gets(city);

  printf(&#34;&lt;%s&gt; is length %ld\n&#34;, city, strlen(city));

  return 0;
}
</code></pre><p>输入一个相对较短的值就可以：</p><pre tabindex=0><code>Where do you live?
Chicago
&lt;Chicago&gt; is length 7
</code></pre><p>然而，<code>gets()</code> 函数非常简单，它会天真地读取数据，直到它认为用户完成为止。但是它不会检查字符串是否足够容纳用户的输入。输入一个非常长的值会导致 <code>gets()</code> 存储的数据超出字符串变量长度，从而导致覆盖其他部分内存。</p><pre tabindex=0><code>Where do you live?
Llanfairpwllgwyngyllgogerychwyrndrobwllllantysiliogogogoch
&lt;Llanfairpwllgwyngyllgogerychwyrndrobwllllantysiliogogogoch&gt; is length 58
Segmentation fault (core dumped)
</code></pre><p>最好的情况是，覆盖部分只会破坏程序。最坏的情况是，这会引入一个严重的安全漏洞，恶意用户可以通过你的程序将任意数据插入计算机的内存中。</p><p>这就是为什么在程序中使用 <code>gets()</code> 函数是危险的。使用 <code>gets()</code>，你无法控制程序尝试从用户读取多少数据，这通常会导致缓冲区溢出。</p><h3 id=安全的方法>安全的方法</h3><p><code>fgets()</code> 函数历来是安全读取字符串的推荐方法。此版本的 <code>gets()</code> 提供了一个安全检查，通过仅读取作为函数参数传递的特定数量的字符：</p><pre tabindex=0><code>char *fgets(char *string, int size, FILE *stream);
</code></pre><p><code>fgets()</code> 函数会从文件指针读取数据，然后将数据存储到字符串变量中，但最多只能达到 <code>size</code> 指定的长度。我们可以更新示例程序来测试这一点，使用 <code>fgets()</code> 而不是 <code>gets()</code>：</p><pre tabindex=0><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main()
{
    char city[10]; // 例如 &#34;Chicago&#34;

    puts(&#34;Where do you live?&#34;);

    // fgets 虽好但是并不完美
    fgets(city, 10, stdin);

    printf(&#34;&lt;%s&gt; is length %ld\n&#34;, city, strlen(city));

    return 0;
}
</code></pre><p>如果编译运行，你可以在提示符后输入任意长的城市名称。但是，程序只会读取 <code>size</code> = 10 数据存储到字符串变量中。因为 C 语言在字符串末尾会添加一个空（<code>\0</code>）字符，这意味着 <code>fgets()</code> 只会读取 9 个字符到字符串中。</p><pre tabindex=0><code>Where do you live?
Minneapolis
&lt;Minneapol&gt; is length 9
</code></pre><p>虽然这肯定比 <code>fgets()</code> 读取用户输入更安全，但代价是如果用户输入过长，它会“切断”用户输入。</p><h3 id=新的安全方法>新的安全方法</h3><p>更灵活的解决方案是，如果用户输入的数据比变量可能容纳的数据多，则允许字符串读取函数为字符串分配更多内存。根据需要调整字符串变量大小，确保程序始终有足够的空间来存储用户输入。</p><p><code>getline()</code> 函数正是这样。它从输入流读取输入，例如键盘或文件，然后将数据存储在字符串变量中。但与 <code>fgets()</code> 和 <code>gets()</code> 不同，<code>getline()</code> 使用 <code>realloc()</code> 调整字符串大小，确保有足够的内存来存储完整输入。</p><pre tabindex=0><code>ssize_t getline(char **pstring, size_t *size, FILE *stream);
</code></pre><p><code>getline()</code> 实际上是一个名为 <code>getdelim()</code> 的类似函数的装饰器，它会读取数据一直到特殊分隔符停止。本例中，<code>getline()</code> 使用换行符（<code>\n</code>）作为分隔符，因为当从键盘或文件读取用户输入时，数据行由换行符分隔。</p><p>结果证明这是一种更安全的方法读取任意数据，一次一行。要使用 <code>getline()</code>，首先定义一个字符串指针并将其设置为 <code>NULL</code> ，表示还没有预留内存，再定义一个 <code>size_t</code> 类型的“字符串大小” 的变量，并给它一个零值。当你调用 <code>getline()</code> 时，你需要传入字符串和字符串大小变量的指针，以及从何处读取数据。对于示例程序，我们可以从标准输入中读取：</p><pre tabindex=0><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main()
{
  char *string = NULL;
  size_t size = 0;
  ssize_t chars_read;

  // 使用 getline 读取长字符串

  puts(&#34;Enter a really long string:&#34;);

  chars_read = getline(&amp;string, &amp;size, stdin);
  printf(&#34;getline returned %ld\n&#34;, chars_read);

  // 检查错误

  if (chars_read &lt; 0) {
    puts(&#34;couldn&#39;t read the input&#34;);
    free(string);
    return 1;
  }

  // 打印字符串

  printf(&#34;&lt;%s&gt; is length %ld\n&#34;, string, strlen(string));

  // 释放字符串使用的内存

  free(string);

  return 0;
}
</code></pre><p>使用 <code>getline()</code> 读取数据时，它将根据需要自动为字符串变量重新分配内存。当函数读取一行的所有数据时，它通过指针更新字符串的大小，并返回读取的字符数，包括分隔符。</p><pre tabindex=0><code>Enter a really long string:
Supercalifragilisticexpialidocious
getline returned 35
&lt;Supercalifragilisticexpialidocious
&gt; is length 35
</code></pre><p>注意，字符串包含分隔符。对于 <code>getline()</code>，分隔符是换行符，这就是为什么输出中有换行符的原因。 如果你不想在字符串值中使用分隔符，可以使用另一个函数将字符串中的分隔符更改为空字符。</p><p>通过 <code>getline()</code>，程序员可以安全地避免 C 编程的一个常见陷阱：你永远无法知道用户可能会输入哪些数据。这就是为什么使用 <code>gets()</code> 不安全，而 <code>fgets()</code> 又太笨拙的原因。相反，<code>getline()</code> 提供了一种更灵活的方法，可以在不破坏系统的情况下将用户数据读入程序。</p><p><em>（题图：MJ/4b23132f-8916-42ae-b2da-06fd2812bea8）</em></p><hr><p>via: <a href=https://opensource.com/article/22/5/safely-read-user-input-getline>https://opensource.com/article/22/5/safely-read-user-input-getline</a></p><p>作者：<a href=https://opensource.com/users/jim-hall>Jim Hall</a> 选题：<a href=https://github.com/lkxed>lkxed</a> 译者：<a href=https://github.com/MjSeven>MjSeven</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/%E8%BE%93%E5%85%A5/ rel=tag>输入</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E5%AE%89%E5%85%A8/ rel=tag>安全</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>