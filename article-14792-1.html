<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Djinn：一个受 Jinja2 启发的代码生成器和模板语言 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="Djinn：一个受 Jinja2 启发的代码生成器和模板语言"><meta property="og:description" content="我决定制作一个类似于 Jinja2 的工具，但让我可以通过使用范围算法转换数据来生成复杂的文件。"><meta property="og:type" content="article"><meta property="og:url" content="/article-14792-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-07-04T10:17:00+00:00"><meta property="article:modified_time" content="2022-07-04T10:17:00+00:00"><meta itemprop=name content="Djinn：一个受 Jinja2 启发的代码生成器和模板语言"><meta itemprop=description content="我决定制作一个类似于 Jinja2 的工具，但让我可以通过使用范围算法转换数据来生成复杂的文件。"><meta itemprop=datePublished content="2022-07-04T10:17:00+00:00"><meta itemprop=dateModified content="2022-07-04T10:17:00+00:00"><meta itemprop=wordCount content="659"><meta itemprop=keywords content="代码生成器,Jinja2,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>Djinn：一个受 Jinja2 启发的代码生成器和模板语言</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2022-07-04T10:17:00Z>July 04, 2022</time></div></div></header><div class="content post__content clearfix"><p><img src=/data/attachment/album/202207/04/101711nq2we7z7x7wz2z7e.jpg alt></p><p>代码生成器是非常有用的工具。我有时使用 <a href=https://jinja2docs.readthedocs.io/en/stable/>jinja2</a> 的命令行版本来生成高度冗余的配置文件和其他文本文件，但它在转换数据方面功能有限。显然，Jinja2 的作者有不同的想法，而我想要类似于 列表推导 list comprehensions 或 D 语言的 可组合范围 composable range 算法之类的东西。</p><p>我决定制作一个类似于 Jinja2 的工具，但让我可以通过使用范围算法转换数据来生成复杂的文件。这个想法非常简单：一个直接用 D 语言代码重写的模板语言。因为它 <em>就是</em> D 语言，它可以支持 D 语言所能做的一切。我想要一个独立的代码生成器，但是由于 <a href=https://dlang.org/articles/mixin.html>D 语言的 <code>mixin</code> 特性</a>，同样的模板语言可以作为嵌入式模板语言工作（例如，Web 应用程序中的 HTML）。有关该技巧的更多信息，请参阅 <a href=https://theartofmachinery.com/2017/12/31/compile_time_brainfuck.html>这篇</a> 关于在编译时使用 mixins 将 Brainfuck 转换为 D 和机器代码的文章。</p><p>像往常一样，<a href=https://gitlab.com/sarneaud/djinn>源码在 GitLab 上</a>。<a href=https://gitlab.com/sarneaud/djinn/-/tree/v0.1.0/examples>这篇文章中的例子也可以在这里找到</a>。</p><h3 id=hello-world-示例>Hello world 示例</h3><p>这是一个演示这个想法的例子：</p><pre tabindex=0><code>Hello [= retro(&#34;dlrow&#34;) ]!
[: enum one = 1; :]
1 + 1 = [= one + one ]
</code></pre><p><code>[= some_expression ]</code> 类似于 Jinja2 中的 <code>{{ some_expression }}</code>，它在输出中呈现一个值。<code>[: some_statement; :]</code> 类似于 <code>{% some_statement %}</code> ，用于执行完整的代码语句。我更改了语法，因为 D 也大量使用花括号，并且将两者混合使模板难以阅读（还有一些特殊的非 D 指令，比如 <code>include</code>，它们被包裹在 <code>[&lt;</code> 和 <code>>]</code> 中）。</p><p>如果你将上面的内容保存到一个名为 <code>hello.txt.dj</code> 的文件中并运行 <code>djinn</code> 命令行工具，你会得到一个名为 <code>hello.txt</code> 的文件，其中包含你可能猜到的内容：</p><pre tabindex=0><code>Hello world!
1 + 1 = 2
</code></pre><p>如果你使用过 Jinja2，你可能想知道第二行发生了什么。Djinn 有一个简化格式化和空格处理的特殊规则：如果源代码行包含 <code>[:</code> 语句或 <code>[&lt;</code> 指令但不包含任何非空格输出，则整行都会被忽略输出。空行则仍会原样呈现。</p><h3 id=生成数据>生成数据</h3><p>好的，现在来讲一些更实用的东西：生成 CSV 数据。</p><pre tabindex=0><code>x,f(x)
[: import std.mathspecial;
foreach (x; iota(-1.0, 1.0, 0.1)) :]
[= &#34;%0.1f,%g&#34;, x, normalDistribution(x) ]
</code></pre><p>一个 <code>[=</code> 和 <code>]</code> 对可以包含多个用逗号分隔的表达式。如果第一个表达式是一个由双引号包裹的字符串，则会被解释为 <a href=https://dlang.org/phobos/std_format.html#format-string>格式化字符串</a>。下面是输出结果：</p><pre tabindex=0><code>x,f(x)
-1.0,0.158655
-0.9,0.18406
-0.8,0.211855
-0.7,0.241964
-0.6,0.274253
-0.5,0.308538
-0.4,0.344578
-0.3,0.382089
-0.2,0.42074
-0.1,0.460172
0.0,0.5
0.1,0.539828
0.2,0.57926
0.3,0.617911
0.4,0.655422
0.5,0.691462
0.6,0.725747
0.7,0.758036
0.8,0.788145
0.9,0.81594
</code></pre><h3 id=制作图片>制作图片</h3><p>这个例子展示了一个图片的生成过程。<a href=http://netpbm.sourceforge.net/doc/#formats>经典的 Netpbm 图像库定义了一堆图像格式</a>，其中一些是基于文本的。例如，这是一个 3 x 3 向量的图像：</p><pre tabindex=0><code>P2 # PGM 格式标识
3 3 # 宽和高
7 # 代表纯白色的值（0 代表黑色）
7 0 7
0 0 0
7 0 7
</code></pre><p>你可以将上述文本保存到名为 <code>cross.pgm</code> 之类的文件中，很多图像工具都知道如何解析它。下面是一些 Djinn 代码，它以相同的格式生成 <a href=https://en.wikipedia.org/wiki/Mandelbrot_set>Mandelbrot 集</a> 分形：</p><pre tabindex=0><code>[:
import std.complex;
enum W = 640;
enum H = 480;
enum kMaxIter = 20;
ubyte mb(uint x, uint y)
{
    const c = complex(3.0 * (x - W / 1.5) / W, 2.0 * (y - H / 2.0) / H);
    auto z = complex(0.0);
    ubyte ret = kMaxIter;
    while (abs(z) &lt;= 2 &amp;&amp; --ret) z = z * z + c;
    return ret;
}
:]
P2
[= W ] [= H ]
[= kMaxIter ]
[: foreach (y; 0..H) :]
[= &#34;%(%s %)&#34;, iota(W).map!(x =&gt; mb(x, y)) ]
</code></pre><p>生成的文件大约为 800 kB，但它可以很好地被压缩为 PNG：</p><pre tabindex=0><code>$ # 使用 GraphicsMagick 进行转换
$ gm convert mandelbrot.pgm mandelbrot.png
</code></pre><p>结果如下：</p><p><img src=/data/attachment/album/202207/04/101716nh6t32cop2ozu6th.png alt></p><h3 id=解决谜题>解决谜题</h3><p>这里有一个谜题：</p><p><img src=/data/attachment/album/202207/04/101716exxxx333kkkcx6g3.svg alt></p><p>一个 5 行 5 列的网格需要用 1 到 5 的数字填充，每个数字在每一行中限使用一次，在每列中限使用一次（即，制作一个 5 行 5 列的 拉丁方格 Latin square ）。相邻单元格中的数字还必须满足所有 <code>></code> 大于号表示的不等式。</p><p><a href=https://theartofmachinery.com/2020/05/21/glico_weighted_rock_paper_scissors.html>几个月前我使用了 线性规划 linear programming （LP）</a>。线性规划问题是具有线性约束的连续变量系统。这次我将使用 混合整数线性规划 mixed integer linear programming （MILP），它通过允许整数约束变量来归纳 LP。事实证明，这足以成为 NP 完备的，而 MILP 恰好可以很好地模拟这个谜题。</p><p>在上一篇文章中，我使用 Julia 库 JuMP 来帮助解决这个问题。这次我将使用 <a href=http://lpsolve.sourceforge.net/5.0/CPLEX-format.htm>CPLEX：基于文本的格式</a>，它受到多个 LP 和 MILP 求解器的支持（如果需要，可以通过现成的工具轻松转换为其他格式）。这是上一篇文章中 CPLEX 格式的 LP：</p><pre tabindex=0><code>Minimize
  obj: v
Subject To
  ptotal: pr + pp + ps = 1
  rock: 4 ps - 5 pp - v &lt;= 0
  paper: 5 pr - 8 ps - v &lt;= 0
  scissors: 8 pp - 4 pr - v &lt;= 0
Bounds
  0 &lt;= pr &lt;= 1
  0 &lt;= pp &lt;= 1
  0 &lt;= ps &lt;= 1
End
</code></pre><p>CPLEX 格式易于阅读，但复杂度高的问题需要大量变量和约束来建模，这使得手工编码既痛苦又容易出错。有一些特定领域的语言，例如 <a href=https://zimpl.zib.de/>ZIMPL</a>，用于以高级方式描述 MILP 和 LP。对于许多问题来说，它们非常酷，但最终它们不如具有良好库（如 JuMP）支持的通用语言或使用 D 语言的代码生成器那样富有表现力。</p><p>我将使用两组变量来模拟这个谜题：<code>v_{r,c}</code> 和 <code>i_{r,c,v}</code>。<code>v_{r,c}</code> 将保存 r 行 c 列单元格的值（从 1 到 5）。<code>i_{r,c,v}</code> 是一个二进制指示器，如果 r 行 c 列的单元格的值是 v，则该指示器值为 1，否则为 0。这两组变量是网格的冗余表示，但第一种表示更容易对不等式约束进行建模，而第二种表示更容易对唯一性约束进行建模。我只需要添加一些额外的约束来强制这两个表示是一致的。但首先，让我们从每个单元格必须只有一个值的基本约束开始。从数学上讲，这意味着给定行和列的所有指示器都必须为 0，但只有一个值为 1 的例外。这可以通过以下等式强制约束：</p><pre tabindex=0><code>[i_{r,c,1} + i_{r,c,2} + i_{r,c,3} + i_{r,c,4} + i_{r,c,5} = 1]
</code></pre><p>可以使用以下 Djinn 代码生成对所有行和列的 CPLEX 约束：</p><pre tabindex=0><code>\ 单元格只有一个值
[:
foreach (r; iota(N))
foreach (c; iota(N))
:]
    [= &#34;%-(%s + %)&#34;, vs.map!(v =&gt; ivar(r, c, v)) ] = 1
[::]
</code></pre><p><code>ivar()</code> 是一个辅助函数，它为我们提供变量名为 <code>i</code> 的字符串标识符，而 <code>vs</code> 存储从 1 到 5 的数字以方便使用。行和列内唯一性的约束完全相同，但在 <code>i</code> 的其他两个维度上迭代。</p><p>为了使变量组 <code>i</code> 与变量组 <code>v</code> 保持一致，我们需要如下约束（请记住，变量组 <code>i</code> 中只有一个元素的值是非零的）：</p><pre tabindex=0><code>[i_{r,c,1} + 2i_{r,c,2} + 3i_{r,c,3} + 4i_{r,c,4} + 5i_{r,c,5} = v_{r,c}]
</code></pre><p>CPLEX 要求所有变量都位于左侧，因此 Djinn 代码如下所示：</p><pre tabindex=0><code>\ 连接变量组 i 和变量组 v
[:
foreach (r; iota(N))
foreach (c; iota(N))
:]
    [= &#34;%-(%s + %)&#34;, vs.map!(v =&gt; text(v, &#39; &#39;, ivar(r, c, v))) ] - [= vvar(r,c) ] = 0
[::]
</code></pre><p>不等符号相邻的和左下角值为为 4 单元格的约束写起来都很简单。剩下的便是将指示器变量声明为二进制，并为变量组 <code>v</code> 设置边界。加上变量的边界，总共有 150 个变量和 111 个约束 <a href=https://gitlab.com/sarneaud/djinn/-/tree/v0.1.0/examples/inequality.lp.dj>你可以在仓库中看到完整的代码</a>。</p><p><a href=https://www.gnu.org/software/glpk/>GNU 线性规划工具集</a> 有一个命令行工具可以解决这个 CPLEX MILP。不幸的是，它的输出是一个包含了所有内容的体积很大的转储，所以我使用 awk 命令来提取需要的内容：</p><pre tabindex=0><code>$ time glpsol --lp inequality.lp -o /dev/stdout | awk &#39;/v[0-9][0-9]/ { print $2, $4 }&#39; | sort
v00 1
v01 3
v02 2
v03 5
v04 4
v10 2
v11 5
v12 4
v13 1
v14 3
v20 3
v21 1
v22 5
v23 4
v24 2
v30 5
v31 4
v32 3
v33 2
v34 1
v40 4
v41 2
v42 1
v43 3
v44 5

real    0m0.114s
user    0m0.106s
sys     0m0.005s
</code></pre><p>这是在原始网格中写出的解决方案：</p><p><img src=/data/attachment/album/202207/04/101717cjbaza2ds0j2qjj1.svg alt></p><p>这些例子只是用来玩的，但我相信你已经明白了。顺便说一下，Djinn 代码仓库的 <code>README.md</code> 文件本身是使用 Djinn 模板生成的。</p><p>正如我所说，Djinn 也可以用作嵌入在 D 语言代码中的编译期模板语言。我最初只是想要一个代码生成器，得益于 D 语言的元编程功能，这算是一个额外获得的功能。</p><hr><p>via: <a href=https://theartofmachinery.com/2021/01/01/djinn.html>https://theartofmachinery.com/2021/01/01/djinn.html</a></p><p>作者：<a href=https://theartofmachinery.com>Simon Arneaud</a> 选题：<a href=https://github.com/lujun9972>lujun9972</a> 译者：<a href=https://github.com/hanszhao80>hanszhao80</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/ rel=tag>代码生成器</a></li><li class=tags__item><a class="tags__link btn" href=/tags/jinja2/ rel=tag>Jinja2</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>