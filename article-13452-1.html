<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>使用 systemd 作为问题定位工具 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="使用 systemd 作为问题定位工具"><meta property="og:description" content="虽然 systemd 并非真正的故障定位工具，但其输出中的信息为解决问题指明了方向。"><meta property="og:type" content="article"><meta property="og:url" content="/article-13452-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-06-02T21:43:51+00:00"><meta property="article:modified_time" content="2021-06-02T21:43:51+00:00"><meta itemprop=name content="使用 systemd 作为问题定位工具"><meta itemprop=description content="虽然 systemd 并非真正的故障定位工具，但其输出中的信息为解决问题指明了方向。"><meta itemprop=datePublished content="2021-06-02T21:43:51+00:00"><meta itemprop=dateModified content="2021-06-02T21:43:51+00:00"><meta itemprop=wordCount content="805"><meta itemprop=keywords content="systemd,故障定位,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>使用 systemd 作为问题定位工具</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2021-06-02T21:43:51Z>June 02, 2021</time></div></div></header><div class="content post__content clearfix"><blockquote><p>虽然 systemd 并非真正的故障定位工具，但其输出中的信息为解决问题指明了方向。</p></blockquote><p><img src=https://img.linux.net.cn/data/attachment/album/202106/02/214321uqzzrqza9mlt9iam.jpg alt title="Magnifying glass on code"></p><p>没有人会认为 systemd 是一个故障定位工具，但当我的 web 服务器遇到问题时，我对 systemd 和它的一些功能的不断了解帮助我找到并规避了问题。</p><p>我遇到的问题是这样，我的服务器 yorktown 为我的家庭办公网络提供名称服务 、DHCP、NTP、HTTPD 和 SendMail 邮件服务，它在正常启动时未能启动 Apache HTTPD 守护程序。在我意识到它没有运行之后，我不得不手动启动它。这个问题已经持续了一段时间，我最近才开始尝试去解决它。</p><p>你们中的一些人会说，systemd 本身就是这个问题的原因，根据我现在了解的情况，我同意你们的看法。然而，我在使用 SystemV 时也遇到了类似的问题。（在本系列文章的 <a href=https://opensource.com/article/20/4/systemd>第一篇</a> 中，我探讨了围绕 systemd 作为旧有 SystemV 启动程序和启动脚本的替代品所产生的争议。如果你有兴趣了解更多关于 systemd 的信息，也可以阅读 <a href=https://opensource.com/article/20/4/systemd-startup>第二篇</a> 和 <a href=https://opensource.com/article/20/4/understanding-and-using-systemd-units>第三篇</a> 文章。）没有完美的软件，systemd 和 SystemV 也不例外，但 systemd 为解决问题提供的信息远远多于 SystemV。</p><h3 id=确定问题所在>确定问题所在</h3><p>找到这个问题根源的第一步是确定 httpd 服务的状态：</p><pre tabindex=0><code>[root@yorktown ~]# systemctl status httpd
● httpd.service - The Apache HTTP Server
   Loaded: loaded (/usr/lib/systemd/system/httpd.service; enabled; vendor preset: disabled)
   Active: failed (Result: exit-code) since Thu 2020-04-16 11:54:37 EDT; 15min ago
     Docs: man:httpd.service(8)
  Process: 1101 ExecStart=/usr/sbin/httpd $OPTIONS -DFOREGROUND (code=exited, status=1/FAILURE)
 Main PID: 1101 (code=exited, status=1/FAILURE)
   Status: &#34;Reading configuration...&#34;
      CPU: 60ms

Apr 16 11:54:35 yorktown.both.org systemd[1]: Starting The Apache HTTP Server...
Apr 16 11:54:37 yorktown.both.org httpd[1101]: (99)Cannot assign requested address: AH00072: make_sock: could not bind to address 192.168.0.52:80
Apr 16 11:54:37 yorktown.both.org httpd[1101]: no listening sockets available, shutting down
Apr 16 11:54:37 yorktown.both.org httpd[1101]: AH00015: Unable to open logs
Apr 16 11:54:37 yorktown.both.org systemd[1]: httpd.service: Main process exited, code=exited, status=1/FAILURE
Apr 16 11:54:37 yorktown.both.org systemd[1]: httpd.service: Failed with result &#39;exit-code&#39;.
Apr 16 11:54:37 yorktown.both.org systemd[1]: Failed to start The Apache HTTP Server.
[root@yorktown ~]#
</code></pre><p>这种状态信息是 systemd 的功能之一，我觉得比 SystemV 提供的任何功能都要有用。这里的大量有用信息使我很容易得出逻辑性的结论，让我找到正确的方向。我从旧的 <code>chkconfig</code> 命令中得到的是服务是否在运行，以及如果它在运行的话，进程 ID（PID）是多少。这可没多大帮助。</p><p>该状态报告中的关键条目显示，HTTPD 不能与 IP 地址绑定，这意味着它不能接受传入的请求。这表明网络启动速度不够快，因为 IP 地址还没有设置好，所以 HTTPD 服务还没有准备好与 IP 地址绑定。这是不应该发生的，所以我查看了我的网络服务的 systemd 启动配置文件；在正确的 <code>after</code> 和 <code>requires</code> 语句下，所有这些似乎都没问题。下面是我服务器上的 <code>/lib/systemd/system/httpd.service</code> 文件：</p><pre tabindex=0><code># Modifying this file in-place is not recommended, because changes 
# will be overwritten during package upgrades.  To customize the 
# behaviour, run &#34;systemctl edit httpd&#34; to create an override unit.

# For example, to pass additional options (such as -D definitions) to 
# the httpd binary at startup, create an override unit (as is done by                             
# systemctl edit) and enter the following:                                           

#    [Service]
#    Environment=OPTIONS=-DMY_DEFINE             

[Unit]                                               
Description=The Apache HTTP Server
Wants=httpd-init.service
After=network.target remote-fs.target nss-lookup.target httpd-init.service
Documentation=man:httpd.service(8)

[Service]
Type=notify
Environment=LANG=C

ExecStart=/usr/sbin/httpd $OPTIONS -DFOREGROUND
ExecReload=/usr/sbin/httpd $OPTIONS -k graceful
# Send SIGWINCH for graceful stop
KillSignal=SIGWINCH
KillMode=mixed
PrivateTmp=true

[Install]
WantedBy=multi-user.target
</code></pre><p><code>httpd.service</code> 单元文件明确规定，它应该在 <code>network.target</code> 和 <code>httpd-init.service</code>（以及其他）之后加载。我试着用 <code>systemctl list-units</code> 命令找到所有这些服务，并在结果数据流中搜索它们。所有这些服务都存在，应该可以确保在设置网络 IP 地址之前，httpd 服务没有加载。</p><h3 id=第一个解决方案>第一个解决方案</h3><p>在互联网上搜索了一下，证实其他人在 httpd 和其他服务也遇到了类似的问题。这似乎是由于其中一个所需的服务向 systemd 表示它已经完成了启动，但实际上它却启动了一个尚未完成的子进程。通过更多搜索，我想到了一个规避方法。</p><p>我搞不清楚为什么花了这么久才把 IP 地址分配给网卡。所以我想，如果我可以将 HTTPD 服务的启动推迟合理的一段时间，那么 IP 地址就会在那个时候分配。</p><p>幸运的是，上面的 <code>/lib/systemd/system/httpd.service</code> 文件提供了一些方向。虽然它说不要修改它，但是它还是指出了如何操作：使用 <code>systemctl edit httpd</code> 命令，它会自动创建一个新文件（<code>/etc/systemd/system/httpd.service.d/override.conf</code>）并打开 <a href=https://www.nano-editor.org/>GNU Nano</a> 编辑器（如果你对 Nano 不熟悉，一定要看一下 Nano 界面底部的提示）。</p><p>在新文件中加入以下代码并保存：</p><pre tabindex=0><code>[root@yorktown ~]# cd /etc/systemd/system/httpd.service.d/
[root@yorktown httpd.service.d]# ll
total 4
-rw-r--r-- 1 root root 243 Apr 16 11:43 override.conf
[root@yorktown httpd.service.d]# cat override.conf
# Trying to delay the startup of httpd so that the network is
# fully up and running so that httpd can bind to the correct
# IP address
#
# By David Both, 2020-04-16

[Service]
ExecStartPre=/bin/sleep 30
</code></pre><p>这个覆盖文件的 <code>[Service]</code> 段有一行代码，将 HTTPD 服务的启动时间推迟了 30 秒。下面的状态命令显示了等待时间里的服务状态：</p><pre tabindex=0><code>[root@yorktown ~]# systemctl status httpd
● httpd.service - The Apache HTTP Server
   Loaded: loaded (/usr/lib/systemd/system/httpd.service; enabled; vendor preset: disabled)
  Drop-In: /etc/systemd/system/httpd.service.d
           └─override.conf
           /usr/lib/systemd/system/httpd.service.d
           └─php-fpm.conf
   Active: activating (start-pre) since Thu 2020-04-16 12:14:29 EDT; 28s ago
     Docs: man:httpd.service(8)
Cntrl PID: 1102 (sleep)
    Tasks: 1 (limit: 38363)
   Memory: 260.0K
      CPU: 2ms
   CGroup: /system.slice/httpd.service
           └─1102 /bin/sleep 30

Apr 16 12:14:29 yorktown.both.org systemd[1]: Starting The Apache HTTP Server...
Apr 16 12:15:01 yorktown.both.org systemd[1]: Started The Apache HTTP Server.
[root@yorktown ~]#
</code></pre><p>这个命令显示了 30 秒延迟过后 HTTPD 服务的状态。该服务已经启动并正常运行。</p><pre tabindex=0><code>[root@yorktown ~]# systemctl status httpd
● httpd.service - The Apache HTTP Server
   Loaded: loaded (/usr/lib/systemd/system/httpd.service; enabled; vendor preset: disabled)
  Drop-In: /etc/systemd/system/httpd.service.d
           └─override.conf
           /usr/lib/systemd/system/httpd.service.d
           └─php-fpm.conf
   Active: active (running) since Thu 2020-04-16 12:15:01 EDT; 1min 18s ago
     Docs: man:httpd.service(8)
  Process: 1102 ExecStartPre=/bin/sleep 30 (code=exited, status=0/SUCCESS)
 Main PID: 1567 (httpd)
   Status: &#34;Total requests: 0; Idle/Busy workers 100/0;Requests/sec: 0; Bytes served/sec:   0 B/sec&#34;
    Tasks: 213 (limit: 38363)
   Memory: 21.8M
      CPU: 82ms
   CGroup: /system.slice/httpd.service
           ├─1567 /usr/sbin/httpd -DFOREGROUND
           ├─1569 /usr/sbin/httpd -DFOREGROUND
           ├─1570 /usr/sbin/httpd -DFOREGROUND
           ├─1571 /usr/sbin/httpd -DFOREGROUND
           └─1572 /usr/sbin/httpd -DFOREGROUND

Apr 16 12:14:29 yorktown.both.org systemd[1]: Starting The Apache HTTP Server...
Apr 16 12:15:01 yorktown.both.org systemd[1]: Started The Apache HTTP Server.
</code></pre><p>我本来可以实验下更短的延迟时间是否也能奏效，但是我的系统并不用那么严格，所以我觉得不这样做。目前系统的工作状态很可靠，所以我很高兴。</p><p>因为我收集了所有这些信息，我将其作为 Bug<a href="https://bugzilla.redhat.com/show_bug.cgi?id=1825554">1825554</a> 报告给红帽 Bugzilla。我相信报告 Bug 比抱怨 Bug 更有有用。</p><h3 id=更好的解决方案>更好的解决方案</h3><p>把这个问题作为 bug 上报几天后，我收到了回复，表示 systemd 只是一个管理工具，如果 httpd 需要在满足某些要求之后被拉起，需要在单元文件中表达出来。这个回复指引我去查阅 <code>httpd.service</code> 的手册页。我希望我能早点发现这个，因为它是比我自己想出的更优秀的解决方案。这种方案明确的针对了前置目标单元，而不仅仅是随机延迟。</p><p>来自 <a href=https://www.mankier.com/8/httpd.service#Description-Starting_the_service_at_boot_time>httpd.service 手册页</a>:</p><blockquote><p><strong>在启动时开启服务</strong></p><p><code>httpd.service</code> 和 <code>httpd.socket</code> 单元默认是 <em>禁用</em> 的。为了在启动阶段开启 httpd 服务，执行：<code>systemctl enable httpd.service</code>。在默认配置中，httpd 守护进程会接受任何配置好的 IPv4 或 IPv6 地址的 80 口上的连接（如果安装了 mod_ssl，就会接受 443 端口上的 TLS 连接）。</p><p>如果 httpd 被配置成依赖任一特定的 IP 地址（比如使用 <code>Listen</code> 指令），该地址可能只在启动阶段可用，又或者 httpd 依赖其他服务（比如数据库守护进程），那么必须配置该服务，以确保正确的启动顺序。</p><p>例如，为了确保 httpd 在所有配置的网络接口配置完成之后再运行，可以创建一个带有以下代码段的 drop-in 文件（如上述）：</p><pre tabindex=0><code>[Unit]
After=network-online.target
Wants=network-online.target
</code></pre></blockquote><p>我仍然觉得这是个 bug，因为在 <code>httpd.conf</code> 配置文件中使用 Listen 指令是很常见的，至少在我的经验中。我一直在使用 Listen 指令，即使在只有一个 IP 地址的主机上，在多个网卡和 IP 地址的机器上这显然也是有必要的。在 <code>/usr/lib/systemd/system/httpd.service</code> 默认配置文件中加入上述几行，对不使用 <code>Listen</code> 指令的不会造成问题，对使用 <code>Listen</code> 指令的则会规避这个问题。</p><p>同时，我将使用建议的方法。</p><h3 id=下一步>下一步</h3><p>本文描述了一个我在服务器上启动 Apache HTTPD 服务时遇到的一个问题。它指引你了解我在解决这个问题上的思路，并说明了我是如何使用 systemd 来协助解决问题。我也介绍了我用 systemd 实现的规避方法，以及我按照我的 bug 报告得到的更好的解决方案。</p><p>如我在开头处提到的那样，这有很大可能是一个 systemd 的问题，特别是 httpd 启动的配置问题。尽管如此，systemd 还是提供了工具让我找到了问题的可能来源，并制定和实现了规避方案。两种方案都没有真正令我满意地解决问题。目前，这个问题根源依旧存在，必须要解决。如果只是在 <code>/usr/lib/systemd/system/httpd.service</code> 文件中添加推荐的代码，那对我来说是可行的。</p><p>在这个过程中我发现了一件事，我需要了解更多关于定义服务启动顺序的知识。我会在下一篇文章中探索这个领域，即本系列的第五篇。</p><h3 id=资源>资源</h3><p>网上有大量的关于 systemd 的参考资料，但是大部分都有点简略、晦涩甚至有误导性。除了本文中提到的资料，下列的网页提供了跟多可靠且详细的 systemd 入门信息。</p><ul><li>Fedora 项目有一篇切实好用的 <a href=https://docs.fedoraproject.org/en-US/quick-docs/understanding-and-administering-systemd/index.html>systemd 入门</a>，它囊括了几乎所有你需要知道的关于如何使用 systemd 配置、管理和维护 Fedora 计算机的信息。</li><li>Fedora 项目也有一个不错的 <a href=https://fedoraproject.org/wiki/SysVinit_to_Systemd_Cheatsheet>备忘录</a>，交叉引用了过去 SystemV 命令和 systemd 命令做对比。</li><li>关于 systemd 的技术细节和创建这个项目的原因，请查看 <a href=http://Freedesktop.org>Freedesktop.org</a> 上的 <a href=http://www.freedesktop.org/wiki/Software/systemd>systemd 描述</a>。</li><li><a href=http://Linux.com>Linux.com</a> 的“更多 systemd 的乐趣”栏目提供了更多高级的 systemd <a href=https://www.linux.com/training-tutorials/more-systemd-fun-blame-game-and-stopping-services-prejudice/>信息和技巧</a>。</li></ul><p>此外，还有一系列深度的技术文章，是由 systemd 的设计者和主要开发者 Lennart Poettering 为 Linux 系统管理员撰写的。这些文章写于 2010 年 4 月至 2011 年 9 月间，但它们现在和当时一样具有现实意义。关于 systemd 及其生态的许多其他好文章都是基于这些文章：</p><ul><li><a href=http://0pointer.de/blog/projects/systemd.html>Rethinking PID 1</a></li><li><a href=http://0pointer.de/blog/projects/systemd-for-admins-1.html>systemd for Administrators，Part I</a></li><li><a href=http://0pointer.de/blog/projects/systemd-for-admins-2.html>systemd for Administrators，Part II</a></li><li><a href=http://0pointer.de/blog/projects/systemd-for-admins-3.html>systemd for Administrators，Part III</a></li><li><a href=http://0pointer.de/blog/projects/systemd-for-admins-4.html>systemd for Administrators，Part IV</a></li><li><a href=http://0pointer.de/blog/projects/three-levels-of-off.html>systemd for Administrators，Part V</a></li><li><a href=http://0pointer.de/blog/projects/changing-roots>systemd for Administrators，Part VI</a></li><li><a href=http://0pointer.de/blog/projects/blame-game.html>systemd for Administrators，Part VII</a></li><li><a href=http://0pointer.de/blog/projects/the-new-configuration-files.html>systemd for Administrators，Part VIII</a></li><li><a href=http://0pointer.de/blog/projects/on-etc-sysinit.html>systemd for Administrators，Part IX</a></li><li><a href=http://0pointer.de/blog/projects/instances.html>systemd for Administrators，Part X</a></li><li><a href=http://0pointer.de/blog/projects/inetd.html>systemd for Administrators，Part XI</a></li></ul><hr><p>via: <a href=https://opensource.com/article/20/5/systemd-troubleshooting-tool>https://opensource.com/article/20/5/systemd-troubleshooting-tool</a></p><p>作者：<a href=https://opensource.com/users/dboth>David Both</a> 选题：<a href=https://github.com/lujun9972>lujun9972</a> 译者：<a href=https://github.com/tt67wq>tt67wq</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/systemd/ rel=tag>systemd</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E6%95%85%E9%9A%9C%E5%AE%9A%E4%BD%8D/ rel=tag>故障定位</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>