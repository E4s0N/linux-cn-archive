<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>OpenGL 与 Go 教程（三）实现游戏 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="OpenGL 与 Go 教程（三）实现游戏"><meta property="og:description" content="到目前为止，你应该懂得如何创建网格系统以及创建代表方格中每一个单元的格子阵列。现在可以开始把网格当作游戏面板实现康威生命游戏。"><meta property="og:type" content="article"><meta property="og:url" content="/article-8969-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-10-18T09:43:00+00:00"><meta property="article:modified_time" content="2017-10-18T09:43:00+00:00"><meta itemprop=name content="OpenGL 与 Go 教程（三）实现游戏"><meta itemprop=description content="到目前为止，你应该懂得如何创建网格系统以及创建代表方格中每一个单元的格子阵列。现在可以开始把网格当作游戏面板实现康威生命游戏。"><meta itemprop=datePublished content="2017-10-18T09:43:00+00:00"><meta itemprop=dateModified content="2017-10-18T09:43:00+00:00"><meta itemprop=wordCount content="1431"><meta itemprop=keywords content="OpenGL,Golang,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>OpenGL 与 Go 教程（三）实现游戏</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-10-18T09:43:00Z>October 18, 2017</time></div></div></header><div class="content post__content clearfix"><p><img src=https://img.linux.net.cn/data/attachment/album/201710/17/154427lifqhohyri5frun0.jpg alt></p><ul><li><a href=/article-8933-1.html>第一节: Hello, OpenGL</a></li><li><a href=/article-8937-1.html>第二节: 绘制游戏面板</a></li><li><a href=/article-8969-1.html>第三节：实现游戏功能</a></li></ul><p>该教程的完整源代码可以从 <a href=https://github.com/KyleBanks/conways-gol>GitHub</a> 上找到。</p><p>欢迎回到《OpenGL 与 Go 教程》！如果你还没有看过 <a href=/article-8933-1.html>第一节</a> 和 <a href=https://kylewbanks.com/blog/%5BPart%202:%20Drawing%20the%20Game%20Board%5D(/blog/tutorial-opengl-with-golang-part-2-drawing-the-game-board)>第二节</a>，那就要回过头去看一看。</p><p>到目前为止，你应该懂得如何创建网格系统以及创建代表方格中每一个单元的格子阵列。现在可以开始把网格当作游戏面板实现 康威生命游戏 Conway&rsquo;s Game of Life 。</p><p>开始吧！</p><h3 id=实现康威生命游戏>实现康威生命游戏</h3><p>康威生命游戏的其中一个要点是所有 细胞 cell 必须同时基于当前细胞在面板中的状态确定下一个细胞的状态。也就是说如果细胞 <code>(X=3,Y=4)</code> 在计算过程中状态发生了改变，那么邻近的细胞 <code>(X=4,Y=4)</code> 必须基于 <code>(X=3,Y=4)</code> 的状态决定自己的状态变化，而不是基于自己现在的状态。简单的讲，这意味着我们必须遍历细胞，确定下一个细胞的状态，而在绘制之前不改变他们的当前状态，然后在下一次循环中我们将新状态应用到游戏里，依此循环往复。</p><p>为了完成这个功能，我们需要在 <code>cell</code> 结构体中添加两个布尔型变量：</p><pre tabindex=0><code>type cell struct {
    drawable uint32

    alive     bool
    aliveNext bool

    x int
    y int
}
</code></pre><p>这里我们添加了 <code>alive</code> 和 <code>aliveNext</code>，前一个是细胞当前的专题，后一个是经过计算后下一回合的状态。</p><p>现在添加两个函数，我们会用它们来确定 cell 的状态：</p><pre tabindex=0><code>// checkState 函数决定下一次游戏循环时的 cell 状态
func (c *cell) checkState(cells [][]*cell) {
    c.alive = c.aliveNext
    c.aliveNext = c.alive

    liveCount := c.liveNeighbors(cells)
    if c.alive {
        // 1. 当任何一个存活的 cell 的附近少于 2 个存活的 cell 时，该 cell 将会消亡，就像人口过少所导致的结果一样
        if liveCount &lt; 2 {
            c.aliveNext = false
        }

        // 2. 当任何一个存活的 cell 的附近有 2 至 3 个存活的 cell 时，该 cell 在下一代中仍然存活。
        if liveCount == 2 || liveCount == 3 {
            c.aliveNext = true
        }

        // 3. 当任何一个存活的 cell 的附近多于 3 个存活的 cell 时，该 cell 将会消亡，就像人口过多所导致的结果一样
        if liveCount &gt; 3 {
            c.aliveNext = false
        }
    } else {
        // 4. 任何一个消亡的 cell 附近刚好有 3 个存活的 cell，该 cell 会变为存活的状态，就像重生一样。
        if liveCount == 3 {
            c.aliveNext = true
        }
    }
}

// liveNeighbors 函数返回当前 cell 附近存活的 cell 数
func (c *cell) liveNeighbors(cells [][]*cell) int {
    var liveCount int
    add := func(x, y int) {
        // If we&#39;re at an edge, check the other side of the board.
        if x == len(cells) {
            x = 0
        } else if x == -1 {
            x = len(cells) - 1
        }
        if y == len(cells[x]) {
            y = 0
        } else if y == -1 {
            y = len(cells[x]) - 1
        }

        if cells[x][y].alive {
            liveCount++
        }
    }

    add(c.x-1, c.y)   // To the left
    add(c.x+1, c.y)   // To the right
    add(c.x, c.y+1)   // up
    add(c.x, c.y-1)   // down
    add(c.x-1, c.y+1) // top-left
    add(c.x+1, c.y+1) // top-right
    add(c.x-1, c.y-1) // bottom-left
    add(c.x+1, c.y-1) // bottom-right

    return liveCount
}
</code></pre><p>在 <code>checkState</code> 中我们设置当前状态（<code>alive</code>） 等于我们最近迭代结果（<code>aliveNext</code>）。接下来我们计数邻居数量，并根据游戏的规则来决定 <code>aliveNext</code> 状态。该规则是比较清晰的，而且我们在上面的代码当中也有说明，所以这里不再赘述。</p><p>更加值得注意的是 <code>liveNeighbors</code> 函数里，我们返回的是当前处于存活（<code>alive</code>）状态的细胞的邻居个数。我们定义了一个叫做 <code>add</code> 的内嵌函数，它会对 <code>X</code> 和 <code>Y</code> 坐标做一些重复性的验证。它所做的事情是检查我们传递的数字是否超出了范围——比如说，如果细胞 <code>(X=0,Y=5)</code> 想要验证它左边的细胞，它就得验证面板另一边的细胞 <code>(X=9,Y=5)</code>，Y 轴与之类似。</p><p>在 <code>add</code> 内嵌函数后面，我们给当前细胞附近的八个细胞分别调用 <code>add</code> 函数，示意如下：</p><pre tabindex=0><code>[
    [-, -, -],
    [N, N, N],
    [N, C, N],
    [N, N, N],
    [-, -, -]
]
</code></pre><p>在该示意中，每一个叫做 N 的细胞是 C 的邻居。</p><p>现在是我们的 <code>main</code> 函数，这里我们执行核心游戏循环，调用每个细胞的 <code>checkState</code> 函数进行绘制：</p><pre tabindex=0><code>func main() {
    ...

    for !window.ShouldClose() {
        for x := range cells {
            for _, c := range cells[x] {
                c.checkState(cells)
            }
        }

        draw(cells, window, program)
    }
}
</code></pre><p>现在我们的游戏逻辑全都设置好了，我们需要修改细胞绘制函数来跳过绘制不存活的细胞：</p><pre tabindex=0><code>func (c *cell) draw() {
    if !c.alive {
            return
    }

    gl.BindVertexArray(c.drawable)
    gl.DrawArrays(gl.TRIANGLES, 0, int32(len(square)/3))
}
</code></pre><p>如果我们现在运行这个游戏，你将看到一个纯黑的屏幕，而不是我们辛苦工作后应该看到生命模拟。为什么呢？其实这正是模拟在工作。因为我们没有活着的细胞，所以就一个都不会绘制出来。</p><p>现在完善这个函数。回到 <code>makeCells</code> 函数，我们用 <code>0.0</code> 到 <code>1.0</code> 之间的一个随机数来设置游戏的初始状态。我们会定义一个大小为 <code>0.15</code> 的常量阈值，也就是说每个细胞都有 15% 的几率处于存活状态。</p><pre tabindex=0><code>import (
    &#34;math/rand&#34;
    &#34;time&#34;
    ...
)

const (
    ...

    threshold = 0.15
)

func makeCells() [][]*cell {
    rand.Seed(time.Now().UnixNano())

    cells := make([][]*cell, rows, rows)
    for x := 0; x &lt; rows; x++ {
        for y := 0; y &lt; columns; y++ {
            c := newCell(x, y)

            c.alive = rand.Float64() &lt; threshold
            c.aliveNext = c.alive

            cells[x] = append(cells[x], c)
        }
    }

    return cells
}
</code></pre><p>我们首先增加两个引入：随机（<code>math/rand</code>）和时间（<code>time</code>），并定义我们的常量阈值。然后在 <code>makeCells</code> 中我们使用当前时间作为随机种子，给每个游戏一个独特的起始状态。你也可也指定一个特定的种子值，来始终得到一个相同的游戏，这在你想重放某个有趣的模拟时很有用。</p><p>接下来在循环中，在用 <code>newCell</code> 函数创造一个新的细胞时，我们根据随机浮点数的大小设置它的存活状态，随机数在 <code>0.0</code> 到 <code>1.0</code> 之间，如果比阈值（<code>0.15</code>）小，就是存活状态。再次强调，这意味着每个细胞在开始时都有 15% 的几率是存活的。你可以修改数值大小，增加或者减少当前游戏中存活的细胞。我们还把 <code>aliveNext</code> 设成 <code>alive</code> 状态，否则在第一次迭代之后我们会发现一大片细胞消亡了，这是因为 <code>aliveNext</code> 将永远是 <code>false</code>。</p><p>现在继续运行它，你很有可能看到细胞们一闪而过，但你却无法理解这是为什么。原因可能在于你的电脑太快了，在你能够看清楚之前就运行了（甚至完成了）模拟过程。</p><p>让我们降低游戏速度，在主循环中引入一个帧率（FPS）限制：</p><pre tabindex=0><code>const (
    ...

    fps = 2
)

func main() {
    ...

    for !window.ShouldClose() {
        t := time.Now()

        for x := range cells {
            for _, c := range cells[x] {
                c.checkState(cells)
            }
        }

        if err := draw(prog, window, cells); err != nil {
            panic(err)
        }

        time.Sleep(time.Second/time.Duration(fps) - time.Since(t))
    }
}
</code></pre><p>现在你能给看出一些图案了，尽管它变换的很慢。把 FPS 加到 10，把方格的尺寸加到 100x100，你就能看到更真实的模拟：</p><pre tabindex=0><code>const (
    ...

    rows = 100
    columns = 100

    fps = 10

    ...
)
</code></pre><p><img src=https://img.linux.net.cn/data/attachment/album/201710/17/154537s5hgt5z95e5gc55w.gif alt=" “Conway&rsquo;s Game of Life” - 示例游戏"></p><p>试着修改常量，看看它们是怎么影响模拟过程的 —— 这是你用 Go 语言写的第一个 OpenGL 程序，很酷吧？</p><h3 id=进阶内容>进阶内容？</h3><p>这是《OpenGL 与 Go 教程》的最后一节，但是这不意味着到此而止。这里有些新的挑战，能够增进你对 OpenGL （以及 Go）的理解。</p><ol><li>给每个细胞一种不同的颜色。</li><li>让用户能够通过命令行参数指定格子尺寸、帧率、种子和阈值。在 GitHub 上的 <a href=https://github.com/KyleBanks/conways-gol>github.com/KyleBanks/conways-gol</a> 里你可以看到一个已经实现的程序。</li><li>把格子的形状变成其它更有意思的，比如六边形。</li><li>用颜色表示细胞的状态 —— 比如，在第一帧把存活状态的格子设成绿色，如果它们存活了超过三帧的时间，就变成黄色。</li><li>如果模拟过程结束了，就自动关闭窗口，也就是说所有细胞都消亡了，或者是最后两帧里没有格子的状态有改变。</li><li>将着色器源代码放到单独的文件中，而不是把它们用字符串的形式放在 Go 的源代码中。</li></ol><h3 id=总结>总结</h3><p>希望这篇教程对想要入门 OpenGL （或者是 Go）的人有所帮助！这很有趣，因此我也希望理解学习它也很有趣。</p><p>正如我所说的，OpenGL 可能是非常恐怖的，但只要你开始着手了就不会太差。你只用制定一个个可达成的小目标，然后享受每一次成功，因为尽管 OpenGL 不会总像它看上去的那么难，但也肯定有些难懂的东西。我发现，当遇到一个难于理解用 go-gl 生成的代码的 OpenGL 问题时，你总是可以参考一下在网上更流行的当作教程的 C 语言代码，这很有用。通常 C 语言和 Go 语言的唯一区别是在 Go 中，gl 函数的前缀是 <code>gl.</code> 而不是 <code>gl</code>，常量的前缀是 <code>gl</code> 而不是 <code>GL_</code>。这可以极大地增加了你的绘制知识！</p><p>该教程的完整源代码可从 <a href=https://github.com/KyleBanks/conways-gol>GitHub</a> 上获得。</p><h3 id=回顾>回顾</h3><p>这是 main.go 文件最终的内容：</p><pre tabindex=0><code>package main

import (
    &#34;fmt&#34;
    &#34;log&#34;
    &#34;math/rand&#34;
    &#34;runtime&#34;
    &#34;strings&#34;
    &#34;time&#34;

    &#34;github.com/go-gl/gl/v4.1-core/gl&#34; // OR: github.com/go-gl/gl/v2.1/gl
    &#34;github.com/go-gl/glfw/v3.2/glfw&#34;
)

const (
    width  = 500
    height = 500

    vertexShaderSource = `
        #version 410
        in vec3 vp;
        void main() {
            gl_Position = vec4(vp, 1.0);
        }
    ` + &#34;\x00&#34;

    fragmentShaderSource = `
        #version 410
        out vec4 frag_colour;
        void main() {
            frag_colour = vec4(1, 1, 1, 1.0);
        }
    ` + &#34;\x00&#34;

    rows    = 100
    columns = 100

    threshold = 0.15
    fps       = 10
)

var (
    square = []float32{
        -0.5, 0.5, 0,
        -0.5, -0.5, 0,
        0.5, -0.5, 0,

        -0.5, 0.5, 0,
        0.5, 0.5, 0,
        0.5, -0.5, 0,
    }
)

type cell struct {
    drawable uint32

    alive     bool
    aliveNext bool

    x int
    y int
}

func main() {
    runtime.LockOSThread()

    window := initGlfw()
    defer glfw.Terminate()
    program := initOpenGL()

    cells := makeCells()
    for !window.ShouldClose() {
        t := time.Now()

        for x := range cells {
            for _, c := range cells[x] {
                c.checkState(cells)
            }
        }

        draw(cells, window, program)

        time.Sleep(time.Second/time.Duration(fps) - time.Since(t))
    }
}

func draw(cells [][]*cell, window *glfw.Window, program uint32) {
    gl.Clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)
    gl.UseProgram(program)

    for x := range cells {
        for _, c := range cells[x] {
            c.draw()
        }
    }

    glfw.PollEvents()
    window.SwapBuffers()
}

func makeCells() [][]*cell {
    rand.Seed(time.Now().UnixNano())

    cells := make([][]*cell, rows, rows)
    for x := 0; x &lt; rows; x++ {
        for y := 0; y &lt; columns; y++ {
            c := newCell(x, y)

            c.alive = rand.Float64() &lt; threshold
            c.aliveNext = c.alive

            cells[x] = append(cells[x], c)
        }
    }

    return cells
}
func newCell(x, y int) *cell {
    points := make([]float32, len(square), len(square))
    copy(points, square)

    for i := 0; i &lt; len(points); i++ {
        var position float32
        var size float32
        switch i % 3 {
        case 0:
            size = 1.0 / float32(columns)
            position = float32(x) * size
        case 1:
            size = 1.0 / float32(rows)
            position = float32(y) * size
        default:
            continue
        }

        if points[i] &lt; 0 {
            points[i] = (position * 2) - 1
        } else {
            points[i] = ((position + size) * 2) - 1
        }
    }

    return &amp;cell{
        drawable: makeVao(points),

        x: x,
        y: y,
    }
}

func (c *cell) draw() {
    if !c.alive {
        return
    }

    gl.BindVertexArray(c.drawable)
    gl.DrawArrays(gl.TRIANGLES, 0, int32(len(square)/3))
}

// checkState 函数决定下一次游戏循环时的 cell 状态
func (c *cell) checkState(cells [][]*cell) {
    c.alive = c.aliveNext
    c.aliveNext = c.alive

    liveCount := c.liveNeighbors(cells)
    if c.alive {
        // 1. 当任何一个存活的 cell 的附近少于 2 个存活的 cell 时，该 cell 将会消亡，就像人口过少所导致的结果一样
        if liveCount &lt; 2 {
            c.aliveNext = false
        }

        // 2. 当任何一个存活的 cell 的附近有 2 至 3 个存活的 cell 时，该 cell 在下一代中仍然存活。
        if liveCount == 2 || liveCount == 3 {
            c.aliveNext = true
        }

        // 3. 当任何一个存活的 cell 的附近多于 3 个存活的 cell 时，该 cell 将会消亡，就像人口过多所导致的结果一样
        if liveCount &gt; 3 {
            c.aliveNext = false
        }
    } else {
        // 4. 任何一个消亡的 cell 附近刚好有 3 个存活的 cell，该 cell 会变为存活的状态，就像重生一样。
        if liveCount == 3 {
            c.aliveNext = true
        }
    }
}

// liveNeighbors 函数返回当前 cell 附近存活的 cell 数
func (c *cell) liveNeighbors(cells [][]*cell) int {
    var liveCount int
    add := func(x, y int) {
        // If we&#39;re at an edge, check the other side of the board.
        if x == len(cells) {
            x = 0
        } else if x == -1 {
            x = len(cells) - 1
        }
        if y == len(cells[x]) {
            y = 0
        } else if y == -1 {
            y = len(cells[x]) - 1
        }

        if cells[x][y].alive {
            liveCount++
        }
    }

    add(c.x-1, c.y)   // To the left
    add(c.x+1, c.y)   // To the right
    add(c.x, c.y+1)   // up
    add(c.x, c.y-1)   // down
    add(c.x-1, c.y+1) // top-left
    add(c.x+1, c.y+1) // top-right
    add(c.x-1, c.y-1) // bottom-left
    add(c.x+1, c.y-1) // bottom-right

    return liveCount
}

// initGlfw 初始化 glfw，返回一个可用的 Window
func initGlfw() *glfw.Window {
    if err := glfw.Init(); err != nil {
        panic(err)
    }
    glfw.WindowHint(glfw.Resizable, glfw.False)
    glfw.WindowHint(glfw.ContextVersionMajor, 4)
    glfw.WindowHint(glfw.ContextVersionMinor, 1)
    glfw.WindowHint(glfw.OpenGLProfile, glfw.OpenGLCoreProfile)
    glfw.WindowHint(glfw.OpenGLForwardCompatible, glfw.True)

    window, err := glfw.CreateWindow(width, height, &#34;Conway&#39;s Game of Life&#34;, nil, nil)
    if err != nil {
        panic(err)
    }
    window.MakeContextCurrent()

    return window
}

// initOpenGL 初始化 OpenGL 并返回一个已经编译好的着色器程序
func initOpenGL() uint32 {
    if err := gl.Init(); err != nil {
        panic(err)
    }
    version := gl.GoStr(gl.GetString(gl.VERSION))
    log.Println(&#34;OpenGL version&#34;, version)

    vertexShader, err := compileShader(vertexShaderSource, gl.VERTEX_SHADER)
    if err != nil {
        panic(err)
    }

    fragmentShader, err := compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER)
    if err != nil {
        panic(err)
    }

    prog := gl.CreateProgram()
    gl.AttachShader(prog, vertexShader)
    gl.AttachShader(prog, fragmentShader)
    gl.LinkProgram(prog)
    return prog
}

// makeVao 初始化并从提供的点里面返回一个顶点数组
func makeVao(points []float32) uint32 {
    var vbo uint32
    gl.GenBuffers(1, &amp;vbo)
    gl.BindBuffer(gl.ARRAY_BUFFER, vbo)
    gl.BufferData(gl.ARRAY_BUFFER, 4*len(points), gl.Ptr(points), gl.STATIC_DRAW)

    var vao uint32
    gl.GenVertexArrays(1, &amp;vao)
    gl.BindVertexArray(vao)
    gl.EnableVertexAttribArray(0)
    gl.BindBuffer(gl.ARRAY_BUFFER, vbo)
    gl.VertexAttribPointer(0, 3, gl.FLOAT, false, 0, nil)

    return vao
}

func compileShader(source string, shaderType uint32) (uint32, error) {
    shader := gl.CreateShader(shaderType)

    csources, free := gl.Strs(source)
    gl.ShaderSource(shader, 1, csources, nil)
    free()
    gl.CompileShader(shader)

    var status int32
    gl.GetShaderiv(shader, gl.COMPILE_STATUS, &amp;status)
    if status == gl.FALSE {
        var logLength int32
        gl.GetShaderiv(shader, gl.INFO_LOG_LENGTH, &amp;logLength)

        log := strings.Repeat(&#34;\x00&#34;, int(logLength+1))
        gl.GetShaderInfoLog(shader, logLength, nil, gl.Str(log))

        return 0, fmt.Errorf(&#34;failed to compile %v: %v&#34;, source, log)
    }

    return shader, nil
}
</code></pre><p>请在 Twitter <a href=https://twitter.com/kylewbanks>@kylewbanks</a> 告诉我这篇文章对你是否有帮助，或者在 Twitter 下方关注我以便及时获取最新文章！</p><hr><p>via: <a href=https://kylewbanks.com/blog/tutorial-opengl-with-golang-part-3-implementing-the-game>https://kylewbanks.com/blog/tutorial-opengl-with-golang-part-3-implementing-the-game</a></p><p>作者：<a href=https://twitter.com/kylewbanks>kylewbanks</a> 译者：<a href=https://github.com/GitFuture>GitFuture</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/opengl/ rel=tag>OpenGL</a></li><li class=tags__item><a class="tags__link btn" href=/tags/golang/ rel=tag>Golang</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>