<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>如何使用 Python 来自动交易加密货币 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="如何使用 Python 来自动交易加密货币"><meta property="og:description" content="在本教程中，教你如何设置和使用 Pythonic 来编程。它是一个图形化编程工具，用户可以很容易地使用现成的函数模块创建 Python 程序。"><meta property="og:type" content="article"><meta property="og:url" content="/article-13242-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-03-28T09:40:48+00:00"><meta property="article:modified_time" content="2021-03-28T09:40:48+00:00"><meta itemprop=name content="如何使用 Python 来自动交易加密货币"><meta itemprop=description content="在本教程中，教你如何设置和使用 Pythonic 来编程。它是一个图形化编程工具，用户可以很容易地使用现成的函数模块创建 Python 程序。"><meta itemprop=datePublished content="2021-03-28T09:40:48+00:00"><meta itemprop=dateModified content="2021-03-28T09:40:48+00:00"><meta itemprop=wordCount content="555"><meta itemprop=keywords content="加密货币,自动交易,Python,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>如何使用 Python 来自动交易加密货币</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2021-03-28T09:40:48Z>March 28, 2021</time></div></div></header><div class="content post__content clearfix"><blockquote><p>在本教程中，教你如何设置和使用 Pythonic 来编程。它是一个图形化编程工具，用户可以很容易地使用现成的函数模块创建 Python 程序。</p></blockquote><p><img src=/data/attachment/album/202103/28/093858qu0bh3w2sd3rh20s.jpg alt title="scientific calculator"></p><p>然而，不像纽约证券交易所这样的传统证券交易所一样，有一段固定的交易时间。对于加密货币而言，则是 7×24 小时交易，这使得任何人都无法独自盯着市场。</p><p>在以前，我经常思考与加密货币交易相关的问题：</p><ul><li>一夜之间发生了什么？</li><li>为什么没有日志记录？</li><li>为什么下单？</li><li>为什么不下单？</li></ul><p>通常的解决手段是使用加密交易机器人，当在你做其他事情时，例如睡觉、与家人在一起或享受空闲时光，代替你下单。虽然有很多商业解决方案可用，但是我选择开源的解决方案，因此我编写了加密交易机器人 <a href=https://github.com/hANSIc99/Pythonic>Pythonic</a>。 正如去年 <a href=https://opensource.com/article/19/5/graphically-programming-pythonic>我写过的文章</a> 一样，“Pythonic 是一种图形化编程工具，它让用户可以轻松使用现成的函数模块来创建 Python 应用程序。” 最初它是作为加密货币机器人使用，并具有可扩展的日志记录引擎以及经过精心测试的可重用部件，例如调度器和计时器。</p><h3 id=开始>开始</h3><p>本教程将教你如何开始使用 Pythonic 进行自动交易。我选择 币安 Binance 交易所的 波场 Tron 与 比特币 Bitcoin 交易对为例。我之所以选择这个加密货币对，是因为它们彼此之间的波动性大，而不是出于个人喜好。</p><p>机器人将根据 指数移动平均 exponential moving averages （EMA）来做出决策。</p><p><img src=/data/attachment/album/202103/28/094050ln73sss1s9st3ssf.png alt="TRX/BTC 1-hour candle chart" title="TRX/BTC 1-hour candle chart"></p><p><em>TRX/BTC 1 小时 K 线图</em></p><p>EMA 指标通常是一个加权的移动平均线，可以对近期价格数据赋予更多权重。尽管移动平均线可能只是一个简单的指标，但我对它很有经验。</p><p>上图中的紫色线显示了 EMA-25 指标（这表示要考虑最近的 25 个值）。</p><p>机器人监视当前的 EMA-25 值（t0）和前一个 EMA-25 值（t-1）之间的差距。如果差值超过某个值，则表示价格上涨，机器人将下达购买订单。如果差值低于某个值，则机器人将下达卖单。</p><p>差值将是做出交易决策的主要指标。在本教程中，它称为交易参数。</p><h3 id=工具链>工具链</h3><p>将在本教程使用如下工具：</p><ul><li>币安专业交易视图（已经有其他人做了数据可视化，所以不需要重复造轮子）</li><li>Jupyter 笔记本：用于数据科学任务</li><li>Pythonic：作为整体框架</li><li>PythonicDaemon ：作为终端运行（仅适用于控制台和 Linux）</li></ul><h3 id=数据挖掘>数据挖掘</h3><p>为了使加密货币交易机器人尽可能做出正确的决定，以可靠的方式获取资产的 美国线 open-high-low-close chart （<a href=https://en.wikipedia.org/wiki/Open-high-low-close_chart>OHLC</a>）数据是至关重要。你可以使用 Pythonic 的内置元素，还可以根据自己逻辑来对其进行扩展。</p><p>一般的工作流程：</p><ol><li>与币安时间同步</li><li>下载 OHLC 数据</li><li>从文件中把 OHLC 数据加载到内存</li><li>比较数据集并扩展更新数据集</li></ol><p>这个工作流程可能有点夸张，但是它能使得程序更加健壮，甚至在停机和断开连接时，也能平稳运行。</p><p>一开始，你需要 币安 OHLC 查询 Binance OHLC Query 元素和一个 基础操作 Basic Operation 元素来执行你的代码。</p><p><img src=/data/attachment/album/202103/28/094051qdkqluhu7sqkus73.png alt="Data-mining workflow" title="Data-mining workflow"></p><p><em>数据挖掘工作流程</em></p><p>OHLC 查询设置为每隔一小时查询一次 <strong>TRXBTC</strong> 资产对（波场/比特币）。</p><p><img src=/data/attachment/album/202103/28/094051lwhwz6qyhg8zspg6.png alt="Configuration of the OHLC query element" title="Configuration of the OHLC query element"></p><p><em>配置 OHLC 查询元素</em></p><p>其中输出的元素是 <a href=https://pandas.pydata.org/pandas-docs/stable/getting_started/dsintro.html#dataframe>Pandas DataFrame</a>。你可以在 <strong>基础操作</strong> 元素中使用 输入 input 变量来访问 DataFrame。其中，将 Vim 设置为 <strong>基础操作</strong> 元素的默认代码编辑器。</p><p><img src=/data/attachment/album/202103/28/094052xn23s2x4xoj24d6f.png alt="Basic Operation element set up to use Vim" title="Basic Operation element set up to use Vim"></p><p><em>使用 Vim 编辑基础操作元素</em></p><p>具体代码如下：</p><pre tabindex=0><code>import pickle, pathlib, os
import pandas as pd

outout = None

if isinstance(input, pd.DataFrame):
    file_name = &#39;TRXBTC_1h.bin&#39;
    home_path = str(pathlib.Path.home())
    data_path = os.path.join(home_path, file_name)

    try:
        df = pickle.load(open(data_path, &#39;rb&#39;))
        n_row_cnt = df.shape[0]
        df = pd.concat([df,input], ignore_index=True).drop_duplicates([&#39;close_time&#39;])
        df.reset_index(drop=True, inplace=True)
        n_new_rows = df.shape[0] - n_row_cnt
        log_txt = &#39;{}: {} new rows written&#39;.format(file_name, n_new_rows)
    except:
        log_txt = &#39;File error - writing new one: {}&#39;.format(e)
        df = input

    pickle.dump(df, open(data_path, &#34;wb&#34; ))
    output = df
</code></pre><p>首先，检查输入是否为 DataFrame 元素。然后在用户的家目录（<code>~/</code>）中查找名为 <code>TRXBTC_1h.bin</code> 的文件。如果存在，则将其打开，执行新代码段（<code>try</code> 部分中的代码），并删除重复项。如果文件不存在，则触发异常并执行 <code>except</code> 部分中的代码，创建一个新文件。</p><p>只要启用了复选框 日志输出 log output ，你就可以使用命令行工具 <code>tail</code> 查看日志记录：</p><pre tabindex=0><code>$ tail -f ~/Pythonic_2020/Feb/log_2020_02_19.txt
</code></pre><p>出于开发目的，现在跳过与币安时间的同步和计划执行，这将在下面实现。</p><h3 id=准备数据>准备数据</h3><p>下一步是在单独的 网格 Grid 中处理评估逻辑。因此，你必须借助 返回元素 Return element 将 DataFrame 从网格 1 传递到网格 2 的第一个元素。</p><p>在网格 2 中，通过使 DataFrame 通过 基础技术分析 Basic Technical Analysis 元素，将 DataFrame 扩展包含 EMA 值的一列。</p><p><img src=/data/attachment/album/202103/28/094052xq7vemsqm9evasx9.png alt="Technical analysis workflow in Grid 2" title="Technical analysis workflow in Grid 2"></p><p><em>在网格 2 中技术分析工作流程</em></p><p>配置技术分析元素以计算 25 个值的 EMA。</p><p><img src=/data/attachment/album/202103/28/094053x0wecdexbcc7idhy.png alt="Configuration of the technical analysis element" title="Configuration of the technical analysis element"></p><p><em>配置技术分析元素</em></p><p>当你运行整个程序并开启 技术分析 Technical Analysis 元素的调试输出时，你将发现 EMA-25 列的值似乎都相同。</p><p><img src=/data/attachment/album/202103/28/094053c6poxlr4exxe4foc.png alt="Missing decimal places in output" title="Missing decimal places in output"></p><p><em>输出中精度不够</em></p><p>这是因为调试输出中的 EMA-25 值仅包含六位小数，即使输出保留了 8 个字节完整精度的浮点值。</p><p>为了能进行进一步处理，请添加 <strong>基础操作</strong> 元素：</p><p><img src=/data/attachment/album/202103/28/094053w4u44j6wqz6fr3kh.png alt="Workflow in Grid 2" title="Workflow in Grid 2"></p><p><em>网格 2 中的工作流程</em></p><p>使用 <strong>基础操作</strong> 元素，将 DataFrame 与添加的 EMA-25 列一起转储，以便可以将其加载到 Jupyter 笔记本中；</p><p><img src=/data/attachment/album/202103/28/094054kc1y44yvcvgycnye.png alt="Dump extended DataFrame to file" title="Dump extended DataFrame to file"></p><p><em>将扩展后的 DataFrame 存储到文件中</em></p><h3 id=评估策略>评估策略</h3><p>在 Juypter 笔记本中开发评估策略，让你可以更直接地访问代码。要加载 DataFrame，你需要使用如下代码：</p><p><img src=/data/attachment/album/202103/28/094054s7ozuzh8ebzpeb9o.png alt="Representation with all decimal places" title="Representation with all decimal places"></p><p><em>用全部小数位表示</em></p><p>你可以使用 <a href=https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.iloc.html>iloc</a> 和列名来访问最新的 EMA-25 值，并且会保留所有小数位。</p><p>你已经知道如何来获得最新的数据。上面示例的最后一行仅显示该值。为了能将该值拷贝到不同的变量中，你必须使用如下图所示的 <code>.at</code> 方法方能成功。</p><p>你也可以直接计算出你下一步所需的交易参数。</p><p><img src=/data/attachment/album/202103/28/094054jnb1dc3caipaksf9.png alt="Buy/sell decision" title="Buy/sell decision"></p><p><em>买卖决策</em></p><h3 id=确定交易参数>确定交易参数</h3><p>如上面代码所示，我选择 0.009 作为交易参数。但是我怎么知道 0.009 是决定交易的一个好参数呢？ 实际上，这个参数确实很糟糕，因此，你可以直接计算出表现最佳的交易参数。</p><p>假设你将根据收盘价进行买卖。</p><p><img src=/data/attachment/album/202103/28/094055jx5yz5ctp8qctej9.png alt="Validation function" title="Validation function"></p><p><em>回测功能</em></p><p>在此示例中，<code>buy_factor</code> 和 <code>sell_factor</code> 是预先定义好的。因此，发散思维用直接计算出表现最佳的参数。</p><p><img src=/data/attachment/album/202103/28/094055b6i0t6cqv5ffhbwq.png alt="Nested for loops for determining the buy and sell factor" title="Nested for loops for determining the buy and sell factor"></p><p><em>嵌套的 for 循环，用于确定购买和出售的参数</em></p><p>这要跑 81 个循环（9x9），在我的机器（Core i7 267QM）上花费了几分钟。</p><p><img src=/data/attachment/album/202103/28/094055bquv9iyqi0rbtqth.png alt="System utilization while brute forcing" title="System utilization while brute forcing"></p><p><em>在暴力运算时系统的利用率</em></p><p>在每个循环之后，它将 <code>buy_factor</code>、<code>sell_factor</code> 元组和生成的 <code>profit</code> 元组追加到 <code>trading_factors</code> 列表中。按利润降序对列表进行排序。</p><p><img src=/data/attachment/album/202103/28/094056ze0gzqu9vgg22v2w.png alt="Sort profit with related trading factors in descending order" title="Sort profit with related trading factors in descending order"></p><p><em>将利润与相关的交易参数按降序排序</em></p><p>当你打印出列表时，你会看到 0.002 是最好的参数。</p><p><img src=/data/attachment/album/202103/28/094056oxlihvaiixwg84jw.png alt="Sorted list of trading factors and profit" title="Sorted list of trading factors and profit"></p><p><em>交易要素和收益的有序列表</em></p><p>当我在 2020 年 3 月写下这篇文章时，价格的波动还不足以呈现出更理想的结果。我在 2 月份得到了更好的结果，但即使在那个时候，表现最好的交易参数也在 0.002 左右。</p><h3 id=分割执行路径>分割执行路径</h3><p>现在开始新建一个网格以保持逻辑清晰。使用 <strong>返回</strong> 元素将带有 EMA-25 列的 DataFrame 从网格 2 传递到网格 3 的 0A 元素。</p><p>在网格 3 中，添加 <strong>基础操作</strong> 元素以执行评估逻辑。这是该元素中的代码：</p><p><img src=/data/attachment/album/202103/28/094056ofn26ububue22fuz.png alt="Implemented evaluation logic" title="Implemented evaluation logic"></p><p><em>实现评估策略</em></p><p>如果输出 <code>1</code> 表示你应该购买，如果输出 <code>2</code> 则表示你应该卖出。 输出 <code>0</code> 表示现在无需操作。使用 分支 Branch 元素来控制执行路径。</p><p><img src=/data/attachment/album/202103/28/094056q3tp37wwlz0b0on1.png alt="Branch element: Grid 3 Position 2A" title="Branch element: Grid 3 Position 2A"></p><p><em>分支元素：网格 3，2A 位置</em></p><p>因为 <code>0</code> 和 <code>-1</code> 的处理流程一样，所以你需要在最右边添加一个分支元素来判断你是否应该卖出。</p><p><img src=/data/attachment/album/202103/28/094057stk7jj4nlwnk2puw.png alt="Branch element: Grid 3 Position 3B" title="Branch element: Grid 3 Position 3B"></p><p><em>分支元素：网格 3，3B 位置</em></p><p>网格 3 应该现在如下图所示：</p><p><img src=/data/attachment/album/202103/28/094057fe1wnzar6x664rnz.png alt="Workflow on Grid 3" title="Workflow on Grid 3"></p><p><em>网格 3 的工作流程</em></p><h3 id=下单>下单</h3><p>由于无需在一个周期中购买两次，因此必须在周期之间保留一个持久变量，以指示你是否已经购买。</p><p>你可以利用 栈 Stack 元素来实现。顾名思义，栈元素表示可以用任何 Python 数据类型来放入的基于文件的栈。</p><p>你需要定义栈仅包含一个布尔类型，该布尔类型决定是否购买了（<code>True</code>）或（<code>False</code>）。因此，你必须使用 <code>False</code> 来初始化栈。例如，你可以在网格 4 中简单地通过将 <code>False</code> 传递给栈来进行设置。</p><p><img src=/data/attachment/album/202103/28/094057yiszipdxx9dxizfw.png alt="Forward a False-variable to the subsequent Stack element" title="Forward a False-variable to the subsequent Stack element"></p><p><em>将 False 变量传输到后续的栈元素中</em></p><p>在分支树后的栈实例可以进行如下配置：</p><p><img src=/data/attachment/album/202103/28/094058xquob8epsfqzopif.png alt="Configuration of the Stack element" title="Configuration of the Stack element"></p><p><em>设置栈元素</em></p><p>在栈元素设置中，将 对输入的操作 Do this with input 设置成 无 Nothing 。否则，布尔值将被 <code>1</code> 或 <code>0</code> 覆盖。</p><p>该设置确保仅将一个值保存于栈中（<code>True</code> 或 <code>False</code>），并且只能读取一个值（为了清楚起见）。</p><p>在栈元素之后，你需要另外一个 <strong>分支</strong> 元素来判断栈的值，然后再放置 币安订单 Binance Order 元素。</p><p><img src=/data/attachment/album/202103/28/094058vwu6v7ii6kvwwx9a.png alt="Evaluate the variable from the stack" title="Evaluate the variable from the stack"></p><p><em>判断栈中的变量</em></p><p>将币安订单元素添加到分支元素的 <code>True</code> 路径。网格 3 上的工作流现在应如下所示：</p><p><img src=/data/attachment/album/202103/28/094059oreu9efclcs5glo9.png alt="Workflow on Grid 3" title="Workflow on Grid 3"></p><p><em>网格 3 的工作流程</em></p><p>币安订单元素应如下配置：</p><p><img src=/data/attachment/album/202103/28/094059cc5ntnvbsqriu43w.png alt="Configuration of the Binance Order element" title="Configuration of the Binance Order element"></p><p><em>编辑币安订单元素</em></p><p>你可以在币安网站上的帐户设置中生成 API 和密钥。</p><p><img src=/data/attachment/album/202103/28/094059dlcgcx40e8eeb4bu.png alt="Creating an API key in Binance" title="Creating an API key in Binance"></p><p><em>在币安账户设置中创建一个 API 密钥</em></p><p>在本文中，每笔交易都是作为市价交易执行的，交易量为 10,000 TRX（2020 年 3 月约为 150 美元）（出于教学的目的，我通过使用市价下单来演示整个过程。因此，我建议至少使用限价下单。）</p><p>如果未正确执行下单（例如，网络问题、资金不足或货币对不正确），则不会触发后续元素。因此，你可以假定如果触发了后续元素，则表示该订单已下达。</p><p>这是一个成功的 XMRBTC 卖单的输出示例：</p><p><img src=/data/attachment/album/202103/28/094059o026ikbaqx3ak6e4.png alt="Output of a successfully placed sell order" title="Output of a successfully placed sell order"></p><p><em>成功卖单的输出</em></p><p>该行为使后续步骤更加简单：你可以始终假设只要成功输出，就表示订单成功。因此，你可以添加一个 <strong>基础操作</strong> 元素，该元素将简单地输出 <strong>True</strong> 并将此值放入栈中以表示是否下单。</p><p>如果出现错误的话，你可以在日志信息中查看具体细节（如果启用日志功能）。</p><p><img src=/data/attachment/album/202103/28/094100lksn1anu9npa99aw.png alt="Logging output of Binance Order element" title="Logging output of Binance Order element"></p><p><em>币安订单元素中的输出日志信息</em></p><h3 id=调度和同步>调度和同步</h3><p>对于日程调度和同步，请在网格 1 中将整个工作流程置于 币安调度器 Binance Scheduler 元素的前面。</p><p><img src=/data/attachment/album/202103/28/094100vg5oseqx5mmongua.png alt="Binance Scheduler at Grid 1, Position 1A" title="Binance Scheduler at Grid 1, Position 1A"></p><p><em>在网格 1，1A 位置的币安调度器</em></p><p>由于币安调度器元素只执行一次，因此请在网格 1 的末尾拆分执行路径，并通过将输出传递回币安调度器来强制让其重新同步。</p><p><img src=/data/attachment/album/202103/28/094100wq624z79q2732w6b.png alt="Grid 1: Split execution path" title="Grid 1: Split execution path"></p><p><em>网格 1：拆分执行路径</em></p><p>5A 元素指向 网格 2 的 1A 元素，并且 5B 元素指向网格 1 的 1A 元素（币安调度器）。</p><h3 id=部署>部署</h3><p>你可以在本地计算机上全天候 7×24 小时运行整个程序，也可以将其完全托管在廉价的云系统上。例如，你可以使用 Linux/FreeBSD 云系统，每月约 5 美元，但通常不提供图形化界面。如果你想利用这些低成本的云，可以使用 PythonicDaemon，它能在终端中完全运行。</p><p><img src=/data/attachment/album/202103/28/094101rmm0m11k2so4r1yp.png alt="PythonicDaemon console interface" title="PythonicDaemon console interface"></p><p><em>PythonicDaemon 控制台</em></p><p>PythonicDaemon 是基础程序的一部分。要使用它，请保存完整的工作流程，将其传输到远程运行的系统中（例如，通过 安全拷贝协议 Secure Copy SCP），然后把工作流程文件作为参数来启动 PythonicDaemon：</p><pre tabindex=0><code>$ PythonicDaemon trading_bot_one
</code></pre><p>为了能在系统启动时自启 PythonicDaemon，可以将一个条目添加到 crontab 中：</p><pre tabindex=0><code># crontab -e
</code></pre><p><img src=/data/attachment/album/202103/28/094101gpj5vpvp3vps33ut.png alt="Crontab on Ubuntu Server" title="Crontab on Ubuntu Server"></p><p><em>在 Ubuntu 服务器上的 Crontab</em></p><h3 id=下一步>下一步</h3><p>正如我在一开始时所说的，本教程只是自动交易的入门。对交易机器人进行编程大约需要 10％ 的编程和 90％ 的测试。当涉及到让你的机器人用金钱交易时，你肯定会对编写的代码再三思考。因此，我建议你编码时要尽可能简单和易于理解。</p><p>如果你想自己继续开发交易机器人，接下来所需要做的事：</p><ul><li>收益自动计算（希望你有正收益！）</li><li>计算你想买的价格</li><li>比较你的预订单（例如，订单是否填写完整？）</li></ul><p>你可以从 <a href=https://github.com/hANSIc99/Pythonic>GitHub</a> 上获取完整代码。</p><hr><p>via: <a href=https://opensource.com/article/20/4/python-crypto-trading-bot>https://opensource.com/article/20/4/python-crypto-trading-bot</a></p><p>作者：<a href=https://opensource.com/users/hansic99>Stephan Avenwedde</a> 选题：<a href=https://github.com/lujun9972>lujun9972</a> 译者：<a href=https://github.com/wyxplus>wyxplus</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/%E5%8A%A0%E5%AF%86%E8%B4%A7%E5%B8%81/ rel=tag>加密货币</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E8%87%AA%E5%8A%A8%E4%BA%A4%E6%98%93/ rel=tag>自动交易</a></li><li class=tags__item><a class="tags__link btn" href=/tags/python/ rel=tag>Python</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>