<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>常用 GDB 命令中文速览 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="常用 GDB 命令中文速览"><meta property="og:description" content="本文整理自《Debugging with GDB: the GNU Source-Level Debugger for GDB (GDB)》"><meta property="og:type" content="article"><meta property="og:url" content="/article-8900-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-09-24T15:04:31+00:00"><meta property="article:modified_time" content="2017-09-24T15:04:31+00:00"><meta itemprop=name content="常用 GDB 命令中文速览"><meta itemprop=description content="本文整理自《Debugging with GDB: the GNU Source-Level Debugger for GDB (GDB)》"><meta itemprop=datePublished content="2017-09-24T15:04:31+00:00"><meta itemprop=dateModified content="2017-09-24T15:04:31+00:00"><meta itemprop=wordCount content="790"><meta itemprop=keywords content="gdb,调试,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>常用 GDB 命令中文速览</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-09-24T15:04:31Z>September 24, 2017</time></div></div></header><div class="content post__content clearfix"><p><img src=/data/attachment/album/201709/24/150421z8qnabqpphbs1a8o.jpg alt></p><h3 id=目录>目录</h3><ul><li>break &ndash; 在指定的行或函数处设置断点，缩写为 <code>b</code></li><li>info breakpoints &ndash; 打印未删除的所有断点，观察点和捕获点的列表，缩写为 <code>i b</code></li><li>disable &ndash; 禁用断点，缩写为 <code>dis</code></li><li>enable &ndash; 启用断点</li><li>clear &ndash; 清除指定行或函数处的断点</li><li>delete &ndash; 删除断点，缩写为 <code>d</code></li><li>tbreak &ndash; 设置临时断点，参数同 <code>break</code>，但在程序第一次停住后会被自动删除</li><li>watch &ndash; 为表达式（或变量）设置观察点，当表达式（或变量）的值有变化时，暂停程序执行</li><li>step &ndash; 单步跟踪，如果有函数调用，会进入该函数，缩写为 <code>s</code></li><li>reverse-step &ndash; 反向单步跟踪，如果有函数调用，会进入该函数</li><li>next &ndash; 单步跟踪，如果有函数调用，不会进入该函数，缩写为 <code>n</code></li><li>reverse-next &ndash; 反向单步跟踪，如果有函数调用，不会进入该函数</li><li>return &ndash; 使选定的栈帧返回到其调用者</li><li>finish &ndash; 执行直到选择的栈帧返回，缩写为 <code>fin</code></li><li>until &ndash; 执行直到达到当前栈帧中当前行后的某一行（用于跳过循环、递归函数调用），缩写为 <code>u</code></li><li>continue &ndash; 恢复程序执行，缩写为 <code>c</code></li><li>print &ndash; 打印表达式 EXP 的值，缩写为 <code>p</code></li><li>x &ndash; 查看内存</li><li>display &ndash; 每次程序停止时打印表达式 EXP 的值（自动显示）</li><li>info display &ndash; 打印早先设置为自动显示的表达式列表</li><li>disable display &ndash; 禁用自动显示</li><li>enable display &ndash; 启用自动显示</li><li>undisplay &ndash; 删除自动显示项</li><li>help &ndash; 打印命令列表（带参数时查找命令的帮助），缩写为 <code>h</code></li><li>attach &ndash; 挂接到已在运行的进程来调试</li><li>run &ndash; 启动被调试的程序，缩写为 <code>r</code></li><li>backtrace &ndash; 查看程序调用栈的信息，缩写为 <code>bt</code></li><li>ptype &ndash; 打印类型 TYPE 的定义</li></ul><hr><h3 id=break>break</h3><p>使用 <code>break</code> 命令（缩写 <code>b</code>）来设置断点。</p><p>用法：</p><ul><li><code>break</code> 当不带参数时，在所选栈帧中执行的下一条指令处设置断点。</li><li><code>break &lt;function-name></code> 在函数体入口处打断点，在 C++ 中可以使用 <code>class::function</code> 或 <code>function(type, ...)</code> 格式来指定函数名。</li><li><code>break &lt;line-number></code> 在当前源码文件指定行的开始处打断点。</li><li><code>break -N</code> <code>break +N</code> 在当前源码行前面或后面的 <code>N</code> 行开始处打断点，<code>N</code> 为正整数。</li><li><code>break &lt;filename:linenum></code> 在源码文件 <code>filename</code> 的 <code>linenum</code> 行处打断点。</li><li><code>break &lt;filename:function></code> 在源码文件 <code>filename</code> 的 <code>function</code> 函数入口处打断点。</li><li><code>break &lt;address></code> 在程序指令的地址处打断点。</li><li><code>break ... if &lt;cond></code> 设置条件断点，<code>...</code> 代表上述参数之一（或无参数），<code>cond</code> 为条件表达式，仅在 <code>cond</code> 值非零时暂停程序执行。</li></ul><p>详见<a href=https://sourceware.org/gdb/current/onlinedocs/gdb/Set-Breaks.html>官方文档</a>。</p><h3 id=info-breakpoints>info breakpoints</h3><p>查看断点，观察点和捕获点的列表。</p><p>用法：</p><ul><li><code>info breakpoints [list...]</code></li><li><code>info break [list...]</code></li><li><code>list...</code> 用来指定若干个断点的编号（可省略），可以是 <code>2</code>， <code>1-3</code>， <code>2 5</code> 等。</li></ul><h3 id=disable>disable</h3><p>禁用一些断点。参数是用空格分隔的断点编号。要禁用所有断点，不加参数。</p><p>禁用的断点不会被忘记，但直到重新启用才有效。</p><p>用法：</p><ul><li><code>disable [breakpoints] [list...]</code></li><li><code>breakpoints</code> 是 <code>disable</code> 的子命令（可省略），<code>list...</code> 同 <code>info breakpoints</code> 中的描述。</li></ul><p>详见<a href=https://sourceware.org/gdb/current/onlinedocs/gdb/Disabling.html>官方文档</a>。</p><h3 id=enable>enable</h3><p>启用一些断点。给出断点编号（以空格分隔）作为参数。没有参数时，所有断点被启用。</p><p>用法：</p><ul><li><code>enable [breakpoints] [list...]</code> 启用指定的断点（或所有定义的断点）。</li><li><code>enable [breakpoints] once list...</code> 临时启用指定的断点。GDB 在停止您的程序后立即禁用这些断点。</li><li><code>enable [breakpoints] delete list...</code> 使指定的断点启用一次，然后删除。一旦您的程序停止，GDB 就会删除这些断点。等效于用 <code>tbreak</code> 设置的断点。</li></ul><p><code>breakpoints</code> 同 <code>disable</code> 中的描述。</p><p>详见<a href=https://sourceware.org/gdb/current/onlinedocs/gdb/Disabling.html>官方文档</a>。</p><h3 id=clear>clear</h3><p>在指定行或函数处清除断点。参数可以是行号，函数名称或 <code>*</code> 跟一个地址。</p><p>用法：</p><ul><li><code>clear</code> 当不带参数时，清除所选栈帧在执行的源码行中的所有断点。</li><li><code>clear &lt;function></code>, <code>clear &lt;filename:function></code> 删除在命名函数的入口处设置的任何断点。</li><li><code>clear &lt;linenum></code>, <code>clear &lt;filename:linenum></code> 删除在指定的文件指定的行号的代码中设置的任何断点。</li><li><code>clear &lt;address></code> 清除指定程序指令的地址处的断点。</li></ul><p>详见<a href=https://sourceware.org/gdb/current/onlinedocs/gdb/Delete-Breaks.html>官方文档</a>。</p><h3 id=delete>delete</h3><p>删除一些断点或自动显示表达式。参数是用空格分隔的断点编号。要删除所有断点，不加参数。</p><p>用法： <code>delete [breakpoints] [list...]</code></p><p>详见<a href=https://sourceware.org/gdb/current/onlinedocs/gdb/Delete-Breaks.html>官方文档</a>。</p><h3 id=tbreak>tbreak</h3><p>设置临时断点。参数形式同 <code>break</code> 一样。</p><p>除了断点是临时的之外，其他同 <code>break</code> 一样，所以在命中时会被删除。</p><p>详见<a href=https://sourceware.org/gdb/current/onlinedocs/gdb/Set-Breaks.html>官方文档</a>。</p><h3 id=watch>watch</h3><p>为表达式设置观察点。</p><p>用法： <code>watch [-l|-location] &lt;expr></code> 每当一个表达式的值改变时，观察点就会暂停程序执行。</p><p>如果给出了 <code>-l</code> 或者 <code>-location</code>，则它会对 <code>expr</code> 求值并观察它所指向的内存。例如，<code>watch *(int *)0x12345678</code> 将在指定的地址处观察一个 4 字节的区域（假设 int 占用 4 个字节）。</p><p>详见<a href=https://sourceware.org/gdb/current/onlinedocs/gdb/Set-Watchpoints.html>官方文档</a>。</p><h3 id=step>step</h3><p>单步执行程序，直到到达不同的源码行。</p><p>用法： <code>step [N]</code> 参数 <code>N</code> 表示执行 N 次（或由于另一个原因直到程序停止）。</p><p>警告：如果当控制在没有调试信息的情况下编译的函数中使用 <code>step</code> 命令，则执行将继续进行，直到控制到达具有调试信息的函数。 同样，它不会进入没有调试信息编译的函数。</p><p>要执行没有调试信息的函数，请使用 <code>stepi</code> 命令，详见后文。</p><p>详见<a href=https://sourceware.org/gdb/current/onlinedocs/gdb/Continuing-and-Stepping.html>官方文档</a>。</p><h3 id=reverse-step>reverse-step</h3><p>反向单步执行程序，直到到达另一个源码行的开头。</p><p>用法： <code>reverse-step [N]</code> 参数 <code>N</code> 表示执行 N 次（或由于另一个原因直到程序停止）。</p><p>详见<a href=https://sourceware.org/gdb/current/onlinedocs/gdb/Reverse-Execution.html>官方文档</a>。</p><h3 id=next>next</h3><p>单步执行程序，执行完子程序调用。</p><p>用法： <code>next [N]</code></p><p>与 <code>step</code> 不同，如果当前的源代码行调用子程序，则此命令不会进入子程序，而是将其视为单个源代码行，继续执行。</p><p>详见<a href=https://sourceware.org/gdb/current/onlinedocs/gdb/Continuing-and-Stepping.html>官方文档</a>。</p><h3 id=reverse-next>reverse-next</h3><p>反向步进程序，执行完子程序调用。</p><p>用法： <code>reverse-next [N]</code></p><p>如果要执行的源代码行调用子程序，则此命令不会进入子程序，调用被视为一个指令。</p><p>参数 <code>N</code> 表示执行 N 次（或由于另一个原因直到程序停止）。</p><p>详见<a href=https://sourceware.org/gdb/current/onlinedocs/gdb/Reverse-Execution.html>官方文档</a>。</p><h3 id=return>return</h3><p>您可以使用 <code>return</code> 命令取消函数调用的执行。如果你给出一个表达式参数，它的值被用作函数的返回值。</p><p>用法： <code>return &lt;expression></code> 将 <code>expression</code> 的值作为函数的返回值并使函数直接返回。</p><p>详见<a href=https://sourceware.org/gdb/current/onlinedocs/gdb/Returning.html>官方文档</a>。</p><h3 id=finish>finish</h3><p>执行直到选定的栈帧返回。</p><p>用法： <code>finish</code> 返回后，返回的值将被打印并放入到值历史记录中。</p><p>详见<a href=https://sourceware.org/gdb/current/onlinedocs/gdb/Continuing-and-Stepping.html>官方文档</a>。</p><h3 id=until>until</h3><p>执行直到程序到达当前栈帧中当前行之后（与 <a href=#break>break</a> 命令相同的参数）的源码行。此命令用于通过一个多次的循环，以避免单步执行。</p><p>用法：<code>until &lt;location></code> 或 <code>u &lt;location></code> 继续运行程序，直到达到指定的位置，或者当前栈帧返回。</p><p>详见<a href=https://sourceware.org/gdb/current/onlinedocs/gdb/Continuing-and-Stepping.html>官方文档</a>。</p><h3 id=continue>continue</h3><p>在信号或断点之后，继续运行被调试的程序。</p><p>用法： <code>continue [N]</code> 如果从断点开始，可以使用数字 <code>N</code> 作为参数，这意味着将该断点的忽略计数设置为 <code>N - 1</code>(以便断点在第 N 次到达之前不会中断)。如果启用了非停止模式（使用 <code>show non-stop</code> 查看），则仅继续当前线程，否则程序中的所有线程都将继续。</p><p>详见<a href=https://sourceware.org/gdb/current/onlinedocs/gdb/Continuing-and-Stepping.html>官方文档</a>。</p><h3 id=print>print</h3><p>求值并打印表达式 EXP 的值。可访问的变量是所选栈帧的词法环境，以及范围为全局或整个文件的所有变量。</p><p>用法：</p><ul><li><code>print [expr]</code> 或 <code>print /f [expr]</code> <code>expr</code> 是一个（在源代码语言中的）表达式。</li></ul><p>默认情况下，<code>expr</code> 的值以适合其数据类型的格式打印；您可以通过指定 <code>/f</code> 来选择不同的格式，其中 <code>f</code> 是一个指定格式的字母；详见<a href=https://sourceware.org/gdb/current/onlinedocs/gdb/Output-Formats.html>输出格式</a>。</p><p>如果省略 <code>expr</code>，GDB 再次显示最后一个值。</p><p>要以每行一个成员带缩进的格式打印结构体变量请使用命令 <code>set print pretty on</code>，取消则使用命令 <code>set print pretty off</code>。</p><p>可使用命令 <code>show print</code> 查看所有打印的设置。</p><p>详见<a href=https://sourceware.org/gdb/current/onlinedocs/gdb/Data.html>官方文档</a>。</p><h3 id=x>x</h3><p>检查内存。</p><p>用法： <code>x/nfu &lt;addr></code> 或 <code>x &lt;addr></code> <code>n</code>、<code>f</code> 和 <code>u</code> 都是可选参数，用于指定要显示的内存以及如何格式化。<code>addr</code> 是要开始显示内存的地址的表达式。</p><p><code>n</code> 重复次数（默认值是 1），指定要显示多少个单位（由 <code>u</code> 指定）的内存值。</p><p><code>f</code> 显示格式（初始默认值是 <code>x</code>），显示格式是 <code>print('x'，'d'，'u'，'o'，'t'，'a'，'c'，'f'，'s')</code> 使用的格式之一，再加 <code>i</code>（机器指令）。</p><p><code>u</code> 单位大小，<code>b</code> 表示单字节，<code>h</code> 表示双字节，<code>w</code> 表示四字节，<code>g</code> 表示八字节。</p><p>例如：</p><p><code>x/3uh 0x54320</code> 表示从地址 0x54320 开始以无符号十进制整数的格式，双字节为单位来显示 3 个内存值。</p><p><code>x/16xb 0x7f95b7d18870</code> 表示从地址 0x7f95b7d18870 开始以十六进制整数的格式，单字节为单位显示 16 个内存值。</p><p>详见<a href=https://sourceware.org/gdb/current/onlinedocs/gdb/Memory.html>官方文档</a>。</p><h3 id=display>display</h3><p>每次程序暂停时，打印表达式 EXP 的值。</p><p>用法： <code>display &lt;expr></code>, <code>display/fmt &lt;expr></code> 或 <code>display/fmt &lt;addr></code> <code>fmt</code> 用于指定显示格式。像 <a href=#print>print</a> 命令里的 <code>/f</code> 一样。</p><p>对于格式 <code>i</code> 或 <code>s</code>，或者包括单位大小或单位数量，将表达式 <code>addr</code> 添加为每次程序停止时要检查的内存地址。</p><p>详见<a href=https://sourceware.org/gdb/current/onlinedocs/gdb/Auto-Display.html>官方文档</a>。</p><h3 id=info-display>info display</h3><p>打印自动显示的表达式列表，每个表达式都带有项目编号，但不显示其值。</p><p>包括被禁用的表达式和不能立即显示的表达式（当前不可用的自动变量）。</p><h3 id=undisplay>undisplay</h3><p>取消某些表达式在程序暂停时的自动显示。参数是表达式的编号（使用 <code>info display</code> 查询编号）。不带参数表示取消所有自动显示表达式。</p><p><code>delete display</code> 具有与此命令相同的效果。</p><h3 id=disable-display>disable display</h3><p>禁用某些表达式在程序暂停时的自动显示。禁用的显示项目不会被自动打印，但不会被忘记。 它可能稍后再次被启用。</p><p>参数是表达式的编号（使用 <code>info display</code> 查询编号）。不带参数表示禁用所有自动显示表达式。</p><h3 id=enable-display>enable display</h3><p>启用某些表达式在程序暂停时的自动显示。</p><p>参数是重新显示的表达式的编号（使用 <code>info display</code> 查询编号）。不带参数表示启用所有自动显示表达式。</p><h3 id=help>help</h3><p>打印命令列表。</p><p>您可以使用不带参数的 <code>help</code>（缩写为 <code>h</code>）来显示命令的类别名的简短列表。</p><p>使用 <code>help &lt;class></code> 您可以获取该类中的各个命令的列表。使用 <code>help &lt;command></code> 显示如何使用该命令。</p><p>详见<a href=https://sourceware.org/gdb/current/onlinedocs/gdb/Help.html>官方文档</a>。</p><h3 id=attach>attach</h3><p>挂接到 GDB 之外的进程或文件。该命令可以将进程 ID 或设备文件作为参数。</p><p>对于进程 ID，您必须具有向进程发送信号的权限，并且必须具有与调试器相同的有效的 uid。</p><p>用法： <code>attach &lt;process-id></code> GDB 在安排调试指定的进程之后做的第一件事是暂停该进程。</p><p>无论是通过 <code>attach</code> 命令挂接的进程还是通过 <code>run</code> 命令启动的进程，您都可以使用的 GDB 命令来检查和修改挂接的进程。</p><p>详见<a href=https://sourceware.org/gdb/current/onlinedocs/gdb/Attach.html>官方文档</a>。</p><h3 id=run>run</h3><p>启动被调试的程序。</p><p>可以直接指定参数，也可以用 <a href=https://sourceware.org/gdb/current/onlinedocs/gdb/Arguments.html>set args</a> 设置（启动所需的）参数。</p><p>例如： <code>run arg1 arg2 ...</code> 等效于</p><pre tabindex=0><code>set args arg1 arg2 ...
run
</code></pre><p>还允许使用 <code>></code>、 <code>&lt;</code> 或 <code>>></code> 进行输入和输出重定向。</p><p>详见<a href=https://sourceware.org/gdb/current/onlinedocs/gdb/Starting.html>官方文档</a>。</p><h3 id=backtrace>backtrace</h3><p>打印整体栈帧信息。</p><ul><li><code>bt</code> 打印整体栈帧信息，每个栈帧一行。</li><li><code>bt n</code> 类似于上，但只打印最内层的 n 个栈帧。</li><li><code>bt -n</code> 类似于上，但只打印最外层的 n 个栈帧。</li><li><code>bt full n</code> 类似于 <code>bt n</code>，还打印局部变量的值。</li></ul><p><code>where</code> 和 <code>info stack</code>(缩写 <code>info s</code>) 是 <code>backtrace</code> 的别名。调用栈信息类似如下：</p><pre tabindex=0><code>(gdb) where
#0  vconn_stream_run (vconn=0x99e5e38) at lib/vconn-stream.c:232
#1  0x080ed68a in vconn_run (vconn=0x99e5e38) at lib/vconn.c:276
#2  0x080dc6c8 in rconn_run (rc=0x99dbbe0) at lib/rconn.c:513
#3  0x08077b83 in ofconn_run (ofconn=0x99e8070, handle_openflow=0x805e274 &lt;handle_openflow&gt;) at ofproto/connmgr.c:1234
#4  0x08075f92 in connmgr_run (mgr=0x99dc878, handle_openflow=0x805e274 &lt;handle_openflow&gt;) at ofproto/connmgr.c:286
#5  0x08057d58 in ofproto_run (p=0x99d9ba0) at ofproto/ofproto.c:1159
#6  0x0804f96b in bridge_run () at vswitchd/bridge.c:2248
#7  0x08054168 in main (argc=4, argv=0xbf8333e4) at vswitchd/ovs-vswitchd.c:125
</code></pre><p>详见<a href=https://sourceware.org/gdb/current/onlinedocs/gdb/Backtrace.html>官方文档</a>。</p><h3 id=ptype>ptype</h3><p>打印类型 TYPE 的定义。</p><p>用法： <code>ptype[/FLAGS] TYPE-NAME | EXPRESSION</code></p><p>参数可以是由 <code>typedef</code> 定义的类型名， 或者 <code>struct STRUCT-TAG</code> 或者 <code>class CLASS-NAME</code> 或者 <code>union UNION-TAG</code> 或者 <code>enum ENUM-TAG</code>。</p><p>根据所选的栈帧的词法上下文来查找该名字。</p><p>类似的命令是 <code>whatis</code>，区别在于 <code>whatis</code> 不展开由 <code>typedef</code> 定义的数据类型，而 <code>ptype</code> 会展开，举例如下：</p><pre tabindex=0><code>/* 类型声明与变量定义 */
typedef double real_t;
struct complex {
    real_t real;
    double imag;
};
typedef struct complex complex_t;

complex_t var;
real_t *real_pointer_var;
</code></pre><p>这两个命令给出了如下输出：</p><pre tabindex=0><code>(gdb) whatis var
type = complex_t
(gdb) ptype var
type = struct complex {
    real_t real;
    double imag;
}
(gdb) whatis complex_t
type = struct complex
(gdb) whatis struct complex
type = struct complex
(gdb) ptype struct complex
type = struct complex {
    real_t real;
    double imag;
}
(gdb) whatis real_pointer_var
type = real_t *
(gdb) ptype real_pointer_var
type = double *
</code></pre><p>详见<a href=https://sourceware.org/gdb/current/onlinedocs/gdb/Symbols.html>官方文档</a>。</p><hr><h3 id=参考资料>参考资料</h3><ul><li><a href=https://sourceware.org/gdb/current/onlinedocs/gdb/>Debugging with GDB</a></li></ul><hr><p>译者：<a href=https://github.com/robot527>robot527</a> 校对：<a href=https://github.com/mudongliang>mudongliang</a>， <a href=https://github.com/wxy>wxy</a></p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/gdb/ rel=tag>gdb</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E8%B0%83%E8%AF%95/ rel=tag>调试</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>