<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>一个用 Java 实现的超轻量级 RESTful Web 服务示例 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="一个用 Java 实现的超轻量级 RESTful Web 服务示例"><meta property="og:description" content="通过管理一套图书的完整代码示例，来探索轻量级的 RESTful 服务。"><meta property="og:type" content="article"><meta property="og:url" content="/article-12555-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-08-27T07:19:00+00:00"><meta property="article:modified_time" content="2020-08-27T07:19:00+00:00"><meta itemprop=name content="一个用 Java 实现的超轻量级 RESTful Web 服务示例"><meta itemprop=description content="通过管理一套图书的完整代码示例，来探索轻量级的 RESTful 服务。"><meta itemprop=datePublished content="2020-08-27T07:19:00+00:00"><meta itemprop=dateModified content="2020-08-27T07:19:00+00:00"><meta itemprop=wordCount content="2095"><meta itemprop=keywords content="RESTful,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>一个用 Java 实现的超轻量级 RESTful Web 服务示例</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2020-08-27T07:19:00Z>August 27, 2020</time></div></div></header><div class="content post__content clearfix"><blockquote><p>通过管理一套图书的完整代码示例，来探索轻量级的 RESTful 服务。</p></blockquote><p><img src=/data/attachment/album/202008/27/071808tt9zlno3b6lmbgl8.jpg alt></p><p>Web 服务，以这样或那样的形式，已经存在了近二十年。比如，<a href=http://xmlrpc.com/>XML-RPC 服务</a>出现在 90 年代后期，紧接着是用 SOAP 分支编写的服务。在 XML-RPC 和 SOAP 这两个开拓者之后出现后不久，REST 架构风格的服务在大约 20 年前也出现了。<a href=https://www.redhat.com/en/topics/integration/whats-the-difference-between-soap-rest>REST</a> 风格（以下简称 Restful）服务现在主导了流行的网站，比如 eBay、Facebook 和 Twitter。尽管分布式计算的 Web 服务有很多替代品（如 Web 套接字、微服务和远程过程调用的新框架），但基于 Restful 的 Web 服务依然具有吸引力，原因如下：</p><ul><li>Restful 服务建立在现有的基础设施和协议上，特别是 Web 服务器和 HTTP/HTTPS 协议。一个拥有基于 HTML 的网站的组织可以很容易地为客户添加 Web 服务，这些客户对数据和底层功能更感兴趣，而不是对 HTML 的表现形式感兴趣。比如，亚马逊就率先通过网站和 Web 服务（基于 SOAP 或 Restful）提供相同的信息和功能。</li><li>Restful 服务将 HTTP 当作 API，因此避免了复杂的软件分层，这种分层是基于 SOAP 的 Web 服务的明显特征。比如，Restful API 支持通过 HTTP 命令（POST-GET-PUT-DELETE）进行标准的 CRUD（增加-读取-更新-删除）操作；通过 HTTP 状态码可以知道请求是否成功或者为什么失败。</li><li>Restful Web 服务可以根据需要变得简单或复杂。Restful 是一种风格，实际上是一种非常灵活的风格，而不是一套关于如何设计和构造服务的规定。（伴随而来的缺点是，可能很难确定哪些服务不能算作 Restful 服务。）</li><li>作为使用者或者客户端，Restful Web 服务与语言和平台无关。客户端发送 HTTP(S) 请求，并以适合现代数据交换的格式（如 JSON）接收文本响应。</li><li>几乎每一种通用编程语言都至少对 HTTP/HTTPS 有足够的（通常是强大的）支持，这意味着 Web 服务的客户端可以用这些语言来编写。</li></ul><p>这篇文章将通过一段完整的 Java 代码示例来探讨轻量级的 Restful 服务。</p><h3 id=基于-restful-的小说-web-服务>基于 Restful 的“小说” Web 服务</h3><p>基于 Restful 的“小说” web 服务包含三个程序员定义的类：</p><ul><li><code>Novel</code> 类代表一个小说，只有三个属性：机器生成的 ID、作者和标题。属性可以根据实际情况进行扩展，但我还是想让这个例子看上去更简单一些。</li><li><code>Novels</code> 类包含了用于各种任务的工具类：将一个 <code>Novel</code> 或者它们的列表的纯文本编码转换成 XML 或者 JSON；支持在小说集合上进行 CRUD 操作；以及从存储在文件中的数据初始化集合。<code>Novels</code> 类在 <code>Novel</code> 实例和 servlet 之间起中介作用。</li><li><code>NovelsServlet</code> 类是从 <code>HttpServlet</code> 中继承的，<code>HttpServlet</code> 是一段健壮且灵活的代码，自 90 年代末的早期企业级 Java 就已经存在了。对于客户端的 CRUD 请求，servlet 可以当作 HTTP 的端点。 servlet 代码主要用于处理客户端的请求和生成相应的响应，而将复杂的细节留给 <code>Novels</code> 类中的工具类进行处理。</li></ul><p>一些 Java 框架，比如 Jersey（JAX-RS）和 Restlet，就是为 Restful 服务设计的。尽管如此，<code>HttpServlet</code> 本身为完成这些服务提供了轻量、灵活、强大且充分测试过的 API。我会通过下面的“小说”例子来说明。</p><h3 id=部署小说-web-服务>部署“小说” Web 服务</h3><p>当然，部署“小说” Web 服务需要一个 Web 服务器。我的选择是 <a href=http://tomcat.apache.org/>Tomcat</a>，但是如果该服务托管在 Jetty 或者甚至是 Java 应用服务器上，那么这个服务应该至少可以工作（著名的最后一句话！）。<a href=https://condor.depaul.edu/mkalin>在我的网站上</a>有总结了如何安装 Tomcat 的 README 文件和代码。还有一个附带文档的 Apache Ant 脚本，可以用来构建“小说”服务（或者任何其他服务或网站），并且将它部署在 Tomcat 或相同的服务。</p><p>Tomcat 可以从它的<a href=https://tomcat.apache.org/download-90.cgi>官网</a>上下载。当你在本地安装后，将 <code>TOMCAT_HOME</code> 设置为安装目录。有两个子目录值得关注：</p><ul><li><code>TOMCAT_HOME/bin</code> 目录包含了类 Unix 系统（<code>startup.sh</code> 和 <code>shutdown.sh</code>）和 Windows（<code>startup.bat</code> 和 <code>shutdown.bat</code>） 的启动和停止脚本。Tomcat 作为 Java 应用程序运行。Web 服务器的 servlet 容器叫做 Catalina。（在 Jetty 中，Web 服务器和容器的名字一样。）当 Tomcat 启动后，在浏览器中输入 <code>http://localhost:8080/</code>可以查看详细文档，包括示例。</li><li><code>TOMCAT_HOME/webapps</code> 目录是已部署的 Web 网站和服务的默认目录。部署网站或 Web 服务的直接方法是复制以 <code>.war</code> 结尾的 JAR 文件（也就是 WAR 文件）到 <code>TOMCAT_HOME/webapps</code> 或它的子目录下。然后 Tomcat 会将 WAR 文件解压到它自己的目录下。比如，Tomcat 会将 <code>novels.war</code> 文件解压到一个叫做 <code>novels</code> 的子目录下，并且保留 <code>novels.war</code> 文件。一个网站或 Web 服务可以通过删除 WAR 文件进行移除，也可以用一个新版 WAR 文件来覆盖已有文件进行更新。顺便说一下，调试网站或服务的第一步就是检查 Tomcat 已经正确解压 WAR 文件；如果没有的话，网站或服务就无法发布，因为代码或配置中有致命错误。</li><li>因为 Tomcat 默认会监听 8080 端口上的 HTTP 请求，所以本机上的 URL 请求以 <code>http://localhost:8080/</code> 开始。</li></ul><p>通过添加不带 <code>.war</code> 后缀的 WAR 文件名来访问由程序员部署的 WAR 文件：</p><pre tabindex=0><code>http://locahost:8080/novels/
</code></pre><p>如果服务部署在 <code>TOMCAT_HOME</code> 下的一个子目录中（比如，<code>myapps</code>），这会在 URL 中反映出来：</p><pre tabindex=0><code>http://locahost:8080/myapps/novels/
</code></pre><p>我会在靠近文章结尾处的测试部分提供这部分的更多细节。</p><p>如前所述，我的主页上有一个包含 Ant 脚本的 ZIP 文件，这个文件可以编译并且部署网站或者服务。（这个 ZIP 文件中也包含一个 <code>novels.war</code> 的副本。）对于“小说”这个例子，命令的示例（<code>%</code> 是命令行提示符）如下：</p><pre tabindex=0><code>% ant -Dwar.name=novels deploy
</code></pre><p>这个命令首先会编译 Java 源代码，并且创建一个可部署的 <code>novels.war</code> 文件，然后将这个文件保存在当前目录中，再复制到 <code>TOMCAT_HOME/webapps</code> 目录中。如果一切顺利，<code>GET</code> 请求（使用浏览器或者命令行工具，比如 <code>curl</code>）可以用来做一个测试：</p><pre tabindex=0><code>% curl http://localhost:8080/novels/
</code></pre><p>默认情况下，Tomcat 设置为 热部署 hot deploys ：Web 服务器不需要关闭就可以进行部署、更新或者移除一个 web 应用。</p><h3 id=小说服务的代码>“小说”服务的代码</h3><p>让我们回到“小说”这个例子，不过是在代码层面。考虑下面的 <code>Novel</code> 类：</p><h4 id=例-1novel-类>例 1：Novel 类</h4><pre tabindex=0><code>package novels;

import java.io.Serializable;

public class Novel implements Serializable, Comparable&lt;Novel&gt; {
    static final long serialVersionUID = 1L;
    private String author;
    private String title;
    private int id;

    public Novel() { }

    public void setAuthor(final String author) { this.author = author; }
    public String getAuthor() { return this.author; }
    public void setTitle(final String title) { this.title = title; }
    public String getTitle() { return this.title; }
    public void setId(final int id) { this.id = id; }
    public int getId() { return this.id; }

    public int compareTo(final Novel other) { return this.id - other.id; }
}
</code></pre><p>这个类实现了 <code>Comparable</code> 接口中的 <code>compareTo</code> 方法，因为 <code>Novel</code> 实例是存储在一个线程安全的无序 <code>ConcurrentHashMap</code> 中。在响应查看集合的请求时，“小说”服务会对从映射中提取的集合（一个 <code>ArrayList</code>）进行排序；<code>compareTo</code> 的实现通过 <code>Novel</code> 的 ID 将它按升序排序。</p><p><code>Novels</code> 类中包含多个实用工具函数：</p><h4 id=例-2novels-实用工具类>例 2：Novels 实用工具类</h4><pre tabindex=0><code>package novels;

import java.io.IOException;
import java.io.File;
import java.io.ByteArrayOutputStream;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.BufferedReader;
import java.nio.file.Files;
import java.util.stream.Stream;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.Collections;
import java.beans.XMLEncoder;
import javax.servlet.ServletContext; // not in JavaSE
import org.json.JSONObject;
import org.json.XML;

public class Novels {
    private final String fileName = &#34;/WEB-INF/data/novels.db&#34;;
    private ConcurrentMap&lt;Integer, Novel&gt; novels;
    private ServletContext sctx;
    private AtomicInteger mapKey;

    public Novels() {
        novels = new ConcurrentHashMap&lt;Integer, Novel&gt;();
        mapKey = new AtomicInteger();
    }

    public void setServletContext(ServletContext sctx) { this.sctx = sctx; }
    public ServletContext getServletContext() { return this.sctx; }

    public ConcurrentMap&lt;Integer, Novel&gt; getConcurrentMap() {
        if (getServletContext() == null) return null; // not initialized
        if (novels.size() &lt; 1) populate();
        return this.novels;
    }

    public String toXml(Object obj) { // default encoding
        String xml = null;
        try {
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            XMLEncoder encoder = new XMLEncoder(out);
            encoder.writeObject(obj);
            encoder.close();
            xml = out.toString();
        }
        catch(Exception e) { }
        return xml;
    }

    public String toJson(String xml) { // option for requester
        try {
            JSONObject jobt = XML.toJSONObject(xml);
            return jobt.toString(3); // 3 is indentation level
        }
        catch(Exception e) { }
        return null;
    }

    public int addNovel(Novel novel) {
        int id = mapKey.incrementAndGet();
        novel.setId(id);
        novels.put(id, novel);
        return id;
    }

    private void populate() {
        InputStream in = sctx.getResourceAsStream(this.fileName);
        // Convert novel.db string data into novels.
        if (in != null) {
            try {
                InputStreamReader isr = new InputStreamReader(in);
                BufferedReader reader = new BufferedReader(isr);

                String record = null;
                while ((record = reader.readLine()) != null) {
                    String[] parts = record.split(&#34;!&#34;);
                    if (parts.length == 2) {
                        Novel novel = new Novel();
                        novel.setAuthor(parts[0]);
                        novel.setTitle(parts[1]);
                        addNovel(novel); // sets the Id, adds to map
                    }
                }
                in.close();
            }
            catch (IOException e) { }
        }
    }
}
</code></pre><p>最复杂的方法是 <code>populate</code>，这个方法从一个包含在 WAR 文件中的文本文件读取。这个文本文件包括了“小说”的初始集合。要打开此文件，<code>populate</code> 方法需要 <code>ServletContext</code>，这是一个 Java 映射类型，包含了关于嵌入在 servlet 容器中的 servlet 的所有关键信息。这个文本文件有包含了像下面这样的记录：</p><pre tabindex=0><code>Jane Austen!Persuasion
</code></pre><p>这一行被解析为两部分（作者和标题），由感叹号（<code>!</code>）分隔。然后这个方法创建一个 <code>Novel</code> 实例，设置作者和标题属性，并且将“小说”加到容器中，保存在内存中。</p><p><code>Novels</code> 类也有一些实用工具函数，可以将“小说”容器编码为 XML 或 JSON，取决于发出请求的人所要求的格式。默认是 XML 格式，但是也可以请求 JSON 格式。一个轻量级的 XML 转 JSON 包提供了 JSON。下面是关于编码的更多细节。</p><h4 id=例-3novelsservlet-类>例 3：NovelsServlet 类</h4><pre tabindex=0><code>package novels;

import java.util.concurrent.ConcurrentMap;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.util.Arrays;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.OutputStream;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.beans.XMLEncoder;
import org.json.JSONObject;
import org.json.XML;

public class NovelsServlet extends HttpServlet {
    static final long serialVersionUID = 1L;
    private Novels novels; // back-end bean

    // Executed when servlet is first loaded into container.
    @Override
    public void init() {
        this.novels = new Novels();
        novels.setServletContext(this.getServletContext());
    }

    // GET /novels
    // GET /novels?id=1
    @Override
    public void doGet(HttpServletRequest request, HttpServletResponse response) {
        String param = request.getParameter(&#34;id&#34;);
        Integer key = (param == null) ? null : Integer.valueOf((param.trim()));

        // Check user preference for XML or JSON by inspecting
        // the HTTP headers for the Accept key.
        boolean json = false;
        String accept = request.getHeader(&#34;accept&#34;);
        if (accept != null &amp;&amp; accept.contains(&#34;json&#34;)) json = true;

        // If no query string, assume client wants the full list.
        if (key == null) {
            ConcurrentMap&lt;Integer, Novel&gt; map = novels.getConcurrentMap();
            Object list = map.values().toArray();
            Arrays.sort(list);

            String payload = novels.toXml(list);        // defaults to Xml
            if (json) payload = novels.toJson(payload); // Json preferred?
            sendResponse(response, payload);
        }
        // Otherwise, return the specified Novel.
        else {
            Novel novel = novels.getConcurrentMap().get(key);
            if (novel == null) { // no such Novel
                String msg = key + &#34; does not map to a novel.\n&#34;;
                sendResponse(response, novels.toXml(msg));
            }
            else { // requested Novel found
                if (json) sendResponse(response, novels.toJson(novels.toXml(novel)));
                else sendResponse(response, novels.toXml(novel));
            }
        }
    }

    // POST /novels
    @Override
    public void doPost(HttpServletRequest request, HttpServletResponse response) {
        String author = request.getParameter(&#34;author&#34;);
        String title = request.getParameter(&#34;title&#34;);

        // Are the data to create a new novel present?
        if (author == null || title == null)
            throw new RuntimeException(Integer.toString(HttpServletResponse.SC_BAD_REQUEST));

        // Create a novel.
        Novel n = new Novel();
        n.setAuthor(author);
        n.setTitle(title);

        // Save the ID of the newly created Novel.
        int id = novels.addNovel(n);

        // Generate the confirmation message.
        String msg = &#34;Novel &#34; + id + &#34; created.\n&#34;;
        sendResponse(response, novels.toXml(msg));
    }

    // PUT /novels
    @Override
    public void doPut(HttpServletRequest request, HttpServletResponse response) {
        /\* A workaround is necessary for a PUT request because Tomcat does not
 generate a workable parameter map for the PUT verb. \*/
        String key = null;
        String rest = null;
        boolean author = false;

        /\* Let the hack begin. \*/
        try {
            BufferedReader br =
                new BufferedReader(new InputStreamReader(request.getInputStream()));
            String data = br.readLine();
            /\* To simplify the hack, assume that the PUT request has exactly
 two parameters: the id and either author or title. Assume, further,
 that the id comes first. From the client side, a hash character
 # separates the id and the author/title, e.g.,

 id=33#title=War and Peace
 \*/
            String[] args = data.split(&#34;#&#34;);      // id in args[0], rest in args[1]
            String[] parts1 = args[0].split(&#34;=&#34;); // id = parts1[1]
            key = parts1[1];

            String[] parts2 = args[1].split(&#34;=&#34;); // parts2[0] is key
            if (parts2[0].contains(&#34;author&#34;)) author = true;
            rest = parts2[1];
        }
        catch(Exception e) {
            throw new RuntimeException(Integer.toString(HttpServletResponse.SC_INTERNAL_SERVER_ERROR));
        }

        // If no key, then the request is ill formed.
        if (key == null)
            throw new RuntimeException(Integer.toString(HttpServletResponse.SC_BAD_REQUEST));

        // Look up the specified novel.
        Novel p = novels.getConcurrentMap().get(Integer.valueOf((key.trim())));
        if (p == null) { // not found
            String msg = key + &#34; does not map to a novel.\n&#34;;
            sendResponse(response, novels.toXml(msg));
        }
        else { // found
            if (rest == null) {
                throw new RuntimeException(Integer.toString(HttpServletResponse.SC_BAD_REQUEST));
            }
            // Do the editing.
            else {
                if (author) p.setAuthor(rest);
                else p.setTitle(rest);

                String msg = &#34;Novel &#34; + key + &#34; has been edited.\n&#34;;
                sendResponse(response, novels.toXml(msg));
            }
        }
    }

    // DELETE /novels?id=1
    @Override
    public void doDelete(HttpServletRequest request, HttpServletResponse response) {
        String param = request.getParameter(&#34;id&#34;);
        Integer key = (param == null) ? null : Integer.valueOf((param.trim()));
        // Only one Novel can be deleted at a time.
        if (key == null)
            throw new RuntimeException(Integer.toString(HttpServletResponse.SC_BAD_REQUEST));
        try {
            novels.getConcurrentMap().remove(key);
            String msg = &#34;Novel &#34; + key + &#34; removed.\n&#34;;
            sendResponse(response, novels.toXml(msg));
        }
        catch(Exception e) {
            throw new RuntimeException(Integer.toString(HttpServletResponse.SC_INTERNAL_SERVER_ERROR));
        }
    }

    // Methods Not Allowed
    @Override
    public void doTrace(HttpServletRequest request, HttpServletResponse response) {
        throw new RuntimeException(Integer.toString(HttpServletResponse.SC_METHOD_NOT_ALLOWED));
    }

    @Override
    public void doHead(HttpServletRequest request, HttpServletResponse response) {
        throw new RuntimeException(Integer.toString(HttpServletResponse.SC_METHOD_NOT_ALLOWED));
    }

    @Override
    public void doOptions(HttpServletRequest request, HttpServletResponse response) {
        throw new RuntimeException(Integer.toString(HttpServletResponse.SC_METHOD_NOT_ALLOWED));
    }

    // Send the response payload (Xml or Json) to the client.
    private void sendResponse(HttpServletResponse response, String payload) {
        try {
            OutputStream out = response.getOutputStream();
            out.write(payload.getBytes());
            out.flush();
        }
        catch(Exception e) {
            throw new RuntimeException(Integer.toString(HttpServletResponse.SC_INTERNAL_SERVER_ERROR));
        }
    }
}
</code></pre><p>上面的 <code>NovelsServlet</code> 类继承了 <code>HttpServlet</code> 类，<code>HttpServlet</code> 类继承了 <code>GenericServlet</code> 类，后者实现了 <code>Servlet</code> 接口：</p><pre tabindex=0><code>NovelsServlet extends HttpServlet extends GenericServlet implements Servlet
</code></pre><p>从名字可以很清楚的看出来，<code>HttpServlet</code> 是为实现 HTTP(S) 上的 servlet 设计的。这个类提供了以标准 HTTP 请求动词（官方说法， 方法 methods ）命名的空方法：</p><ul><li><code>doPost</code> （Post = 创建）</li><li><code>doGet</code> （Get = 读取）</li><li><code>doPut</code> （Put = 更新）</li><li><code>doDelete</code> （Delete = 删除）</li></ul><p>其他一些 HTTP 动词也会涉及到。<code>HttpServlet</code> 的子类，比如 <code>NovelsServlet</code>，会重载相关的 <code>do</code> 方法，并且保留其他方法为 空 no-ops 。<code>NovelsServlet</code> 重载了七个 <code>do</code> 方法。</p><p>每个 <code>HttpServlet</code> 的 CRUD 方法都有两个相同的参数。下面以 <code>doPost</code> 为例：</p><pre tabindex=0><code>public void doPost(HttpServletRequest request, HttpServletResponse response) {
</code></pre><p><code>request</code> 参数是一个 HTTP 请求信息的映射，而 <code>response</code> 提供了一个返回给请求者的输出流。像 <code>doPost</code> 的方法，结构如下：</p><ul><li>读取 <code>request</code> 信息，采取任何适当的措施生成一个响应。如果该信息丢失或者损坏了，就会生成一个错误。</li><li>使用提取的请求信息来执行适当的 CRUD 操作（在本例中，创建一个 <code>Novel</code>），然后使用 <code>response</code> 输出流为请求者编码一个适当的响应。在 <code>doPost</code> 例子中，响应就是已经成功生成一个新“小说”并且添加到容器中的一个确认。当响应被发送后，输出流就关闭了，同时也将连接关闭了。</li></ul><h3 id=关于方法重载的更多内容>关于方法重载的更多内容</h3><p>HTTP 请求的格式相对比较简单。下面是一个非常熟悉的 HTTP 1.1 的格式，注释由双井号分隔：</p><pre tabindex=0><code>GET /novels              ## start line
Host: localhost:8080     ## header element
Accept-type: text/plain  ## ditto
...
[body]                   ## POST and PUT only
</code></pre><p>第一行由 HTTP 动词（在本例中是 <code>GET</code>）和以名词（在本例中是 <code>novels</code>）命名目标资源的 URI 开始。报头中包含键-值对，用冒号分隔左面的键和右面的值。报头中的键 <code>Host</code>（大小写敏感）是必须的；主机名 <code>localhost</code> 是当前机器上的本地符号地址，<code>8080</code> 端口是 Tomcat web 服务器上等待 HTTP 请求的默认端口。（默认情况下，Tomcat 在 8443 端口上监听 HTTP 请求。）报头元素可以以任意顺序出现。在这个例子中，<code>Accept-type</code> 报头的值是 MIME 类型 <code>text/plain</code>。</p><p>一些请求（特别是 <code>POST</code> 和 <code>PUT</code>）会有报文，而其他请求（特别是 <code>GET</code> 和 <code>DELETE</code>）没有。如果有报文（可能为空），以两个换行符将报头和报文分隔开；HTTP 报文包含一系列键-值对。对于无报文的请求，比如说查询字符串，报头元素就可以用来发送信息。下面是一个用 ID 2 对 <code>/novels</code> 资源的 <code>GET</code> 请求：</p><pre tabindex=0><code>GET /novels?id=2
</code></pre><p>通常来说，查询字符串以问号开始，并且包含一个键-值对，尽管这个键-值可能值为空。</p><p>带有 <code>getParameter</code> 和 <code>getParameterMap</code> 等方法的 <code>HttpServlet</code> 很好地回避了有报文和没有报文的 HTTP 请求之前的差异。在“小说”例子中，<code>getParameter</code> 方法用来从 <code>GET</code>、<code>POST</code> 和 <code>DELETE</code> 方法中提取所需的信息。（处理 <code>PUT</code>请求需要更底层的代码，因为 Tomcat 没有提供可以解析 <code>PUT</code> 请求的参数映射。）下面展示了一段在 <code>NovelsServlet</code>中被重载的 <code>doPost</code> 方法：</p><pre tabindex=0><code>@Override
public void doPost(HttpServletRequest request, HttpServletResponse response) {
   String author = request.getParameter(&#34;author&#34;);
   String title = request.getParameter(&#34;title&#34;);
   ...
</code></pre><p>对于没有报文的 <code>DELETE</code> 请求，过程基本是一样的：</p><pre tabindex=0><code>@Override
public void doDelete(HttpServletRequest request, HttpServletResponse response) {
   String param = request.getParameter(&#34;id&#34;); // id of novel to be removed
   ...
</code></pre><p><code>doGet</code> 方法需要区分 <code>GET</code> 请求的两种方式：一种是“获得所有”，而另一种是“获得某一个”。如果 <code>GET</code> 请求 URL 中包含一个键是一个 ID 的查询字符串，那么这个请求就被解析为“获得某一个”：</p><pre tabindex=0><code>http://localhost:8080/novels?id=2  ## GET specified
</code></pre><p>如果没有查询字符串，<code>GET</code> 请求就会被解析为“获得所有”：</p><pre tabindex=0><code>http://localhost:8080/novels       ## GET all
</code></pre><h3 id=一些值得注意的细节>一些值得注意的细节</h3><p>“小说”服务的设计反映了像 Tomcat 这样基于 Java 的 web 服务器是如何工作的。在启动时，Tomcat 构建一个线程池，从中提取请求处理程序，这种方法称为 “ 每个请求一个线程 one thread per request ” 模型。现在版本的 Tomcat 使用非阻塞 I/O 来提高个性能。</p><p>“小说”服务是作为 <code>NovelsServlet</code> 类的单个实例来执行的，该实例也就维护了一个“小说”集合。相应的，也就会出现竞态条件，比如出现两个请求同时被处理：</p><ul><li>一个请求向集合中添加一个新“小说”。</li><li>另一个请求获得集合中的所有“小说”。</li></ul><p>这样的结果是不确定的，取决与 <em>读</em> 和 <em>写</em> 的操作是以怎样的顺序进行操作的。为了避免这个问题，“小说”服务使用了线程安全的 <code>ConcurrentMap</code>。这个映射的关键是生成了一个线程安全的 <code>AtomicInteger</code>。下面是相关的代码片段：</p><pre tabindex=0><code>public class Novels {
    private ConcurrentMap&lt;Integer, Novel&gt; novels;
    private AtomicInteger mapKey;
    ...
</code></pre><p>默认情况下，对客户端请求的响应被编码为 XML。为了简单，“小说”程序使用了以前的 <code>XMLEncoder</code> 类；另一个包含更丰富功能的方式是使用 JAX-B 库。代码很简单：</p><pre tabindex=0><code>public String toXml(Object obj) { // default encoding
   String xml = null;
   try {
      ByteArrayOutputStream out = new ByteArrayOutputStream();
      XMLEncoder encoder = new XMLEncoder(out);
      encoder.writeObject(obj);
      encoder.close();
      xml = out.toString();
   }
   catch(Exception e) { }
   return xml;
}
</code></pre><p><code>Object</code> 参数要么是一个有序的“小说” <code>ArraList</code>（用以响应“ 获得所有 get all ”请求），要么是一个 <code>Novel</code> 实例（用以响应“ 获得一个 get one ”请求），又或者是一个 <code>String</code>（确认消息）。</p><p>如果 HTTP 请求报头指定 JSON 作为所需要的类型，那么 XML 就被转化成 JSON。下面是 <code>NovelsServlet</code> 中的 <code>doGet</code> 方法中的检查：</p><pre tabindex=0><code>String accept = request.getHeader(&#34;accept&#34;); // &#34;accept&#34; is case insensitive
if (accept != null &amp;&amp; accept.contains(&#34;json&#34;)) json = true;
</code></pre><p><code>Novels</code>类中包含了 <code>toJson</code> 方法，可以将 XML 转换成 JSON：</p><pre tabindex=0><code>public String toJson(String xml) { // option for requester
   try {
      JSONObject jobt = XML.toJSONObject(xml);
      return jobt.toString(3); // 3 is indentation level
   }
   catch(Exception e) { }
   return null;
}
</code></pre><p><code>NovelsServlet</code>会对各种类型进行错误检查。比如，<code>POST</code> 请求应该包含新“小说”的作者和标题。如果有一个丢了，<code>doPost</code> 方法会抛出一个异常：</p><pre tabindex=0><code>if (author == null || title == null)
   throw new RuntimeException(Integer.toString(HttpServletResponse.SC_BAD_REQUEST));
</code></pre><p><code>SC_BAD_REQUEST</code> 中的 <code>SC</code> 代表的是 状态码 status code ，<code>BAD_REQUEST</code> 的标准 HTTP 数值是 400。如果请求中的 HTTP 动词是 <code>TRACE</code>，会返回一个不同的状态码：</p><pre tabindex=0><code>public void doTrace(HttpServletRequest request, HttpServletResponse response) {
   throw new RuntimeException(Integer.toString(HttpServletResponse.SC_METHOD_NOT_ALLOWED));
}
</code></pre><h3 id=测试小说服务>测试“小说”服务</h3><p>用浏览器测试 web 服务会很不顺手。在 CRUD 动词中，现代浏览器只能生成 <code>POST</code>（创建）和 <code>GET</code>（读取）请求。甚至从浏览器发送一个 <code>POST</code> 请求都有点不好办，因为报文需要包含键-值对；这样的测试通常通过 HTML 表单完成。命令行工具，比如说 <a href=https://curl.haxx.se/>curl</a>，是一个更好的选择，这个部分展示的一些 <code>curl</code> 命令，已经包含在我网站的 ZIP 文件中了。</p><p>下面是一些测试样例，没有展示相应的输出结果：</p><pre tabindex=0><code>% curl localhost:8080/novels/
% curl localhost:8080/novels?id=1
% curl --header &#34;Accept: application/json&#34; localhost:8080/novels/
</code></pre><p>第一条命令请求所有“小说”，默认是 XML 编码。第二条命令请求 ID 为 1 的“小说”，XML 编码。最后一条命令通过 <code>application/json</code> 添加了 <code>Accept</code> 报头元素，作为所需要的 MIME 类型。“ 获得一个 get one ”命令也可以用这个报头。这些请求用了 JSON 而不是 XML 编码作为响应。</p><p>下面两条命令在集合中创建了一个新“小说”，并且确认添加了进去：</p><pre tabindex=0><code>% curl --request POST --data &#34;author=Tolstoy&amp;amp;title=War and Peace&#34; localhost:8080/novels/
% curl localhost:8080/novels?id=4
</code></pre><p><code>curl</code> 中的 <code>PUT</code> 命令与 <code>POST</code> 命令相似，不同的地方是 <code>PUT</code> 的报文没有使用标准的语法。在 <code>NovelsServlet</code> 中关于 <code>doPut</code> 方法的文档中有详细的介绍，但是简单来说，Tomcat 不会对 <code>PUT</code> 请求生成合适的映射。下面是一个 <code>PUT</code> 命令和确认命令的的例子：</p><pre tabindex=0><code>% curl --request PUT --data &#34;id=3#title=This is an UPDATE&#34; localhost:8080/novels/
% curl localhost:8080/novels?id=3
</code></pre><p>第二个命令确认了集合已经更新。</p><p>最后，<code>DELETE</code> 命令会正常运行：</p><pre tabindex=0><code>% curl --request DELETE localhost:8080/novels?id=2
% curl localhost:8080/novels/
</code></pre><p>这个请求是删除 ID 为 2 的“小说”。第二个命令会显示剩余的“小说”。</p><h3 id=webxml-配置文件>web.xml 配置文件</h3><p>尽管官方规定它是可选的，<code>web.xml</code> 配置文件是一个生产级别网站或服务的重要组成部分。这个配置文件可以配置独立于代码的路由、安全性，或者网站或服务的其他功能。“小说”服务的配置通过为该服务的请求分配一个 URL 模式来配置路由：</p><pre tabindex=0><code>&lt;xml version = &#34;1.0&#34; encoding = &#34;UTF-8&#34;&gt;
&lt;web-app&gt;
   &lt;servlet&gt;
     &lt;servlet-name&gt;novels&lt;/servlet-name&gt;
     &lt;servlet-class&gt;novels.NovelsServlet&lt;/servlet-class&gt;
   &lt;/servlet&gt;
   &lt;servlet-mapping&gt;
     &lt;servlet-name&gt;novels&lt;/servlet-name&gt;
     &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
   &lt;/servlet-mapping&gt;
&lt;/web-app&gt;
</code></pre><p><code>servlet-name</code> 元素为 servlet 全名（<code>novels.NovelsServlet</code>）提供了一个缩写（<code>novels</code>），然后这个名字在下面的 <code>servlet-mapping</code> 元素中使用。</p><p>回想一下，一个已部署服务的 URL 会在端口号后面有 WAR 文件的文件名：</p><pre tabindex=0><code>http://localhost:8080/novels/
</code></pre><p>端口号后斜杠后的 URI，是所请求资源的“路径”，在这个例子中，就是“小说”服务。因此，<code>novels</code> 出现在了第一个单斜杠后。</p><p>在 <code>web.xml</code> 文件中，<code>url-patter</code> 被指定为 <code>/*</code>，代表 “以 <code>/novels</code> 为起始的任意路径”。假设 Tomcat 遇到了一个不存在的 URL，像这样：</p><pre tabindex=0><code>http://localhost:8080/novels/foobar/
</code></pre><p><code>web.xml</code> 配置也会指定这个请求被分配到“小说” servlet 中，因为 <code>/*</code> 模式也包含 <code>/foobar</code>。因此，这个不存在的 URL 也会得到像上面合法路径的相同结果。</p><p>生产级别的配置文件可能会包含安全相关的信息，包括 连接级别 wire-level 和 用户角色 users-roles 。即使在这种情况下，配置文件的大小也只会是这个例子中的两到三倍大。</p><h3 id=总结>总结</h3><p><code>HttpServlet</code> 是 Java web 技术的核心。像“小说”这样的网站或 web 服务继承了这个类，并且根据需求重载了相应的 <code>do</code> 动词方法。像 Jersay（JAX-RS）或 Restlet 这样的 Restful 框架通过提供定制的 servlet 完成了基本相同的功能，针对框架中的 web 应用程序的请求，这个 servlet 扮演着 HTTP(S) 终端 endpoint 的角色。</p><p>当然，基于 servlet 的应用程序可以访问 web 应用程序中所需要的任何 Java 库。如果应用程序遵循 关注点分离 separation-of-concerns 原则，那么 servlet 代码仍然相当简单：代码会检查请求，如果存在缺陷，就会发出适当的错误；否则，代码会调用所需要的功能（比如，查询数据库，以特定格式为响应编码），然后向请求这发送响应。<code>HttpServletRequest</code> 和 <code>HttpServletReponse</code> 类型使得读取请求和编写响应变得简单。</p><p>Java 的 API 可以从非常简单变得相当复杂。如果你需要用 Java 交付一些 Restful 服务的话，我的建议是在做其他事情之前先尝试一下简单的 <code>HttpServlet</code>。</p><hr><p>via: <a href=https://opensource.com/article/20/7/restful-services-java>https://opensource.com/article/20/7/restful-services-java</a></p><p>作者：<a href=https://opensource.com/users/mkalindepauledu>Marty Kalin</a> 选题：<a href=https://github.com/lujun9972>lujun9972</a> 译者：<a href=https://github.com/Yufei-Yan>Yufei-Yan</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/restful/ rel=tag>RESTful</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>