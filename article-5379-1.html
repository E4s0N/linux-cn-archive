<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>搭建一个私有的Docker registry - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="搭建一个私有的Docker registry"><meta property="og:description" content="这是系列的第二篇文章，这系列讲述了我的公司如何把基础服务从PaaS迁移到Docker上  第一篇文章: 我谈到了接触Docker之前的经历； 第三篇文章: 我展示如何使创建镜像的过程自动化以及如何用Docker部署一个Rails应用。   为什么需要搭建一个私有的registry呢？嗯，对于新手来说，Docker Hub（一个Docker公共仓库）只允许你拥有一个免费的私有版本库（repo）。其他的公司也开始提供类似服务，但是价格可不便宜。另外，如果你需要用Docker部署一个用于生产环境的应用，恐怕你不希望将这些镜像放在公开的Docker Hub上吧！ 这篇文章提供了一个非"><meta property="og:type" content="article"><meta property="og:url" content="/article-5379-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2015-05-04T10:48:00+00:00"><meta property="article:modified_time" content="2015-05-04T10:48:00+00:00"><meta itemprop=name content="搭建一个私有的Docker registry"><meta itemprop=description content="这是系列的第二篇文章，这系列讲述了我的公司如何把基础服务从PaaS迁移到Docker上  第一篇文章: 我谈到了接触Docker之前的经历； 第三篇文章: 我展示如何使创建镜像的过程自动化以及如何用Docker部署一个Rails应用。   为什么需要搭建一个私有的registry呢？嗯，对于新手来说，Docker Hub（一个Docker公共仓库）只允许你拥有一个免费的私有版本库（repo）。其他的公司也开始提供类似服务，但是价格可不便宜。另外，如果你需要用Docker部署一个用于生产环境的应用，恐怕你不希望将这些镜像放在公开的Docker Hub上吧！ 这篇文章提供了一个非"><meta itemprop=datePublished content="2015-05-04T10:48:00+00:00"><meta itemprop=dateModified content="2015-05-04T10:48:00+00:00"><meta itemprop=wordCount content="295"><meta itemprop=keywords content="Docker,registry,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>搭建一个私有的Docker registry</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2015-05-04T10:48:00Z>May 04, 2015</time></div></div></header><div class="content post__content clearfix"><p><img src=/data/attachment/album/201505/03/235052rf8iq6i6x1xiz8qo.jpg alt></p><p>[TL;DR] 这是系列的第二篇文章，这系列讲述了我的公司如何把基础服务从PaaS迁移到Docker上</p><ul><li><a href=/article-5339-1.html>第一篇文章</a>: 我谈到了接触Docker之前的经历；</li><li><a href=/article-5408-1.html>第三篇文章</a>: 我展示如何使创建镜像的过程自动化以及如何用Docker部署一个Rails应用。</li></ul><hr><p>为什么需要搭建一个私有的registry呢？嗯，对于新手来说，Docker Hub（一个Docker公共仓库）只允许你拥有一个免费的私有版本库（repo）。其他的公司也开始提供类似服务，但是价格可不便宜。另外，如果你需要用Docker部署一个用于生产环境的应用，恐怕你不希望将这些镜像放在公开的Docker Hub上吧！</p><p>这篇文章提供了一个非常务实的方法来处理搭建私有Docker registry时出现的各种错综复杂的情况。我们将会使用一个运行于DigitalOcean（之后简称为DO）的非常小巧的512MB VPS 实例。并且我会假定你已经了解了Docker的基本概念，因为我必须集中精力在复杂的事情上！</p><h3 id=本地搭建>本地搭建</h3><p>首先你需要安装<strong>boot2docker</strong>以及docker CLI。如果你已经搭建好了基本的Docker环境，你可以直接跳过这一步。</p><p>从终端运行以下命令（我假设你使用OS X，使用 HomeBrew 来安装相关软件，你可以根据你的环境使用不同的包管理软件来安装）:</p><pre tabindex=0><code>brew install boot2docker docker  
</code></pre><p>如果一切顺利（想要了解搭建docker环境的完整指南，请参阅 <a href=http://boot2docker.io/>http://boot2docker.io/</a>） ，你现在就能够通过如下命令启动一个 Docker 运行于其中的虚拟机：</p><pre tabindex=0><code>boot2docker up  
</code></pre><p>按照屏幕显示的说明，复制粘贴book2docker在终端输出的命令。如果你现在运行<code>docker ps</code>命令，终端将有以下显示。</p><pre tabindex=0><code>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES  
</code></pre><p>好了，Docker已经准备就绪，这就够了，我们回过头去搭建registry。</p><h3 id=创建服务器>创建服务器</h3><p>登录进你的DO账号，选择一个预安装了Docker的镜像文件，创建一个新的Drople。（本文写成时选择的是 Image > Applications > Docker 1.4.1 on 14.04）</p><p><img src=/data/attachment/album/201505/03/235325m6r1k1mom96mqn8m.png alt></p><p>你将会以邮件的方式收到一个根用户凭证。登录进去，然后运行<code>docker ps</code>命令来查看系统状态。</p><h3 id=搭建aws-s3>搭建AWS S3</h3><p>我们现在将使用Amazo Simple Storage Service（S3）作为我们registry/repository的存储层。我们将需要创建一个桶(bucket)以及用户凭证（user credentials）来允许我们的docker容器访问它。</p><p>登录到我们的AWS账号（如果没有，就申请一个<a href=http://aws.amazon.com/>http://aws.amazon.com/</a>），在控制台选择S3（Simpole Storage Service）。</p><p><img src=/data/attachment/album/201505/03/235330nzcuztdvxit4z2ki.png alt></p><p>点击 <strong>Create Bucket</strong>，为你的桶输入一个名字（把它记下来，我们一会需要用到它），然后点击<strong>Create</strong>。</p><p><img src=/data/attachment/album/201505/03/235333gph8umin9yc98n9k.png alt></p><p>OK！我们已经搭建好存储部分了。</p><h3 id=设置aws访问凭证>设置AWS访问凭证</h3><p>我们现在将要创建一个新的用户。退回到AWS控制台然后选择IAM（Identity & Access Management)。</p><p><img src=/data/attachment/album/201505/03/235337pht9iif6v2h03uiz.png alt></p><p>在dashboard的左边，点击Users。然后选择 <strong>Create New Users</strong>。</p><p>如图所示：</p><p><img src=/data/attachment/album/201505/03/235339yy3gv263g2vglvv3.png alt></p><p>输入一个用户名（例如 docker-registry）然后点击Create。写下（或者下载csv文件）你的Access Key以及Secret Access Key。回到你的用户列表然后选择你刚刚创建的用户。</p><p>在Permission section下面，点击Attach User Policy。之后在下一屏，选择Custom Policy。</p><p><img src=/data/attachment/album/201505/03/235341g7y717cq2447ywfr.png alt></p><p>custom policy的内容如下：</p><pre tabindex=0><code>{
  &#34;Version&#34;: &#34;2012-10-17&#34;,
  &#34;Statement&#34;: [
    {
      &#34;Sid&#34;: &#34;SomeStatement&#34;,
      &#34;Effect&#34;: &#34;Allow&#34;,
      &#34;Action&#34;: [
        &#34;s3:*&#34;
      ],
      &#34;Resource&#34;: [
        &#34;arn:aws:s3:::docker-registry-bucket-name/*&#34;,       
        &#34;arn:aws:s3:::docker-registry-bucket-name&#34;
      ]
    }
  ]
}
</code></pre><p>这个配置将允许用户（也就是regitstry）来对桶上的内容进行操作（读/写）（确保使用你之前创建AWS S3时使用的桶名）。总结一下：当你想把你的Docker镜像从你的本机推送到仓库中时，服务器就会将他们上传到S3。</p><h3 id=安装registry>安装registry</h3><p>现在回过头来看我们的DO服务器，SSH登录其上。我们将要<a href=https://github.com/docker/docker-registry/>使用</a>一个<a href=https://registry.hub.docker.com/_/registry/>官方Docker registry镜像</a>。</p><p>输入如下命令，开启registry。</p><pre tabindex=0><code>docker run \  
         -e SETTINGS_FLAVOR=s3 \
         -e AWS_BUCKET=bucket-name \
         -e STORAGE_PATH=/registry \
         -e AWS_KEY=your_aws_key \
         -e AWS_SECRET=your_aws_secret \
         -e SEARCH_BACKEND=sqlalchemy \
         -p 5000:5000 \
         --name registry \
         -d \
         registry
</code></pre><p>Docker将会从Docker Hub上拉取所需的文件系统分层（fs layers）并启动守护容器（daemonised container）。</p><h3 id=测试registry>测试registry</h3><p>如果上述操作奏效，你可以通过ping命令，或者查找它的内容来测试registry（虽然这个时候容器还是空的）。</p><p>我们的registry非常基础，而且没有提供任何“验明正身”的方式。因为添加身份验证可不是一件轻松事（至少我认为没有一种部署方法是简单的，像是为了证明你努力过似的），我觉得“查询/拉取/推送”仓库内容的最简单方法就是通过SSH通道的未加密连接（通过HTTP）。</p><p>打开SSH通道的操作非常简单：</p><pre tabindex=0><code>ssh -N -L 5000:localhost:5000 root@your_registry.com
</code></pre><p>这条命令建立了一条从registry服务器（前面执行<code>docker run</code>命令的时候我们见过它）的5000号端口到本机的5000号端口之间的 SSH 管道连接。</p><p>如果你现在用浏览器访问 <a href=http://localhost:5000/v1/_ping>http://localhost:5000/v1/_ping</a>，将会看到下面这个非常简短的回复。</p><pre tabindex=0><code>{}
</code></pre><p>这个意味着registry工作正常。你还可以通过登录 <a href=http://localhost:5000/v1/search>http://localhost:5000/v1/search</a> 来查看registry内容，内容相似：</p><pre tabindex=0><code>{
  &#34;num_results&#34;: 2,
  &#34;query&#34;: &#34;&#34;,
  &#34;results&#34;: [
    {
      &#34;description&#34;: &#34;&#34;,
      &#34;name&#34;: &#34;username/first-repo&#34;
    },
    {
      &#34;description&#34;: &#34;&#34;,
      &#34;name&#34;: &#34;username/second-repo&#34;
    }
  ]
}
</code></pre><h3 id=创建一个镜像>创建一个镜像</h3><p>我们现在创建一个非常简单的Docker镜像，来检验我们新弄好的registry。在我们的本机上，用如下内容创建一个Dockerfile（这里只有一点代码，在下一篇文章里我将会展示给你如何将一个Rails应用绑定进Docker容器中。）：</p><pre tabindex=0><code>#  ruby 2.2.0 的基础镜像
FROM ruby:2.2.0

MAINTAINER Michelangelo Chasseur &lt;michelangelo.chasseur@touchwa.re&gt;  
</code></pre><p>并创建它：</p><pre tabindex=0><code>docker build -t localhost:5000/username/repo-name .  
</code></pre><p><code>localhost:5000</code>这个部分非常重要：Docker镜像名的最前面一个部分将告知<code>docker push</code>命令我们将要把我们的镜像推送到哪里。在我们这个例子当中，因为我们要通过SSH管道连接远程的私有registry，<code>localhost:5000</code>精确地指向了我们的registry。</p><p>如果一切顺利，当命令执行完成返回后，你可以输入<code>docker images</code>命令来列出新近创建的镜像。执行它看看会出现什么现象？</p><h3 id=推送到仓库>推送到仓库</h3><p>接下来是更好玩的部分。实现我所描述的东西着实花了我一点时间，所以如果你第一次读的话就耐心一点吧，跟着我一起操作。我知道接下来的东西会非常复杂（如果你不自动化这个过程就一定会这样），但是我保证到最后你一定都能明白。在下一篇文章里我将会使用到一大波shell脚本和Rake任务，通过它们实现自动化并且用简单的命令实现部署Rails应用。</p><p>你在终端上运行的docker命令实际上都是使用boot2docker虚拟机来运行容器及各种东西。所以当你执行像<code>docker push some_repo</code>这样的命令时，是boot2docker虚拟机在与registry交互，而不是我们自己的机器。</p><p>接下来是一个非常重要的点：为了将Docker镜像推送到远端的私有仓库，SSH管道需要在boot2docker虚拟机上配置好，而不是在你的本地机器上配置。</p><p>有许多种方法实现它。我给你展示最简短的一种（可能不是最容易理解的，但是能够帮助你实现自动化）</p><p>在这之前，我们需要对 SSH 做最后一点工作。</p><h3 id=设置-ssh>设置 SSH</h3><p>让我们把boot2docker 的 SSH key添加到远端服务器的“已知主机”里面。我们可以使用ssh-copy-id工具完成，通过下面的命令就可以安装上它了：</p><pre tabindex=0><code>brew install ssh-copy-id  
</code></pre><p>然后运行：</p><pre tabindex=0><code>ssh-copy-id -i /Users/username/.ssh/id_boot2docker root@your-registry.com  
</code></pre><p>用你ssh key的真实路径代替<code>/Users/username/.ssh/id_boot2docker</code>。</p><p>这样做能够让我们免密码登录SSH。</p><p>现在我们来测试以下：</p><pre tabindex=0><code>boot2docker ssh &#34;ssh -o &#39;StrictHostKeyChecking no&#39; -i /Users/michelangelo/.ssh/id_boot2docker -N -L 5000:localhost:5000 root@registry.touchwa.re &amp;&#34; &amp;  
</code></pre><p>分开阐述：</p><ul><li><code>boot2docker ssh</code>允许你以参数的形式传递给boot2docker虚拟机一条执行的命令；</li><li>最后面那个<code>&</code>表明这条命令将在后台执行；</li><li><code>ssh -o 'StrictHostKeyChecking no' -i /Users/michelangelo/.ssh/id_boot2docker -N -L 5000:localhost:5000 root@registry.touchwa.re &</code>是boot2docker虚拟机实际运行的命令；<ul><li><code>-o 'StrictHostKeyChecking no'</code>——不提示安全问题；</li><li><code>-i /Users/michelangelo/.ssh/id_boot2docker</code>指出虚拟机使用哪个SSH key来进行身份验证。（注意这里的key应该是你前面添加到远程仓库的那个）</li><li>最后我们将打开一条端口5000映射到localhost:5000的SSH通道。</li></ul></li></ul><h3 id=从其他服务器上拉取>从其他服务器上拉取</h3><p>你现在将可以通过下面的简单命令将你的镜像推送到远端仓库：</p><pre tabindex=0><code>docker push localhost:5000/username/repo_name  
</code></pre><p>在下一篇<a href=/article-5408-1.html>文章</a>中，我们将会了解到如何自动化处理这些事务，并且真正地容器化一个Rails应用。请继续收听！</p><p>如有错误，请不吝指出。祝你Docker之路顺利！</p><hr><p>via: <a href=http://cocoahunter.com/2015/01/23/docker-2/>http://cocoahunter.com/2015/01/23/docker-2/</a></p><p>作者：<a href=http://cocoahunter.com/author/michelangelo/>Michelangelo Chasseur</a> 译者：<a href=https://github.com/DongShuaike>DongShuaike</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创翻译，<a href=http://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/docker/ rel=tag>Docker</a></li><li class=tags__item><a class="tags__link btn" href=/tags/registry/ rel=tag>registry</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>