<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Linux 内核里的数据结构——双向链表 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="Linux 内核里的数据结构——双向链表"><meta property="og:description" content="我们将会首先从双向链表数据结构开始介绍内核里的数据结构。为什么？因为它在内核里使用的很广泛，你只需要在 free-electrons.com 检索一下就知道了。"><meta property="og:type" content="article"><meta property="og:url" content="/article-7321-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2016-05-10T14:23:00+00:00"><meta property="article:modified_time" content="2016-05-10T14:23:00+00:00"><meta itemprop=name content="Linux 内核里的数据结构——双向链表"><meta itemprop=description content="我们将会首先从双向链表数据结构开始介绍内核里的数据结构。为什么？因为它在内核里使用的很广泛，你只需要在 free-electrons.com 检索一下就知道了。"><meta itemprop=datePublished content="2016-05-10T14:23:00+00:00"><meta itemprop=dateModified content="2016-05-10T14:23:00+00:00"><meta itemprop=wordCount content="542"><meta itemprop=keywords content="双向链表,内核,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>Linux 内核里的数据结构——双向链表</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-05-10T14:23:00Z>May 10, 2016</time></div></div></header><div class="content post__content clearfix"><p>Linux 内核中自己实现了双向链表，可以在 <a href=https://github.com/torvalds/linux/blob/master/include/linux/list.h>include/linux/list.h</a> 找到定义。我们将会首先从双向链表数据结构开始介绍<strong>内核里的数据结构</strong>。为什么？因为它在内核里使用的很广泛，你只需要在 <a href="http://lxr.free-electrons.com/ident?i=list_head">free-electrons.com</a> 检索一下就知道了。</p><p><img src=/data/attachment/album/201605/10/053544tvbmvkebls3evvea.jpg alt></p><p>首先让我们看一下在 <a href=https://github.com/torvalds/linux/blob/master/include/linux/types.h>include/linux/types.h</a> 里的主结构体：</p><pre tabindex=0><code>struct list_head {
    struct list_head *next, *prev;
};
</code></pre><p>你可能注意到这和你以前见过的双向链表的实现方法是不同的。举个例子来说，在 <a href=http://www.gnu.org/software/libc/>glib</a> 库里是这样实现的：</p><pre tabindex=0><code>struct GList {
  gpointer data;
  GList *next;
  GList *prev;
};
</code></pre><p>通常来说一个链表结构会包含一个指向某个项目的指针。但是 Linux 内核中的链表实现并没有这样做。所以问题来了：<strong>链表在哪里保存数据呢？</strong>。实际上，内核里实现的链表是<strong>侵入式链表（Intrusive list）</strong>。侵入式链表并不在节点内保存数据-它的节点仅仅包含指向前后节点的指针，以及指向链表节点数据部分的指针——数据就是这样附加在链表上的。这就使得这个数据结构是通用的，使用起来就不需要考虑节点数据的类型了。</p><p>比如：</p><pre tabindex=0><code>struct nmi_desc {
    spinlock_t lock;
    struct list_head head;
};
</code></pre><p>让我们看几个例子来理解一下在内核里是如何使用 <code>list_head</code> 的。如上所述，在内核里有很多很多不同的地方都用到了链表。我们来看一个在杂项字符驱动里面的使用的例子。在 <a href=https://github.com/torvalds/linux/blob/master/drivers/char/misc.c>drivers/char/misc.c</a> 的杂项字符驱动 API 被用来编写处理小型硬件或虚拟设备的小驱动。这些驱动共享相同的主设备号：</p><pre tabindex=0><code>#define MISC_MAJOR              10
</code></pre><p>但是都有各自不同的次设备号。比如：</p><pre tabindex=0><code>ls -l /dev |  grep 10
crw-------   1 root root     10, 235 Mar 21 12:01 autofs
drwxr-xr-x  10 root root         200 Mar 21 12:01 cpu
crw-------   1 root root     10,  62 Mar 21 12:01 cpu_dma_latency
crw-------   1 root root     10, 203 Mar 21 12:01 cuse
drwxr-xr-x   2 root root         100 Mar 21 12:01 dri
crw-rw-rw-   1 root root     10, 229 Mar 21 12:01 fuse
crw-------   1 root root     10, 228 Mar 21 12:01 hpet
crw-------   1 root root     10, 183 Mar 21 12:01 hwrng
crw-rw----+  1 root kvm      10, 232 Mar 21 12:01 kvm
crw-rw----   1 root disk     10, 237 Mar 21 12:01 loop-control
crw-------   1 root root     10, 227 Mar 21 12:01 mcelog
crw-------   1 root root     10,  59 Mar 21 12:01 memory_bandwidth
crw-------   1 root root     10,  61 Mar 21 12:01 network_latency
crw-------   1 root root     10,  60 Mar 21 12:01 network_throughput
crw-r-----   1 root kmem     10, 144 Mar 21 12:01 nvram
brw-rw----   1 root disk      1,  10 Mar 21 12:01 ram10
crw--w----   1 root tty       4,  10 Mar 21 12:01 tty10
crw-rw----   1 root dialout   4,  74 Mar 21 12:01 ttyS10
crw-------   1 root root     10,  63 Mar 21 12:01 vga_arbiter
crw-------   1 root root     10, 137 Mar 21 12:01 vhci
</code></pre><p>现在让我们看看它是如何使用链表的。首先看一下结构体 <code>miscdevice</code>：</p><pre tabindex=0><code>struct miscdevice
{
      int minor;
      const char *name;
      const struct file_operations *fops;
      struct list_head list;
      struct device *parent;
      struct device *this_device;
      const char *nodename;
      mode_t mode;
};
</code></pre><p>可以看到结构体<code>miscdevice</code>的第四个变量<code>list</code> 是所有注册过的设备的链表。在源代码文件的开始可以看到这个链表的定义：</p><pre tabindex=0><code>static LIST_HEAD(misc_list);
</code></pre><p>它实际上是对用<code>list_head</code> 类型定义的变量的扩展。</p><pre tabindex=0><code>#define LIST_HEAD(name) \
    struct list_head name = LIST_HEAD_INIT(name)
</code></pre><p>然后使用宏 <code>LIST_HEAD_INIT</code> 进行初始化，这会使用变量<code>name</code> 的地址来填充<code>prev</code>和<code>next</code> 结构体的两个变量。</p><pre tabindex=0><code>#define LIST_HEAD_INIT(name) { &amp;(name), &amp;(name) }
</code></pre><p>现在来看看注册杂项设备的函数<code>misc_register</code>。它在一开始就用函数 <code>INIT_LIST_HEAD</code> 初始化了<code>miscdevice->list</code>。</p><pre tabindex=0><code>INIT_LIST_HEAD(&amp;misc-&gt;list);
</code></pre><p>作用和宏<code>LIST_HEAD_INIT</code>一样。</p><pre tabindex=0><code>static inline void INIT_LIST_HEAD(struct list_head *list)
{
    list-&gt;next = list;
    list-&gt;prev = list;
}
</code></pre><p>接下来，在函数<code>device_create</code> 创建了设备后，我们就用下面的语句将设备添加到设备链表：</p><pre tabindex=0><code>list_add(&amp;misc-&gt;list, &amp;misc_list);
</code></pre><p>内核文件<code>list.h</code> 提供了向链表添加新项的 API 接口。我们来看看它的实现：</p><pre tabindex=0><code>static inline void list_add(struct list_head *new, struct list_head *head)
{
    __list_add(new, head, head-&gt;next);
}
</code></pre><p>实际上就是使用3个指定的参数来调用了内部函数<code>__list_add</code>：</p><ul><li>new - 新项。</li><li>head - 新项将会插在<code>head</code>的后面</li><li>head->next - 插入前，<code>head</code> 后面的项。</li></ul><p><code>__list_add</code>的实现非常简单：</p><pre tabindex=0><code>static inline void __list_add(struct list_head *new,
                  struct list_head *prev,
                  struct list_head *next)
{
    next-&gt;prev = new;
    new-&gt;next = next;
    new-&gt;prev = prev;
    prev-&gt;next = new;
}
</code></pre><p>这里，我们在<code>prev</code>和<code>next</code> 之间添加了一个新项。所以我们开始时用宏<code>LIST_HEAD_INIT</code>定义的<code>misc</code> 链表会包含指向<code>miscdevice->list</code> 的向前指针和向后指针。</p><p>这儿还有一个问题：如何得到列表的内容呢？这里有一个特殊的宏：</p><pre tabindex=0><code>#define list_entry(ptr, type, member) \
    container_of(ptr, type, member)
</code></pre><p>使用了三个参数：</p><ul><li>ptr - 指向结构 <code>list_head</code> 的指针；</li><li>type - 结构体类型;</li><li>member - 在结构体内类型为<code>list_head</code> 的变量的名字；</li></ul><p>比如说：</p><pre tabindex=0><code>const struct miscdevice *p = list_entry(v, struct miscdevice, list)
</code></pre><p>然后我们就可以使用<code>p->minor</code> 或者 <code>p->name</code>来访问<code>miscdevice</code>。让我们来看看<code>list_entry</code> 的实现：</p><pre tabindex=0><code>#define list_entry(ptr, type, member) \
    container_of(ptr, type, member)
</code></pre><p>如我们所见，它仅仅使用相同的参数调用了宏<code>container_of</code>。初看这个宏挺奇怪的：</p><pre tabindex=0><code>#define container_of(ptr, type, member) ({                      \
    const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr);    \
    (type *)( (char *)__mptr - offsetof(type,member) );})
</code></pre><p>首先你可以注意到花括号内包含两个表达式。编译器会执行花括号内的全部语句，然后返回最后的表达式的值。</p><p>举个例子来说：</p><pre tabindex=0><code>#include &lt;stdio.h&gt;

int main() {
    int i = 0;
    printf(&#34;i = %d\n&#34;, ({++i; ++i;}));
    return 0;
}
</code></pre><p>最终会打印出<code>2</code>。</p><p>下一点就是<code>typeof</code>,它也很简单。就如你从名字所理解的，它仅仅返回了给定变量的类型。当我第一次看到宏<code>container_of</code>的实现时，让我觉得最奇怪的就是表达式<code>((type *)0)</code>中的0。实际上这个指针巧妙的计算了从结构体特定变量的偏移，这里的<code>0</code>刚好就是位宽里的零偏移。让我们看一个简单的例子：</p><pre tabindex=0><code>#include &lt;stdio.h&gt;

struct s {
        int field1;
        char field2;
     char field3;
};

int main() {
    printf(&#34;%p\n&#34;, &amp;((struct s*)0)-&gt;field3);
    return 0;
}
</code></pre><p>结果显示<code>0x5</code>。</p><p>下一个宏<code>offsetof</code>会计算从结构体起始地址到某个给定结构字段的偏移。它的实现和上面类似：</p><pre tabindex=0><code>#define offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)
</code></pre><p>现在我们来总结一下宏<code>container_of</code>。只需给定结构体中<code>list_head</code>类型 字段的地址、名字和结构体容器的类型，它就可以返回结构体的起始地址。在宏定义的第一行，声明了一个指向结构体成员变量<code>ptr</code>的指针<code>__mptr</code>，并且把<code>ptr</code> 的地址赋给它。现在<code>ptr</code> 和<code>__mptr</code> 指向了同一个地址。从技术上讲我们并不需要这一行，但是它可以方便地进行类型检查。第一行保证了特定的结构体（参数<code>type</code>）包含成员变量<code>member</code>。第二行代码会用宏<code>offsetof</code>计算成员变量相对于结构体起始地址的偏移，然后从结构体的地址减去这个偏移，最后就得到了结构体。</p><p>当然了<code>list_add</code> 和 <code>list_entry</code>不是<code>&lt;linux/list.h></code>提供的唯一功能。双向链表的实现还提供了如下API：</p><ul><li>list_add</li><li>list_add_tail</li><li>list_del</li><li>list_replace</li><li>list_move</li><li>list_is_last</li><li>list_empty</li><li>list_cut_position</li><li>list_splice</li><li>list_for_each</li><li>list_for_each_entry</li></ul><p>等等很多其它API。</p><hr><p>via: <a href=https://github.com/0xAX/linux-insides/blob/master/DataStructures/dlist.md>https://github.com/0xAX/linux-insides/blob/master/DataStructures/dlist.md</a></p><p>译者：<a href=https://github.com/oska874>Ezio</a> 校对：<a href=https://github.com/tinyeyeser>Mr小眼儿</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/ rel=tag>双向链表</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E5%86%85%E6%A0%B8/ rel=tag>内核</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>