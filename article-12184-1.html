<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Go 中对栈中函数进行内联 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="Go 中对栈中函数进行内联"><meta property="og:description" content="本文中，我要论述内联的限制以及叶子内联与栈中内联mid-stack inlining的对比。"><meta property="og:type" content="article"><meta property="og:url" content="/article-12184-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-05-04T23:04:20+00:00"><meta property="article:modified_time" content="2020-05-04T23:04:20+00:00"><meta itemprop=name content="Go 中对栈中函数进行内联"><meta itemprop=description content="本文中，我要论述内联的限制以及叶子内联与栈中内联mid-stack inlining的对比。"><meta itemprop=datePublished content="2020-05-04T23:04:20+00:00"><meta itemprop=dateModified content="2020-05-04T23:04:20+00:00"><meta itemprop=wordCount content="554"><meta itemprop=keywords content="内联,Go,编译器,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>Go 中对栈中函数进行内联</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2020-05-04T23:04:20Z>May 04, 2020</time></div></div></header><div class="content post__content clearfix"><p><img src=/data/attachment/album/202005/04/230304avxkxlyoozbiw1bn.jpg alt></p><p><a href=/article-12176-1.html>上一篇文章</a>中我论述了 叶子内联 leaf inlining 是怎样让 Go 编译器减少函数调用的开销的，以及延伸出了跨函数边界的优化的机会。本文中，我要论述内联的限制以及叶子内联与 栈中内联 mid-stack inlining 的对比。</p><h3 id=内联的限制>内联的限制</h3><p>把函数内联到它的调用处消除了调用的开销，为编译器进行其他的优化提供了更好的机会，那么问题来了，既然内联这么好，内联得越多开销就越少，<em>为什么不尽可能多地内联呢？</em></p><p>内联可能会以增加程序大小换来更快的执行时间。限制内联的最主要原因是，创建许多函数的内联副本会增加编译时间，并导致生成更大的二进制文件的边际效应。即使把内联带来的进一步的优化机会考虑在内，太激进的内联也可能会增加生成的二进制文件的大小和编译时间。</p><p>内联收益最大的是<a href=https://medium.com/@joshsaintjacque/small-functions-considered-awesome-c95b3fd1812f>小函数</a>，相对于调用它们的开销来说，这些函数做很少的工作。随着函数大小的增长，函数内部做的工作与函数调用的开销相比省下的时间越来越少。函数越大通常越复杂，因此优化其内联形式相对于原地优化的好处会减少。</p><h3 id=内联预算>内联预算</h3><p>在编译过程中，每个函数的内联能力是用<em>内联预算</em>计算的 1 。开销的计算过程可以巧妙地内化，像一元和二元等简单操作，在 抽象语法数 Abstract Syntax Tree （AST）中通常是每个节点一个单位，更复杂的操作如 <code>make</code> 可能单位更多。考虑下面的例子：</p><pre tabindex=0><code>package main

func small() string {
    s := &#34;hello, &#34; + &#34;world!&#34;
    return s
}

func large() string {
    s := &#34;a&#34;
    s += &#34;b&#34;
    s += &#34;c&#34;
    s += &#34;d&#34;
    s += &#34;e&#34;
    s += &#34;f&#34;
    s += &#34;g&#34;
    s += &#34;h&#34;
    s += &#34;i&#34;
    s += &#34;j&#34;
    s += &#34;k&#34;
    s += &#34;l&#34;
    s += &#34;m&#34;
    s += &#34;n&#34;
    s += &#34;o&#34;
    s += &#34;p&#34;
    s += &#34;q&#34;
    s += &#34;r&#34;
    s += &#34;s&#34;
    s += &#34;t&#34;
    s += &#34;u&#34;
    s += &#34;v&#34;
    s += &#34;w&#34;
    s += &#34;x&#34;
    s += &#34;y&#34;
    s += &#34;z&#34;
    return s
}

func main() {
    small()
    large()
}
</code></pre><p>使用 <code>-gcflags=-m=2</code> 参数编译这个函数能让我们看到编译器分配给每个函数的开销：</p><pre tabindex=0><code>% go build -gcflags=-m=2 inl.go
# command-line-arguments
./inl.go:3:6: can inline small with cost 7 as: func() string { s := &#34;hello, world!&#34;; return s }
./inl.go:8:6: cannot inline large: function too complex: cost 82 exceeds budget 80
./inl.go:38:6: can inline main with cost 68 as: func() { small(); large() }
./inl.go:39:7: inlining call to small func() string { s := &#34;hello, world!&#34;; return s }
</code></pre><p>编译器根据函数 <code>func small()</code> 的开销（7）决定可以对它内联，而 <code>func large()</code> 的开销太大，编译器决定不进行内联。<code>func main()</code> 被标记为适合内联的，分配了 68 的开销；其中 <code>small</code> 占用 7，调用 <code>small</code> 函数占用 57，剩余的（4）是它自己的开销。</p><p>可以用 <code>-gcflag=-l</code> 参数控制内联预算的等级。下面是可使用的值：</p><ul><li><code>-gcflags=-l=0</code> 默认的内联等级。</li><li><code>-gcflags=-l</code>（或 <code>-gcflags=-l=1</code>）取消内联。</li><li><code>-gcflags=-l=2</code> 和 <code>-gcflags=-l=3</code> 现在已经不使用了。和 <code>-gcflags=-l=0</code> 相比没有区别。</li><li><code>-gcflags=-l=4</code> 减少非叶子函数和通过接口调用的函数的开销。 2</li></ul><h4 id=不确定语句的优化>不确定语句的优化</h4><p>一些函数虽然内联的开销很小，但由于太复杂它们仍不适合进行内联。这就是函数的不确定性，因为一些操作的语义在内联后很难去推导，如 <code>recover</code>、<code>break</code>。其他的操作，如 <code>select</code> 和 <code>go</code> 涉及运行时的协调，因此内联后引入的额外的开销不能抵消内联带来的收益。</p><p>不确定的语句也包括 <code>for</code> 和 <code>range</code>，这些语句不一定开销很大，但目前为止还没有对它们进行优化。</p><h3 id=栈中函数优化>栈中函数优化</h3><p>在过去，Go 编译器只对叶子函数进行内联 —— 只有那些不调用其他函数的函数才有资格。在上一段不确定的语句的探讨内容中，一次函数调用就会让这个函数失去内联的资格。</p><p>进入栈中进行内联，就像它的名字一样，能内联在函数调用栈中间的函数，不需要先让它下面的所有的函数都被标记为有资格内联的。栈中内联是 David Lazar 在 Go 1.9 中引入的，并在随后的版本中做了改进。<a href="https://docs.google.com/presentation/d/1Wcblp3jpfeKwA0Y4FOmj63PW52M_qmNqlQkNaLj0P5o/edit#slide=id.p">这篇文稿</a>深入探究了保留栈追踪行为和被深度内联后的代码路径里的 <code>runtime.Callers</code> 的难点。</p><p>在前面的例子中我们看到了栈中函数内联。内联后，<code>func main()</code> 包含了 <code>func small()</code> 的函数体和对 <code>func large()</code> 的一次调用，因此它被判定为非叶子函数。在过去，这会阻止它被继续内联，虽然它的联合开销小于内联预算。</p><p>栈中内联的最主要的应用案例就是减少贯穿函数调用栈的开销。考虑下面的例子：</p><pre tabindex=0><code>package main

import (
    &#34;fmt&#34;
    &#34;strconv&#34;
)

type Rectangle struct {}

//go:noinline
func (r *Rectangle) Height() int {
    h, _ := strconv.ParseInt(&#34;7&#34;, 10, 0)
    return int(h)
}

func (r *Rectangle) Width() int {
    return 6
}

func (r *Rectangle) Area() int { return r.Height() * r.Width() }

func main() {
    var r Rectangle
    fmt.Println(r.Area())
}
</code></pre><p>在这个例子中， <code>r.Area()</code> 是个简单的函数，调用了两个函数。<code>r.Width()</code> 可以被内联，<code>r.Height()</code> 这里用 <code>//go:noinline</code> 指令标注了，不能被内联。 3</p><pre tabindex=0><code>% go build -gcflags=&#39;-m=2&#39; square.go                                                                                                          
# command-line-arguments
./square.go:12:6: cannot inline (*Rectangle).Height: marked go:noinline                                                                               
./square.go:17:6: can inline (*Rectangle).Width with cost 2 as: method(*Rectangle) func() int { return 6 }
./square.go:21:6: can inline (*Rectangle).Area with cost 67 as: method(*Rectangle) func() int { return r.Height() * r.Width() }                       
./square.go:21:61: inlining call to (*Rectangle).Width method(*Rectangle) func() int { return 6 }                                                     
./square.go:23:6: cannot inline main: function too complex: cost 150 exceeds budget 80                        
./square.go:25:20: inlining call to (*Rectangle).Area method(*Rectangle) func() int { return r.Height() * r.Width() }
./square.go:25:20: inlining call to (*Rectangle).Width method(*Rectangle) func() int { return 6 }
</code></pre><p>由于 <code>r.Area()</code> 中的乘法与调用它的开销相比并不大，因此内联它的表达式是纯收益，即使它的调用的下游 <code>r.Height()</code> 仍是没有内联资格的。</p><h4 id=快速路径内联>快速路径内联</h4><p>关于栈中内联的效果最令人吃惊的例子是 2019 年 <a href=https://go-review.googlesource.com/c/go/+/148959>Carlo Alberto Ferraris</a> 通过允许把 <code>sync.Mutex.Lock()</code> 的快速路径（非竞争的情况）内联到它的调用方来<a href=https://go-review.googlesource.com/c/go/+/148959>提升它的性能</a>。在这个修改之前，<code>sync.Mutex.Lock()</code> 是个很大的函数，包含很多难以理解的条件，使得它没有资格被内联。即使锁可用时，调用者也要付出调用 <code>sync.Mutex.Lock()</code> 的代价。</p><p>Carlo 把 <code>sync.Mutex.Lock()</code> 分成了两个函数（他自己称为 外联 outlining ）。外部的 <code>sync.Mutex.Lock()</code> 方法现在调用 <code>sync/atomic.CompareAndSwapInt32()</code> 且如果 CAS（ 比较并交换 Compare and Swap ）成功了之后立即返回给调用者。如果 CAS 失败，函数会走到 <code>sync.Mutex.lockSlow()</code> 慢速路径，需要对锁进行注册，暂停 goroutine。 4</p><pre tabindex=0><code>% go build -gcflags=&#39;-m=2 -l=0&#39; sync 2&gt;&amp;1 | grep &#39;(*Mutex).Lock&#39;
../go/src/sync/mutex.go:72:6: can inline (*Mutex).Lock with cost 69 as: method(*Mutex) func() { if &#34;sync/atomic&#34;.CompareAndSwapInt32(&amp;m.state, 0, mutexLocked) { if race.Enabled {  }; return  }; m.lockSlow() }
</code></pre><p>通过把函数分割成一个简单的不能再被分割的外部函数，和（如果没走到外部函数就走到的）一个处理慢速路径的复杂的内部函数，Carlo 组合了栈中函数内联和<a href=https://dave.cheney.net/2019/08/20/go-compiler-intrinsics>编译器对基础操作的支持</a>，减少了非竞争锁 14% 的开销。之后他在 <code>sync.RWMutex.Unlock()</code> 重复这个技巧，节省了另外 9% 的开销。</p><h3 id=相关文章>相关文章：</h3><ol><li><a href=https://dave.cheney.net/2020/04/25/inlining-optimisations-in-go title="Inlining optimisations in Go">Go 中的内联优化</a></li><li><a href=https://dave.cheney.net/2013/06/02/why-is-a-goroutines-stack-infinite title="Why is a Goroutine’s stack infinite ?">goroutine 的栈为什么会无限增长？</a></li><li><a href=https://dave.cheney.net/2016/06/12/stack-traces-and-the-errors-package title="Stack traces and the errors package">栈追踪和 errors 包</a></li><li><a href=https://dave.cheney.net/2013/01/19/what-is-the-zero-value-and-why-is-it-useful title="What is the zero value, and why is it useful?">零值是什么，为什么它很有用？</a></li></ol><hr><ol><li>不同发布版本中，在考虑该函数是否适合内联时，Go 编译器对同一函数的预算是不同的。 <a href=#fnref1>↩</a></li><li>时刻记着编译器的作者警告过<a href=https://github.com/golang/go/blob/be08e10b3bc07f3a4e7b27f44d53d582e15fd6c7/src/cmd/compile/internal/gc/inl.go#L11>“更高的内联等级（比 -l 更高）可能导致错误或不被支持”</a>。 Caveat emptor。 <a href=#fnref2>↩</a></li><li>编译器有足够的能力来内联像 <code>strconv.ParseInt</code> 的复杂函数。作为一个实验，你可以尝试去掉 <code>//go:noinline</code> 注释，使用 <code>-gcflags=-m=2</code> 编译后观察。 <a href=#fnref3>↩</a></li><li><code>race.Enable</code> 表达式是通过传递给 <code>go</code> 工具的 <code>-race</code> 参数控制的一个常量。对于普通编译，它的值是 <code>false</code>，此时编译器可以完全省略代码路径。 <a href=#fnref4>↩</a></li></ol><hr><p>via: <a href=https://dave.cheney.net/2020/05/02/mid-stack-inlining-in-go>https://dave.cheney.net/2020/05/02/mid-stack-inlining-in-go</a></p><p>作者：<a href=https://dave.cheney.net/author/davecheney>Dave Cheney</a> 选题：<a href=https://github.com/lujun9972>lujun9972</a> 译者：<a href=https://github.com/lxbwolf>lxbwolf</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/%E5%86%85%E8%81%94/ rel=tag>内联</a></li><li class=tags__item><a class="tags__link btn" href=/tags/go/ rel=tag>Go</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E7%BC%96%E8%AF%91%E5%99%A8/ rel=tag>编译器</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>