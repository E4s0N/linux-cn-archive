<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>CentOS上配置主DNS服务器的简易指南 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="CentOS上配置主DNS服务器的简易指南"><meta property="og:description" content="任何运作中的域名至少有两台DNS服务器，一台称为主域名服务器（比如叫做ns1），而另一台称为从域名服务器（比如叫做ns2）。这些服务器通常用于故障转移：如果一台宕机，另外一台就激活成为DNS服务器（译注：此处译者有不同意见，事实上两个或更多的DNS服务器是共同工作的，并不是第一台停止服务后，第二台才接替工作。解析器是随机选择一个DNS服务器进行询问，如果超时则会询问下一个，这是多个DNS的故障容错机制）。也可以实现包括负载均衡、防火墙和集群在内的更为复杂的故障转移机制。 一个域的所有DNS条目都会被添加到主域名服务器，"><meta property="og:type" content="article"><meta property="og:url" content="/article-3092-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2014-05-26T15:14:00+00:00"><meta property="article:modified_time" content="2014-05-26T15:14:00+00:00"><meta itemprop=name content="CentOS上配置主DNS服务器的简易指南"><meta itemprop=description content="任何运作中的域名至少有两台DNS服务器，一台称为主域名服务器（比如叫做ns1），而另一台称为从域名服务器（比如叫做ns2）。这些服务器通常用于故障转移：如果一台宕机，另外一台就激活成为DNS服务器（译注：此处译者有不同意见，事实上两个或更多的DNS服务器是共同工作的，并不是第一台停止服务后，第二台才接替工作。解析器是随机选择一个DNS服务器进行询问，如果超时则会询问下一个，这是多个DNS的故障容错机制）。也可以实现包括负载均衡、防火墙和集群在内的更为复杂的故障转移机制。 一个域的所有DNS条目都会被添加到主域名服务器，"><meta itemprop=datePublished content="2014-05-26T15:14:00+00:00"><meta itemprop=dateModified content="2014-05-26T15:14:00+00:00"><meta itemprop=wordCount content="474"><meta itemprop=keywords content="DNS,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>CentOS上配置主DNS服务器的简易指南</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-05-26T15:14:00Z>May 26, 2014</time></div></div></header><div class="content post__content clearfix"><p>任何运作中的域名至少有两台DNS服务器，一台称为主域名服务器（比如叫做ns1），而另一台称为从域名服务器（比如叫做ns2）。这些服务器通常用于故障转移：如果一台宕机，另外一台就激活成为DNS服务器（译注：此处译者有不同意见，事实上两个或更多的DNS服务器是共同工作的，并不是第一台停止服务后，第二台才接替工作。解析器是随机选择一个DNS服务器进行询问，如果超时则会询问下一个，这是多个DNS的故障容错机制）。也可以实现包括负载均衡、防火墙和集群在内的更为复杂的故障转移机制。</p><p>一个域的所有DNS条目都会被添加到主域名服务器，从服务器只会根据主服务器上的SOA记录的序列号参数从主服务器同步所有信息。</p><p>此教程将会讲述<strong>如何创建一台在CentOS上运行的主DNS服务器</strong>。请注意，本教程中提到的DNS服务器将会是一台开放DNS服务器，这也就是说该服务器将会回应来自任何IP地址的查询。对于DNS服务器的访问控制将在<a href=http://linux.cn/article-2969-1.html>此教程</a>中讨论（译注：开放的DNS服务器是一个安全隐患）。</p><p><img src=/data/attachment/album/201405/26/151355uzrlxqrp5855qdxy.jpg alt></p><p>在开始之前，我想要提一下的是，DNS可以在chroot环境中配置，也可以在非chroot环境中配置。chroot环境将DNS服务器限制在系统中某个特定目录中，以避免让服务器具有系统级的访问权限。在此环境中，任何DNS服务器的安全漏洞不会导致整个系统的破坏。将DNS服务器置于chroot环境中，对于部署测试也很有用。</p><h3 id=目标>目标</h3><p>我们将在基于域名example.tst的测试环境中配置一台DNS服务器，这个域名是虚假的（并不真实存在的）。这样，我们就不会意外干扰到其它真实的域名。</p><p>在该域中，有以下三台服务器。</p><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>服务器</td><td>IP地址</td><td>托管的服务</td><td>完全限定域名（FQDN）</td></tr><tr><td>Server A</td><td>172.16.1.1</td><td>Mail</td><td>mail.example.tst</td></tr><tr><td>Server B</td><td>172.16.1.2</td><td>Web, FTP</td><td><a href=https://www.example.tstftp.example.tst>www.example.tstftp.example.tst</a></td></tr><tr><td>Server C</td><td>172.16.1.3</td><td>Primary DNS server</td><td>ns1.example.tst</td></tr></tbody></table><p>我们将会配置一台主域名服务器，并添加上表中必要的域和DNS记录。</p><h3 id=设置主机名>设置主机名</h3><p>所有的主机名必须以完全限定域名的方式正确定义，可以通过以下方法完成设置。</p><pre tabindex=0><code># vim /etc/sysconfig/network 
</code></pre><hr><pre tabindex=0><code>HOSTNAME=ns1.example.tst
</code></pre><p>注：该文件中指定的主机名参数在服务器启动后才会启用（译注：或者网络服务重启后），因此，该设置不会马上生效。下面的命令可以立刻临时性地修改主机名。</p><pre tabindex=0><code># hostname ns1.example.tst 
</code></pre><p>一旦设置，主机名可以通过以下命令验证。</p><pre tabindex=0><code># hostname   
ns1.example.tst
</code></pre><p>在进入下一步之前，请确保上述三台服务器上的主机名已经设置正确。</p><h3 id=安装软件包>安装软件包</h3><p>我们将使用bind来配置DNS服务，该软件可以很方便地通过yum来安装。</p><p>不使用chroot环境的：</p><pre tabindex=0><code># yum install bind bind-chroot 
</code></pre><p>使用chroot环境的：</p><pre tabindex=0><code># yum install bind bind-chroot 
</code></pre><h3 id=准备配置文件>准备配置文件</h3><p>正如前面提到的，bind可以在chroot环境下配置，或者在非chroot环境下配置，配置文件的路径会因为是否安装chroot包而不同。</p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td></td><td>配置文件路径</td><td>区域文件路径</td></tr><tr><td>不带有 chroot</td><td>/etc/</td><td>/var/named/</td></tr><tr><td>带有 chroot</td><td>/var/named/chroot/etc/</td><td>/var/named/chroot/var/named/</td></tr></tbody></table><p>可以使用默认提供的named.conf配置文件，但是为了更方便使用，我们将使用另外一个简单的配置文件模板。</p><p>非chroot环境：</p><pre tabindex=0><code># cp /usr/share/doc/bind-9.8.2/sample/etc/named.rfc1912.zones /etc/named.conf
</code></pre><p>chroot环境：</p><pre tabindex=0><code># cp /usr/share/doc/bind-9.8.2/sample/etc/named.rfc1912.zones /var/named/chroot/etc/named.conf
</code></pre><p>现在来备份并修改配置文件。</p><p>非chroot环境：</p><pre tabindex=0><code># vim /etc/named.conf 
</code></pre><p>chroot环境：</p><pre tabindex=0><code># vim /var/named/chroot/etc/named.conf 
</code></pre><p>添加/修改以下行：</p><pre tabindex=0><code>options {
## 区域文件存放目录 ##
directory &#34;/var/named&#34;;

## 对于非本地权威域的请求转发到 Google 的公开 DNS 服务器 ##
forwarders { 8.8.8.8; };
};

## 申明一个本地域 example.tst ##
zone &#34;example.tst&#34; IN {
        type master;
        file &#34;example-fz&#34;; ## 存储文件名，放在 /var/named ##
        allow-update { none; };
};

## 为IP段 172.16.1.0 提供反向解析 ##
zone &#34;1.16.172.in-addr.arpa&#34; IN {
        type master;
        file &#34;rz-172-16-1&#34;; ## 存储文件名，放在 /var/named ##
        allow-update { none; };
};
</code></pre><h3 id=准备区域文件>准备区域文件</h3><p>那些默认的区域文件会自动创建到/var/named 或者/var/named/chroot/var/named (chroot环境)。如果在这些地方找不到这些文件，/usr/share/doc/bind目录中提供了模板文件，可以从这里拷贝。</p><p>假设默认区域文件没有提供，我们可以从/usr拷贝模板文件。</p><p>非chroot环境：</p><pre tabindex=0><code># cp /usr/share/doc/bind-9.8.2/sample/var/named/named.* /var/named/
</code></pre><p>chroot环境：</p><pre tabindex=0><code># cp /usr/share/doc/bind-9.8.2/sample/var/named/named.* /var/named/chroot/var/named
</code></pre><p>很好！由于现在默认的区域文件已经准备好，我们可以为example.tst和172.16.1.0网络创建区域文件了，以下要点必须时刻谨记。</p><ul><li>区域文件中的特殊字符‘@’意味着空。（译注：意即代表本域。）</li><li>所有的完全限定域名必须以点‘.’结束。如：example.tst.如果没有这个点，你会发生问题。（译注：即会被当做当前@所代表的域的子域。）</li></ul><h4 id=1-转发区域本地权威域>1. 转发区域（本地权威域）</h4><p>转发区域包含了名称到IP地址的映射。对于公开的域，域名托管提供商的DNS服务器存储了转发区域文件。（译注：转发区域即本地的权威域，由这个服务器自身提供权威的解析数据）</p><p>非chroot环境：</p><pre tabindex=0><code># vim /var/named/example-fz 
</code></pre><p>chroot环境：</p><pre tabindex=0><code># vim /var/named/chroot/var/named/example-fz 
</code></pre><hr><pre tabindex=0><code>$TTL 1D
@       IN SOA  ns1.example.tst. sarmed.example.tst. (
                                        0       ; serial
                                        1D      ; refresh
                                        1H      ; retry
                                        1W      ; expire
                                        3H )    ; minimum
IN NS      ns1.example.tst.
IN A       172.16.1.3
mail        IN A        172.16.1.1
        IN MX 10    mail.example.tst.
www     IN A        172.16.1.2
ns1     IN A        172.16.1.3
ftp     IN CNAME    www.example.tst.
</code></pre><p><strong>说明</strong>：在区域文件中，SOA是开始授权（Start Of Authority）的意思。它的值的第一段是授权名称服务器的完全限定域名。完全限定域名后面跟着的是电子邮件地址。由于不能在<a href=mailto:sarmed@example.tst>sarmed@example.tst</a>这样的格式中使用‘@’符号（译注：@有特定意义，代表本域。），我们将电子邮件地址重写成sarmed.example.tst.这样的格式。</p><p>以下是典型的常用DNS记录类型：</p><ul><li><strong>NS</strong>：域名服务器</li><li><strong>A</strong>: 地址记录，记录主机名到IP地址的映射（译注，此处原文有误。）</li><li><strong>MX</strong>: 邮件交换记录。这里我们只用了一个邮件交换记录，设置其优先级为10。如果有多个邮件交换记录，我们可以使用多个数值优先级，数字小的优先级最高。例如，MX 0比MX 1优先级更高。</li><li><strong>CNAME</strong>: 标准名。如果在一台单一服务器上托管了多个服务，也很可能将多个名称解析到某个单一服务器。CNAME指定了一台服务器可能有的其它名称，并且将它们指向具有实际A记录的名称。</li></ul><h4 id=2-反向区域>2. 反向区域</h4><p>反向区域包含了IP地址到名称的映射。这里，我们为172.16.1.0网络创建反向区域。在正式的域中，公共IP区块的拥有者拥有的DNS服务器存储反向区域文件。（某些服务，如邮件服务，要求IP地址具备正确的反向解析才能正常工作。而IP的反向解析，通常是由IP的拥有者如接入商或IDC来负责解析。）</p><p>非chroot环境：</p><pre tabindex=0><code># vim /var/named/rz-172-16-1 
</code></pre><p>chroot环境：</p><pre tabindex=0><code># vim /var/named/chroot/var/named/rz-172-16-1 
</code></pre><hr><pre tabindex=0><code>$TTL 1D
@       IN SOA  ns1.example.tst. sarmed.example.tst. (
                                        0       ; serial
                                        1D      ; refresh
                                        1H      ; retry
                                        1W      ; expire
                                        3H )    ; minimum
IN NS      ns1.example.tst.
1       IN PTR  mail.example.tst.
2       IN PTR  www.example.tst.
3       IN PTR  ns1.example.tst.
</code></pre><p><strong>说明</strong>:除了下面的参数外，反向区域文件中的大多数参数和转发区域文件中的相同。</p><ul><li>PTR: IP反向解析记录，指向一个反向限定域名。</li></ul><h3 id=结束工作>结束工作</h3><p>既然区域文件已经准备好，我们接下来调整它们的权限。</p><p>非chroot环境：</p><pre tabindex=0><code># chgrp named /var/named/* 
</code></pre><p>chroot环境：</p><pre tabindex=0><code># chgrp named /var/named/chroot/var/named/* 
</code></pre><p>现在，我们为DNS服务器设置IP地址。</p><pre tabindex=0><code># vim /etc/resolv.conf 
</code></pre><hr><pre tabindex=0><code>nameserver 172.16.1.3
</code></pre><p>最后，我们可以启动DNS服务，并确保将它添加到启动服务中。</p><pre tabindex=0><code># service named restart
# chkconfig named on 
</code></pre><p>DNS服务器起动后，建议关注一下日志文件/var/log/messages，这里头包含了后台运行的一些有用信息。如果没有发现错误，我们可以开始测试DNS服务器。</p><h3 id=测试dns>测试DNS</h3><p>我们可以使用dig或者nslookup来测试DNS。首先，我们需要安装必要的软件包。</p><pre tabindex=0><code># yum install bind-utils 
</code></pre><h4 id=1-使用dig测试转发区域>1. 使用dig测试转发区域</h4><p>使用dig来测试时，必须时刻关注状态信息：“NOERROR”，任何其它值都表明存在问题。</p><pre tabindex=0><code># dig example.tst 
</code></pre><hr><pre tabindex=0><code>;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY,  status: NOERROR, id: 31184

;; QUESTION SECTION:
;example.com.                   IN      A

;; ANSWER SECTION:
example.com.            86400   IN      A       172.16.1.3

;; AUTHORITY SECTION:
example.com.            86400   IN      NS      ns1.example.com.

;; ADDITIONAL SECTION:
ns1.example.com.        86400   IN      A       172.16.1.3
</code></pre><h4 id=2-使用dig测试ptr记录>2. 使用dig测试PTR记录</h4><p>使用dig来测试时，必须时刻关注状态信息：“NOERROR”，任何其它值都表明存在问题。（译注，也可用 dig 1.1.16.172.in-addr.arpa. ptr 来测试。）</p><pre tabindex=0><code># dig -x 172.16.1.1 
</code></pre><hr><pre tabindex=0><code>;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 27415

;; QUESTION SECTION:
;1.1.17.172.in-addr.arpa.       IN      PTR

;; ANSWER SECTION:
1.1.16.172.in-addr.arpa. 86400  IN      PTR     mail.example.tst.

;; AUTHORITY SECTION:
1.16.172.in-addr.arpa.  86400   IN      NS      ns1.example.tst.

;; ADDITIONAL SECTION:
ns1.example.tst.        86400   IN      A       172.16.1.3
</code></pre><h4 id=3-使用dig测试mx记录>3. 使用dig测试MX记录</h4><pre tabindex=0><code># dig example.tst mx 
</code></pre><hr><pre tabindex=0><code>;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 35405

;; QUESTION SECTION:
;example.tst.                        IN      MX

;; ANSWER SECTION:
example.tst.         14366   IN      MX     10  mail.example.tst.
</code></pre><h3 id=排错提示>排错提示</h3><ol><li>我已经把SELinux关闭。</li><li>保证防火墙没有阻挡UDP 53端口</li><li>万一出错，可在/var/log/messages中查看到有用的信息</li><li>确保区域文件的属主为‘named’</li><li>确保DNS服务器的IP地址是/etc/resolv.conf中的第一条目</li><li>如果你使用example.tst作为实验环境，确保将服务器从互联网断开，因为example.tst是一个不存在的域。</li></ol><p>最后小结，该教程关注的是实验环境中配置example.tst域用作为演示。请注意，该教程中创建了一台公共DNS服务器，此服务器会回应来自任何源IP地址的查询。如果你是在配置DNS生产服务器，请确保检查与公共DNS相关的策略。其它教程涵盖了<a href=http://linux.cn/article-3093-1.html>创建从DNS服务器</a>, <a href=http://xmodulo.com/2014/04/close-open-dns-resolver.html>限制对DNS服务器的访问</a>以及部署DNSSEC。</p><p>希望此教程对您有所帮助。</p><hr><p>via: <a href=http://xmodulo.com/2014/04/primary-dns-server-using-centos.html>http://xmodulo.com/2014/04/primary-dns-server-using-centos.html</a></p><p>译者：<a href=https://github.com/GOLinux>GOLinux</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创翻译，<a href=http://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/dns/ rel=tag>DNS</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>