<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>这儿几个字节，那里几个字节，我们说的是真正的内存 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="这儿几个字节，那里几个字节，我们说的是真正的内存"><meta property="og:description" content="今天的帖子来自于最近的 Go 语言的一次小测试"><meta property="og:type" content="article"><meta property="og:url" content="/article-16381-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-11-15T15:48:58+00:00"><meta property="article:modified_time" content="2023-11-15T15:48:58+00:00"><meta itemprop=name content="这儿几个字节，那里几个字节，我们说的是真正的内存"><meta itemprop=description content="今天的帖子来自于最近的 Go 语言的一次小测试"><meta itemprop=datePublished content="2023-11-15T15:48:58+00:00"><meta itemprop=dateModified content="2023-11-15T15:48:58+00:00"><meta itemprop=wordCount content="464"><meta itemprop=keywords content="Go,内存,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>这儿几个字节，那里几个字节，我们说的是真正的内存</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2023-11-15T15:48:58Z>November 15, 2023</time></div></div></header><div class="content post__content clearfix"><p><img src=https://img.linux.net.cn/data/attachment/album/202311/15/154636bhoqwdrdxczdhzxg.png alt></p><p>今天的帖子来自于最近的 Go 语言的一次小测试，观察下面的测试基础片段 [1] ：</p><pre tabindex=0><code>func BenchmarkSortStrings(b *testing.B) {
        s := []string{&#34;heart&#34;, &#34;lungs&#34;, &#34;brain&#34;, &#34;kidneys&#34;, &#34;pancreas&#34;}
        b.ReportAllocs()
        for i := 0; i &lt; b.N; i++ {
                sort.Strings(s)
        }
}
</code></pre><p><code>sort.Strings</code> 是 <code>sort.StringSlice(s)</code> 的便捷包装器，<code>sort.Strings</code> 在原地对输入进行排序，因此不会分配内存（或至少 43% 回答此问题的 Twitter 用户是这么认为的）。然而，至少在 Go 的最近版本中，基准测试的每次迭代都会导致一次堆分配。为什么会是这种情况？</p><p>正如所有 Go 程序员应该知道的那样，接口是以 <a href=https://research.swtch.com/interfaces>双词结构</a> 实现的。每个接口值包含一个字段，其中保存接口内容的类型，以及指向接口内容的指针。 [2]</p><p>在 Go 语言伪代码中，一个接口可能是这样的：</p><pre tabindex=0><code>type interface struct {
        // the ordinal number for the type of the value
        // assigned to the interface 
        type uintptr

        // (usually) a pointer to the value assigned to
        // the interface
        data uintptr
}
</code></pre><p><code>interface.data</code> 可以容纳一个机器字（在大多数情况下为 8 个字节），但一个 <code>[]string</code> 却需要 24 个字节：一个字用于指向切片的底层数组；一个字用于存储切片的长度；另一个字用于存储底层数组的剩余容量。那么，Go 是如何将 24 个字节装入个 8 个字节的呢？通过编程中最古老的技巧，即间接引用。一个 <code>[]string</code>，即 <code>s</code>，需要 24 个字节；但 <code>*[]string</code> —— 即指向字符串切片的指针，只需要 8 个字节。</p><h3 id=逃逸到堆>逃逸到堆</h3><p>为了让示例更加明确，以下是重新编写的基准测试，不使用 <code>sort.Strings</code> 辅助函数：</p><pre tabindex=0><code>func BenchmarkSortStrings(b *testing.B) {
        s := []string{&#34;heart&#34;, &#34;lungs&#34;, &#34;brain&#34;, &#34;kidneys&#34;, &#34;pancreas&#34;}
        b.ReportAllocs()
        for i := 0; i &lt; b.N; i++ {
                var ss sort.StringSlice = s
                var si sort.Interface = ss // allocation
                sort.Sort(si)
        }
}
</code></pre><p>为了让接口正常运行，编译器将赋值重写为 <code>var si sort.Interface = &amp;ss</code>，即 <code>ss</code> 的地址分配给接口值。 [3] 我们现在有这么一种情况：出现一个持有指向 <code>ss</code> 的指针的接口值。它指向哪里？还有 <code>ss</code> 存储在哪个内存位置？</p><p>似乎 <code>ss</code> 被移动到了堆上，这也同时导致了基准测试报告中的分配：</p><pre tabindex=0><code>Total:    296.01MB   296.01MB (flat, cum) 99.66%
      8            .          .           func BenchmarkSortStrings(b *testing.B) { 
      9            .          .           	s := []string{&#34;heart&#34;, &#34;lungs&#34;, &#34;brain&#34;, &#34;kidneys&#34;, &#34;pancreas&#34;} 
     10            .          .           	b.ReportAllocs() 
     11            .          .           	for i := 0; i &lt; b.N; i++ { 
     12            .          .           		var ss sort.StringSlice = s 
     13     296.01MB   296.01MB           		var si sort.Interface = ss // allocation 
     14            .          .           		sort.Sort(si) 
     15            .          .           	} 
     16            .          .           } 
</code></pre><p>发生这种分配是因为编译器当前无法确认 <code>ss</code> 比 <code>si</code> 生存期更长。Go 编译器开发人员对此的普遍态度是，觉得 <a href=https://github.com/golang/go/issues/23676>这个问题改进的余地</a>，不过我们另找时间再议。事实上，<code>ss</code> 就是被分配到了堆上。因此，问题变成了：每次迭代会分配多少个字节？为什么不去询问 <code>testing</code> 包呢？</p><pre tabindex=0><code>% go test -bench=. sort_test.go
goos: darwin
goarch: amd64
cpu: Intel(R) Core(TM) i7-5650U CPU @ 2.20GHz
BenchmarkSortStrings-4          12591951                91.36 ns/op           24 B/op          1 allocs/op
PASS
ok      command-line-arguments  1.260s
</code></pre><p>可以看到，在 amd 64 平台的 Go 1.16 beta1 版本上，每次操作会分配 24 字节。 [4] 然而，在同一平台先前的 Go 版本中，每次操作则消耗了 32 字节。</p><pre tabindex=0><code>% go1.15 test -bench=. sort_test.go
goos: darwin
goarch: amd64
BenchmarkSortStrings-4          11453016                96.4 ns/op            32 B/op          1 allocs/op
PASS
ok      command-line-arguments  1.225s
</code></pre><p>这引出了本文的主题，即 Go 1.16 版本中即将推出的一项便利改进。不过在讨论这个内容之前，我需要聊聊 “ 尺寸类别 size class ”。</p><h3 id=尺寸类别>尺寸类别</h3><p>在解释什么是 “ 尺寸类别 size class ” 之前，我们先考虑个问题，理论上的 Go 语言在运行时是如何在其堆上分配 24 字节的。有一个简单的方法：追踪目前为止已分配到的所有内存的动向——利用指向堆上最后分配的字节的指针。分配 24 字节，堆指针就会增加 24，然后将前一个值返回给调用函数。只要写入的请求 24 字节的代码不超出该标记的范围，这种机制就没有额外开销。不过，现实情况下，内存分配器不仅要分配内存，有时还得释放内存。</p><p>最终，Go 语言程序在运行时将释放这些 24 字节，但从运行的视角来看，它只知道它给调用者的开始地址。它不知道从该地址起始之后又分配了多少字节。为了允许释放内存，我们假设的 Go 语言程序运行时分配器必须记录堆上每个分配的长度值。那么这些长度值的分配存储在何处？当然是在堆上。</p><p>在我们的设想中，当程序运行需要分配内存的时候，它可以请求稍微多一点，并把它用来存储请求的数量。而对于我们的切片示例而言，当我们请求 24 字节时，实际上会消耗 24 字节加上存储数字 <code>24</code> 的一些开销。这些开销有多大？事实上，实际上的最小开销量是一个字。 [5]</p><p>用来记录 24 字节分配的开销将是 8 字节。25% 不是很大，但也不算糟糕，随着分配的大小增加，开销将变得微不足道。然而，如果我们只想在堆上存储一个字节，会发生什么？开销将是请求数据量的 8 倍！是否有一种更高效的方式在堆上分配少量内存？</p><p>与其在每个分配旁边存储长度，不如将相同大小的内容存储在一起，这个主意如何？如果所有的 24 字节的内容都存储在一起，那么运行时会自动获取它们的大小。运行时所需要的是一个单一的位，指示 24 字节区域是否在使用中。在 Go 语言中，这些区域被称为 Size Classes，因为相同大小的所有内容都会存储在一起（类似学校班级，所有学生都按同一年级分班，而不是 C++ 中的类）。当运行时需要分配少量内存时，它会使用能够容纳该分配的最小的尺寸类别。</p><h3 id=无限制的尺寸类别>无限制的尺寸类别</h3><p>现在我们知道尺寸类别是如何工作的了，那么问题又来了，它们存储在哪里？和我们想的一样，尺寸类别的内存来自堆。为了最小化开销，运行时会从堆上分配较大的内存块（通常是系统页面大小的倍数），然后将该空间用于单个大小的分配。不过，这里存在一个问题————</p><p>将大块区域用于存储同一大小的事物的模式很好用 [6] ，如果分配大小的数量是固定的，最好是少数几个。那么在通用语言中，程序可以要求运行时以任何大小分配内存 [7] 。</p><p>例如，想象一下向运行时请求 9 字节。9 字节是一个不常见的大小，因此可能需要一个新的尺寸类别来存储 9 字节大小的物品。因为 9 字节大小的物品不常见，所以分配的其余部分（通常为 4KB 或更多）可能会被浪费。由于尺寸类别的集合是固定的，如果没有精确匹配的 size class 可用，分配将并入到下一个尺寸类别。在我们的示例中，9 字节可能会在 12 字节的尺寸类别中分配。未使用的 3 字节的开销要比几乎未使用的整个尺寸类别分配好。</p><h3 id=总结一下>总结一下</h3><p>这是谜题的最后一块拼图。Go 1.15 版本没有 24 字节的尺寸类别，因此 <code>ss</code> 的堆分配是在 32 字节的尺寸类别中分配的。由于 Martin Möhrmann 的工作，Go 1.16 版本有一个 24 字节的尺寸类别，非常适合分配给接口的切片值。</p><h3 id=相关文章>相关文章</h3><ol><li><a href=https://dave.cheney.net/2017/08/23/im-talking-about-go-at-devfest-siberia-2017>我在 Devfest 2017年西伯利亚大会谈 Go 语言</a></li><li><a href=https://dave.cheney.net/2018/01/06/if-aligned-memory-writes-are-atomic-why-do-we-need-the-sync-atomic-package>如果对齐的内存写操作是原子性的，为什么我们还需要 sync/atomic 包呢？</a></li><li><a href=https://dave.cheney.net/2014/01/05/a-real-serial-console-for-your-raspberry-pi>为你的树莓派创建一个真实的串行控制台</a></li><li><a href=https://dave.cheney.net/2013/06/02/why-is-a-goroutines-stack-infinite>为什么 Go 语言线程的栈是无限制的？</a></li></ol><p><em>（题图：MJ/01d5fe46-778f-48fe-9481-162f4d0289dc）</em></p><hr><ol><li>这不是正确的对排序函数进行基准测试的方式，因为在第一次迭代之后，输入已经排序。但这又是另外一个话题了。 <a href=#fnref1>↩︎</a></li><li>此语句的准确性取决于所使用的 Go 版本。例如，Go 1.15 版本添加了直接将一些 <a href=https://golang.org/doc/go1.15#runtime>整数存储在接口值</a> 中的功能，从而节省了分配和间接性。然而，对于大多数值来说，如果它不是指针类型，它的地址将被取出并存储在接口值中。 <a href=#fnref2>↩︎</a></li><li>编译器在接口值的类型字段中跟踪了这种手法，因此它记住了分配给 <code>si</code> 的类型是 <code>sort.StringSlice</code> 而不是 <code>*sort.StringSlice</code>。 <a href=#fnref3>↩︎</a></li><li>在 32 位平台上，这个数字减半，<a href=https://www.tallengestore.com/products/i-never-look-back-darling-it-distracts-from-the-now-edna-mode-inspirational-quote-tallenge-motivational-poster-collection-large-art-prints>但我们不再关注它</a>。 <a href=#fnref4>↩︎</a></li><li>如果你准备限制分配为 4G 或者可能是 64KB，你可以使用较少内存来存储分配的尺寸，但实际上使用小于一个字来存储长度标头的节省会受到填充的影响。 <a href=#fnref5>↩︎</a></li><li>将相同大小的物品存储在一起也是一种有效的对抗碎片化的策略。 <a href=#fnref6>↩︎</a></li><li>这并不是一个不切实际的设想，字符串有各种形状和大小，生成以前未见过的大小的字符串可能就像附加空格一样简单。 <a href=#fnref7>↩︎</a></li></ol><hr><p>via: <a href=https://dave.cheney.net/2021/01/05/a-few-bytes-here-a-few-there-pretty-soon-youre-talking-real-memory>https://dave.cheney.net/2021/01/05/a-few-bytes-here-a-few-there-pretty-soon-youre-talking-real-memory</a></p><p>作者：<a href=https://dave.cheney.net/>Dave Cheney</a> 选题：<a href=https://github.com/lujun9972>lujun9972</a> 译者：<a href=https://github.com/Drwhooooo>Drwhooooo</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/go/ rel=tag>Go</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E5%86%85%E5%AD%98/ rel=tag>内存</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>