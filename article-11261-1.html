<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Podman：一个更安全的运行容器的方式 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="Podman：一个更安全的运行容器的方式"><meta property="og:description" content="Podman 使用传统的 fork/exec 模型（相对于客户端/服务器模型）来运行容器。"><meta property="og:type" content="article"><meta property="og:url" content="/article-11261-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-08-23T23:50:08+00:00"><meta property="article:modified_time" content="2019-08-23T23:50:08+00:00"><meta itemprop=name content="Podman：一个更安全的运行容器的方式"><meta itemprop=description content="Podman 使用传统的 fork/exec 模型（相对于客户端/服务器模型）来运行容器。"><meta itemprop=datePublished content="2019-08-23T23:50:08+00:00"><meta itemprop=dateModified content="2019-08-23T23:50:08+00:00"><meta itemprop=wordCount content="356"><meta itemprop=keywords content="Podman,容器,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>Podman：一个更安全的运行容器的方式</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2019-08-23T23:50:08Z>August 23, 2019</time></div></div></header><div class="content post__content clearfix"><blockquote><p>Podman 使用传统的 fork/exec 模型（相对于客户端/服务器模型）来运行容器。</p></blockquote><p><img src=/data/attachment/album/201908/23/234924m55sn8zt3b5q8815.jpg alt></p><p>在进入本文的主要主题 <a href=https://podman.io>Podman</a> 和容器之前，我需要了解一点 Linux 审计功能的技术。</p><h3 id=什么是审计>什么是审计？</h3><p>Linux 内核有一个有趣的安全功能，叫做<strong>审计</strong>。它允许管理员在系统上监视安全事件，并将它们记录到<code>audit.log</code> 中，该文件可以本地存储或远程存储在另一台机器上，以防止黑客试图掩盖他的踪迹。</p><p><code>/etc/shadow</code> 文件是一个经常要监控的安全文件，因为向其添加记录可能允许攻击者获得对系统的访问权限。管理员想知道是否有任何进程修改了该文件，你可以通过执行以下命令来执行此操作：</p><pre tabindex=0><code># auditctl -w /etc/shadow
</code></pre><p>现在让我们看看当我修改了 <code>/etc/shadow</code> 文件会发生什么：</p><pre tabindex=0><code># touch /etc/shadow 
# ausearch -f /etc/shadow -i -ts recent

type=PROCTITLE msg=audit(10/10/2018 09:46:03.042:4108) : proctitle=touch /etc/shadow type=SYSCALL msg=audit(10/10/2018 09:46:03.042:4108) : arch=x86_64 syscall=openat success=yes exit=3 a0=0xffffff9c a1=0x7ffdb17f6704 a2=O_WRONLY|O_CREAT|O_NOCTTY| O_NONBLOCK a3=0x1b6 items=2 ppid=2712 pid=3727 auid=dwalsh uid=root gid=root euid=root suid=root fsuid=root egid=root sgid=root fsgid=root tty=pts1 ses=3 comm=touch exe=/usr/bin/touch subj=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 key=(null)`
</code></pre><p>审计记录中有很多信息，但我重点注意到它记录了 root 修改了 <code>/etc/shadow</code> 文件，并且该进程的审计 UID（<code>auid</code>）的所有者是 <code>dwalsh</code>。</p><p>内核修改了这个文件了么？</p><h4 id=跟踪登录-uid>跟踪登录 UID</h4><p>登录 UID（<code>loginuid</code>），存储在 <code>/proc/self/loginuid</code> 中，它是系统上每个进程的 proc 结构的一部分。该字段只能设置一次；设置后，内核将不允许任何进程重置它。</p><p>当我登录系统时，登录程序会为我的登录过程设置 <code>loginuid</code> 字段。</p><p>我（<code>dwalsh</code>）的 UID 是 3267。</p><pre tabindex=0><code>$ cat /proc/self/loginuid
3267
</code></pre><p>现在，即使我变成了 root，我的登录 UID 仍将保持不变。</p><pre tabindex=0><code>$ sudo cat /proc/self/loginuid
3267
</code></pre><p>请注意，从初始登录过程 fork 并 exec 的每个进程都会自动继承 <code>loginuid</code>。这就是内核知道登录的人是 <code>dwalsh</code> 的方式。</p><h3 id=容器>容器</h3><p>现在让我们来看看容器。</p><pre tabindex=0><code>sudo podman run fedora cat /proc/self/loginuid
3267
</code></pre><p>甚至容器进程也保留了我的 <code>loginuid</code>。 现在让我们用 Docker 试试。</p><pre tabindex=0><code>sudo docker run fedora cat /proc/self/loginuid 
4294967295
</code></pre><h3 id=为什么不一样>为什么不一样？</h3><p>Podman 对于容器使用传统的 fork/exec 模型，因此容器进程是 Podman 进程的后代。Docker 使用客户端/服务器模型。我执行的 <code>docker</code> 命令是 Docker 客户端工具，它通过客户端/服务器操作与 Docker 守护进程通信。然后 Docker 守护程序创建容器并处理 stdin/stdout 与 Docker 客户端工具的通信。</p><p>进程的默认 <code>loginuid</code>（在设置 <code>loginuid</code> 之前）是 <code>4294967295</code>（LCTT 译注：2 32 - 1）。由于容器是 Docker 守护程序的后代，而 Docker 守护程序是 init 系统的子代，所以，我们看到 systemd、Docker 守护程序和容器进程全部具有相同的 <code>loginuid</code>：<code>4294967295</code>，审计系统视其为未设置审计 UID。</p><pre tabindex=0><code>cat /proc/1/loginuid 
4294967295
</code></pre><h3 id=怎么会被滥用>怎么会被滥用？</h3><p>让我们来看看如果 Docker 启动的容器进程修改 <code>/etc/shadow</code> 文件会发生什么。</p><pre tabindex=0><code>$ sudo docker run --privileged -v /:/host fedora touch /host/etc/shadow 
$ sudo ausearch -f /etc/shadow -i type=PROCTITLE msg=audit(10/10/2018 10:27:20.055:4569) : proctitle=/usr/bin/coreutils --coreutils-prog-shebang=touch /usr/bin/touch /host/etc/shadow type=SYSCALL msg=audit(10/10/2018 10:27:20.055:4569) : arch=x86_64 syscall=openat success=yes exit=3 a0=0xffffff9c a1=0x7ffdb6973f50 a2=O_WRONLY|O_CREAT|O_NOCTTY| O_NONBLOCK a3=0x1b6 items=2 ppid=11863 pid=11882 auid=unset uid=root gid=root euid=root suid=root fsuid=root egid=root sgid=root fsgid=root tty=(none) ses=unset comm=touch exe=/usr/bin/coreutils subj=system_u:system_r:spc_t:s0 key=(null)
</code></pre><p>在 Docker 情形中，<code>auid</code> 是未设置的（<code>4294967295</code>）；这意味着安全人员可能知道有进程修改了 <code>/etc/shadow</code> 文件但身份丢失了。</p><p>如果该攻击者随后删除了 Docker 容器，那么在系统上谁修改 <code>/etc/shadow</code> 文件将没有任何跟踪信息。</p><p>现在让我们看看相同的场景在 Podman 下的情况。</p><pre tabindex=0><code>$ sudo podman run --privileged -v /:/host fedora touch /host/etc/shadow 
$ sudo ausearch -f /etc/shadow -i type=PROCTITLE msg=audit(10/10/2018 10:23:41.659:4530) : proctitle=/usr/bin/coreutils --coreutils-prog-shebang=touch /usr/bin/touch /host/etc/shadow type=SYSCALL msg=audit(10/10/2018 10:23:41.659:4530) : arch=x86_64 syscall=openat success=yes exit=3 a0=0xffffff9c a1=0x7fffdffd0f34 a2=O_WRONLY|O_CREAT|O_NOCTTY| O_NONBLOCK a3=0x1b6 items=2 ppid=11671 pid=11683 auid=dwalsh uid=root gid=root euid=root suid=root fsuid=root egid=root sgid=root fsgid=root tty=(none) ses=3 comm=touch exe=/usr/bin/coreutils subj=unconfined_u:system_r:spc_t:s0 key=(null)
</code></pre><p>由于它使用传统的 fork/exec 方式，因此 Podman 正确记录了所有内容。</p><p>这只是观察 <code>/etc/shadow</code> 文件的一个简单示例，但审计系统对于观察系统上的进程非常有用。使用 fork/exec 容器运行时（而不是客户端/服务器容器运行时）来启动容器允许你通过审计日志记录保持更好的安全性。</p><h3 id=最后的想法>最后的想法</h3><p>在启动容器时，与客户端/服务器模型相比，fork/exec 模型还有许多其他不错的功能。例如，systemd 功能包括：</p><ul><li><code>SD_NOTIFY</code>：如果将 Podman 命令放入 systemd 单元文件中，容器进程可以通过 Podman 返回通知，表明服务已准备好接收任务。这是在客户端/服务器模式下无法完成的事情。</li><li>套接字激活：你可以将连接的套接字从 systemd 传递到 Podman，并传递到容器进程以便使用它们。这在客户端/服务器模型中是不可能的。</li></ul><p>在我看来，其最好的功能是<strong>作为非 root 用户运行 Podman 和容器</strong>。这意味着你永远不会在宿主机上授予用户 root 权限，而在客户端/服务器模型中（如 Docker 使用的），你必须打开以 root 身份运行的特权守护程序的套接字来启动容器。在那里，你将受到守护程序中实现的安全机制与宿主机操作系统中实现的安全机制的支配 —— 这是一个危险的主张。</p><hr><p>via: <a href=https://opensource.com/article/18/10/podman-more-secure-way-run-containers>https://opensource.com/article/18/10/podman-more-secure-way-run-containers</a></p><p>作者：<a href=https://opensource.com/users/rhatdan>Daniel J Walsh</a> 选题：<a href=https://github.com/lujun9972>lujun9972</a> 译者：<a href=https://github.com/wxy>wxy</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/podman/ rel=tag>Podman</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E5%AE%B9%E5%99%A8/ rel=tag>容器</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>