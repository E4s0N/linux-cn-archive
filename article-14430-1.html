<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Python 内存数据库 CyberDB 使用实例 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="Python 内存数据库 CyberDB 使用实例"><meta property="og:description" content="CyberDB，一个基于 Python 字典和列表的内存数据库。"><meta property="og:type" content="article"><meta property="og:url" content="/article-14430-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-04-04T12:55:00+00:00"><meta property="article:modified_time" content="2022-04-04T12:55:00+00:00"><meta itemprop=name content="Python 内存数据库 CyberDB 使用实例"><meta itemprop=description content="CyberDB，一个基于 Python 字典和列表的内存数据库。"><meta itemprop=datePublished content="2022-04-04T12:55:00+00:00"><meta itemprop=dateModified content="2022-04-04T12:55:00+00:00"><meta itemprop=wordCount content="439"><meta itemprop=keywords content="Python,内存数据库,CyberDB,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>Python 内存数据库 CyberDB 使用实例</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2022-04-04T12:55:00Z>April 04, 2022</time></div></div></header><div class="content post__content clearfix"><blockquote><p>CyberDB，一个基于 Python 字典和列表的内存数据库。</p></blockquote><p><img src=/data/attachment/album/202204/04/125600vvprv1d98vffbfrv.jpg alt></p><h3 id=概括>概括</h3><p>CyberDB 是一个轻量级的 Python 内存数据库。它旨在利用 Python 内置数据结构字典、列表作数据存储，通过 TCP 套接字高效通信，并提供了数据持久化。该数据库的亮点在于它使用了 Pythonic 的方式编程，你可以像使用字典和列表一样使用 CyberDB。</p><p>现在我们把 CyberDB 带到能发挥其作用的地方，在生产环境中将 CyberDB 作为 Flask 的内存数据库，使用 Gunicorn 运行，并实现多进程间的通信。</p><p>这篇文章通过一个尽可能精简的 Flask 实例讲解，不会涉及复杂的 Web 知识。核心思路为 CyberDB + Gunicorn + Gevent + Flask（多进程 + 协程），启动一个 CyberDB 服务器，使用 Gunicorn 多进程运行 Flask 实例，每个进程的实例通过 Gevent 运行，进程中使用 CyberDB 客户端连接至内存数据库，由此实现对 CyberDB 数据库的高并发访问。</p><h3 id=源码解析>源码解析</h3><p>文章使用 PyPy 运行，同样适用 CPython。</p><p>运行环境: Debian 10, Python 3.8.12, PyPy 7.3.7</p><p>此项目的目录结构</p><pre tabindex=0><code>.
├── app.py
├── cyberdb_init.py
├── cyberdb_serve.py
├── requirements.txt
└── venv
</code></pre><p>我们通过列举每个文件的内容顺序讲解 CyberDB 的核心操作。</p><h4 id=文件-requirementstxt>文件 requirements.txt</h4><pre tabindex=0><code>CyberDB&gt;=0.7.1
Flask==2.1.1
gevent==21.12.0
gunicorn==20.1.0
</code></pre><p>这是此项目的依赖。这篇文章不是 Python 基础教程，如果你不清楚，请查询相关文档创建虚拟环境 <code>venv</code> 目录并安装 <code>requirements.txt</code> 中的依赖。</p><p>生成 <code>venv</code> 目录并安装好依赖后，下面所有操作都在激活的虚拟环境中运行。</p><h4 id=文件-cyberdb_initpy>文件 cyberdb_init.py</h4><p>功能：初始化 CyberDB 的表结构，只在第一次运行时使用，后续不再使用。</p><pre tabindex=0><code>import time

import cyberdb

db = cyberdb.Server()
# 配置 CyberDB 服务端的 地址、端口、密码。
db.start(host=&#39;127.0.0.1&#39;, port=9980, password=&#39;123456&#39;)

# 待服务端启动后，连接 CyberDB 服务端。
time.sleep(3)
client = cyberdb.connect(host=&#39;127.0.0.1&#39;, port=9980, password=&#39;123456&#39;)
# 生成 proxy 对象。
with client.get_proxy() as proxy:
    # 创建类型为 CyberDict 的表 centre，并初始化内容。
    proxy.create_cyberdict(&#39;centre&#39;)
    centre = proxy.get_cyberdict(&#39;centre&#39;)
    centre[&#39;content&#39;] = &#39;Hello CyberDB!&#39;

# 将 CyberDB 保存至 data.cdb 。
db.save_db(&#39;data.cdb&#39;)
</code></pre><p>在项目根目录执行</p><pre tabindex=0><code>python cyberdb_init.py
</code></pre><p>以完成 CyberDB 数据库表的初始化。</p><p>它会在 CyberDB 中创建了一个名为 <code>centre</code>、类型为 <code>CyberDict</code> 的表；初始化 <code>content</code> 键的值为 <code>Hello CyberDB!</code>；最后将 CyberDB 数据库保存至硬盘（在项目根目录生成了名为 <code>data.cdb</code> 的文件）。</p><h4 id=文件-cyberdb_servepy>文件 cyberdb_serve.py</h4><p>功能：运行 CyberDB 服务端。</p><pre tabindex=0><code>import cyberdb

def main():
    # 后台运行 CyberDB 服务端，设置相关信息。
    db = cyberdb.Server()
    # 从硬盘读取 data.cdb 至 CyberDB。
    db.load_db(&#39;data.cdb&#39;)
    # 每 300 秒备份一次数据库。
    db.set_backup(&#39;data.cdb&#39;, cycle=300)
    db.run(
        host=&#39;127.0.0.1&#39;, # TCP 运行地址
        port=9980, # TCP 监听端口
        password=&#39;hWjYvVdqRC&#39;, # 数据库连接密码
        max_con=10000, # 最大并发数
        encrypt=True, # 加密通信
        print_log=False # 不打印日志
    )


if __name__ == &#39;__main__&#39;:
    main()
</code></pre><p>在项目根目录执行</p><pre tabindex=0><code>python cyberdb_serve.py
</code></pre><p>以运行 CyberDB 服务端。</p><p>此处设置了 <code>encrypt=True</code> ，CyberDB 会将 TCP 通信内容使用 AES-256 算法加密。开启 <code>encrypt=True</code> 后，CyberDB 仅允许白名单中的 IP 通信，默认白名单为 <code>['127.0.0.1']</code>（查看白名单 <a href=https://www.cyberlight.xyz/static/cyberdb-chn/API/#cyberdbserver>设置方法</a>）。一般，若只需在本地进程间通信，无需开启 <code>encrypt=True</code> 和设置白名单，只有远程通信时需要此操作。</p><h4 id=文件-apppyhttpapppy>文件 <a href=http://app.py>app.py</a></h4><p>功能：运行 Flask 实例和 CyberDB 客户端。</p><pre tabindex=0><code>import cyberdb
from flask import Flask, g

# 连接 CyberDB 并生成客户端实例。
client = cyberdb.connect(
    host=&#39;127.0.0.1&#39;, 
    port=9980, 
    password=&#39;hWjYvVdqRC&#39;,
    # 服务端若加密，客户端必须加密，反之亦然。
    encrypt=True,
    # 每个连接若超过900秒无操作，将舍弃该连接。
    # 连接由连接池智能管理，无需关注细节。
    time_out=900
)

# 创建 Flask 实例，此部分请参考 
# Flask 文档 https://flask.palletsprojects.com/
app = Flask(__name__)

@app.before_request
def before_request():
    # 每次请求执行前生成 proxy 对象。
    g.proxy = client.get_proxy()
    # 从连接池获取连接。
    g.proxy.connect()

@app.get(&#34;/&#34;)
def hello_world():
    # 从数据库获取 centre 表。
    centre = g.proxy.get_cyberdict(&#39;centre&#39;)
    
    return {
        &#39;code&#39;: 1,
        &#39;content&#39;: centre[&#39;content&#39;]
    }

@app.teardown_request
def teardown_request(error):
    # 每次请求执行后归还连接至连接池。
    g.proxy.close()

if __name__ == &#39;__main__&#39;:
    app.run(host=&#39;127.0.0.1&#39;, port=8000)
</code></pre><p>该模块会在每次请求执行前（<code>before_request()</code>）使用 <code>client.get_proxy()</code> 获取 <code>proxy</code> 对象，每个获取的 <code>proxy</code> 对象可以绑定一个 TCP 连接，此处使用 <code>proxy.connect()</code> 从连接池获取连接。视图函数 <code>hello_world()</code> 中，由 <code>proxy</code> 获取的对象 <code>centre</code>，与 <code>proxy</code> 共用同一个连接，<code>proxy</code> 的连接释放后，<code>centre</code> 也会失去连接。在每次请求后（<code>teardown_request()</code>）使用 <code>proxy.close()</code> 方法释放 <code>proxy</code> 绑定的连接，归还至连接池。</p><p><code>cyberdb.connect</code> 的 <code>time_out</code> 参数表示连接池中每个连接的超时时间，此处每个连接超过 900 秒无操作将被舍弃。若不设置该参数，连接池的每个连接会维持到失效为止。</p><h4 id=使用-gunicorn-运行-flask-实例>使用 Gunicorn 运行 Flask 实例</h4><p>Gunicorn 是一个用于 UNIX 的 Python WSGI HTTP 服务器，通常在生产环境使用，可以利用多核 CPU 。</p><p>Gevent 是一个基于协程的 Python 网络库。Gevent 会更改 CyberDB 客户端的底层套接字通信，使之支持协程。</p><p>在项目根目录运行</p><pre tabindex=0><code>gunicorn -w 4 -b 127.0.0.1:8000 -k gevent app:app
</code></pre><p>使用 4 进程、Gevent 启动 Flask 实例。</p><p>浏览器访问 <code>127.0.0.1:8000</code> ，得到如下响应：</p><pre tabindex=0><code>{&#34;code&#34;:1,&#34;content&#34;:&#34;Hello CyberDB!&#34;}
</code></pre><h3 id=参考信息>参考信息</h3><p>CyberDB 源码: <a href=https://github.com/Cyberbolt/CyberDB>https://github.com/Cyberbolt/CyberDB</a></p><h3 id=总结>总结</h3><p>通过此例，你可以把 CyberDB 部署到更复杂的 Web 环境中，充分享受内存的低延迟特性。CyberDB 的核心是以 Pythonic 的方式编程，你可以在任何 Python 代码中将 CyberDB 作为内存数据库。</p><hr><p>作者简介：</p><p>Cyberbolt：一个自由的 Python 开发者。</p><hr><p>via: <a href=https://www.cyberlight.xyz/static/cyberdb-chn/tutorial/flask/>https://www.cyberlight.xyz/static/cyberdb-chn/tutorial/flask/</a></p><p>作者：<a href=https://www.zhihu.com/people/cyberbolt>Cyberbolt</a> 编辑：<a href=https://github.com/wxy>wxy</a></p><p>本文由贡献者投稿至 <a href=https://github.com/LCTT/Articles/>Linux 中国公开投稿计划</a>，采用 <a href=https://creativecommons.org/licenses/by-sa/4.0/deed.zh>CC-BY-SA 协议</a> 发布，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/python/ rel=tag>Python</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93/ rel=tag>内存数据库</a></li><li class=tags__item><a class="tags__link btn" href=/tags/cyberdb/ rel=tag>CyberDB</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>