<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Caffeinated 6.828：实验工具指南 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="Caffeinated 6.828：实验工具指南"><meta property="og:description" content="本文将为你简单概述一下 JOS 环境和非常有用的 GDB 和 QEMU 命令。"><meta property="og:type" content="article"><meta property="og:url" content="/article-10273-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-11-25T12:02:04+00:00"><meta property="article:modified_time" content="2018-11-25T12:02:04+00:00"><meta itemprop=name content="Caffeinated 6.828：实验工具指南"><meta itemprop=description content="本文将为你简单概述一下 JOS 环境和非常有用的 GDB 和 QEMU 命令。"><meta itemprop=datePublished content="2018-11-25T12:02:04+00:00"><meta itemprop=dateModified content="2018-11-25T12:02:04+00:00"><meta itemprop=wordCount content="572"><meta itemprop=keywords content="GDB,6.828,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>Caffeinated 6.828：实验工具指南</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2018-11-25T12:02:04Z>November 25, 2018</time></div></div></header><div class="content post__content clearfix"><p><img src=/data/attachment/album/201811/25/115935paqa0dqwtg5o5o7j.jpg alt></p><p>熟悉你的环境对高效率的开发和调试来说是至关重要的。本文将为你简单概述一下 JOS 环境和非常有用的 GDB 和 QEMU 命令。话虽如此，但你仍然应该去阅读 GDB 和 QEMU 手册，来理解这些强大的工具如何使用。</p><h3 id=调试小贴士>调试小贴士</h3><h4 id=内核>内核</h4><p>GDB 是你的朋友。使用 <code>qemu-gdb target</code>（或它的变体 <code>qemu-gdb-nox</code>）使 QEMU 等待 GDB 去绑定。下面在调试内核时用到的一些命令，可以去查看 GDB 的资料。</p><p>如果你遭遇意外的中断、异常、或三重故障，你可以使用 <code>-d</code> 参数要求 QEMU 去产生一个详细的中断日志。</p><p>调试虚拟内存问题时，尝试 QEMU 的监视命令 <code>info mem</code>（提供内存高级概述）或 <code>info pg</code>（提供更多细节内容）。注意，这些命令仅显示<strong>当前</strong>页表。</p><p>（在实验 4 以后）去调试多个 CPU 时，使用 GDB 的线程相关命令，比如 <code>thread</code> 和 <code>info threads</code>。</p><h4 id=用户环境在实验-3-以后>用户环境（在实验 3 以后）</h4><p>GDB 也可以去调试用户环境，但是有些事情需要注意，因为 GDB 无法区分开多个用户环境或区分开用户环境与内核环境。</p><p>你可以使用 <code>make run-name</code>（或编辑 <code>kern/init.c</code> 目录）来指定 JOS 启动的用户环境，为使 QEMU 等待 GDB 去绑定，使用 <code>run-name-gdb</code> 的变体。</p><p>你可以符号化调试用户代码，就像调试内核代码一样，但是你要告诉 GDB，哪个符号表用到符号文件命令上，因为它一次仅能够使用一个符号表。提供的 <code>.gdbinit</code> 用于加载内核符号表 <code>obj/kern/kernel</code>。对于一个用户环境，这个符号表在它的 ELF 二进制文件中，因此你可以使用 <code>symbol-file obj/user/name</code> 去加载它。不要从任何 <code>.o</code> 文件中加载符号，因为它们不会被链接器迁移进去（库是静态链接进 JOS 用户二进制文件中的，因此这些符号已经包含在每个用户二进制文件中了）。确保你得到了正确的用户二进制文件；在不同的二进制文件中，库函数被链接为不同的 EIP，而 GDB 并不知道更多的内容！</p><p>（在实验 4 以后）因为 GDB 绑定了整个虚拟机，所以它可以将时钟中断看作为一种控制转移。这使得从底层上不可能实现步进用户代码，因为一个时钟中断无形中保证了片刻之后虚拟机可以再次运行。因此可以使用 <code>stepi</code> 命令，因为它阻止了中断，但它仅可以步进一个汇编指令。断点一般来说可以正常工作，但要注意，因为你可能在不同的环境（完全不同的一个二进制文件）上遇到同一个 EIP。</p><h3 id=参考>参考</h3><h4 id=jos-makefile>JOS makefile</h4><p>JOS 的 GNUmakefile 包含了在各种方式中运行的 JOS 的许多假目标。所有这些目标都配置 QEMU 去监听 GDB 连接（<code>*-gdb</code> 目标也等待这个连接）。要在运行中的 QEMU 上启动它，只需要在你的实验目录中简单地运行 <code>gdb</code> 即可。我们提供了一个 <code>.gdbinit</code> 文件，它可以在 QEMU 中自动指向到 GDB、加载内核符号文件、以及在 16 位和 32 位模式之间切换。退出 GDB 将关闭 QEMU。</p><ul><li><code>make qemu</code></li></ul><p>在一个新窗口中构建所有的东西并使用 VGA 控制台和你的终端中的串行控制台启动 QEMU。想退出时，既可以关闭 VGA 窗口，也可以在你的终端中按 <code>Ctrl-c</code> 或 <code>Ctrl-a x</code>。</p><ul><li><code>make qemu-nox</code></li></ul><p>和 <code>make qemu</code> 一样，但仅使用串行控制台来运行。想退出时，按下 <code>Ctrl-a x</code>。这种方式在通过 SSH 拨号连接到 Athena 上时非常有用，因为 VGA 窗口会占用许多带宽。</p><ul><li><code>make qemu-gdb</code></li></ul><p>和 <code>make qemu</code> 一样，但它与任意时间被动接受 GDB 不同，而是暂停第一个机器指令并等待一个 GDB 连接。</p><ul><li><code>make qemu-nox-gdb</code></li></ul><p>它是 <code>qemu-nox</code> 和 <code>qemu-gdb</code> 目标的组合。</p><ul><li><code>make run-nam</code></li></ul><p>（在实验 3 以后）运行用户程序 name。例如，<code>make run-hello</code> 运行 <code>user/hello.c</code>。</p><ul><li><code>make run-name-nox</code>,<code>run-name-gdb</code>, <code>run-name-gdb-nox</code></li></ul><p>（在实验 3 以后）与 <code>qemu</code> 目标变量对应的 <code>run-name</code> 的变体。</p><p>makefile 也接受几个非常有用的变量：</p><ul><li><code>make V=1 …</code></li></ul><p>详细模式。输出正在运行的每个命令，包括参数。</p><ul><li><code>make V=1 grade</code></li></ul><p>在评级测试失败后停止，并将 QEMU 的输出放入 <code>jos.out</code> 文件中以备检查。</p><ul><li><code>make QEMUEXTRA=' _args_ ' …</code></li></ul><p>指定传递给 QEMU 的额外参数。</p><h4 id=jos-obj>JOS obj/</h4><p>在构建 JOS 时，makefile 也产生一些额外的输出文件，这些文件在调试时非常有用：</p><ul><li><code>obj/boot/boot.asm</code>、<code>obj/kern/kernel.asm</code>、<code>obj/user/hello.asm</code>、等等。</li></ul><p>引导加载器、内核、和用户程序的汇编代码列表。</p><ul><li><code>obj/kern/kernel.sym</code>、<code>obj/user/hello.sym</code>、等等。</li></ul><p>内核和用户程序的符号表。</p><ul><li><code>obj/boot/boot.out</code>、<code>obj/kern/kernel</code>、<code>obj/user/hello</code>、等等。</li></ul><p>内核和用户程序链接的 ELF 镜像。它们包含了 GDB 用到的符号信息。</p><h4 id=gdb>GDB</h4><p>完整的 GDB 命令指南请查看 <a href=http://sourceware.org/gdb/current/onlinedocs/gdb/>GDB 手册</a>。下面是一些在 6.828 课程中非常有用的命令，它们中的一些在操作系统开发之外的领域几乎用不到。</p><ul><li><code>Ctrl-c</code></li></ul><p>在当前指令处停止机器并打断进入到 GDB。如果 QEMU 有多个虚拟的 CPU，所有的 CPU 都会停止。</p><ul><li><code>c</code>（或 <code>continue</code>）</li></ul><p>继续运行，直到下一个断点或 <code>Ctrl-c</code>。</p><ul><li><code>si</code>（或 <code>stepi</code>）</li></ul><p>运行一个机器指令。</p><ul><li><code>b function</code> 或 <code>b file:line</code>（或 <code>breakpoint</code>）</li></ul><p>在给定的函数或行上设置一个断点。</p><ul><li><code>b * addr</code>（或 <code>breakpoint</code>）</li></ul><p>在 EIP 的 addr 处设置一个断点。</p><ul><li><code>set print pretty</code></li></ul><p>启用数组和结构的美化输出。</p><ul><li><code>info registers</code></li></ul><p>输出通用寄存器 <code>eip</code>、<code>eflags</code>、和段选择器。更多更全的机器寄存器状态转储，查看 QEMU 自己的 <code>info registers</code> 命令。</p><ul><li><code>x/ N x addr</code></li></ul><p>以十六进制显示虚拟地址 addr 处开始的 N 个词的转储。如果 N 省略，默认为 1。addr 可以是任何表达式。</p><ul><li><code>x/ N i addr</code></li></ul><p>显示从 addr 处开始的 N 个汇编指令。使用 <code>$eip</code> 作为 addr 将显示当前指令指针寄存器中的指令。</p><ul><li><code>symbol-file file</code></li></ul><p>（在实验 3 以后）切换到符号文件 file 上。当 GDB 绑定到 QEMU 后，它并不是虚拟机中进程边界内的一部分，因此我们要去告诉它去使用哪个符号。默认情况下，我们配置 GDB 去使用内核符号文件 <code>obj/kern/kernel</code>。如果机器正在运行用户代码，比如是 <code>hello.c</code>，你就需要使用 <code>symbol-file obj/user/hello</code> 去切换到 hello 的符号文件。</p><p>QEMU 将每个虚拟 CPU 表示为 GDB 中的一个线程，因此你可以使用 GDB 中所有的线程相关的命令去查看或维护 QEMU 的虚拟 CPU。</p><ul><li><code>thread n</code></li></ul><p>GDB 在一个时刻只关注于一个线程（即：CPU）。这个命令将关注的线程切换到 n，n 是从 0 开始编号的。</p><ul><li><code>info threads</code></li></ul><p>列出所有的线程（即：CPU），包括它们的状态（活动还是停止）和它们在什么函数中。</p><h4 id=qemu>QEMU</h4><p>QEMU 包含一个内置的监视器，它能够有效地检查和修改机器状态。想进入到监视器中，在运行 QEMU 的终端中按入 <code>Ctrl-a c</code> 即可。再次按下 <code>Ctrl-a c</code> 将切换回串行控制台。</p><p>监视器命令的完整参考资料，请查看 <a href=http://wiki.qemu.org/download/qemu-doc.html#pcsys_005fmonitor>QEMU 手册</a>。下面是 6.828 课程中用到的一些有用的命令：</p><ul><li><code>xp/ N x paddr</code></li></ul><p>显示从物理地址 paddr 处开始的 N 个词的十六进制转储。如果 N 省略，默认为 1。这是 GDB 的 <code>x</code> 命令模拟的物理内存。</p><ul><li><code>info registers</code></li></ul><p>显示机器内部寄存器状态的一个完整转储。实践中，对于段选择器，这将包含机器的 隐藏 段状态和局部、全局、和中断描述符表加任务状态寄存器。隐藏状态是在加载段选择器后，虚拟的 CPU 从 GDT/LDT 中读取的信息。下面是实验 1 中 JOS 内核处于运行中时的 CS 信息和每个字段的含义：</p><pre tabindex=0><code>CS =0008 10000000 ffffffff 10cf9a00 DPL=0 CS32 [-R-]
</code></pre><ul><li><code>CS =0008</code></li></ul><p>代码选择器可见部分。我们使用段 0x8。这也告诉我们参考全局描述符表（0x8&amp;4=0），并且我们的 CPL（当前权限级别）是 0x8&amp;3=0。</p><ul><li><code>10000000</code></li></ul><p>这是段基址。线性地址 = 逻辑地址 + 0x10000000。</p><ul><li><code>ffffffff</code></li></ul><p>这是段限制。访问线性地址 0xffffffff 以上将返回段违规异常。</p><ul><li><code>10cf9a00</code></li></ul><p>段的原始标志，QEMU 将在接下来的几个字段中解码这些对我们有用的标志。</p><ul><li><code>DPL=0</code></li></ul><p>段的权限级别。一旦代码以权限 0 运行，它将就能够加载这个段。</p><ul><li><code>CS32</code></li></ul><p>这是一个 32 位代码段。对于数据段（不要与 DS 寄存器混淆了），另外的值还包括 <code>DS</code>，而对于本地描述符表是 <code>LDT</code>。</p><ul><li><code>[-R-]</code></li></ul><p>这个段是只读的。</p><ul><li><code>info mem</code></li></ul><p>（在实验 2 以后）显示映射的虚拟内存和权限。比如：</p><pre tabindex=0><code>ef7c0000-ef800000 00040000 urw
efbf8000-efc00000 00008000 -rw
</code></pre><p>这告诉我们从 0xef7c0000 到 0xef800000 的 0x00040000 字节的内存被映射为读取/写入/用户可访问，而映射在 0xefbf8000 到 0xefc00000 之间的内存权限是读取/写入，但是仅限于内核可访问。</p><ul><li><code>info pg</code></li></ul><p>（在实验 2 以后）显示当前页表结构。它的输出类似于 <code>info mem</code>，但与页目录条目和页表条目是有区别的，并且为每个条目给了单独的权限。重复的 PTE 和整个页表被折叠为一个单行。例如：</p><pre tabindex=0><code>VPN range     Entry         Flags        Physical page
[00000-003ff]  PDE[000]     -------UWP
  [00200-00233]  PTE[200-233] -------U-P 00380 0037e 0037d 0037c 0037b 0037a ..
[00800-00bff]  PDE[002]     ----A--UWP
  [00800-00801]  PTE[000-001] ----A--U-P 0034b 00349
  [00802-00802]  PTE[002]     -------U-P 00348
</code></pre><p>这里各自显示了两个页目录条目、虚拟地址范围 0x00000000 到 0x003fffff 以及 0x00800000 到 0x00bfffff。 所有的 PDE 都存在于内存中、可写入、并且用户可访问，而第二个 PDE 也是可访问的。这些页表中的第二个映射了三个页、虚拟地址范围 0x00800000 到 0x00802fff，其中前两个页是存在于内存中的、可写入、并且用户可访问的，而第三个仅存在于内存中，并且用户可访问。这些 PTE 的第一个条目映射在物理页 0x34b 处。</p><p>QEMU 也有一些非常有用的命令行参数，使用 <code>QEMUEXTRA</code> 变量可以将参数传递给 JOS 的 makefile。</p><ul><li><code>make QEMUEXTRA='-d int' ...</code></li></ul><p>记录所有的中断和一个完整的寄存器转储到 <code>qemu.log</code> 文件中。你可以忽略前两个日志条目、“SMM: enter” 和 “SMM: after RMS”，因为这些是在进入引导加载器之前生成的。在这之后的日志条目看起来像下面这样：</p><pre tabindex=0><code>     4: v=30 e=0000 i=1 cpl=3 IP=001b:00800e2e pc=00800e2e SP=0023:eebfdf28 EAX=00000005
EAX=00000005 EBX=00001002 ECX=00200000 EDX=00000000
ESI=00000805 EDI=00200000 EBP=eebfdf60 ESP=eebfdf28
...
</code></pre><p>第一行描述了中断。<code>4:</code> 只是一个日志记录计数器。<code>v</code> 提供了十六进程的向量号。<code>e</code> 提供了错误代码。<code>i=1</code> 表示它是由一个 <code>int</code> 指令（相对一个硬件产生的中断而言）产生的。剩下的行的意思很明显。对于一个寄存器转储而言，接下来看到的就是寄存器信息。</p><p>注意：如果你运行的是一个 0.15 版本之前的 QEMU，日志将写入到 <code>/tmp</code> 目录，而不是当前目录下。</p><hr><p>via: <a href=https://pdos.csail.mit.edu/6.828/2018/labguide.html>https://pdos.csail.mit.edu/6.828/2018/labguide.html</a></p><p>作者：<a href=https://pdos.csail.mit.edu>csail.mit</a> 选题：<a href=https://github.com/lujun9972>lujun9972</a> 译者：<a href=https://github.com/qhwdw>qhwdw</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/gdb/ rel=tag>GDB</a></li><li class=tags__item><a class="tags__link btn" href=/tags/6.828/ rel=tag>6.828</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>