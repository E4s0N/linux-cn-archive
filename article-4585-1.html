<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>一大波有用的 bash 别名和函数 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="一大波有用的 bash 别名和函数"><meta property="og:description" content="作为一个命令行探索者，你或许发现你自己一遍又一遍重复同样的命令。如果你总是用ssh进入到同一台电脑，如果你总是将一连串命令连接起来，如果你总是用同样的参数运行一个程序，你也许希望在这种不断的重复中为你的生命节约下几秒钟。 解决方案是使用一个别名（alias）。正如你可能知道的，别名用一种让你的shell记住一个特定的命令并且给它一个新的名字的方式。不管怎么样，别名有一些限制，它只是shell命令的快捷方式，不能传递或者控制其中的参数。所以作为补充，bash 也允许你创建你自己的函数，这可能更长一些和复杂一点，它允许任意"><meta property="og:type" content="article"><meta property="og:url" content="/article-4585-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2015-01-03T09:32:00+00:00"><meta property="article:modified_time" content="2015-01-03T09:32:00+00:00"><meta itemprop=name content="一大波有用的 bash 别名和函数"><meta itemprop=description content="作为一个命令行探索者，你或许发现你自己一遍又一遍重复同样的命令。如果你总是用ssh进入到同一台电脑，如果你总是将一连串命令连接起来，如果你总是用同样的参数运行一个程序，你也许希望在这种不断的重复中为你的生命节约下几秒钟。 解决方案是使用一个别名（alias）。正如你可能知道的，别名用一种让你的shell记住一个特定的命令并且给它一个新的名字的方式。不管怎么样，别名有一些限制，它只是shell命令的快捷方式，不能传递或者控制其中的参数。所以作为补充，bash 也允许你创建你自己的函数，这可能更长一些和复杂一点，它允许任意"><meta itemprop=datePublished content="2015-01-03T09:32:00+00:00"><meta itemprop=dateModified content="2015-01-03T09:32:00+00:00"><meta itemprop=wordCount content="732"><meta itemprop=keywords content="命令行,别名,alias,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>一大波有用的 bash 别名和函数</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2015-01-03T09:32:00Z>January 03, 2015</time></div></div></header><div class="content post__content clearfix"><p>作为一个命令行探索者，你或许发现你自己一遍又一遍重复同样的命令。如果你总是用ssh进入到同一台电脑，如果你总是将一连串命令连接起来，如果你总是用同样的参数运行一个程序，你也许希望在这种不断的重复中为你的生命节约下几秒钟。</p><p>解决方案是使用一个别名（alias）。正如你可能知道的，别名用一种让你的shell记住一个特定的命令并且给它一个新的名字的方式。不管怎么样，别名有一些限制，它只是shell命令的快捷方式，不能传递或者控制其中的参数。所以作为补充，bash 也允许你创建你自己的函数，这可能更长一些和复杂一点，它允许任意数量的参数。</p><p>当然，当你有美食时，比如某种汤，你要分享它给大家。我这里有一个列表，列出了一些最有用bash别名和函数的。注意“最有用的”只是个说法，别名的是否有用要看你是否每天都需要在 shell 里面用它。</p><p>在你开始你的别名体验之旅前，这里有一个便于使用的小技巧：如果你的别名和原本的命令名字相同，你可以用如下技巧来访问原本的命令（LCTT 译注：你也可以直接原本命令的完整路径来访问它。）</p><pre tabindex=0><code>\command 
</code></pre><p>例如，如果有一个替换了ls命令的别名 ls。如果你想使用原本的ls命令而不是别名，通过调用它:</p><pre tabindex=0><code>\ls 
</code></pre><p><img src=/data/attachment/album/201501/02/223953tqtiwwwo71t3iq55.png alt></p><h3 id=提升生产力>提升生产力</h3><p>这些别名真的很简单并且真的很短，但他们大多数是为了给你的生命节省几秒钟，最终也许为你这一辈子节省出来几年，也许呢。</p><pre tabindex=0><code>alias ls=&#34;ls --color=auto&#34;
</code></pre><p>简单但非常重要。使ls命令带着彩色输出。</p><pre tabindex=0><code>alias ll=&#34;ls --color -al&#34;
</code></pre><p>以彩色的列表方式列出目录里面的全部文件。</p><pre tabindex=0><code>alias grep=&#39;grep --color=auto&#39;
</code></pre><p>类似，只是在grep里输出带上颜色。</p><pre tabindex=0><code>mcd() { mkdir -p &#34;$1&#34;; cd &#34;$1&#34;;} 
</code></pre><p>我的最爱之一。创建一个目录并进入该目录里： mcd [目录名]。</p><pre tabindex=0><code>cls() { cd &#34;$1&#34;; ls;}
</code></pre><p>类似上一个函数，进入一个目录并列出它的的内容：cls[目录名]。</p><pre tabindex=0><code>backup() { cp &#34;$1&#34;{,.bak};}
</code></pre><p>简单的给文件创建一个备份: backup [文件] 将会在同一个目录下创建 [文件].bak。</p><pre tabindex=0><code>md5check() { md5sum &#34;$1&#34; | grep &#34;$2&#34;;}
</code></pre><p>因为我讨厌通过手工比较文件的md5校验值，这个函数会计算它并进行比较：md5check[文件][校验值]。</p><p><img src=/data/attachment/album/201501/02/223955zvoyi4z9hlcwkqlh.jpg alt></p><pre tabindex=0><code>alias makescript=&#34;fc -rnl | head -1 &gt;&#34; 
</code></pre><p>很容易用你上一个运行的命令创建一个脚本：makescript [脚本名字.sh]</p><pre tabindex=0><code>alias genpasswd=&#34;strings /dev/urandom | grep -o &#39;[[:alnum:]]&#39; | head -n 30 | tr -d &#39;\n&#39;; echo&#34; 
</code></pre><p>只是瞬间产生一个强壮的密码。</p><p><img src=/data/attachment/album/201501/02/223956s1t993jta1m8aojb.jpg alt></p><pre tabindex=0><code>alias c=&#34;clear&#34;
</code></pre><p>清除你终端屏幕不能更简单了吧？</p><pre tabindex=0><code>alias histg=&#34;history | grep&#34;
</code></pre><p>快速搜索你的命令输入历史：histg [关键字]</p><pre tabindex=0><code>alias ..=&#39;cd ..&#39;
</code></pre><p>回到上层目录还需要输入 cd 吗？</p><pre tabindex=0><code>alias ...=&#39;cd ../..&#39;
</code></pre><p>自然，去到上两层目录。</p><pre tabindex=0><code>extract() { 
    if [ -f $1 ] ; then 
      case $1 in 
        *.tar.bz2)   tar xjf $1     ;; 
        *.tar.gz)    tar xzf $1     ;; 
        *.bz2)       bunzip2 $1     ;; 
        *.rar)       unrar e $1     ;; 
        *.gz)        gunzip $1      ;; 
        *.tar)       tar xf $1      ;; 
        *.tbz2)      tar xjf $1     ;; 
        *.tgz)       tar xzf $1     ;; 
        *.zip)       unzip $1       ;; 
        *.Z)         uncompress $1  ;; 
        *.7z)        7z x $1        ;; 
        *)     echo &#34;&#39;$1&#39; cannot be extracted via extract()&#34; ;; 
         esac 
     else 
         echo &#34;&#39;$1&#39; is not a valid file&#34; 
     fi 
}
</code></pre><p>很长，但是也是最有用的。解压任何的文档类型：extract: [压缩文件]</p><h3 id=系统信息>系统信息</h3><p>想尽快地知道关于你的系统一切信息？</p><pre tabindex=0><code>alias cmount=&#34;mount | column -t&#34;
</code></pre><p>按列格式化输出mount信息。</p><p><img src=/data/attachment/album/201501/02/223959ksw82w2gxgzkwh3w.jpg alt></p><pre tabindex=0><code>alias tree=&#34;ls -R | grep &#34;:$&#34; | sed -e &#39;s/:$//&#39; -e &#39;s/[^-][^\/]*\//--/g&#39; -e &#39;s/^/   /&#39; -e &#39;s/-/|/&#39;&#34; 
</code></pre><p>以树形结构递归地显示目录结构。</p><pre tabindex=0><code>sbs() { du -b --max-depth 1 | sort -nr | perl -pe &#39;s{([0-9]+)}{sprintf &#34;%.1f%s&#34;, $1&gt;=2**30? ($1/2**30, &#34;G&#34;): $1&gt;=2**20? ($1/2**20, &#34;M&#34;): $1&gt;=2**10? ($1/2**10, &#34;K&#34;): ($1, &#34;&#34;)}e&#39;;} 
</code></pre><p>安装文件在磁盘存储的大小排序，显示当前目录的文件列表。</p><pre tabindex=0><code>alias intercept=&#34;sudo strace -ff -e trace=write -e write=1,2 -p&#34; 
</code></pre><p>接管某个进程的标准输出和标准错误。注意你需要安装了 strace。</p><pre tabindex=0><code>alias meminfo=&#39;free -m -l -t&#39;
</code></pre><p>查看你还有剩下多少内存。</p><p><img src=/data/attachment/album/201501/02/224001onkdgkhngjrkrvnd.jpg alt></p><pre tabindex=0><code>alias ps? = &#34;ps aux | grep&#34;
</code></pre><p>可以很容易地找到某个进程的PID：ps? [名字]。</p><pre tabindex=0><code>alias volume=&#34;amixer get Master | sed &#39;1,4 d&#39; | cut -d [ -f 2 | cut -d ] -f 1&#34;
</code></pre><p>显示当前音量设置。</p><p><img src=/data/attachment/album/201501/02/224003nrw5i49u4jocfrw6.jpg alt></p><h3 id=网络>网络</h3><p>对于所有用在互联网和本地网络的命令，也有一些神奇的别名给它们。</p><pre tabindex=0><code>alias websiteget=&#34;wget --random-wait -r -p -e robots=off -U mozilla&#34;
</code></pre><p>下载整个网站：websiteget [URL]。</p><pre tabindex=0><code>alias listen=&#34;lsof -P -i -n&#34; 
</code></pre><p>显示出哪个应用程序连接到网络。</p><p><img src=/data/attachment/album/201501/02/224006abrlf8zf1c9p85ls.jpg alt></p><pre tabindex=0><code>alias port=&#39;netstat -tulanp&#39;
</code></pre><p>显示出活动的端口。</p><pre tabindex=0><code>gmail() { curl -u &#34;$1&#34; --silent &#34;https://mail.google.com/mail/feed/atom&#34; | sed -e &#39;s/&lt;\/fullcount.*/\n/&#39; | sed -e &#39;s/.*fullcount&gt;//&#39;}
</code></pre><p>大概的显示你的谷歌邮件里未读邮件的数量：gmail [用户名]</p><pre tabindex=0><code>alias ipinfo=&#34;curl ifconfig.me &amp;&amp; curl ifconfig.me/host&#34;
</code></pre><p>获得你的公网IP地址和主机名。</p><pre tabindex=0><code>getlocation() { lynx -dump http://www.ip-adress.com/ip_tracer/?QRY=$1|grep address|egrep &#39;city|state|country&#39;|awk &#39;{print $3,$4,$5,$6,$7,$8}&#39;|sed &#39;s\ip address flag \\&#39;|sed &#39;s\My\\&#39;;} 
</code></pre><p>返回你的当前IP地址的地理位置。</p><h3 id=也许无用>也许无用</h3><p>所以呢，如果一些别名并不是全都具有使用价值？它们可能仍然有趣。</p><pre tabindex=0><code>kernelgraph() { lsmod | perl -e &#39;print &#34;digraph \&#34;lsmod\&#34; {&#34;;&lt;&gt;;while(&lt;&gt;){@_=split/\s+/; print &#34;\&#34;$_[0]\&#34; -&gt; \&#34;$_\&#34;\n&#34; for split/,/,$_[3]}print &#34;}&#34;&#39; | dot -Tpng | display -;}
</code></pre><p>绘制内核模块依赖曲线图。需要可以查看图片。</p><pre tabindex=0><code>alias busy=&#34;cat /dev/urandom | hexdump -C | grep &#39;ca fe&#39;&#34; 
</code></pre><p>在那些非技术人员的眼里你看起来是总是那么忙和神秘。</p><p><img src=/data/attachment/album/201501/02/224008xeo2mou92ap9ri8e.jpg alt></p><p>最后，这些别名和函数的很大一部分来自于我个人的.bashrc。而那些令人点赞的网站 <a href=http://alias.sh/>alias.sh</a>和<a href=http://www.commandlinefu.com/commands/browse>commandlinefu.com</a>我早已在我的帖子<a href=http://xmodulo.com/useful-online-tools-linux.html>best online tools for Linux</a> 里面介绍过。你可以去看看，如果你愿意，也可以分享下你的。也欢迎你在这里评论，分享一下你的智慧。</p><p>做为奖励，这里有我提到的全部别名和函数的纯文本版本，随时可以复制粘贴到你的.bashrc。（如果你已经一行一行的复制到这里了，哈哈，你发现你又浪费了生命的几秒钟~）</p><pre tabindex=0><code>#Productivity
alias ls=&#34;ls --color=auto&#34;
alias ll=&#34;ls --color -al&#34;
alias grep=&#39;grep --color=auto&#39;
mcd() { mkdir -p &#34;$1&#34;; cd &#34;$1&#34;;}
cls() { cd &#34;$1&#34;; ls;}
backup() { cp &#34;$1&#34;{,.bak};}
md5check() { md5sum &#34;$1&#34; | grep &#34;$2&#34;;}
alias makescript=&#34;fc -rnl | head -1 &gt;&#34;
alias genpasswd=&#34;strings /dev/urandom | grep -o &#39;[[:alnum:]]&#39; | head -n 30 | tr -d &#39;\n&#39;; echo&#34;
alias c=&#34;clear&#34;
alias histg=&#34;history | grep&#34;
alias ..=&#39;cd ..&#39;
alias ...=&#39;cd ../..&#39;
extract() {
    if [ -f $1 ] ; then
      case $1 in
        *.tar.bz2)   tar xjf $1     ;;
        *.tar.gz)    tar xzf $1     ;;
        *.bz2)       bunzip2 $1     ;;
        *.rar)       unrar e $1     ;;
        *.gz)        gunzip $1      ;;
        *.tar)       tar xf $1      ;;
        *.tbz2)      tar xjf $1     ;;
        *.tgz)       tar xzf $1     ;;
        *.zip)       unzip $1       ;;
        *.Z)         uncompress $1  ;;
        *.7z)        7z x $1        ;;
        *)     echo &#34;&#39;$1&#39; cannot be extracted via extract()&#34; ;;
         esac
     else
         echo &#34;&#39;$1&#39; is not a valid file&#34;
     fi
}

#System info
alias cmount=&#34;mount | column -t&#34;
alias tree=&#34;ls -R | grep &#34;:$&#34; | sed -e &#39;s/:$//&#39; -e &#39;s/[^-][^\/]*\//--/g&#39; -e &#39;s/^/   /&#39; -e &#39;s/-/|/&#39;&#34;
sbs(){ du -b --max-depth 1 | sort -nr | perl -pe &#39;s{([0-9]+)}{sprintf &#34;%.1f%s&#34;, $1&gt;=2**30? ($1/2**30, &#34;G&#34;): $1&gt;=2**20? ($1/2**20, &#34;M&#34;): $1&gt;=2**10? ($1/2**10, &#34;K&#34;): ($1, &#34;&#34;)}e&#39;;}
alias intercept=&#34;sudo strace -ff -e trace=write -e write=1,2 -p&#34;
alias meminfo=&#39;free -m -l -t&#39;
alias ps?=&#34;ps aux | grep&#34;
alias volume=&#34;amixer get Master | sed &#39;1,4 d&#39; | cut -d [ -f 2 | cut -d ] -f 1&#34;

#Network
alias websiteget=&#34;wget --random-wait -r -p -e robots=off -U mozilla&#34;
alias listen=&#34;lsof -P -i -n&#34;
alias port=&#39;netstat -tulanp&#39;
gmail() { curl -u &#34;$1&#34; --silent &#34;https://mail.google.com/mail/feed/atom&#34; | sed -e &#39;s/&lt;\/fullcount.*/\n/&#39; | sed -e &#39;s/.*fullcount&gt;//&#39;}
alias ipinfo=&#34;curl ifconfig.me &amp;&amp; curl ifconfig.me/host&#34;
getlocation() { lynx -dump http://www.ip-adress.com/ip_tracer/?QRY=$1|grep address|egrep &#39;city|state|country&#39;|awk &#39;{print $3,$4,$5,$6,$7,$8}&#39;|sed &#39;s\ip address flag \\&#39;|sed &#39;s\My\\&#39;;}

#Funny
kernelgraph() { lsmod | perl -e &#39;print &#34;digraph \&#34;lsmod\&#34; {&#34;;&lt;&gt;;while(&lt;&gt;){@_=split/\s+/; print &#34;\&#34;$_[0]\&#34; -&gt; \&#34;$_\&#34;\n&#34; for split/,/,$_[3]}print &#34;}&#34;&#39; | dot -Tpng | display -;}
alias busy=&#34;cat /dev/urandom | hexdump -C | grep \&#34;ca fe\&#34;&#34;
</code></pre><hr><p>via: <a href=http://xmodulo.com/useful-bash-aliases-functions.html>http://xmodulo.com/useful-bash-aliases-functions.html</a></p><p>作者：<a href=http://xmodulo.com/author/adrien>Adrien Brochard</a> 译者：<a href=https://github.com/luoyutiantang>luoyutiantang</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创翻译，<a href=http://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/ rel=tag>命令行</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E5%88%AB%E5%90%8D/ rel=tag>别名</a></li><li class=tags__item><a class="tags__link btn" href=/tags/alias/ rel=tag>alias</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>