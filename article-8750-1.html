<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>LXD 2.15 中的存储管理 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="LXD 2.15 中的存储管理"><meta property="og:description" content="长久以来 LXD 已经支持多种存储驱动。用户可以在 zfs、btrfs、lvm 或纯目录存储池之间进行选择，但他们只能使用单个存储池。一个被频繁被提到的需求是不仅支持单个存储池，还支持多个存储池。"><meta property="og:type" content="article"><meta property="og:url" content="/article-8750-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-08-03T18:37:38+00:00"><meta property="article:modified_time" content="2017-08-03T18:37:38+00:00"><meta itemprop=name content="LXD 2.15 中的存储管理"><meta itemprop=description content="长久以来 LXD 已经支持多种存储驱动。用户可以在 zfs、btrfs、lvm 或纯目录存储池之间进行选择，但他们只能使用单个存储池。一个被频繁被提到的需求是不仅支持单个存储池，还支持多个存储池。"><meta itemprop=datePublished content="2017-08-03T18:37:38+00:00"><meta itemprop=dateModified content="2017-08-03T18:37:38+00:00"><meta itemprop=wordCount content="144"><meta itemprop=keywords content="LXD,容器,存储,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>LXD 2.15 中的存储管理</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-08-03T18:37:38Z>August 03, 2017</time></div></div></header><div class="content post__content clearfix"><p><img src=/data/attachment/album/201708/03/183727syjxl7jwmy3myzfy.jpg alt></p><p>长久以来 LXD 已经支持多种存储驱动。用户可以在 zfs、btrfs、lvm 或纯目录存储池之间进行选择，但他们只能使用单个存储池。一个被频繁被提到的需求是不仅支持单个存储池，还支持多个存储池。这样，用户可以维护一个由 SSD 支持的 zfs 存储池用于 I/O 密集型容器，另一个简单的基于目录的存储池用于其他容器。幸运的是，现在这是可能的，因为 LXD 在几个版本后有了自己的存储管理 API。</p><h3 id=创建存储池>创建存储池</h3><p>新安装 LXD 没有定义任何存储池。如果你运行 <code>lxd init</code> ，LXD 将提供为你创建一个存储池。由 <code>lxd init</code> 创建的存储池将是创建容器的默认存储池。</p><p><img src=/data/attachment/album/201708/03/183742znbdqms55exehmax.png alt=asciicast></p><h3 id=创建更多的存储池>创建更多的存储池</h3><p>我们的客户端工具使得创建额外的存储池变得非常简单。为了创建和管理新的存储池，你可以使用 <code>lxc storage</code> 命令。所以如果你想在块设备 <code>/dev/sdb</code> 上创建一个额外的 btrfs 存储池，你只需使用 <code>lxc storage create my-btrfs btrfs source=/dev/sdb</code>。让我们来看看：</p><p><img src=/data/attachment/album/201708/03/183745leleohwutuu97qtq.png alt=asciicast></p><h3 id=在默认存储池上创建容器>在默认存储池上创建容器</h3><p>如果你从全新安装的 LXD 开始，并通过 <code>lxd init</code> 创建了一个存储池，LXD 将使用此池作为默认存储池。这意味着如果你执行 <code>lxc launch images:ubuntu/xenial xen1</code>，LXD 将为此存储池上的容器的根文件系统创建一个存储卷。在示例中，我们使用 <code>my-first-zfs-pool</code> 作为默认存储池。</p><p><img src=/data/attachment/album/201708/03/183748w445y36fffe5ov3x.png alt=asciicast></p><h3 id=在特定存储池上创建容器>在特定存储池上创建容器</h3><p>但是你也可以通过传递 <code>-s</code> 参数来告诉 <code>lxc launch</code> 和 <code>lxc init</code> 在特定存储池上创建一个容器。例如，如果要在 <code>my-btrfs</code> 存储池上创建一个新的容器，你可以执行 <code>lxc launch images:ubuntu/xenial xen-on-my-btrfs -s my-btrfs</code>：</p><p><img src=/data/attachment/album/201708/03/183752f6br797bu4r7579g.png alt=asciicast></p><h3 id=创建自定义存储卷>创建自定义存储卷</h3><p>如果你其中一个容器需要额外的空间存储额外的数据，那么新的存储 API 将允许你创建可以连接到容器的存储卷。只需要 <code>lxc storage volume create my-btrfs my-custom-volume</code>：</p><p><img src=/data/attachment/album/201708/03/183755ef4pvhcrag6z4gwp.png alt=asciicast></p><h3 id=连接自定义卷到容器中>连接自定义卷到容器中</h3><p>当然，这个功能是有用的，因为存储 API 让你把这些存储卷连接到容器。要将存储卷连接到容器，可以使用 <code>lxc storage volume attach my-btrfs my-custom-volume xen1 data /opt/my/data</code>：</p><p><img src=/data/attachment/album/201708/03/183757uk2z86ykrb7bu8er.png alt=asciicast></p><h3 id=在容器之间共享自定义存储卷>在容器之间共享自定义存储卷</h3><p>默认情况下，LXD 将使连接的存储卷由其所连接的容器写入。这意味着它会将存储卷的所有权更改为容器的 id 映射。但存储卷也可以同时连接到多个容器。这对于在多个容器之间共享数据是非常好的。但是，这有一些限制。为了将存储卷连接到多个容器，它们必须共享相同的 id 映射。让我们创建一个额外的具有一个隔离的 id 映射的容器 <code>xen-isolated</code>。这意味着它的 id 映射在这个 LXD 实例中将是唯一的，因此没有其他容器具有相同的id映射。将相同的存储卷 <code>my-custom-volume</code> 连接到此容器现在将会失败：</p><p><img src=/data/attachment/album/201708/03/183800okv60676c0zc99xd.png alt=asciicast></p><p>但是我们让 <code>xen-isolated</code> 与 <code>xen1</code> 有相同的映射，并把它重命名为 <code>xen2</code> 来反映这个变化。现在我们可以将 <code>my-custom-volume</code> 连接到 <code>xen1</code> 和 <code>xen2</code> 而不会有问题：</p><p><img src=/data/attachment/album/201708/03/183803tuv0ty10i9z2v9v2.png alt=asciicast></p><h3 id=总结>总结</h3><p>存储 API 是 LXD 非常强大的补充。它提供了一组基本功能，有助于在大规模使用容器时处理各种问题。这个简短的介绍希望给你一个印象，你可以做什么。将来会有更多介绍。</p><p>本篇文章最初在 <a href=https://cbrauner.wordpress.com/>Brauner 的博客</a>中发布。</p><hr><p>via: <a href=https://insights.ubuntu.com/2017/07/12/storage-management-in-lxd-2-15/>https://insights.ubuntu.com/2017/07/12/storage-management-in-lxd-2-15/</a></p><p>作者：<a href=https://cbrauner.wordpress.com/>Christian Brauner</a> 译者：<a href=https://github.com/geekpi>geekpi</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/lxd/ rel=tag>LXD</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E5%AE%B9%E5%99%A8/ rel=tag>容器</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E5%AD%98%E5%82%A8/ rel=tag>存储</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>