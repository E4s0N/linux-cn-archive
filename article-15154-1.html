<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>在 Kubernetes 上使用 Flask 搭建 Python 微服务 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="在 Kubernetes 上使用 Flask 搭建 Python 微服务"><meta property="og:description" content="微服务遵循领域驱动设计（DDD），与开发平台无关。Python 微服务也不例外。Python3 的面向对象特性使得按照 DDD 对服务进行建模变得更加容易。"><meta property="og:type" content="article"><meta property="og:url" content="/article-15154-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-10-19T12:44:58+00:00"><meta property="article:modified_time" content="2022-10-19T12:44:58+00:00"><meta itemprop=name content="在 Kubernetes 上使用 Flask 搭建 Python 微服务"><meta itemprop=description content="微服务遵循领域驱动设计（DDD），与开发平台无关。Python 微服务也不例外。Python3 的面向对象特性使得按照 DDD 对服务进行建模变得更加容易。"><meta itemprop=datePublished content="2022-10-19T12:44:58+00:00"><meta itemprop=dateModified content="2022-10-19T12:44:58+00:00"><meta itemprop=wordCount content="1032"><meta itemprop=keywords content="微服务,Python,Flask,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>在 Kubernetes 上使用 Flask 搭建 Python 微服务</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2022-10-19T12:44:58Z>October 19, 2022</time></div></div></header><div class="content post__content clearfix"><p><img src=/data/attachment/album/202210/19/124429nmw0xmfz3x3mrrf2.jpg alt></p><p><em>微服务遵循领域驱动设计（DDD），与开发平台无关。Python 微服务也不例外。Python3 的面向对象特性使得按照 DDD 对服务进行建模变得更加容易。本系列的第 10 部分演示了如何将用户管理系统的查找服务作为 Python 微服务部署在 Kubernetes 上。</em></p><p>微服务架构的强大之处在于它的多语言性。企业将其功能分解为一组微服务，每个团队自由选择一个平台。</p><p>我们的用户管理系统已经分解为四个微服务，分别是添加、查找、搜索和日志服务。添加服务在 Java 平台上开发并部署在 Kubernetes 集群上，以实现弹性和可扩展性。这并不意味着其余的服务也要使用 Java 开发，我们可以自由选择适合个人服务的平台。</p><p>让我们选择 Python 作为开发查找服务的平台。查找服务的模型已经设计好了（参考 2022 年 3 月份的文章），我们只需要将这个模型转换为代码和配置。</p><h3 id=pythonic-方法>Pythonic 方法</h3><p>Python 是一种通用编程语言，已经存在了大约 30 年。早期，它是自动化脚本的首选。然而，随着 Django 和 Flask 等框架的出现，它的受欢迎程度越来越高，现在各种领域中都在应用它，如企业应用程序开发。数据科学和机器学习进一步推动了它的发展，Python 现在是三大编程语言之一。</p><p>许多人将 Python 的成功归功于它容易编码。这只是一部分原因。只要你的目标是开发小型脚本，Python 就像一个玩具，你会非常喜欢它。然而，当你进入严肃的大规模应用程序开发领域时，你将不得不处理大量的 <code>if</code> 和 <code>else</code>，Python 变得与任何其他平台一样好或一样坏。例如，采用一种面向对象的方法！许多 Python 开发人员甚至可能没意识到 Python 支持类、继承等功能。Python 确实支持成熟的面向对象开发，但是有它自己的方式 &ndash; Pythonic！让我们探索一下！</p><h3 id=领域模型>领域模型</h3><p><code>AddService</code> 通过将数据保存到一个 MySQL 数据库中来将用户添加到系统中。<code>FindService</code> 的目标是提供一个 REST API 按用户名查找用户。域模型如图 1 所示。它主要由一些值对象组成，如 <code>User</code> 实体的<code>Name</code>、<code>PhoneNumber</code> 以及 <code>UserRepository</code>。</p><p><img src=/data/attachment/album/202210/19/124459ozaec7k784oqk6c5.png alt="图 1: 查找服务的域模型"></p><p>让我们从 <code>Name</code> 开始。由于它是一个值对象，因此必须在创建时进行验证，并且必须保持不可变。基本结构如所示：</p><pre tabindex=0><code>class Name:
    value: str
    def __post_init__(self):
        if self.value is None or len(self.value.strip()) &lt; 8 or len(self.value.strip()) &gt; 32:
            raise ValueError(&#34;Invalid Name&#34;)
</code></pre><p>如你所见，<code>Name</code> 包含一个字符串类型的值。作为后期初始化的一部分，我们会验证它。</p><p>Python 3.7 提供了 <code>@dataclass</code> 装饰器，它提供了许多开箱即用的数据承载类的功能，如构造函数、比较运算符等。如下是装饰后的 <code>Name</code> 类：</p><pre tabindex=0><code>from dataclasses import dataclass

@dataclass
class Name:
    value: str
    def __post_init__(self):
        if self.value is None or len(self.value.strip()) &lt; 8 or len(self.value.strip()) &gt; 32:
            raise ValueError(&#34;Invalid Name&#34;)
</code></pre><p>以下代码可以创建一个 <code>Name</code> 对象：</p><pre tabindex=0><code>name = Name(&#34;Krishna&#34;)
</code></pre><p><code>value</code> 属性可以按照如下方式读取或写入：</p><pre tabindex=0><code>name.value = &#34;Mohan&#34;
print(name.value)
</code></pre><p>可以很容易地与另一个 <code>Name</code> 对象比较，如下所示：</p><pre tabindex=0><code>other = Name(&#34;Mohan&#34;)
if name == other:
    print(&#34;same&#34;)
</code></pre><p>如你所见，对象比较的是值而不是引用。这一切都是开箱即用的。我们还可以通过冻结对象使对象不可变。这是 <code>Name</code> 值对象的最终版本：</p><pre tabindex=0><code>from dataclasses import dataclass

@dataclass(frozen=True)
class Name:
    value: str
    def __post_init__(self):
        if self.value is None or len(self.value.strip()) &lt; 8 or len(self.value.strip()) &gt; 32:
            raise ValueError(&#34;Invalid Name&#34;)
</code></pre><p><code>PhoneNumber</code> 也遵循类似的方法，因为它也是一个值对象：</p><pre tabindex=0><code>@dataclass(frozen=True)
class PhoneNumber:
    value: int
    def __post_init__(self):
        if self.value &lt; 9000000000:
            raise ValueError(&#34;Invalid Phone Number&#34;)
</code></pre><p><code>User</code> 类是一个实体，不是一个值对象。换句话说，<code>User</code> 是可变的。以下是结构：</p><pre tabindex=0><code>from dataclasses import dataclass
import datetime

@dataclass
class User:
    _name: Name
    _phone: PhoneNumber
    _since: datetime.datetime

    def __post_init__(self):
        if self._name is None or self._phone is None:
            raise ValueError(&#34;Invalid user&#34;)
        if self._since is None:
            self.since = datetime.datetime.now()
</code></pre><p>你能观察到 <code>User</code> 并没有冻结，因为我们希望它是可变的。但是，我们不希望所有属性都是可变的。标识字段如 <code>_name</code> 和 <code>_since</code> 是希望不会修改的。那么，这如何做到呢？</p><p>Python3 提供了所谓的描述符协议，它会帮助我们正确定义 getter 和 setter。让我们使用 <code>@property</code> 装饰器将 getter 添加到 <code>User</code> 的所有三个字段中。</p><pre tabindex=0><code>@property
def name(self) -&gt; Name:
    return self._name

@property
def phone(self) -&gt; PhoneNumber:
    return self._phone

@property
def since(self) -&gt; datetime.datetime:
    return self._since
</code></pre><p><code>phone</code> 字段的 setter 可以使用 <code>@&lt;字段>.setter</code> 来装饰：</p><pre tabindex=0><code>@phone.setter
def phone(self, phone: PhoneNumber) -&gt; None:
    if phone is None:
        raise ValueError(&#34;Invalid phone&#34;)
    self._phone = phone
</code></pre><p>通过重写 <code>__str__()</code> 函数，也可以为 <code>User</code> 提供一个简单的打印方法：</p><pre tabindex=0><code>def __str__(self):
    return self.name.value + &#34; [&#34; + str(self.phone.value) + &#34;] since &#34; + str(self.since)
</code></pre><p>这样，域模型的实体和值对象就准备好了。创建异常类如下所示：</p><pre tabindex=0><code>class UserNotFoundException(Exception):
    pass
</code></pre><p>域模型现在只剩下 <code>UserRepository</code> 了。Python 提供了一个名为 <code>abc</code> 的有用模块来创建抽象方法和抽象类。因为 <code>UserRepository</code> 只是一个接口，所以我们可以使用 <code>abc</code> 模块。</p><p>任何继承自 <code>abc.ABC</code> 的类都将变为抽象类，任何带有 <code>@abc.abstractmethod</code> 装饰器的函数都会变为一个抽象函数。下面是 <code>UserRepository</code> 的结构：</p><pre tabindex=0><code>from abc import ABC, abstractmethod

class UserRepository(ABC):
    @abstractmethod
    def fetch(self, name:Name) -&gt; User:
        pass
</code></pre><p><code>UserRepository</code> 遵循仓储模式。换句话说，它在 <code>User</code> 实体上提供适当的 CRUD 操作，而不会暴露底层数据存储语义。在本例中，我们只需要 <code>fetch()</code> 操作，因为 <code>FindService</code> 只查找用户。</p><p>因为 <code>UserRepository</code> 是一个抽象类，我们不能从抽象类创建实例对象。创建对象必须依赖于一个具体类实现这个抽象类。数据层 <code>UserRepositoryImpl</code> 提供了 <code>UserRepository</code> 的具体实现：</p><pre tabindex=0><code>class UserRepositoryImpl(UserRepository):
    def fetch(self, name:Name) -&gt; User:
        pass
</code></pre><p>由于 <code>AddService</code> 将用户数据存储在一个 MySQL 数据库中，因此 <code>UserRepositoryImpl</code> 也必须连接到相同的数据库去检索数据。下面是连接到数据库的代码。注意，我们正在使用 MySQL 的连接库。</p><pre tabindex=0><code>from mysql.connector import connect, Error

class UserRepositoryImpl(UserRepository):
    def fetch(self, name:Name) -&gt; User:
        try:
            with connect(
                    host=&#34;mysqldb&#34;,
                    user=&#34;root&#34;,
                    password=&#34;admin&#34;,
                    database=&#34;glarimy&#34;,
                ) as connection:
                with connection.cursor() as cursor:
                    cursor.execute(&#34;SELECT * FROM ums_users where name=%s&#34;, (name.value,))
                    row = cursor.fetchone()
                    if cursor.rowcount == -1:
                        raise UserNotFoundException()
                    else:
                        return User(Name(row[0]), PhoneNumber(row[1]), row[2])
        except Error as e:
            raise e
</code></pre><p>在上面的片段中，我们使用用户 <code>root</code> / 密码 <code>admin</code> 连接到一个名为 <code>mysqldb</code> 的数据库服务器，使用名为 <code>glarimy</code> 的数据库（模式）。在演示代码中是可以包含这些信息的，但在生产中不建议这么做，因为这会暴露敏感信息。</p><p><code>fetch()</code> 操作的逻辑非常直观，它对 <code>ums_users</code> 表执行 SELECT 查询。回想一下，<code>AddService</code> 正在将用户数据写入同一个表中。如果 SELECT 查询没有返回记录，<code>fetch()</code> 函数将抛出 <code>UserNotFoundException</code> 异常。否则，它会从记录中构造 <code>User</code> 实体并将其返回给调用者。这没有什么特殊的。</p><h3 id=应用层>应用层</h3><p>最终，我们需要创建应用层。此模型如图 2 所示。它只包含两个类：控制器和一个 DTO。</p><p><img src=/data/attachment/album/202210/19/124500ns7pem96lottcc0p.png alt="图 2: 添加服务的应用层"></p><p>众所周知，一个 DTO 只是一个没有任何业务逻辑的数据容器。它主要用于在 <code>FindService</code> 和外部之间传输数据。我们只是提供了在 REST 层中将 <code>UserRecord</code> 转换为字典以便用于 JSON 传输：</p><pre tabindex=0><code>class UserRecord:
    def toJSON(self):
        return {
            &#34;name&#34;: self.name,
            &#34;phone&#34;: self.phone,
            &#34;since&#34;: self.since
        }
</code></pre><p>控制器的工作是将 DTO 转换为用于域服务的域对象，反之亦然。可以从 <code>find()</code> 操作中观察到这一点。</p><pre tabindex=0><code>class UserController:

    def __init__(self):
        self._repo = UserRepositoryImpl()

    def find(self, name: str):
        try:
            user: User = self._repo.fetch(Name(name))
            record: UserRecord = UserRecord()
            record.name = user.name.value
            record.phone = user.phone.value
            record.since = user.since
            return record
        except UserNotFoundException as e:
            return None
</code></pre><p><code>find()</code> 操作接收一个字符串作为用户名，然后将其转换为 <code>Name</code> 对象，并调用 <code>UserRepository</code> 获取相应的 <code>User</code> 对象。如果找到了，则使用检索到的 <code>User`` 对象创建</code>UserRecord`。回想一下，将域对象转换为 DTO 是很有必要的，这样可以对外部服务隐藏域模型。</p><p><code>UserController</code> 不需要有多个实例，它也可以是单例的。通过重写 <code>__new__</code>，可以将其建模为一个单例。</p><pre tabindex=0><code>class UserController:
    def __new__(self):
        if not hasattr(self, ‘instance’):
            self.instance = super().__new__(self)
        return self.instance

    def __init__(self):
        self._repo = UserRepositoryImpl()

    def find(self, name: str):
        try:
            user: User = self._repo.fetch(Name(name))
            record: UserRecord = UserRecord()
            record.name = user.name.getValue()
            record.phone = user.phone.getValue()
            record.since = user.since
            return record
        except UserNotFoundException as e:
            return None
</code></pre><p>我们已经完全实现了 <code>FindService</code> 的模型，剩下的唯一任务是将其作为 REST 服务公开。</p><h3 id=rest-api>REST API</h3><p><code>FindService</code> 只提供一个 API，那就是通过用户名查找用户。显然 URI 如下所示：</p><pre tabindex=0><code>GET /user/{name}
</code></pre><p>此 API 希望根据提供的用户名查找用户，并以 JSON 格式返回用户的电话号码等详细信息。如果没有找到用户，API 将返回一个 404 状态码。</p><p>我们可以使用 Flask 框架来构建 REST API，它最初的目的是使用 Python 开发 Web 应用程序。除了 HTML 视图，它还进一步扩展到支持 REST 视图。我们选择这个框架是因为它足够简单。 创建一个 Flask 应用程序：</p><pre tabindex=0><code>from flask import Flask
app = Flask(__name__)
</code></pre><p>然后为 Flask 应用程序定义路由，就像函数一样简单：</p><pre tabindex=0><code>@app.route(&#39;/user/&lt;name&gt;&#39;)
def get(name):
    pass
</code></pre><p>注意 <code>@app.route</code> 映射到 API <code>/user/&lt;name></code>，与之对应的函数的 <code>get()</code>。</p><p>如你所见，每次用户访问 API 如 <code>http://server:port/user/Krishna</code> 时，都将调用这个 <code>get()</code> 函数。Flask 足够智能，可以从 URL 中提取 <code>Krishna</code> 作为用户名，并将其传递给 <code>get()</code> 函数。</p><p><code>get()</code> 函数很简单。它要求控制器找到该用户，并将其与通常的 HTTP 头一起打包为 JSON 格式后返回。如果控制器返回 <code>None</code>，则 <code>get()</code> 函数返回合适的 HTTP 状态码。</p><pre tabindex=0><code>from flask import jsonify, abort

controller = UserController()
record = controller.find(name)
if record is None:
    abort(404)
else:
    resp = jsonify(record.toJSON())
    resp.status_code = 200
    return resp
</code></pre><p>最后，我们需要 Flask 应用程序提供服务，可以使用 <code>waitress</code> 服务：</p><pre tabindex=0><code>from waitress import serve
serve(app, host=&#34;0.0.0.0&#34;, port=8080)
</code></pre><p>在上面的片段中，应用程序在本地主机的 8080 端口上提供服务。最终代码如下所示：</p><pre tabindex=0><code>from flask import Flask, jsonify, abort
from waitress import serve

app = Flask(__name__)

@app.route(&#39;/user/&lt;name&gt;&#39;)
def get(name):
    controller = UserController()
    record = controller.find(name)
    if record is None:
        abort(404)
    else:
        resp = jsonify(record.toJSON())
        resp.status_code = 200
        return resp

serve(app, host=&#34;0.0.0.0&#34;, port=8080)
</code></pre><h3 id=部署>部署</h3><p><code>FindService</code> 的代码已经准备完毕。除了 REST API 之外，它还有域模型、数据层和应用程序层。下一步是构建此服务，将其容器化，然后部署到 Kubernetes 上。此过程与部署其他服务妹有任何区别，但有一些 Python 特有的步骤。</p><p>在继续前进之前，让我们来看下文件夹和文件结构：</p><pre tabindex=0><code>+ ums-find-service
+ ums
- domain.py
- data.py
- app.py
- Dockerfile
- requirements.txt
- kube-find-deployment.yml
</code></pre><p>如你所见，整个工作文件夹都位于 <code>ums-find-service</code> 下，它包含了 <code>ums</code> 文件夹中的代码和一些配置文件，例如 <code>Dockerfile</code>、<code>requirements.txt</code> 和 <code>kube-find-deployment.yml</code>。</p><p><code>domain.py</code> 包含域模型，<code>data.py</code> 包含 <code>UserRepositoryImpl</code>，<code>app.py</code> 包含剩余代码。我们已经阅读过代码了，现在我们来看看配置文件。</p><p>第一个是 <code>requirements.txt</code>，它声明了 Python 系统需要下载和安装的外部依赖项。我们需要用查找服务中用到的每个外部 Python 模块来填充它。如你所见，我们使用了 MySQL 连接器、Flask 和 Waitress 模块。因此，下面是 <code>requirements.txt</code> 的内容。</p><pre tabindex=0><code>Flask==2.1.1
Flask_RESTful
mysql-connector-python
waitress
</code></pre><p>第二步是在 <code>Dockerfile</code> 中声明 Docker 相关的清单，如下：</p><pre tabindex=0><code>FROM python:3.8-slim-buster

WORKDIR /ums
ADD ums /ums
ADD requirements.txt requirements.txt
RUN pip3 install -r requirements.txt

EXPOSE 8080
ENTRYPOINT [&#34;python&#34;]
CMD [&#34;/ums/app.py&#34;]
</code></pre><p>总的来说，我们使用 Python 3.8 作为基线，除了移动 <code>requirements.txt</code> 之外，我们还将代码从 <code>ums</code> 文件夹移动到 Docker 容器中对应的文件夹中。然后，我们指示容器运行 <code>pip3 install</code> 命令安装对应模块。最后，我们向外暴露 8080 端口（因为 waitress 运行在此端口上）。</p><p>为了运行此服务，我们指示容器使用使用以下命令：</p><pre tabindex=0><code>python /ums/app.py
</code></pre><p>一旦 <code>Dockerfile</code> 准备完成，在 <code>ums-find-service</code> 文件夹中运行以下命令，创建 Docker 镜像：</p><pre tabindex=0><code>docker build -t glarimy/ums-find-service
</code></pre><p>它会创建 Docker 镜像，可以使用以下命令查找镜像：</p><pre tabindex=0><code>docker images
</code></pre><p>尝试将镜像推送到 Docker Hub，你也可以登录到 Docker。</p><pre tabindex=0><code>docker login
docker push glarimy/ums-find-service
</code></pre><p>最后一步是为 Kubernetes 部署构建清单。</p><p>在之前的文章中，我们已经介绍了如何建立 Kubernetes 集群、部署和使用服务的方法。我假设仍然使用之前文章中的清单文件来部署添加服务、MySQL、Kafka 和 Zookeeper。我们只需要将以下内容添加到 <code>kube-find-deployment.yml</code> 文件中：</p><pre tabindex=0><code>apiVersion: apps/v1
kind: Deployment
metadata:
name: ums-find-service
labels:
app: ums-find-service
spec:
replicas: 3
selector:
matchLabels:
app: ums-find-service
template:
metadata:
labels:
app: ums-find-service
spec:
containers:
- name: ums-find-service
image: glarimy/ums-find-service
ports:
- containerPort: 8080
---
apiVersion: v1
kind: Service
metadata:
name: ums-find-service
labels:
name: ums-find-service
spec:
type: LoadBalancer
ports:
- port: 8080
selector:
app: ums-find-service
</code></pre><p>上面清单文件的第一部分声明了 <code>glarimy/ums-find-service</code> 镜像的 <code>FindService</code>，它包含三个副本。它还暴露 8080 端口。清单的后半部分声明了一个 Kubernetes 服务作为 <code>FindService</code> 部署的前端。请记住，在之前文章中，mysqldb 服务已经是上述清单的一部分了。</p><p>运行以下命令在 Kubernetes 集群上部署清单文件：</p><pre tabindex=0><code>kubectl create -f kube-find-deployment.yml
</code></pre><p>部署完成后，可以使用以下命令验证容器组和服务：</p><pre tabindex=0><code>kubectl get services
</code></pre><p>输出如图 3 所示：</p><p><img src=/data/attachment/album/202210/19/124500tffukqizzoqqtpf2.png alt="图 3: Kubernetes 服务"></p><p>它会列出集群上运行的所有服务。注意查找服务的外部 IP，使用 <code>curl</code> 调用此服务：</p><pre tabindex=0><code>curl http://10.98.45.187:8080/user/KrishnaMohan
</code></pre><p>注意：10.98.45.187 对应查找服务，如图 3 所示。</p><p>如果我们使用 <code>AddService</code> 创建一个名为 <code>KrishnaMohan</code> 的用户，那么上面的 <code>curl</code> 命令看起来如图 4 所示：</p><p><img src=/data/attachment/album/202210/19/124500fv3z4uithciei4in.png alt="图 4: 查找服务"></p><p>用户管理系统（UMS）的体系结构包含 <code>AddService</code> 和 <code>FindService</code>，以及存储和消息传递所需的后端服务，如图 5 所示。可以看到终端用户使用 <code>ums-add-service</code> 的 IP 地址添加新用户，使用 <code>ums-find-service</code> 的 IP 地址查找已有用户。每个 Kubernetes 服务都由三个对应容器的节点支持。还要注意：同样的 mysqldb 服务用于存储和检索用户数据。</p><p><img src=/data/attachment/album/202210/19/124500eu85ibyzdy7tutuj.png alt="图 5: UMS 的添加服务和查找服务"></p><h3 id=其他服务>其他服务</h3><p>UMS 系统还包含两个服务：<code>SearchService</code> 和 <code>JournalService</code>。在本系列的下一部分中，我们将在 Node 平台上设计这些服务，并将它们部署到同一个 Kubernetes 集群，以演示多语言微服务架构的真正魅力。最后，我们将观察一些与微服务相关的设计模式。</p><hr><p>via: <a href=https://www.opensourceforu.com/2022/09/python-microservices-using-flask-on-kubernetes/>https://www.opensourceforu.com/2022/09/python-microservices-using-flask-on-kubernetes/</a></p><p>作者：<a href=https://www.opensourceforu.com/author/krishna-mohan-koyya/>Krishna Mohan Koyya</a> 选题：<a href=https://github.com/lkxed>lkxed</a> 译者：<a href=https://github.com/MjSeven>MjSeven</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/ rel=tag>微服务</a></li><li class=tags__item><a class="tags__link btn" href=/tags/python/ rel=tag>Python</a></li><li class=tags__item><a class="tags__link btn" href=/tags/flask/ rel=tag>Flask</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>