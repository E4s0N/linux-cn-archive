<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>10个 Linux/Unix下 Bash 和 KSH shell 的作业控制实例 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="10个 Linux/Unix下 Bash 和 KSH shell 的作业控制实例"><meta property="og:description" content="Linux 和 Unix 属于多任务的操作系统，也就是说一个系统在同一时间段内能运行多重任务(进程)。在这个新的博客系列，我将会列出相关的 Linux 和 Unix 作业（job）控制的命令，你可以通过这些命令在 Bash 或 Korn 还有 &mldr;"><meta property="og:type" content="article"><meta property="og:url" content="/article-2680-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2014-03-13T10:29:00+00:00"><meta property="article:modified_time" content="2014-03-13T10:29:00+00:00"><meta itemprop=name content="10个 Linux/Unix下 Bash 和 KSH shell 的作业控制实例"><meta itemprop=description content="Linux 和 Unix 属于多任务的操作系统，也就是说一个系统在同一时间段内能运行多重任务(进程)。在这个新的博客系列，我将会列出相关的 Linux 和 Unix 作业（job）控制的命令，你可以通过这些命令在 Bash 或 Korn 还有 &mldr;"><meta itemprop=datePublished content="2014-03-13T10:29:00+00:00"><meta itemprop=dateModified content="2014-03-13T10:29:00+00:00"><meta itemprop=wordCount content="703"><meta itemprop=keywords content="Linux,Unix,Bash,KSH,POSIX,shell,作业控制,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>10个 Linux/Unix下 Bash 和 KSH shell 的作业控制实例</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-03-13T10:29:00Z>March 13, 2014</time></div></div></header><div class="content post__content clearfix"><p><img src=/data/attachment/album/201403/13/102928m2z2n364a66vua66.jpg alt></p><p>Linux 和 Unix 属于多任务的操作系统，也就是说一个系统在同一时间段内能运行多重任务(进程)。在这个新的博客系列，我将会列出相关的 Linux 和 Unix 作业（job）控制的命令，你可以通过这些命令在 Bash 或 Korn 还有 POSIX shell 下实现执行多重任务。</p><h3 id=什么是作业控制>什么是作业控制？</h3><p>作业控制不只是能够停止/挂起(stop/suspend)正在执行的进程(命令)，也可以继续/唤醒(continue/resume)执行你需要的每一个进程。这完全可以用你的操作系统和 bash/ksh 之类的 shell 或 POSIX shell 完成。</p><h3 id=谁给作业控制的提供了环境>谁给作业控制的提供了环境？</h3><p>Bash / Korn shell，或者是 POSIX shell 提供给了作业控制的环境。</p><h3 id=跟作业表打个招呼吧>跟作业表打个招呼吧</h3><p>你的 shell 会留有一张当前作业的表单，称为作业表。当你键入命令时，shell 会给它分配一个 jobID(也称作 JOB<em>SPEC)。一个 jobID 或 JOB</em>SPEC只是很小的整数数值。</p><h3 id=1-创建你的首个-linuxunix-作业>#1: 创建你的首个 Linux/Unix 作业</h3><p>我要运行一个名为 xeyes 的命令，它会在屏幕上显示两个椭圆的眼睛,输入： $ xeyes &</p><p>输出样例：</p><p><a href=http://www.cyberciti.biz/howto/unix-linux-job-control-command-list-for-bash-ksh-shell/attachment/run-xeyes-command-in-background/><img src=/data/attachment/album/201403/13/102929zi14vzpkp937d1mm.jpg alt></a></p><p><em>Fig.01: 在后台运行 xeyes 命令</em></p><p>我使用&符号让一个 job 在后台运行。shell 会打印一行信息类似如下:</p><pre tabindex=0><code>[1] 6891
</code></pre><p>在这个例子中，有两个数字输出，分别表示：</p><ul><li><a href=http://www.cyberciti.biz/faq/unix-linux-jobs-command-examples-usage-syntax/>1</a> : 在后台执行的 xeyes 任务的作业号为 1。</li><li>6891 : 作业1的进程ID。</li></ul><p>我在多执行一些 job:</p><pre tabindex=0><code>## 启动一个文本编辑器，X 的系统负载显示，和 sleep 命令 ##
gedit /tmp/hello.c &amp;
xload &amp;
sleep 100000 &amp;
</code></pre><h3 id=2-列出当前的作业>#2: 列出当前的作业</h3><p>要<a href=http://www.cyberciti.biz/faq/unix-linux-jobs-command-examples-usage-syntax/>查看当前 shell 的激活的任务状态</a>，输入：</p><pre tabindex=0><code>$ jobs
$ jobs -l
</code></pre><p>输出如下:</p><pre tabindex=0><code>[1]   9379 Running                 xeyes &amp;
[2]   9380 Running                 gedit /tmp/hello.c &amp;
[3]-  9420 Running                 xload &amp;
[4]+  9421 Running                 sleep 100000 &amp;
</code></pre><p>简要描述如下：</p><table><thead><tr><th>字段</th><th>值</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>1</td><td>[1]</td><td><strong>jobID</strong> 或 <strong>JOB_SPEC</strong> - 工作号要与fg, bg, wait, kill和其他shell命令一起使用。你必须在工作号前缀添加一个百分号：(<code>**%**</code>)。加号 (<code>+</code>) 标识着默认的或是现在的作业。减号 (<code>-</code>) 标识着前一个作业。</td><td><code>%1``fg %1``kill %2</code></td></tr><tr><td>2</td><td>9379</td><td><strong>进程 ID</strong> - 系统自动为每个进程创建并分配地独有的身份标志号。</td><td>kill 9379</td></tr><tr><td>3</td><td>Running</td><td><strong>状态</strong> - 关于作业的状态:<code>**Running**</code> - 该 作业正在运行,还没有被外部信号挂起。<code>**Stopped**</code> - 该作业已经被挂起。</td><td>N/A</td></tr><tr><td>4</td><td>xeyes &</td><td><strong>command</strong> - 由shell给出的命令。</td><td>script &amp;firefox url&</td></tr></tbody></table><p>你也可以用 ps 命名列出当前系统正在运行的进程:</p><pre tabindex=0><code>$ ps
</code></pre><h3 id=3-停止或挂起正在运行的作业>#3: 停止或挂起正在运行的作业</h3><p>按下[Ctrl]-[Z]键或使用<a href=http://www.cyberciti.biz/faq/unix-kill-command-examples/>kill 命令</a>,如下所示：</p><pre tabindex=0><code>kill -s stop PID
</code></pre><p>举个例子，启动<a href=http://www.cyberciti.biz/faq/unix-ping-command-examples/>ping 命令</a>，然后用 Ctrl-Z 键来停止 ping 命令作业：</p><p><a href=http://www.cyberciti.biz/howto/unix-linux-job-control-command-list-for-bash-ksh-shell/attachment/suspend-unix-job-command/><img src=/data/attachment/album/201403/13/102931y9nquzs59x5yyy9y.gif alt></a></p><p><em>Animated gif 01: 挂起 ping 命令作业</em></p><h3 id=4-在前台恢复-挂起的停止的作业>#4: 在前台恢复 挂起的/停止的作业</h3><p>让我们<a href=http://www.cyberciti.biz/faq/unix-linux-fg-command-examples-usage-syntax/>恢复处于停止状态下的作业，让它回到前台继续运行</a>，要将其变成当前作业，必须借助<a href=http://www.cyberciti.biz/faq/unix-linux-fg-command-examples-usage-syntax/>fg 命令</a>。具体语法如下：</p><pre tabindex=0><code>## ping 命令的作业号的值为5 ##
fg %5
</code></pre><p>我也可以规定命令行开端符合字符串"ping"的作业[译注：不能出现不明确的字符串，例如如果后台有两个 vim 进程而你敲入 fg %vim 会报错。]:</p><pre tabindex=0><code>## %String ##
fg %ping
</code></pre><p>输出样例：</p><pre tabindex=0><code>64 bytes from www.cyberciti.biz (75.126.153.206): icmp_req=3 ttl=53 time=265 ms
64 bytes from www.cyberciti.biz (75.126.153.206): icmp_req=4 ttl=53 time=249 ms
64 bytes from www.cyberciti.biz (75.126.153.206): icmp_req=5 ttl=53 time=267 ms
^C
</code></pre><h3 id=5-在后台恢复-挂起停止状态的作业>#5: 在后台恢复 挂起/停止状态的作业</h3><p>在这个例子中，我使用<a href=http://www.cyberciti.biz/faq/rhel-centos-fedora-linux-yum-command-howto/>yum 命令</a>更新所有安装在 Redhat 或 CentOS Linux 生产服务器上的软件包并置于后台作业。</p><pre tabindex=0><code># yum -y update &amp;&gt;/root/patch.log &amp;
</code></pre><p>然而，由于一些原因(例如,过载问题)我决定停止这个作业20分钟：</p><pre tabindex=0><code># kill -s stop %yum
</code></pre><p>输出样例：</p><pre tabindex=0><code>[7]+  Stopped                 yum -y update &amp;&gt;/root/patch.log &amp;
</code></pre><p>用 bg 重启停止在后台的 yum 进程</p><p>现在，我将要<a href=http://www.cyberciti.biz/faq/unix-linux-bg-command-examples-usage-syntax/>恢复停止的 yum -y update &>/root/patch.log & 作业</a>，键入：</p><pre tabindex=0><code># bg %7
</code></pre><p>或者：</p><pre tabindex=0><code># bg %yum
</code></pre><p>输出样例：</p><pre tabindex=0><code>[7]+ yum -y update &amp;&gt;/root/patch.log &amp;
</code></pre><h3 id=6-杀死作业进程>#6: 杀死作业/进程</h3><p>杀死<a href=http://www.cyberciti.biz/faq/rhel-centos-fedora-linux-yum-command-howto/>yum 命令</a>进程，输入如下<a href=http://www.cyberciti.biz/faq/unix-kill-command-examples/>kill 命令</a>及其作业号 7：</p><pre tabindex=0><code># kill %7
</code></pre><p>或者</p><pre tabindex=0><code># kill 进程ID
</code></pre><p>输出样例：</p><pre tabindex=0><code>[7]+  Terminated              yum -y update &amp;&gt;/root/patch.log &amp;
</code></pre><p>在 Linux/FreeBSD/OS X Unix 下你也可以<a href=http://www.cyberciti.biz/faq/unix-linux-killall-command-examples-usage-syntax/>使用 killall 命令通过名字杀死进程或是 jobID 而不是通过 PID</a></p><h3 id=7-为什么当我登出后-shell-会清除我的所有后台作业>#7 为什么当我登出后 shell 会清除我的所有后台作业</h3><p>在这个例子中,我将会启动 pdfwriter.py 来批量生成<a href=http://www.cyberciti.biz/faq/>这个站点</a>的 pdf 文件:</p><pre tabindex=0><code>~/scripts/www/pdfwriter.py --profile=faq --type=clean --header=logo\
--footer-left &#34;nixCraft is GIT UL++++ W+++ C++++ M+ e+++ d-&#34; \
--footer-right &#34;Page [of] of [total]&#34; &amp;
</code></pre><p>一旦当我登出shell时，pdfwriter.py 作业就会被我的 shell 杀死。为了克服这个问题需要使用<a href=http://www.cyberciti.biz/faq/unix-linux-disown-command-examples-usage-syntax/>shell的内置命令 disown 来告诉 shell 不要发送 HUP 信号</a>,键入：</p><pre tabindex=0><code>$ ~/scripts/www/pdfwriter.py --profile=faq .... &amp;
$ disown
$ exit
</code></pre><h3 id=8-使用一个名为-nohup-的外部命令阻止在登出时杀死作业>#8 使用一个名为 nohup 的外部命令阻止在登出时杀死作业</h3><p>你也可以使用<a href=http://www.cyberciti.biz/tips/nohup-execute-commands-after-you-exit-from-a-shell-prompt.html>nohup 命令在你退出 shell 后执行作业</a>:</p><pre tabindex=0><code>$ nohup ~/scripts/www/pdfwriter.py --profile=faq .... &amp;
$ exit
</code></pre><h3 id=9-查找最后的作业的-pid>#9: 查找最后的作业的 PID</h3><p>为了查找最近在后台执行的(异步)命令的进程ID，可使用 bash shell 的特殊参数 $!</p><pre tabindex=0><code>$ gedit foo.txt &amp;
$ echo &#34;最近在后台执行的job 的PID - $!&#34; 
</code></pre><p>输出样例：</p><pre tabindex=0><code>最近在后台执行的job 的PID - 9421
</code></pre><h3 id=10-等候作业完成>#10: 等候作业完成</h3><p>wait 命令会等候给予的进程ID 或 作业ID指定的进程，然后报告它的终止状态。语法如下：</p><pre tabindex=0><code>/path/to/large-job/command/foo &amp;
wait $!
/path/to/next/job/that-is-dependents/on-foo-command/bar
</code></pre><p>这是我的一个工作脚本：</p><pre tabindex=0><code>#!/bin/bash
# A shell script wrapper to create pdf files for our blog/faq section
########################################################################
# init() - Must be run first 
# Purpose - Create index file in $_tmp for all our wordpress databases 
########################################################################
init(){
 _php=&#34;/usr/bin/php&#34;
 _phpargs=&#34;-d apc.enabled=0&#34;
 _base=&#34;~/scripts&#34;
 _tmp=&#34;$_base/tmp&#34;
 _what=&#34;$1&#34;
 for i in $_what
 do
        [[ ! -d &#34;$_tmp/$i&#34; ]] &amp;&amp; /bin/mkdir &#34;$_tmp/$i&#34;
        $_php $_phpargs -f &#34;$_base/php/rawsqlmaster${i}.php&#34; &gt;  &#34;$_tmp/$i/output.txt&#34;
 done
}

#####################################################
# Without index file, we can out generate pdf files
#####################################################
init blog

###########################################################
# Do not run the rest of the script until init() finished
###########################################################
wait $!

## Alright, create pdf files 
~/scripts/www/pdfwriter.py --profile=blog --type=clean --header=logo\
--footer-left &#34;nixCraft is GIT UL++++ W+++ C++++ M+ e+++ d-&#34; \
--footer-right &#34;Page [of] of [total]&#34;
</code></pre><h4 id=linux-和-unix-作业控制命令总结列表>Linux 和 Unix 作业控制命令总结列表</h4><table><thead><tr><th>命令</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td><code>**&**</code></td><td>将作业置入后台</td><td><code>命令 &</code></td></tr><tr><td><code>**%n**</code></td><td>设置作业号为 n (数字)的作业</td><td><code>命令 %1</code></td></tr><tr><td><code>**%Word**</code></td><td>引用命令行开端包含 Word 的作业</td><td><code>命令 %yum</code></td></tr><tr><td><code>**%?Word**</code></td><td>引用命令行包含 Word 的作业</td><td><code>命令 %?ping</code></td></tr><tr><td><code>**%%**``**%+**</code></td><td>引用当前作业</td><td><code>kill %%kill %+</code></td></tr><tr><td><code>**%-**</code></td><td>引用先前作业</td><td><code>bg %-</code></td></tr><tr><td><code>**CTRL-Z**</code><strong>kill -s stop jobID</strong>``</td><td>挂起或停止作业</td><td><code>kill -s stop %ping</code></td></tr><tr><td><code>**jobs**</code><strong>jobs -l</strong>``</td><td>列出活动的作业</td><td><code>jobs -l</code></td></tr><tr><td><code>**bg**</code></td><td>将 作业置入后台</td><td><code>bg %1bg %ping</code></td></tr><tr><td><code>**fg**</code></td><td>将作业置入前台</td><td><code>fg %2fg %apt-get</code></td></tr></tbody></table><h3 id=关于-shell-内置命令和外部命令的小注>关于 shell 内置命令和外部命令的小注</h3><p>运行下面的 type 命令找出给予命令是否属于内部或外部的。</p><pre tabindex=0><code>type -a fg bg jobs disown
</code></pre><p>输出样式：</p><pre tabindex=0><code>fg is a shell builtin
fg is /usr/bin/fg
bg is a shell builtin
bg is /usr/bin/bg
jobs is a shell builtin
jobs is /usr/bin/jobs
disown is a shell builtin
</code></pre><p>在几乎所有情况下，你都需要使用 shell 的内置命令。所有外部命令例如 /usr/bin/fg 或 /usr/bin/jobs 工作在一个不同的 shell 环境下，而不能用在父 shell 的环境下。</p><h3 id=总结>总结</h3><p>我希望你能喜欢这篇博文系列(<a href=http://www.cyberciti.biz/tutorials/practical-unixlinux-series/feed/>rss 订阅</a>),我建议你阅读下面的更多信息：</p><ul><li>在我们的 faq 章节查阅有关进程管理的文章<a href=http://www.cyberciti.biz/faq/unix-linux-disown-command-examples-usage-syntax/>disoen 命令示例</a>，<a href=http://www.cyberciti.biz/faq/unix-linux-jobs-command-examples-usage-syntax/>jobs 命令示例</a>，<a href=http://www.cyberciti.biz/faq/unix-linux-bg-command-examples-usage-syntax/>bg 命令示例</a>，和<a href=http://www.cyberciti.biz/faq/unix-linux-fg-command-examples-usage-syntax/>fg 命令示例</a>。</li><li>Man pages <a href=http://www.manpager.com/linux/man1/bash.1.html>bash(1)</a>, <a href=http://www.manpager.com/linux/man1/ksh.1.html>ksh(1)</a>, <a href=http://www.manpager.com/linux/man1/ps.1.html>ps(1)</a>, <a href=http://www.manpager.com/linux/man1/kill.1.html>kill(1)</a></li><li><a href=http://www2.research.att.com/sw/download/man/man1/ksh.html>Korn shell (ksh93) 文档</a>.</li><li><a href=https://www.gnu.org/software/bash/manual/bashref.html>NU bash shell 文档</a>.</li></ul><p>我会计划在这个系列添加更多深入的教程。若果你需要看到具体的主题，请在下方评论让我知道。</p><hr><p>via: <a href=http://www.cyberciti.biz/howto/unix-linux-job-control-command-examples-for-bash-ksh-shell/>http://www.cyberciti.biz/howto/unix-linux-job-control-command-examples-for-bash-ksh-shell/</a></p><p>译者：<a href=https://github.com/Luoxcat>Luoxcat</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创翻译，<a href=http://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/linux/ rel=tag>Linux</a></li><li class=tags__item><a class="tags__link btn" href=/tags/unix/ rel=tag>Unix</a></li><li class=tags__item><a class="tags__link btn" href=/tags/bash/ rel=tag>Bash</a></li><li class=tags__item><a class="tags__link btn" href=/tags/ksh/ rel=tag>KSH</a></li><li class=tags__item><a class="tags__link btn" href=/tags/posix/ rel=tag>POSIX</a></li><li class=tags__item><a class="tags__link btn" href=/tags/shell/ rel=tag>shell</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6/ rel=tag>作业控制</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>