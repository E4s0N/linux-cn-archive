<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>使用 Ansible 的 Kubernetes 模块实现容器编排自动化 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="使用 Ansible 的 Kubernetes 模块实现容器编排自动化"><meta property="og:description" content="将 Kubernetes 与 Ansible 结合实现云端自动化。此外，还可以参照我们的 Ansible 的 k8s 模块速查表。"><meta property="og:type" content="article"><meta property="og:url" content="/article-12766-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-10-28T21:19:13+00:00"><meta property="article:modified_time" content="2020-10-28T21:19:13+00:00"><meta itemprop=name content="使用 Ansible 的 Kubernetes 模块实现容器编排自动化"><meta itemprop=description content="将 Kubernetes 与 Ansible 结合实现云端自动化。此外，还可以参照我们的 Ansible 的 k8s 模块速查表。"><meta itemprop=datePublished content="2020-10-28T21:19:13+00:00"><meta itemprop=dateModified content="2020-10-28T21:19:13+00:00"><meta itemprop=wordCount content="472"><meta itemprop=keywords content="Kubernetes,Ansible,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>使用 Ansible 的 Kubernetes 模块实现容器编排自动化</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2020-10-28T21:19:13Z>October 28, 2020</time></div></div></header><div class="content post__content clearfix"><blockquote><p>将 Kubernetes 与 Ansible 结合实现云端自动化。此外，还可以参照我们的 Ansible 的 k8s 模块速查表。</p></blockquote><p><img src=/data/attachment/album/202010/28/211747jhlttlf3f81xrffi.jpg alt></p><p><a href=https://opensource.com/resources/what-ansible>Ansible</a> 是实现自动化工作的优秀工具，而 <a href=https://opensource.com/resources/what-is-kubernetes>Kubernetes</a> 则是容器编排方面的利器，要是把两者结合起来，会有怎样的效果呢？正如你所猜测的，Ansible + Kubernetes 的确可以实现容器编排自动化。</p><h3 id=ansible-模块>Ansible 模块</h3><p>实际上，Ansible 本身只是一个用于解释 YAML 文件的框架。它真正强大之处在于它<a href=https://docs.ansible.com/ansible/latest/modules/modules_by_category.html>丰富的模块</a>，所谓 模块 module ，就是在 Ansible 剧本 playbook 中让你得以通过简单配置就能调用外部应用程序的一些工具。</p><p>Ansible 中有模块可以直接操作 Kubernetes，也有对一些相关组件（例如 <a href=https://opensource.com/resources/what-docker>Docker</a> 和 <a href=http://podman.io>Podman</a>）实现操作的模块。学习使用一个新模块的过程和学习新的终端命令、API 一样，可以先从文档中了解这个模块在调用的时候需要接受哪些参数，以及这些参数在外部应用程序中产生的具体作用。</p><h3 id=访问-kubernetes-集群>访问 Kubernetes 集群</h3><p>在使用 Ansible Kubernetes 模块之前，先要有能够访问 Kubernetes 集群的权限。在没有权限的情况下，可以尝试使用一个短期在线试用账号，但我们更推荐的是按照 Kubernetes 官网上的指引，或是参考 Braynt Son 《<a href=https://opensource.com/article/18/10/getting-started-minikube>入门 Kubernetes</a>》的教程安装 <a href=https://kubernetes.io/docs/tasks/tools/install-minikube>Minikube</a>。Minikube 提供了一个单节点 Kubernetes 实例的安装过程，你可以像使用一个完整集群一样对其进行配置和交互。</p><ul><li>下载 <a href=https://opensource.com/downloads/ansible-k8s-cheat-sheet>Ansible k8s 速记表</a>（需注册）</li></ul><p>在安装 Minikube 之前，你需要确保你的环境支持虚拟化并安装 <code>libvirt</code>，然后对 <code>libvirt</code> 用户组授权：</p><pre tabindex=0><code>$ sudo dnf install libvirt
$ sudo systemctl start libvirtd
$ sudo usermod --append --groups libvirt `whoami`
$ newgrp libvirt
</code></pre><h4 id=安装-python-模块>安装 Python 模块</h4><p>为了能够在 Ansible 中使用 Kubernetes 相关的模块，你需要安装以下这些 Python 模块：</p><pre tabindex=0><code>$ pip3.6 install kubernetes --user
$ pip3.6 install openshift --user
</code></pre><h4 id=启动-kubernetes>启动 Kubernetes</h4><p>如果你使用的是 Minikube 而不是完整的 Kubernetes 集群，请使用 <code>minikube</code> 命令在本地创建一个最精简化的 Kubernetes 实例：</p><pre tabindex=0><code>$ minikube start --driver=kvm2 --kvm-network default
</code></pre><p>然后等待 Minikube 完成初始化，这个过程所需的时间会因实际情况而异。</p><h3 id=获取集群信息>获取集群信息</h3><p>集群启动以后，通过 <code>cluster-info</code> 选项就可以获取到集群相关信息了：</p><pre tabindex=0><code>$ kubectl cluster-info
Kubernetes master is running at https://192.168.39.190:8443
KubeDNS is running at https://192.168.39.190:8443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy

To further debug and diagnose cluster problems, use &#39;kubectl cluster-info dump&#39;.
</code></pre><h3 id=使用-k8s-模块>使用 k8s 模块</h3><p>Ansible 使用 <code>k8s</code> 这个模块来实现对 Kubernetes 的操作，在剧本中使用 <code>k8s</code> 模块就可以对 Kuvernetes 对象进行管理。这个模块描述了 <code>kubectl</code> 命令的最终状态，例如对于以下这个使用 <code>kubectl</code> 创建新的<a href=https://opensource.com/article/19/10/namespaces-and-containers-linux>命名空间</a>的操作：</p><pre tabindex=0><code>$ kubectl create namespace my-namespace
</code></pre><p>这是一个很简单的操作，而对这个操作的最终状态用 YAML 文件来描述是这样的：</p><pre tabindex=0><code>- hosts: localhost
  tasks:
    - name: create namespace
      k8s:
        name: my-namespace
        api_version: v1
        kind: Namespace
        state: present
</code></pre><p>如果你使用的是 Minikube，那么主机名（<code>hosts</code>）应该定义为 <code>localhost</code>。需要注意的是，所使用的模块也定义了可用参数的语法（例如 <code>api_version</code> 和 <code>kind</code> 参数）。</p><p>在运行这个剧本之前，先通过 <code>yamllint</code> 命令验证是否有错误：</p><pre tabindex=0><code>$ yamllint example.yaml
</code></pre><p>确保没有错误之后，运行剧本：</p><pre tabindex=0><code>$ ansible-playbook ./example.yaml
</code></pre><p>可以验证新的命名空间是否已经被创建出来：</p><pre tabindex=0><code>$ kubectl get namespaces
NAME              STATUS   AGE
default           Active   37h
kube-node-lease   Active   37h
kube-public       Active   37h
kube-system       Active   37h
demo              Active   11h
my-namespace      Active   3s
</code></pre><h3 id=使用-podman-拉取容器镜像>使用 Podman 拉取容器镜像</h3><p>容器是个 Linux 系统，几乎是最小化的，可以由 Kubernetes 管理。<a href=https://www.redhat.com/sysadmin/exploring-containers-lxc>LXC 项目</a>和 Docker 定义了大部分的容器规范。最近加入容器工具集的是 Podman，它不需要守护进程就可以运行，为此受到了很多用户的欢迎。</p><p>通过 Podman 可以从 Docker Hub 或者 <a href=http://Quay.io>Quay.io</a> 等存储库拉取容器镜像。这一操作对应的 Ansible 语法也很简单，只需要将存储库网站提供的镜像路径写在剧本中的相应位置就可以了：</p><pre tabindex=0><code>   - name: pull an image
      podman_image:
        name: quay.io/jitesoft/nginx
</code></pre><p>使用 <code>yamllint</code> 验证：</p><pre tabindex=0><code>$ yamllint example.yaml
</code></pre><p>运行剧本：</p><pre tabindex=0><code>$ ansible-playbook ./example.yaml
[WARNING]: provided hosts list is empty, only localhost is available.
Note that the implicit localhost does not match &#39;all&#39;

PLAY [localhost] ************************

TASK [Gathering Facts] ************************
ok: [localhost]

TASK [create k8s namespace] ************************
ok: [localhost]

TASK [pull an image] ************************
changed: [localhost]

PLAY RECAP ************************
localhost: ok=3 changed=1 unreachable=0 failed=0
           skipped=0 rescued=0 ignored=0
</code></pre><h3 id=使用-ansible-实现部署>使用 Ansible 实现部署</h3><p>Ansible 除了可以执行小型维护任务以外，还可以通过剧本实现其它由 <code>kubectl</code> 实现的功能，因为两者的 YAML 文件之间只有少量的差异。在 Kubernetes 中使用的 YAML 文件只需要稍加改动，就可以在 Ansible 剧本中使用。例如下面这个用于使用 <code>kubectl</code> 命令部署 Web 服务器的 YAML 文件：</p><pre tabindex=0><code>apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-webserver
spec:
  selector:
    matchLabels:
      run: my-webserver
  replicas: 1
  template:
    metadata:
      labels:
        run: my-webserver
    spec:
      containers:
      - name: my-webserver
        image: nginx
        ports:
        - containerPort: 80
</code></pre><p>如果你对其中的参数比较熟悉，你只要把 YAML 文件中的大部分内容放到剧本中的 <code>definition</code> 部分，就可以在 Ansible 中使用了：</p><pre tabindex=0><code>   - name: deploy a web server
      k8s:
        api_version: v1
        namespace: my-namespace
        definition:
          kind: Deployment
          metadata:
            labels:
              app: nginx
            name: nginx-deploy
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: nginx
            template:
              metadata:
                labels:
                  app: nginx
              spec:
                containers:
                  - name: my-webserver
                    image: quay.io/jitesoft/nginx
                    ports:
                      - containerPort: 80
                        protocol: TCP
</code></pre><p>执行完成后，使用 <code>kubectl</code> 命令可以看到预期中的的 部署 deployment ：</p><pre tabindex=0><code>$ kubectl -n my-namespace get pods
NAME                      READY  STATUS
nginx-deploy-7fdc9-t9wc2  1/1    Running
</code></pre><h3 id=在云上使用模块>在云上使用模块</h3><p>随着现在越来越多的开发和部署工作往云上转移的趋势，我们必须了解如何在云上实现自动化。其中 <code>k8s</code> 和 <code>podman_image</code> 这两个模块只是云开发中的其中一小部分。你可以在你的工作流程中寻找一些需要自动化的任务，并学习如何使用 Ansible 让你在这些任务上事半功倍。</p><hr><p>via: <a href=https://opensource.com/article/20/9/ansible-modules-kubernetes>https://opensource.com/article/20/9/ansible-modules-kubernetes</a></p><p>作者：<a href=https://opensource.com/users/seth>Seth Kenlon</a> 选题：<a href=https://github.com/lujun9972>lujun9972</a> 译者：<a href=https://github.com/HankChow>HankChow</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/kubernetes/ rel=tag>Kubernetes</a></li><li class=tags__item><a class="tags__link btn" href=/tags/ansible/ rel=tag>Ansible</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>