<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>如何用 GVM 管理 Go 项目 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="如何用 GVM 管理 Go 项目"><meta property="og:description" content="使用 Go 版本管理器管理多个版本的 Go 语言环境及其模块。"><meta property="og:type" content="article"><meta property="og:url" content="/article-11447-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-10-11T11:22:41+00:00"><meta property="article:modified_time" content="2019-10-11T11:22:41+00:00"><meta itemprop=name content="如何用 GVM 管理 Go 项目"><meta itemprop=description content="使用 Go 版本管理器管理多个版本的 Go 语言环境及其模块。"><meta itemprop=datePublished content="2019-10-11T11:22:41+00:00"><meta itemprop=dateModified content="2019-10-11T11:22:41+00:00"><meta itemprop=wordCount content="483"><meta itemprop=keywords content="Go,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>如何用 GVM 管理 Go 项目</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2019-10-11T11:22:41Z>October 11, 2019</time></div></div></header><div class="content post__content clearfix"><blockquote><p>使用 Go 版本管理器管理多个版本的 Go 语言环境及其模块。</p></blockquote><p><img src=/data/attachment/album/201910/11/112215m48u4zocc7p48okn.png alt></p><p>Go 语言版本管理器（<a href=https://github.com/moovweb/gvm>GVM</a>）是管理 Go 语言环境的开源工具。GVM “pkgsets” 支持安装多个版本的 Go 并管理每个项目的模块。它最初由 <a href=https://github.com/jbussdieker>Josh Bussdieker</a> 开发，GVM（像它的对手 Ruby RVM 一样）允许你为每个项目或一组项目创建一个开发环境，分离不同的 Go 版本和包依赖关系，以提供更大的灵活性，防止不同版本造成的问题。</p><p>有几种管理 Go 包的方式，包括内置于 Go 中的 Go 1.11 的 Modules。我发现 GVM 简单直观，即使我不用它来管理包，我还是会用它来管理 Go 不同的版本的。</p><h3 id=安装-gvm>安装 GVM</h3><p>安装 GVM 很简单。<a href=https://github.com/moovweb/gvm#installing>GVM 存储库</a>安装文档指示你下载安装程序脚本并将其传送到 Bash 来安装:</p><pre tabindex=0><code>bash &lt; &lt;(curl -s -S -L https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer)
</code></pre><p>尽管越来越多的人采用这种安装方法，但是在安装之前先看看安装程序在做什么仍然是一个很好的想法。以 GVM 为例，该安装程序脚本:</p><ol><li>检查一些相关依赖性</li><li>克隆 GVM 存储库</li><li>使用 shell 脚本：<ul><li>安装 Go 语言</li><li>管理 <code>GOPATH</code> 环境变量</li><li>向 <code>bashrc</code>、<code>zshrc</code> 或配置文件中添加一行内容</li></ul></li></ol><p>如果你想确认它在做什么，你可以克隆该存储库并查看 shell 脚本，然后运行 <code>./binscripts/gvm-installer</code> 这个本地脚本进行设置。</p><p><code>注意：</code> 因为 GVM 可以用来下载和编译新的 Go 版本，所以有一些预期的依赖关系，如 Make、Git 和 Curl。你可以在 <a href=https://github.com/moovweb/gvm/blob/master/README.md>GVM 的自述文件</a>中找到完整的发行版列表。</p><h3 id=使用-gvm-安装和管理-go-版本>使用 GVM 安装和管理 GO 版本</h3><p>一旦安装了 GVM，你就可以使用它来安装和管理不同版本的 Go。<code>gvm listall</code> 命令显示可下载和编译的可用版本的 Go：</p><pre tabindex=0><code>[chris@marvin ]$ gvm listall

gvm gos (available)

   go1
   go1.0.1
   go1.0.2
   go1.0.3

&lt;输出截断&gt;
</code></pre><p>安装特定的 Go 版本就像 <code>gvm install &lt;版本></code> 一样简单，其中 <code>&lt;版本></code> 是 <code>gvm listall</code> 命令返回的版本之一。</p><p>假设你正在进行一个使用 Go1.12.8 版本的项目。你可以使用 <code>gvm install go1.12.8</code> 安装这个版本:</p><pre tabindex=0><code>[chris@marvin]$ gvm install go1.12.8
Installing go1.12.8...
 * Compiling...
go1.12.8 successfully installed!
</code></pre><p>输入 <code>gvm list</code>，你会看到 Go 版本 1.12.8 与系统 Go 版本（使用操作系统的软件包管理器打包的版本）一起并存：</p><pre tabindex=0><code>[chris@marvin]$ gvm list

gvm gos (installed)

   go1.12.8
=&gt; system
</code></pre><p>GVM 仍在使用系统版本的 Go ，由 <code>=></code> 符号表示。你可以使用 <code>gvm use</code> 命令切换你的环境以使用新安装的 go1.12.8：</p><pre tabindex=0><code>[chris@marvin]$ gvm use go1.12.8
Now using version go1.12.8

[chris@marvin]$ go version
go version go1.12.8 linux/amd64
</code></pre><p>GVM 使管理已安装版本的 Go 变得极其简单，但它不止于此！</p><h3 id=使用-gvm-pkgset>使用 GVM pkgset</h3><p>开箱即用，Go 有一种出色而令人沮丧的管理包和模块的方式。默认情况下，如果你 <code>go get</code> 获取一个包，它将被下载到 <code>$GOPATH</code> 目录中的 <code>src</code> 和 <code>pkg</code> 目录下，然后可以使用 <code>import</code> 将其包含在你的 Go 程序中。这使得获得软件包变得很容易，特别是对于非特权用户，而不需要 <code>sudo</code> 或 root 特权（很像 Python 中的 <code>pip install --user</code>）。然而，在不同的项目中管理相同包的不同版本是非常困难的。</p><p>有许多方法可以尝试修复或缓解这个问题，包括实验性 Go Modules（Go 1.11 版中增加了初步支持）和 <a href=https://golang.github.io/dep/>Go dep</a>（Go Modules 的“官方实验”并且持续迭代）。在我发现 GVM 之前，我会在一个 Go 项目自己的 Docker 容器中构建和测试它，以确保分离。</p><p>GVM 通过使用 “pkgsets” 将项目的新目录附加到安装的 Go 版本的默认 <code>$GOPATH</code> 上，很好地实现了项目之间包的管理和隔离，就像 <code>$PATH</code> 在 Unix/Linux 系统上工作一样。</p><p>想象它如何运行的。首先，安装新版 Go 1.12.9：</p><pre tabindex=0><code>[chris@marvin]$ echo $GOPATH
/home/chris/.gvm/pkgsets/go1.12.8/global

[chris@marvin]$ gvm install go1.12.9
Installing go1.12.9...
 * Compiling...
go1.12.9 successfully installed

[chris@marvin]$ gvm use go1.12.9
Now using version go1.12.9
</code></pre><p>当 GVM 被告知使用新版本时，它会更改为新的 <code>$GOPATH</code>，默认 <code>gloabl</code> pkgset 应用于该版本:</p><pre tabindex=0><code>[chris@marvin]$ echo $GOPATH
/home/chris/.gvm/pkgsets/go1.12.9/global

[chris@marvin]$ gvm pkgset list

gvm go package sets (go1.12.9)

=&gt;  global
</code></pre><p>尽管默认情况下没有安装额外的包，但是全局 pkgset 中的包对于使用该特定版本的 Go 的任何项目都是可用的。</p><p>现在，假设你正在启用一个新项目，它需要一个特定的包。首先，使用 GVM 创建一个新的 pkgset，名为 <code>introToGvm</code>:</p><pre tabindex=0><code>[chris@marvin]$ gvm pkgset create introToGvm

[chris@marvin]$ gvm pkgset use introToGvm
Now using version go1.12.9@introToGvm

[chris@marvin]$ gvm pkgset list

gvm go package sets (go1.12.9)

    global
=&gt;  introToGvm
</code></pre><p>如上所述，pkgset 的一个新目录被添加到 <code>$GOPATH</code>：</p><pre tabindex=0><code>[chris@marvin]$ echo $GOPATH
/home/chris/.gvm/pkgsets/go1.12.9/introToGvm:/home/chris/.gvm/pkgsets/go1.12.9/global
</code></pre><p>将目录更改为预先设置的 <code>introToGvm</code> 路径，检查目录结构，这里使用 <code>awk</code> 和 <code>bash</code> 完成。</p><pre tabindex=0><code>[chris@marvin]$ cd $( awk -F&#39;:&#39; &#39;{print $1}&#39; &lt;&lt;&lt; $GOPATH )
[chris@marvin]$ pwd
/home/chris/.gvm/pkgsets/go1.12.9/introToGvm

[chris@marvin]$ ls
overlay  pkg  src
</code></pre><p>请注意，新目录看起来很像普通的 <code>$GOPATH</code>。新的 Go 包使用同样的 <code>go get</code> 命令下载并正常使用，且添加到 pkgset 中。</p><p>例如，使用以下命令获取 <code>gorilla/mux</code> 包，然后检查 pkgset 的目录结构：</p><pre tabindex=0><code>[chris@marvin]$ go get github.com/gorilla/mux
[chris@marvin]$ tree
[chris@marvin introToGvm ]$ tree
.
├── overlay
│   ├── bin
│   └── lib
│       └── pkgconfig
├── pkg
│   └── linux_amd64
│       └── github.com
│           └── gorilla
│               └── mux.a
src/
└── github.com
    └── gorilla
        └── mux
            ├── AUTHORS
            ├── bench_test.go
            ├── context.go
            ├── context_test.go
            ├── doc.go
            ├── example_authentication_middleware_test.go
            ├── example_cors_method_middleware_test.go
            ├── example_route_test.go
            ├── go.mod
            ├── LICENSE
            ├── middleware.go
            ├── middleware_test.go
            ├── mux.go
            ├── mux_test.go
            ├── old_test.go
            ├── README.md
            ├── regexp.go
            ├── route.go
            └── test_helpers.go
</code></pre><p>如你所见，<code>gorilla/mux</code> 已按预期添加到 pkgset <code>$GOPATH</code> 目录中，现在可用于使用此 pkgset 项目了。</p><h3 id=gvm-让-go-管理变得轻而易举>GVM 让 Go 管理变得轻而易举</h3><p>GVM 是一种直观且非侵入性的管理 Go 版本和包的方式。它可以单独使用，也可以与其他 Go 模块管理技术结合使用并利用 GVM Go 版本管理功能。按 Go 版本和包依赖来分离项目使得开发更加容易，并且减少了管理版本冲突的复杂性，GVM 让这变得轻而易举。</p><hr><p>via: <a href=https://opensource.com/article/19/10/introduction-gvm>https://opensource.com/article/19/10/introduction-gvm</a></p><p>作者：<a href=https://opensource.com/users/clcollins>Chris Collins</a> 选题：<a href=https://github.com/lujun9972>lujun9972</a> 译者：<a href=https://github.com/heguangzhi>heguangzhi</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/go/ rel=tag>Go</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>