<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>使用 GitHub 和 Python 实现持续部署 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="使用 GitHub 和 Python 实现持续部署"><meta property="og:description" content="这篇教程将展示如何使用 Python 和 Flask 框架来搭建一个简单的持续部署（CD）服务。"><meta property="og:type" content="article"><meta property="og:url" content="/article-9550-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-04-15T23:27:47+00:00"><meta property="article:modified_time" content="2018-04-15T23:27:47+00:00"><meta itemprop=name content="使用 GitHub 和 Python 实现持续部署"><meta itemprop=description content="这篇教程将展示如何使用 Python 和 Flask 框架来搭建一个简单的持续部署（CD）服务。"><meta itemprop=datePublished content="2018-04-15T23:27:47+00:00"><meta itemprop=dateModified content="2018-04-15T23:27:47+00:00"><meta itemprop=wordCount content="365"><meta itemprop=keywords content="持续集成,GitHub,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>使用 GitHub 和 Python 实现持续部署</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2018-04-15T23:27:47Z>April 15, 2018</time></div></div></header><div class="content post__content clearfix"><p><img src=/data/attachment/album/201804/15/232751wtiet561e925o5io.jpg alt></p><p>借助 GitHub 的 网络钩子 webhook ，开发者可以创建很多有用的服务。从触发一个 Jenkins 实例上的 CI（持续集成） 任务到配置云中的机器，几乎有着无限的可能性。这篇教程将展示如何使用 Python 和 Flask 框架来搭建一个简单的持续部署（CD）服务。</p><p>在这个例子中的持续部署服务是一个简单的 Flask 应用，其带有接受 GitHub 的 网络钩子 webhook 请求的 REST 端点 endpoint 。在验证每个请求都来自正确的 GitHub 仓库后，服务器将 拉取 pull 更改到仓库的本地副本。这样每次一个新的 提交 commit 推送到远程 GitHub 仓库，本地仓库就会自动更新。</p><h3 id=flask-web-服务>Flask web 服务</h3><p>用 Flask 搭建一个小的 web 服务非常简单。这里可以先看看项目的结构。</p><pre tabindex=0><code>├── app
│   ├── __init__.py
│   └── webhooks.py
├── requirements.txt
└── wsgi.py
</code></pre><p>首先，创建应用。应用代码在 <code>app</code> 目录下。</p><p>两个文件（<code>__init__.py</code> 和 <code>webhooks.py</code>）构成了 Flask 应用。前者包含有创建 Flask 应用并为其添加配置的代码。后者有 端点 endpoint 逻辑。这是该应用接收 GitHub 请求数据的地方。</p><p>这里是 <code>app/__init__.py</code> 的内容：</p><pre tabindex=0><code>import os
from flask import Flask

from .webhooks import webhook

def create_app():
 &#34;&#34;&#34; Create, configure and return the Flask application &#34;&#34;&#34;

  app = Flask(__name__)
  app.config[&#39;GITHUB_SECRET&#39;] = os.environ.get(&#39;GITHUB_SECRET&#39;)
  app.config[&#39;REPO_PATH&#39;] = os.environ.get(&#39;REPO_PATH&#39;)
  app.register_blueprint(webhook)

  return(app)
</code></pre><p>该函数创建了两个配置变量：</p><ul><li><code>GITHUB_SECRET</code> 保存一个密码，用来认证 GitHub 请求。</li><li><code>REPO_PATH</code> 保存了自动更新的仓库路径。</li></ul><p>这份代码使用 Flask 蓝图 Flask Blueprints 来组织应用的 端点 endpoint 。使用蓝图可以对 API 进行逻辑分组，使应用程序更易于维护。通常认为这是一种好的做法。</p><p>这里是 <code>app/webhooks.py</code> 的内容：</p><pre tabindex=0><code>import hmac
from flask import request, Blueprint, jsonify, current_app 
from git import Repo

webhook = Blueprint(&#39;webhook&#39;, __name__, url_prefix=&#39;&#39;)

@webhook.route(&#39;/github&#39;, methods=[&#39;POST&#39;]) 
def handle_github_hook(): 
 &#34;&#34;&#34; Entry point for github webhook &#34;&#34;&#34;

  signature = request.headers.get(&#39;X-Hub-Signature&#39;) 
  sha, signature = signature.split(&#39;=&#39;)

  secret = str.encode(current_app.config.get(&#39;GITHUB_SECRET&#39;))

  hashhex = hmac.new(secret, request.data, digestmod=&#39;sha1&#39;).hexdigest()
  if hmac.compare_digest(hashhex, signature): 
    repo = Repo(current_app.config.get(&#39;REPO_PATH&#39;)) 
    origin = repo.remotes.origin 
    origin.pull(&#39;--rebase&#39;)

    commit = request.json[&#39;after&#39;][0:6]
    print(&#39;Repository updated with commit {}&#39;.format(commit))
  return jsonify({}), 200
</code></pre><p>首先代码创建了一个新的蓝图 <code>webhook</code>。然后它使用 Flask <code>route</code> 为蓝图添加了一个端点。任何请求 <code>/GitHub</code> URL 端点的 POST 请求都将调用这个路由。</p><h4 id=验证请求>验证请求</h4><p>当服务在该端点上接到请求时，首先它必须验证该请求是否来自 GitHub 以及来自正确的仓库。GitHub 在请求头的 <code>X-Hub-Signature</code> 中提供了一个签名。该签名由一个密码（<code>GITHUB_SECRET</code>），请求体的 HMAC 十六进制摘要，并使用 <code>sha1</code> 哈希生成。</p><p>为了验证请求，服务需要在本地计算签名并与请求头中收到的签名做比较。这可以由 <code>hmac.compare_digest</code> 函数完成。</p><h4 id=自定义钩子逻辑>自定义钩子逻辑</h4><p>在验证请求后，现在就可以处理了。这篇教程使用 <a href=https://gitpython.readthedocs.io/en/stable/index.html>GitPython</a> 模块来与 git 仓库进行交互。GitPython 模块中的 <code>Repo</code> 对象用于访问远程仓库 <code>origin</code>。该服务在本地拉取 <code>origin</code> 仓库的最新更改，还用 <code>--rebase</code> 选项来避免合并的问题。</p><p>调试打印语句显示了从请求体收到的短提交哈希。这个例子展示了如何使用请求体。更多关于请求体的可用数据的信息，请查询 <a href=https://developer.github.com/v3/activity/events/types/#webhook-payload-example-26>GitHub 文档</a>。</p><p>最后该服务返回了一个空的 JSON 字符串和 200 的状态码。这用于告诉 GitHub 的网络钩子服务已经收到了请求。</p><h3 id=部署服务>部署服务</h3><p>为了运行该服务，这个例子使用 <a href=http://gunicorn.org/>gunicorn</a> web 服务器。首先安装服务依赖。在支持的 Fedora 服务器上，以 <a href=https://fedoramagazine.org/howto-use-sudo/>sudo</a> 运行这条命令:</p><pre tabindex=0><code>sudo dnf install python3-gunicorn python3-flask python3-GitPython
</code></pre><p>现在编辑 gunicorn 使用的 <code>wsgi.py</code> 文件来运行该服务：</p><pre tabindex=0><code>from app import create_app
application = create_app()
</code></pre><p>为了部署服务，使用以下命令克隆这个 git <a href=https://github.com/cverna/github_hook_deployment.git>仓库</a>或者使用你自己的 git 仓库：</p><pre tabindex=0><code>git clone https://github.com/cverna/github_hook_deployment.git /opt/
</code></pre><p>下一步是配置服务所需的环境变量。运行这些命令：</p><pre tabindex=0><code>export GITHUB_SECRET=asecretpassphraseusebygithubwebhook
export REPO_PATH=/opt/github_hook_deployment/
</code></pre><p>这篇教程使用网络钩子服务的 GitHub 仓库，但你可以使用你想要的不同仓库。最后，使用这些命令开启该 web 服务：</p><pre tabindex=0><code>cd /opt/github_hook_deployment/
gunicorn --bind 0.0.0.0 wsgi:application --reload
</code></pre><p>这些选项中绑定了 web 服务的 IP 地址为 <code>0.0.0.0</code>，意味着它将接收来自任何的主机的请求。选项 <code>--reload</code> 确保了当代码更改时重启 web 服务。这就是持续部署的魔力所在。每次接收到 GitHub 请求时将拉取仓库的最近更新，同时 gunicore 检测这些更改并且自动重启服务。</p><p>**注意： **为了能接收到 GitHub 请求，web 服务必须部署到具有公有 IP 地址的服务器上。做到这点的简单方法就是使用你最喜欢的云提供商比如 DigitalOcean，AWS，Linode等。</p><h3 id=配置-github>配置 GitHub</h3><p>这篇教程的最后一部分是配置 GitHub 来发送网络钩子请求到 web 服务上。这是持续部署的关键。</p><p>从你的 GitHub 仓库的设置中，选择 Webhook 菜单，并且点击“Add Webhook”。输入以下信息：</p><ul><li>“Payload URL”： 服务的 URL，比如 <code>&lt;http://public_ip_address:8000/github></code></li><li>“Content type”： 选择 “application/json”</li><li>“Secret”： 前面定义的 <code>GITHUB_SECRET</code> 环境变量</li></ul><p>然后点击“Add Webhook” 按钮。</p><p><img src=/data/attachment/album/201804/15/232752i1h2f17zo1777760.png alt></p><p>现在每当该仓库发生推送事件时，GitHub 将向服务发送请求。</p><h3 id=总结>总结</h3><p>这篇教程向你展示了如何写一个基于 Flask 的用于接收 GitHub 的网络钩子请求，并实现持续集成的 web 服务。现在你应该能以本教程作为起点来搭建对自己有用的服务。</p><hr><p>via: <a href=https://fedoramagazine.org/continuous-deployment-github-python/>https://fedoramagazine.org/continuous-deployment-github-python/</a></p><p>作者：<a href=https://fedoramagazine.org>Clément Verna</a> 选题：<a href=https://github.com/lujun9972>lujun9972</a> 译者：<a href=https://github.com/kimii>kimii</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/ rel=tag>持续集成</a></li><li class=tags__item><a class="tags__link btn" href=/tags/github/ rel=tag>GitHub</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>