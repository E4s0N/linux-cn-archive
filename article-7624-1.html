<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>使用 Python 创建你自己的 Shell （上） - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="使用 Python 创建你自己的 Shell （上）"><meta property="og:description" content="我很想知道一个 shell （像 bash，csh 等）内部是如何工作的。于是为了满足自己的好奇心，我使用 Python 实现了一个名为 yosh （Your Own Shell）的 Shell。"><meta property="og:type" content="article"><meta property="og:url" content="/article-7624-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2016-07-28T11:11:00+00:00"><meta property="article:modified_time" content="2016-07-28T11:11:00+00:00"><meta itemprop=name content="使用 Python 创建你自己的 Shell （上）"><meta itemprop=description content="我很想知道一个 shell （像 bash，csh 等）内部是如何工作的。于是为了满足自己的好奇心，我使用 Python 实现了一个名为 yosh （Your Own Shell）的 Shell。"><meta itemprop=datePublished content="2016-07-28T11:11:00+00:00"><meta itemprop=dateModified content="2016-07-28T11:11:00+00:00"><meta itemprop=wordCount content="431"><meta itemprop=keywords content="shell,python,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>使用 Python 创建你自己的 Shell （上）</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-07-28T11:11:00Z>July 28, 2016</time></div></div></header><div class="content post__content clearfix"><p>我很想知道一个 shell （像 bash，csh 等）内部是如何工作的。于是为了满足自己的好奇心，我使用 Python 实现了一个名为 <strong>yosh</strong> （Your Own Shell）的 Shell。本文章所介绍的概念也可以应用于其他编程语言。</p><p><img src=https://img.linux.net.cn/data/attachment/album/201607/28/111101bqbl5of2qkz2b2ls.jpg alt></p><p>（提示：你可以在<a href=https://github.com/supasate/yosh>这里</a>查找本博文使用的源代码，代码以 MIT 许可证发布。在 Mac OS X 10.11.5 上，我使用 Python 2.7.10 和 3.4.3 进行了测试。它应该可以运行在其他类 Unix 环境，比如 Linux 和 Windows 上的 Cygwin。）</p><p>让我们开始吧。</p><h3 id=步骤-0项目结构>步骤 0：项目结构</h3><p>对于此项目，我使用了以下的项目结构。</p><pre tabindex=0><code>yosh_project
|-- yosh
   |-- __init__.py
   |-- shell.py
</code></pre><p><code>yosh_project</code> 为项目根目录（你也可以把它简单命名为 <code>yosh</code>）。</p><p><code>yosh</code> 为包目录，且 <code>__init__.py</code> 可以使它成为与包的目录名字相同的包（如果你不用 Python 编写的话，可以忽略它。）</p><p><code>shell.py</code> 是我们主要的脚本文件。</p><h3 id=步骤-1shell-循环>步骤 1：Shell 循环</h3><p>当启动一个 shell，它会显示一个命令提示符并等待你的命令输入。在接收了输入的命令并执行它之后（稍后文章会进行详细解释），你的 shell 会重新回到这里，并循环等待下一条指令。</p><p>在 <code>shell.py</code> 中，我们会以一个简单的 main 函数开始，该函数调用了 shell_loop() 函数，如下：</p><pre tabindex=0><code>def shell_loop():
    # Start the loop here

def main():
    shell_loop()

if __name__ == &#34;__main__&#34;:
    main()
</code></pre><p>接着，在 <code>shell_loop()</code> 中，为了指示循环是否继续或停止，我们使用了一个状态标志。在循环的开始，我们的 shell 将显示一个命令提示符，并等待读取命令输入。</p><pre tabindex=0><code>import sys

SHELL_STATUS_RUN = 1
SHELL_STATUS_STOP = 0

def shell_loop():
    status = SHELL_STATUS_RUN

    while status == SHELL_STATUS_RUN:
        ### 显示命令提示符
        sys.stdout.write(&#39;&gt; &#39;)
        sys.stdout.flush()

        ### 读取命令输入
        cmd = sys.stdin.readline()
</code></pre><p>之后，我们 切分命令 （ tokenize ） 输入并进行 执行 （ execute ） （我们即将实现 <code>tokenize</code> 和 <code>execute</code> 函数）。</p><p>因此，我们的 shell_loop() 会是如下这样：</p><pre tabindex=0><code>import sys

SHELL_STATUS_RUN = 1
SHELL_STATUS_STOP = 0

def shell_loop():
    status = SHELL_STATUS_RUN

    while status == SHELL_STATUS_RUN:
        ### 显示命令提示符
        sys.stdout.write(&#39;&gt; &#39;)
        sys.stdout.flush()

        ### 读取命令输入
        cmd = sys.stdin.readline()

        ### 切分命令输入
        cmd_tokens = tokenize(cmd)

        ### 执行该命令并获取新的状态
        status = execute(cmd_tokens)
</code></pre><p>这就是我们整个 shell 循环。如果我们使用 <code>python shell.py</code> 启动我们的 shell，它会显示命令提示符。然而如果我们输入命令并按回车，它会抛出错误，因为我们还没定义 <code>tokenize</code> 函数。</p><p>为了退出 shell，可以尝试输入 ctrl-c。稍后我将解释如何以优雅的形式退出 shell。</p><h3 id=步骤-2ruby-命令切分-rp---rp-rt--tokenize-rt-rp---rpruby>步骤 2： 命令切分 （ tokenize ）</h3><p>当用户在我们的 shell 中输入命令并按下回车键，该命令将会是一个包含命令名称及其参数的长字符串。因此，我们必须切分该字符串（分割一个字符串为多个元组）。</p><p>咋一看似乎很简单。我们或许可以使用 <code>cmd.split()</code>，以空格分割输入。它对类似 <code>ls -a my_folder</code> 的命令起作用，因为它能够将命令分割为一个列表 <code>['ls', '-a', 'my_folder']</code>，这样我们便能轻易处理它们了。</p><p>然而，也有一些类似 <code>echo "Hello World"</code> 或 <code>echo 'Hello World'</code> 以单引号或双引号引用参数的情况。如果我们使用 cmd.spilt，我们将会得到一个存有 3 个标记的列表 <code>['echo', '"Hello', 'World"']</code> 而不是 2 个标记的列表 <code>['echo', 'Hello World']</code>。</p><p>幸运的是，Python 提供了一个名为 <code>shlex</code> 的库，它能够帮助我们如魔法般地分割命令。（提示：我们也可以使用正则表达式，但它不是本文的重点。）</p><pre tabindex=0><code>import sys
import shlex

...

def tokenize(string):
    return shlex.split(string)

...
</code></pre><p>然后我们将这些元组发送到执行进程。</p><h3 id=步骤-3执行>步骤 3：执行</h3><p>这是 shell 中核心而有趣的一部分。当 shell 执行 <code>mkdir test_dir</code> 时，到底发生了什么？（提示： <code>mkdir</code> 是一个带有 <code>test_dir</code> 参数的执行程序，用于创建一个名为 <code>test_dir</code> 的目录。）</p><p><code>execvp</code> 是这一步的首先需要的函数。在我们解释 <code>execvp</code> 所做的事之前，让我们看看它的实际效果。</p><pre tabindex=0><code>import os
...

def execute(cmd_tokens):
    ### 执行命令
    os.execvp(cmd_tokens[0], cmd_tokens)

    ### 返回状态以告知在 shell_loop 中等待下一个命令
    return SHELL_STATUS_RUN

...
</code></pre><p>再次尝试运行我们的 shell，并输入 <code>mkdir test_dir</code> 命令，接着按下回车键。</p><p>在我们敲下回车键之后，问题是我们的 shell 会直接退出而不是等待下一个命令。然而，目录正确地创建了。</p><p>因此，<code>execvp</code> 实际上做了什么？</p><p><code>execvp</code> 是系统调用 <code>exec</code> 的一个变体。第一个参数是程序名字。<code>v</code> 表示第二个参数是一个程序参数列表（参数数量可变）。<code>p</code> 表示将会使用环境变量 <code>PATH</code> 搜索给定的程序名字。在我们上一次的尝试中，它将会基于我们的 <code>PATH</code> 环境变量查找<code>mkdir</code> 程序。</p><p>（还有其他 <code>exec</code> 变体，比如 execv、execvpe、execl、execlp、execlpe；你可以 google 它们获取更多的信息。）</p><p><code>exec</code> 会用即将运行的新进程替换调用进程的当前内存。在我们的例子中，我们的 shell 进程内存会被替换为 <code>mkdir</code> 程序。接着，<code>mkdir</code> 成为主进程并创建 <code>test_dir</code> 目录。最后该进程退出。</p><p>这里的重点在于<strong>我们的 shell 进程已经被 <code>mkdir</code> 进程所替换</strong>。这就是我们的 shell 消失且不会等待下一条命令的原因。</p><p>因此，我们需要其他的系统调用来解决问题：<code>fork</code>。</p><p><code>fork</code> 会分配新的内存并拷贝当前进程到一个新的进程。我们称这个新的进程为<strong>子进程</strong>，调用者进程为<strong>父进程</strong>。然后，子进程内存会被替换为被执行的程序。因此，我们的 shell，也就是父进程，可以免受内存替换的危险。</p><p>让我们看看修改的代码。</p><pre tabindex=0><code>...

def execute(cmd_tokens):
    ### 分叉一个子 shell 进程
    ### 如果当前进程是子进程，其 `pid` 被设置为 `0`
    ### 否则当前进程是父进程的话，`pid` 的值
    ### 是其子进程的进程 ID。
    pid = os.fork()

    if pid == 0:
    ### 子进程
        ### 用被 exec 调用的程序替换该子进程
        os.execvp(cmd_tokens[0], cmd_tokens)
    elif pid &gt; 0:
    ### 父进程
        while True:
            ### 等待其子进程的响应状态（以进程 ID 来查找）
            wpid, status = os.waitpid(pid, 0)

            ### 当其子进程正常退出时
            ### 或者其被信号中断时，结束等待状态
            if os.WIFEXITED(status) or os.WIFSIGNALED(status):
                break

    ### 返回状态以告知在 shell_loop 中等待下一个命令
    return SHELL_STATUS_RUN

...
</code></pre><p>当我们的父进程调用 <code>os.fork()</code> 时，你可以想象所有的源代码被拷贝到了新的子进程。此时此刻，父进程和子进程看到的是相同的代码，且并行运行着。</p><p>如果运行的代码属于子进程，<code>pid</code> 将为 <code>0</code>。否则，如果运行的代码属于父进程，<code>pid</code> 将会是子进程的进程 id。</p><p>当 <code>os.execvp</code> 在子进程中被调用时，你可以想象子进程的所有源代码被替换为正被调用程序的代码。然而父进程的代码不会被改变。</p><p>当父进程完成等待子进程退出或终止时，它会返回一个状态，指示继续 shell 循环。</p><h3 id=运行>运行</h3><p>现在，你可以尝试运行我们的 shell 并输入 <code>mkdir test_dir2</code>。它应该可以正确执行。我们的主 shell 进程仍然存在并等待下一条命令。尝试执行 <code>ls</code>，你可以看到已创建的目录。</p><p>但是，这里仍有一些问题。</p><p>第一，尝试执行 <code>cd test_dir2</code>，接着执行 <code>ls</code>。它应该会进入到一个空的 <code>test_dir2</code> 目录。然而，你将会看到目录并没有变为 <code>test_dir2</code>。</p><p>第二，我们仍然没有办法优雅地退出我们的 shell。</p><p>我们将会在<a href=https://hackercollider.com/articles/2016/07/06/create-your-own-shell-in-python-part-2/>下篇</a>解决诸如此类的问题。</p><hr><p>via: <a href=https://hackercollider.com/articles/2016/07/05/create-your-own-shell-in-python-part-1/>https://hackercollider.com/articles/2016/07/05/create-your-own-shell-in-python-part-1/</a></p><p>作者：<a href=https://disqus.com/by/supasate_choochaisri/>Supasate Choochaisri</a> 译者：<a href=https://github.com/cposture>cposture</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/shell/ rel=tag>shell</a></li><li class=tags__item><a class="tags__link btn" href=/tags/python/ rel=tag>python</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>