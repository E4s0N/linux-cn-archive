<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>grep 命令系列：grep 中的正则表达式 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="grep 命令系列：grep 中的正则表达式"><meta property="og:description" content="Linux 附带有 GNU grep 命令工具，它支持扩展正则表达式extended regular expressions，而且 GNU grep 在所有的 Linux 系统中都是默认有的。Grep 命令被用于搜索定位存储在您服务器或工作站上的任何信息。"><meta property="og:type" content="article"><meta property="og:url" content="/article-6941-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2016-01-27T11:30:00+00:00"><meta property="article:modified_time" content="2016-01-27T11:30:00+00:00"><meta itemprop=name content="grep 命令系列：grep 中的正则表达式"><meta itemprop=description content="Linux 附带有 GNU grep 命令工具，它支持扩展正则表达式extended regular expressions，而且 GNU grep 在所有的 Linux 系统中都是默认有的。Grep 命令被用于搜索定位存储在您服务器或工作站上的任何信息。"><meta itemprop=datePublished content="2016-01-27T11:30:00+00:00"><meta itemprop=dateModified content="2016-01-27T11:30:00+00:00"><meta itemprop=wordCount content="498"><meta itemprop=keywords content="grep,正则表达式,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>grep 命令系列：grep 中的正则表达式</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-01-27T11:30:00Z>January 27, 2016</time></div></div></header><div class="content post__content clearfix"><p>在 Linux 、类 Unix 系统中我该如何使用 Grep 命令的正则表达式呢？</p><p>Linux 附带有 GNU grep 命令工具，它支持 扩展正则表达式 （ extended regular expressions ） ，而且 GNU grep 在所有的 Linux 系统中都是默认有的。Grep 命令被用于搜索定位存储在您服务器或工作站上的任何信息。</p><p><img src=/data/attachment/album/201601/27/113023qx42fw5i561fip1z.jpg alt></p><h3 id=正则表达式>正则表达式</h3><p>正则表达式就是用于匹配每行输入的一种模式，模式是指一串字符序列。下面是范例：</p><pre tabindex=0><code>^w1
w1|w2
[^ ]
</code></pre><h4 id=grep-正则表达式示例>grep 正则表达式示例</h4><p>在 /etc/passswd 目录中搜索 &lsquo;vivek&rsquo;</p><pre tabindex=0><code>grep vivek /etc/passwd
</code></pre><p>输出例子:</p><pre tabindex=0><code>vivek:x:1000:1000:Vivek Gite,,,:/home/vivek:/bin/bash
vivekgite:x:1001:1001::/home/vivekgite:/bin/sh
gitevivek:x:1002:1002::/home/gitevivek:/bin/sh
</code></pre><p>搜索大小写任意的 vivek(即不区分大小写的搜索)</p><pre tabindex=0><code>grep -i -w vivek /etc/passwd
</code></pre><p>搜索大小写任意的 vivek 或 raj</p><pre tabindex=0><code>grep -E -i -w &#39;vivek|raj&#39; /etc/passwd
</code></pre><p>上面最后的例子显示的，就是一个扩展的正则表达式的模式。</p><h3 id=锚点>锚点</h3><p>你可以分别使用 ^ 和 $ 符号来正则匹配输入行的开始或结尾。下面的例子搜索显示仅仅以 vivek 开始的输入行：</p><pre tabindex=0><code>grep ^vivek /etc/passwd
</code></pre><p>输出例子:</p><pre tabindex=0><code>vivek:x:1000:1000:Vivek Gite,,,:/home/vivek:/bin/bash
vivekgite:x:1001:1001::/home/vivekgite:/bin/sh
</code></pre><p>你可以仅仅只搜索出以单词 vivek 开始的行，即不显示 vivekgit、vivekg 等（LCTT 译注：即该单词后面是空格、符号等英文的单词分隔符。）</p><pre tabindex=0><code>grep -w ^vivek /etc/passwd
</code></pre><p>找出以单词 word 结尾的行：</p><pre tabindex=0><code>grep &#39;foo$&#39; 文件名
</code></pre><p>匹配仅仅只包含 foo 的行：</p><pre tabindex=0><code>grep &#39;^foo$&#39; 文件名
</code></pre><p>如下所示的例子可以搜索空行：</p><pre tabindex=0><code>grep &#39;^$&#39; 文件名
</code></pre><h3 id=字符类>字符类</h3><p>匹配 Vivek 或 vivek：</p><pre tabindex=0><code>grep &#39;[vV]ivek&#39; 文件名
</code></pre><p>或者</p><pre tabindex=0><code>grep &#39;[vV][iI][Vv][Ee][kK]&#39; 文件名
</code></pre><p>也可以匹配数字 (即匹配 vivek1 或 Vivek2 等等):</p><pre tabindex=0><code>grep -w &#39;[vV]ivek[0-9]&#39; 文件名
</code></pre><p>可以匹配两个数字字符(即 foo11、foo12 等):</p><pre tabindex=0><code>grep &#39;foo[0-9][0-9]&#39; 文件名
</code></pre><p>不仅仅局限于数字，也能匹配至少一个字母的:</p><pre tabindex=0><code>grep &#39;[A-Za-z]&#39; 文件名
</code></pre><p>显示含有 &ldquo;w&rdquo; 或 &ldquo;n&rdquo; 字符的所有行：</p><pre tabindex=0><code>grep [wn] 文件名
</code></pre><p>放在括号内的表达式，即包在 &ldquo;[:&rdquo; 和 &ldquo;:]&rdquo; 之间的字符类的名字，它表示的是属于此类的所有字符列表。标准的字符类名称如下：</p><ul><li><code>[:alnum:]</code> - 字母数字字符</li><li><code>[:alpha:]</code> - 字母字符</li><li><code>[:blank:]</code> - 空字符: 空格键符 和 制表符</li><li><code>[:digit:]</code> - 数字: &lsquo;0 1 2 3 4 5 6 7 8 9&rsquo;</li><li><code>[:lower:]</code> - 小写字母: &lsquo;a b c d e f g h i j k l m n o p q r s t u v w x y z&rsquo;</li><li><code>[:space:]</code> - 空格字符: 制表符、换行符、垂直制表符、换页符、回车符和空格键符</li><li><code>[:upper:]</code> - 大写字母: &lsquo;A B C D E F G H I J K L M N O P Q R S T U V W X Y Z&rsquo;</li></ul><p>在这个例子所示的是匹配所有大写字母:</p><pre tabindex=0><code>grep &#39;[:upper:]&#39; 文件名
</code></pre><h3 id=通配符>通配符</h3><p>你可以使用 &ldquo;.&rdquo; 来匹配单个字符。例子中匹配以 &ldquo;b&rdquo; 开头以 &ldquo;t&rdquo; 结尾的3个字符的单词：</p><pre tabindex=0><code>grep &#39;\&lt;b.t\&gt;&#39; 文件名
</code></pre><p>在这儿,</p><ul><li><code>\&lt;</code> 匹配单词前面的空字符串</li><li><code>\></code> 匹配单词后面的空字符串</li></ul><p>打印出只有两个字符的所有行:</p><pre tabindex=0><code>grep &#39;^..$&#39; 文件名
</code></pre><p>显示以一个点和一个数字开头的行：</p><pre tabindex=0><code>grep &#39;^\.[0-9]&#39; 文件名
</code></pre><h4 id=点字符转义>点字符转义</h4><p>下面要匹配到 IP 地址为 192.168.1.254 的正则式是不正确的：（LCTT 译注：可以匹配到该 IP 地址，但是也有可能匹配到间隔符号不是点的类似格式）</p><pre tabindex=0><code>grep &#39;192.168.1.254&#39; /etc/hosts
</code></pre><p>三个点字符都需要转义：</p><pre tabindex=0><code>grep &#39;192\.168\.1\.254&#39; /etc/hosts
</code></pre><p>下面的例子只能匹配出 IP 地址：（LCTT 译注：实际上由于 IP 地址中数字的取值范围，该正则表达式并不精确）</p><pre tabindex=0><code>egrep &#39;[[:digit:]]{1,3}\.[[:digit:]]{1,3}\.[[:digit:]]{1,3}\.[[:digit:]]{1,3}&#39; 文件名
</code></pre><h3 id=怎么样搜索以--符号开头的匹配模式>怎么样搜索以“-” 符号开头的匹配模式？</h3><p>要使用 -e 选项来搜索匹配 &lsquo;&ndash;test&ndash;&rsquo; 字符串，如果不使用 -e 选项，grep 命令会试图把 &lsquo;&ndash;test&ndash;&rsquo; 当作自己的选项参数来解析：</p><pre tabindex=0><code>grep -e &#39;--test--&#39; 文件名
</code></pre><h3 id=怎么使用-grep-的或匹配>怎么使用 grep 的“或”匹配?</h3><p>使用如下的语法：</p><pre tabindex=0><code>grep -E &#39;word1|word2&#39; 文件名
或
egrep &#39;word1|word2&#39; 文件名
</code></pre><p>或者是</p><pre tabindex=0><code>grep &#39;word1\|word2&#39; 文件名
</code></pre><h3 id=怎么使用-grep-的和匹配>怎么使用 grep 的“和”匹配?</h3><p>使用下面的语法来显示既包含 &lsquo;word1&rsquo; 又包含 &lsquo;word2&rsquo; 的所有行</p><pre tabindex=0><code>grep &#39;word1&#39; 文件名 | grep &#39;word2&#39;
</code></pre><h3 id=怎么样使用序列检测>怎么样使用序列检测?</h3><p>使用如下的语法，您可以检测一个字符在序列中重复出现次数：</p><pre tabindex=0><code>{N}
{N,}
{min,max}
</code></pre><p>要匹配字符 “v" 出现两次：</p><pre tabindex=0><code>egrep &#34;v{2}&#34; 文件名
</code></pre><p>下面的命令能匹配到 &ldquo;col&rdquo; 和 &ldquo;cool&rdquo; ：</p><pre tabindex=0><code>egrep &#39;co{1,2}l&#39; 文件名
</code></pre><p>下面的命令将会匹配出至少有三个 &lsquo;c&rsquo; 字符的所有行。</p><pre tabindex=0><code>egrep &#39;c{3,}&#39; 文件名
</code></pre><p>下面的例子会匹配 91-1234567890（即二个数字-十个数字） 这种格式的手机号。</p><pre tabindex=0><code>grep &#34;[[:digit:]]\{2\}[ -]\?[[:digit:]]\{10\}&#34; 文件名
</code></pre><h3 id=怎么样使-grep-命令高亮显示>怎么样使 grep 命令高亮显示？</h3><p>使用如下的语法：</p><pre tabindex=0><code>grep --color 正则表达式 文件名
</code></pre><h3 id=怎么样仅仅只显示匹配出的字符而不是匹配出的行>怎么样仅仅只显示匹配出的字符，而不是匹配出的行？</h3><p>使用如下语法：</p><pre tabindex=0><code>grep -o 正则表达式 文件名
</code></pre><h3 id=正则表达式限定符>正则表达式限定符</h3><table><thead><tr><th>限定符</th><th>描述</th></tr></thead><tbody><tr><td><code>.</code></td><td>匹配任意的一个字符。</td></tr><tr><td><code>?</code></td><td>匹配前面的子表达式，最多一次。</td></tr><tr><td><code>*</code></td><td>匹配前面的子表达式零次或多次。</td></tr><tr><td><code>+</code></td><td>匹配前面的子表达式一次或多次。</td></tr><tr><td><code>{N}</code></td><td>匹配前面的子表达式 N 次。</td></tr><tr><td><code>{N,}</code></td><td>匹配前面的子表达式 N 次到多次。</td></tr><tr><td><code>{N,M}</code></td><td>匹配前面的子表达式 N 到 M 次，至少 N 次至多 M 次。</td></tr><tr><td><code>-</code></td><td>只要不是在序列开始、结尾或者序列的结束点上，表示序列范围。</td></tr><tr><td><code>^</code></td><td>匹配一行开始的空字符串；也表示字符不在要匹配的列表中。</td></tr><tr><td><code>$</code></td><td>匹配一行末尾的空字符串。</td></tr><tr><td><code>\b</code></td><td>匹配一个单词前后的空字符串。</td></tr><tr><td><code>\B</code></td><td>匹配一个单词中间的空字符串。</td></tr><tr><td><code>\&lt;</code></td><td>匹配单词前面的空字符串。</td></tr><tr><td><code>\></code></td><td>匹配单词后面的空字符串。</td></tr></tbody></table><h4 id=grep-和-egrep>grep 和 egrep</h4><p>egrep 等同于 <strong>grep -E</strong> 。它会以扩展的正则表达式的模式来解释模式。下面来自 grep 的帮助页：</p><blockquote><p>基本的正则表达式元字符 ?、+、 {、 |、 ( 和 ) 已经失去了它们原来的意义，要使用的话用反斜线的版本 ?、+、{、|、( 和 ) 来代替。 传统的 egrep 并不支持 { 元字符，一些 egrep 的实现是以 { 替代的，所以一个可移植的脚本应该避免在 grep -E 使用 { 符号，要匹配字面的 { 应该使用 [}]。</p><p>GNU grep -E 试图支持传统的用法，如果 { 出在在无效的间隔规范字符串这前，它就会假定 { 不是特殊字符。</p><p>例如，grep -E &lsquo;{1&rsquo; 命令搜索包含 {1 两个字符的串，而不会报出正则表达式语法错误。</p><p>POSIX.2 标准允许这种操作的扩展，但在可移植脚本文件里应该避免这样使用。</p></blockquote><p>参考:</p><ul><li>grep 和 regex 帮助手册页(7)</li><li>grep 的 info 页</li></ul><hr><p>via: <a href=http://www.cyberciti.biz/faq/grep-regular-expressions/>http://www.cyberciti.biz/faq/grep-regular-expressions/</a></p><p>作者：Vivek Gite 译者：<a href=https://github.com/runningwater>runningwater</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/grep/ rel=tag>grep</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/ rel=tag>正则表达式</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>