<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>一起来学习 Lisp 编程语言吧！ - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="一起来学习 Lisp 编程语言吧！"><meta property="og:description" content="许多大型代码库中都有 Lisp 代码的身影，因此，熟悉一下这门语言是一个明智之举。"><meta property="og:type" content="article"><meta property="og:url" content="/article-14751-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-06-24T12:40:00+00:00"><meta property="article:modified_time" content="2022-06-24T12:40:00+00:00"><meta itemprop=name content="一起来学习 Lisp 编程语言吧！"><meta itemprop=description content="许多大型代码库中都有 Lisp 代码的身影，因此，熟悉一下这门语言是一个明智之举。"><meta itemprop=datePublished content="2022-06-24T12:40:00+00:00"><meta itemprop=dateModified content="2022-06-24T12:40:00+00:00"><meta itemprop=wordCount content="563"><meta itemprop=keywords content="Lisp,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>一起来学习 Lisp 编程语言吧！</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2022-06-24T12:40:00Z>June 24, 2022</time></div></div></header><div class="content post__content clearfix"><blockquote><p>许多大型代码库中都有 Lisp 代码的身影，因此，熟悉一下这门语言是一个明智之举。</p></blockquote><p><img src=/data/attachment/album/202206/24/124147v0loy4e3y0hneih8.jpg alt></p><p>早在 1958 年，Lisp 就被发明出来了，它是世界上第二古老的计算机编程语言（LCTT 译注：最古老的编程语言是 Fortran，诞生于 1957 年）。它有许多现代的衍生品，包括 Common Lisp、Emacs Lisp（Elisp）、Clojure、Racket、Scheme、Fennel 和 GNU Guile 等。</p><p>那些喜欢思考编程语言的设计的人，往往都喜欢 Lisp，因为它的语法和数据有着相同的结构：Lisp 代码实际上是 一个列表的列表 a list of lists ，它的名字其实是 “ 列表处理 LISt Processing ” 的简写。而那些喜欢思考编程语言的美学的人，往往都讨厌 Lisp，因为它经常使用括号来定义范围；事实上，编程界也有一个广为流传的笑话：Lisp 代表的其实是 “大量烦人的多余括号” Lots of Irritating Superfluous Parentheses 。</p><p>不管你是喜欢还是讨厌 Lisp 的设计哲学，你都不得不承认，它都是一门有趣的语言，过去如此，现在亦然（这得归功于现代方言 Clojure 和 Guile）。你可能会惊讶于在任何特定行业的大代码库中潜伏着多少 Lisp 代码，因此，现在开始学习 Lisp，至少熟悉一下它，不失为一个好主意。</p><h3 id=安装-lisp>安装 Lisp</h3><p>Lisp 有很多不同的实现。比较流行的开源版本有 <a href=http://sbcl.org>SBCL</a>、<a href=http://clisp.org>GNU Lisp</a> 和 <a href=https://www.gnu.org/software/gcl/>GNU Common Lisp</a>（GCL）。你可以使用发行版的包管理器安装它们中的任意一个，在本文中，我是用的是 <code>clisp</code>（LCTT 译注：也就是 GNU Lisp，一种 ANSI Common Lisp 的实现）。</p><p>以下是在不同的 Linux 发行版中安装 <code>clisp</code> 的步骤。</p><p>在 Fedora Linux 上，使用 <code>dnf</code>：</p><pre tabindex=0><code>$ sudo dnf install clisp
</code></pre><p>在 Debian 上，使用 <code>apt</code>：</p><pre tabindex=0><code>$ sudo apt install clisp
</code></pre><p>在 macOS 上，使用 <a href=https://opensource.com/article/20/11/macports>MacPorts</a> 或者 <a href=https://opensource.com/article/20/6/homebrew-linux>Homebrew</a>：</p><pre tabindex=0><code># 使用 MacPorts
$ sudo port install clisp

# 使用 Homebrew
$ brew install clisp
</code></pre><p>在 Windows 上，你可以使用 <a href=https://cygwin.fandom.com/wiki/Clisp>clisp on Cygwin</a> 或者从 <a href=http://mirror.lagoon.nc/gnu/gcl/binaries/stable>gnu.org/software/gcl</a> 上下载 GCL 的二进制文件。</p><p>虽然我使用 <code>clisp</code> 命令来运行 Lisp 代码，但是本文中涉及到的大多数语法规则，对任何 Lisp 实现都是适用的。如果你选择使用一个不同的 Lisp 实现，除了用来运行 Lisp 代码的命令会和我不一样外（比如，你可能要用 <code>gcl</code> 或 <code>sbcl</code> 而不是 <code>clisp</code>），其它的所有东西都是相同的。</p><h3 id=列表处理>列表处理</h3><p>Lisp 源代码的基本单元是 “ 表达式 expression ”，它在形式上是一个列表。举个例子，下面就是一个列表，它由一个操作符（<code>+</code>）和两个整数（<code>1</code> 和 <code>2</code>）组成：</p><pre tabindex=0><code>(+ 1 2)
</code></pre><p>同时，它也是一个 Lisp 表达式，内容是一个符号（<code>+</code>，会被解析成一个加法函数）和它的两个参数（<code>1</code> 和 <code>2</code>）。你可以在 Common Lisp 的交互式环境（即 REPL）中运行该表达式和其它表达式。如果你熟悉 Python 的 IDLE，那么你应该会对 Lisp 的 REPL 感到亲切。（LCTT 译注：REPL 的全称是 “Read-Eval-Print Loop”，意思是 “‘读取-求值-输出’循环”，这个名字很好地描述了它的工作过程。）</p><p>要进入到 REPL 中，只需运行 Common Lisp 即可：</p><pre tabindex=0><code>$ clisp
[1]&gt;
</code></pre><p>在 REPL 提示符中，尝试输入一些表达式：</p><pre tabindex=0><code>[1]&gt; (+ 1 2)
3
[2]&gt; (- 1 2)
-1
[3]&gt; (- 2 1)
1
[4]&gt; (+ 2 3 4)
9
</code></pre><h3 id=函数>函数</h3><p>在了解了 Lisp 表达式的基本结构后，你可以使用函数来做更多有用的事。譬如，<code>print</code> 函数可以接受任意数量的参数，然后把它们都显示在你的终端上，<code>pprint</code> 函数还可以实现格式化打印。还有更多不同的打印函数，不过，<code>pprint</code> 在 REPL 中的效果就挺好的：</p><pre tabindex=0><code>[1]&gt; (pprint &#34;hello world&#34;)

&#34;hello world&#34;

[2]&gt;
</code></pre><p>你可以使用 <code>defun</code> 函数来创建一个自定义函数。<code>defun</code> 函数需要你提供自定义函数的名称，以及它接受的参数列表：</p><pre tabindex=0><code>[1]&gt; (defun myprinter (s) (pprint s))
MYPRINTER
[2]&gt; (myprinter &#34;hello world&#34;)

&#34;hello world&#34;

[3]&gt;
</code></pre><h3 id=变量>变量</h3><p>你可以使用 <code>setf</code> 函数来在 Lisp 中创建变量：</p><pre tabindex=0><code>[1]&gt; (setf foo &#34;hello world&#34;)
&#34;hello world&#34;
[2]&gt; (pprint foo)

&#34;hello world&#34;

[3]&gt;
</code></pre><p>你可以在表达式里嵌套表达式（就像使用某种管道一样）。举个例子，你可以先使用 <code>string-upcase</code> 函数，把某个字符串的所有字符转换成大写，然后再使用 <code>pprint</code> 函数，将它的内容格式化打印到终端上：</p><pre tabindex=0><code>[3]&gt; (pprint (string-upcase foo))

&#34;HELLO WORLD&#34;

[4]&gt;
</code></pre><p>Lisp 是动态类型语言，这意味着，你在给变量赋值时不需要声明它的类型。Lisp 默认会把整数当作整数来处理：</p><pre tabindex=0><code>[1]&gt; (setf foo 2)
[2]&gt; (setf bar 3)
[3]&gt; (+ foo bar)
5
</code></pre><p>如果你想让整数被当作字符串来处理，你可以给它加上引号：</p><pre tabindex=0><code>[4]&gt; (setf foo &#34;2&#34;)
&#34;2&#34;
[5]&gt; (setf bar &#34;3&#34;)
&#34;3&#34;
[6]&gt; (+ foo bar)

*** - +: &#34;2&#34; is not a number
The following restarts are available:
USE-VALUE      :R1      Input a value to be used instead.
ABORT          :R2      Abort main loop
Break 1 [7]&gt;
</code></pre><p>在这个示例 REPL 会话中，变量 <code>foo</code> 和 <code>bar</code> 都被赋值为加了引号的数字，因此，Lisp 会把它们当作字符串来处理。数学运算符不能够用在字符串上，因此 REPL 进入了调试器模式。想要跳出这个调试器，你需要按下 <code>Ctrl+D</code> 才行（LCTT 译注：就 <code>clisp</code> 而言，使用 <code>quit</code> 关键字也可以退出）。</p><p>你可以使用 <code>typep</code> 函数对一些对象进行类型检查，它可以测试对象是否为某个特定数据类型。返回值 <code>T</code> 和 <code>NIL</code> 分别代表 <code>True</code> 和 <code>False</code>。</p><pre tabindex=0><code>[4]&gt; (typep foo &#39;string)
NIL
[5]&gt; (typep foo &#39;integer)
T
</code></pre><p><code>string</code> 和 <code>integer</code> 前面加上了一个单引号（<code>'</code>），这是为了防止 Lisp（错误地）把这两个单词当作是变量来求值：</p><pre tabindex=0><code>[6]&gt; (typep foo string)
*** - SYSTEM::READ-EVAL-PRINT: variable STRING has no value
[...]
</code></pre><p>这是一种保护某些术语（LCTT 译注：类似于字符串转义）的简便方法，正常情况下它是用 <code>quote</code> 函数来实现的：</p><pre tabindex=0><code>[7]&gt; (typep foo (quote string))
NIL
[5]&gt; (typep foo (quote integer))
T
</code></pre><h3 id=列表>列表</h3><p>不出人意料，你当然也可以在 Lisp 中创建列表：</p><pre tabindex=0><code>[1]&gt; (setf foo (list &#34;hello&#34; &#34;world&#34;))
(&#34;hello&#34; &#34;world&#34;)
</code></pre><p>你可以使用 <code>nth</code> 函数来索引列表：</p><pre tabindex=0><code>[2]&gt; (nth 0 foo)
&#34;hello&#34;
[3]&gt; (pprint (string-capitalize (nth 1 foo)))

&#34;World&#34;
</code></pre><h3 id=退出-repl>退出 REPL</h3><p>要结束一个 REPL 会话，你需要按下键盘上的 <code>Ctrl+D</code>，或者是使用 Lisp 的 <code>quit</code> 关键字：</p><pre tabindex=0><code>[99]&gt; (quit)
$
</code></pre><h3 id=编写脚本>编写脚本</h3><p>Lisp 可以被编译，也可以作为解释型的脚本语言来使用。在你刚开始学习的时候，后者很可能是最容易的方式，特别是当你已经熟悉 Python 或 <a href=https://opensource.com/article/20/4/bash-programming-guide>Shell 脚本</a> 时。</p><p>下面是一个用 Common Lisp 编写的简单的“掷骰子”脚本：</p><pre tabindex=0><code>#!/usr/bin/clisp

(defun roller (num)  
  (pprint (random (parse-integer (nth 0 num))))
)

(setf userput *args*)
(setf *random-state* (make-random-state t))
(roller userput)
</code></pre><p>脚本的第一行注释（LCTT 译注：称之为“ 释伴 shebang ”）告诉了你的 POSIX 终端，该使用什么可执行文件来运行这个脚本。</p><p><code>roller</code> 函数使用 <code>defun</code> 函数创建，它在内部使用 <code>random</code> 函数来打印一个伪随机数，这个伪随机数严格小于 <code>num</code> 列表中下标为 0 的元素。在脚本中，这个 <code>num</code> 列表还没有被创建，不过没关系，因为只有当脚本被调用时，函数才会执行。</p><p>接下来的那一行，我们把运行脚本时提供的任意参数，都赋值给一个叫做 <code>userput</code> 的变量。这个 <code>userput</code> 变量是一个列表，当它被传递给 <code>roller</code> 函数后，它就会变成参数 <code>num</code>。</p><p>脚本的倒数第二行产生了一个“随机种子”。这为 Lisp 提供了足够的随机性来生成一个几乎随机的数字。</p><p>最后一行调用了自定义的 <code>roller</code> 函数，并将 <code>userput</code> 列表作为唯一的参数传递给它。</p><p>将这个文件保存为 <code>dice.lisp</code>，并赋予它可执行权限：</p><pre tabindex=0><code>$ chmod +x dice.lisp
</code></pre><p>最后，运行它，并给它提供一个数字，以作为它选择随机数的最大值：</p><pre tabindex=0><code>$ ./dice.lisp 21

13
$ ./dice.lisp 21

7
$ ./dice.lisp 21

20
</code></pre><p>看起来还不错！</p><p>你或许注意到，你的模拟骰子有可能会是 0，并且永远达不到你提供给它的最大值参数。换句话说，对于一个 20 面的骰子，这个脚本永远投不出 20（除非你把 0 当作 20）。有一个简单的解决办法，它只需要用到在本文中介绍的知识，你能够想到吗？</p><h3 id=学习-lisp>学习 Lisp</h3><p>无论你是想将 Lisp 作为个人脚本的实用语言，还是为了助力你的职业生涯，抑或是仅仅作为一个有趣的实验，你都可以去看看一年一度（LCTT 译注：应该是两年一度）的 <a href=https://itch.io/jam/spring-lisp-game-jam-2021>Lisp 游戏果酱 Game Jam </a>，从而收获一些特别有创意的用途（其中的大多数提交都是开源的，因此你可以查看代码以从中学习）。</p><p>Lisp 是一门有趣而独特的语言，它有着不断增长的开发者用户群、足够悠久的历史和新兴的方言，因此，它有能力让从事各个行业的程序员都满意。</p><hr><p>via: <a href=https://opensource.com/article/21/5/learn-lisp>https://opensource.com/article/21/5/learn-lisp</a></p><p>作者：<a href=https://opensource.com/users/seth>Seth Kenlon</a> 选题：<a href=https://github.com/lkxed>lkxed</a> 译者：<a href=https://github.com/lkxed>lkxed</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/lisp/ rel=tag>Lisp</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>