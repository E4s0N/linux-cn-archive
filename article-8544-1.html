<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>我是见鬼了么？这是史上最邪恶的脚本！没有之一！ - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="我是见鬼了么？这是史上最邪恶的脚本！没有之一！"><meta property="og:description" content="这是一个 bash shell 脚本，其中有若干可以整蛊（结仇）你的同事的小技巧——或者说恶作剧。看完之后，感觉不寒而栗，要是谁敢这样整我，我一定和他绝交！"><meta property="og:type" content="article"><meta property="og:url" content="/article-8544-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-05-27T12:35:00+00:00"><meta property="article:modified_time" content="2017-05-27T12:35:00+00:00"><meta itemprop=name content="我是见鬼了么？这是史上最邪恶的脚本！没有之一！"><meta itemprop=description content="这是一个 bash shell 脚本，其中有若干可以整蛊（结仇）你的同事的小技巧——或者说恶作剧。看完之后，感觉不寒而栗，要是谁敢这样整我，我一定和他绝交！"><meta itemprop=datePublished content="2017-05-27T12:35:00+00:00"><meta itemprop=dateModified content="2017-05-27T12:35:00+00:00"><meta itemprop=wordCount content="565"><meta itemprop=keywords content="脚本,别名,alias,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>我是见鬼了么？这是史上最邪恶的脚本！没有之一！</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-05-27T12:35:00Z>May 27, 2017</time></div></div></header><div class="content post__content clearfix"><p><img src=https://img.linux.net.cn/data/attachment/album/201705/27/123313bhhiigzol1od5hri.jpg alt></p><p>昨天，微博上的朋友 <a href=http://weibo.com/3404002352>@马甲与小号</a> 告诉我发现了一个奇怪的东西，本着好奇心使人进步（害死猫？）的目的，我去观摩了一番，于是就有了今天这篇文章。</p><p>这是一个 bash shell 脚本，其中有若干可以整蛊（结仇）你的同事的小技巧——或者说恶作剧。看完之后，感觉不寒而栗，要是谁敢这样整我，我一定和他绝交！</p><blockquote><p><strong>警告，切勿在生产环境体验，一切后果脚本作者和本文作者均不不承担！</strong></p><p><strong>警告，切勿在生产环境体验，一切后果脚本作者和本文作者均不不承担！</strong></p><p><strong>警告，切勿在生产环境体验，一切后果脚本作者和本文作者均不不承担！</strong></p></blockquote><h3 id=这个世界怎么了>这个世界怎么了？</h3><p>这个脚本主要由一些别名、函数、环境变量定义组织而成，执行该脚本后，你的 shell 环境就变成了一个光怪陆离的世界。</p><p>好了，那么我们来看看都发生了什么。</p><p>注：本脚本适用于 bash 环境，其它 shell 环境有些不支持。</p><h4 id=可怕的默认编辑器>可怕的默认编辑器</h4><p>当系统调用默认编辑器来编辑比如 crontab 时，biu 的一下，文件没了！</p><pre tabindex=0><code>export EDITOR=/bin/rm;
</code></pre><p>这是将 <code>EDITOR</code> 环境变量定义为 <code>rm</code>，而它原本应该是 <code>vi</code>、<code>emacs</code> 或 <code>nano</code> 的，体会一下，是不是很酸爽？</p><blockquote><p>学习课堂：</p><p><code>EDITOR</code> 环境变量用于定于系统的默认编辑器，在一些系统内置功能里面，比如编辑 crontab 时，会根据该变量调用默认编辑器。</p></blockquote><h4 id=猥琐的制表符tab>猥琐的制表符（tab）</h4><p>当你想用制表符来个自动补全时，你会它非但不干，而且还删除了一个字母，不信邪的你使劲多砸了几个制表符，这下好了，更多的字符被删除了。</p><pre tabindex=0><code>tset -Qe $&#39;\t&#39;;
</code></pre><p>原来是将制表符定义为退格键了。</p><blockquote><p>学习课堂：</p><p><code>tset</code> 用于设置终端特征；<code>-e</code> 参数设置擦除字符，缺省为退格字符；<code>-Q</code> 表示不显示设置信息（静默）。</p></blockquote><h4 id=莫名退出>莫名退出</h4><p>有时候，执行一个命令就会莫名其妙地退出 shell，只不过是命令有个非 0 的返回状态嘛，为什么会这样？</p><pre tabindex=0><code>((RANDOM % 10)) || set -o errexit;
</code></pre><blockquote><p>学习课堂：</p><p><code>set -o errexit</code> 等价于 <code>set -e</code>，表示有任何错误（命令的返回状态非 0 ）时即退出。</p></blockquote><h4 id=啥都看cat不了>啥都看（cat）不了</h4><p>当我想看（<code>cat</code>）一下文件时，它居然就当没听见，到底文件里面有啥啊？</p><pre tabindex=0><code>alias cat=true;
</code></pre><p>原来是把 <code>cat</code> 定义成 <code>true</code> 命令的别名了， <code>true</code> 命令啥都不干，不管你给它什么参数和什么输入，它只是静静地返回一个 <code>0</code> 的状态码。</p><blockquote><p>学习课堂</p><p><code>true</code> 命令和 <code>false</code> 命令常用于 shell 脚本中。</p></blockquote><h4 id=到底是按什么排列的啊>到底是按什么排列的啊？</h4><p>好吧，我想看看目录里面有啥文件，于是我输入了 <code>ls</code>，咦？这是什么顺序？我再次输入一遍，怎么回事，列出的文件和目录又是一种顺序，难道它的输出看心情吗？</p><pre tabindex=0><code>function ls { command ls -$(opts=&#34;frStu&#34;; echo ${opts:$((RANDOM % ${#opts})):1}) &#34;$@&#34;; }
</code></pre><p>原来它用一个函数重新定义了 <code>ls</code>，所以，真是看心情，你永远不知道它会以什么顺序返回结果。</p><blockquote><p>学习课堂：</p><p>ls 的 <code>f</code> 选项表示不排序输出（即只按照磁盘存储顺序输出）；<code>r</code> 表示反向排序；<code>S</code> 表示按文件大小排序；<code>t</code> 表示按修改时间排序；<code>u</code> 表示按最后访问时间排序。</p></blockquote><h4 id=再也不要试着进入目录了>再也不要试着进入目录了</h4><p>当我想进入目录看看时，惊奇的是居然没进去，难道没有自动补全我就输入错了？用前面那个奇奇怪怪的 <code>ls</code> 再次看看时，令人惊恐的是，那个目录！它没有了！！！不信邪的我又重复了这个过程，然后，我就一个子目录也没有了！</p><pre tabindex=0><code>alias cd=&#39;rm -rfv&#39;;
</code></pre><p>这该死的，连输入 <code>cd</code> 这么无害的命令都这么可怕！</p><blockquote><p>学习课堂：</p><p><code>rm</code> 命令的 <code>-r</code> 表示可删除（非空）目录；<code>-f</code> 表示不需要确认删除；<code>-v</code> 表示删除后显示被删除的文件/目录名称——这里是用来嘲讽我删除了某个目录的吗？</p></blockquote><h4 id=还敢用-sudo-权限吗>还敢用 sudo 权限吗？</h4><p>我很遵守安全守则，从来不用 root 直接登录，凡是管理任务，都用 <code>sudo</code> 来执行。然而，现在无论我用 <code>sudo</code> 执行什么命令，都会<strong>马上关机</strong>，并将我输入的命令广而告之！这是我被系统讨厌了么？</p><pre tabindex=0><code>alias sudo=&#39;sudo shutdown -P now&#39;;
</code></pre><blockquote><p>学习课堂：</p><p><code>shutdown</code> 命令用来关闭系统，<code>-P</code> 参数表示连同电源一起关闭； <code>now</code> 表示马上关机。这之后的参数（在此例中，是原本希望 <code>sudo</code> 执行的命令）会作为关闭前的通知信息，广播给系统上所有在线的用户。</p></blockquote><h4 id=我原本想静静结果世界都静了>我原本想静静，结果世界都静了</h4><p>杂乱的屏幕输出让你厌憎，所以，一个 <code>clear</code> 命令就可以静静了——等等，为什么我的终端崩溃了？然后系统也死机了。</p><pre tabindex=0><code>alias clear=&#39;:(){ :|:&amp; };:&#39;;
</code></pre><p>这是将 <code>clear</code> 命令别名为一个 <a href=/article-5685-1.html>fork 炸弹</a>了，据说这个是最精简、最难懂的 fork 炸弹了。至于炸弹的效果，嗯，世界都安静了</p><blockquote><p>学习课堂：</p><p>Fork 炸弹带来的后果就是耗尽服务器资源，使服务器不能正常的对外提供服务，也就是常说的 DoS（Denial of Service）。</p></blockquote><h4 id=今夕是何年>今夕是何年？</h4><p>这光怪陆离的世界啊，让我疑似梦中，那么，现在是什么时候？当然，我肯定不会去翻日历的，输入 <code>date</code> 命令才是我们命令行极客该做的事情。看着返回的日期，我不禁怀疑我的记忆，难道我穿越了么？</p><pre tabindex=0><code>alias date=&#39;date -d &#34;now + $RANDOM days&#34;&#39;;
</code></pre><blockquote><p>学习课堂：</p><p><code>date</code> 命令可以显示相对偏移的日期，上述命令中 <code>$RANDOM</code> 的结果是一个随机的整数，也就是说这里的 <code>date</code> 命令会返回若干天之后的日期。</p></blockquote><h4 id=如果你有一个鬼马的-cd-驱动器>如果你有一个鬼马的 CD 驱动器</h4><p>现在 CD 驱动器用的不多了，但是很多机器上还残留着这个“咖啡杯托”，如果你有幸还有这个东西的话，或许今天它就被鬼怪附体了，一会弹出，一会又收回去，有时候你按下弹出键却毫无反应——当你真的将咖啡杯放上面时，小心，你的咖啡杯会掉下来！</p><blockquote><p>将 CD 盘托当成咖啡杯托是一个笑话，据说某人曾经给电脑厂家打电话：</p><p>“您好，我想说你们的机器上的咖啡杯托以前挺好用的，可是现在它不动了。”</p><p>“‘咖啡杯托’？那是什么？”</p><p>“就是那个一按按钮就会弹出的托盘啊，放咖啡杯正好，还有合适的凹槽，设计的不错！以前都好好的，现在它不会弹出了。”</p><p>“……”</p></blockquote><pre tabindex=0><code>    N=$[$RANDOM % 3];
    if [[ $N == 0 ]]; then
        # 几分钟后随即打开或关闭
        sh -c &#39;sleep $[($RANDOM % 900) + 300]s; while :; do eject -T; sleep $[($RANDOM % 20) + 1]s; done&#39; &gt; /dev/null 2&gt;&amp;1 &amp;
    elif [[ $N == 1 ]]; then
        # 要么，死活打不开
        sh -c &#39;while :; do eject -t; eject -i on; sleep 0.1s; done&#39; &gt; /dev/null 2&gt;&amp;1 &amp;
    else
        # 要么，读取变得极慢（1 倍速），需要循环的原因是弹出后就需要重新设定。
        sh -c &#39;set +o errexit; while :; do eject -x 1; sleep 1s; done&#39; &gt; /dev/null 2&gt;&amp;1 &amp;
    fi;
</code></pre><blockquote><p>学习课堂：</p><p><code>eject</code> 是操作 CD 驱动器的命令行，记得当年有位第一次接触 SUN Solaris 的同事问我，这 CD 怎么打开啊？我默默地输入了 <code>eject</code>， 在同事愕然的眼光中不带走一丝云彩轻轻地离开。</p><p><code>eject</code> 的 <code>-T</code> 选项会将关闭的 CD 驱动器打开，将打开的 CD 驱动器关闭；<code>-t</code> 选项则是关闭 CD 驱动器；<code>-x</code> 选项用来设置读取倍速；<code>-i on</code> 用于将弹出按钮失效。</p></blockquote><h4 id=冰川时代>冰川时代</h4><p>突然地，某个你已经打开的程序冻结了，也许是你的浏览器、也许是你正写了一半的文档，所以，随时保存文档是个好习惯吗？</p><pre tabindex=0><code>sleep $[ ( $RANDOM % 100 )  + 1 ]s &amp;&amp; kill -STOP $(ps x -o pid|sed 1d|sort -R|head -1) &amp;
</code></pre><blockquote><p>学习课题：</p><p><code>sleep</code> 就不用解释了，这代表暂停若干秒。</p><p>通过上述 <code>ps</code> 命令会会随机选出（<code>sort</code> 命令的 <code>-R</code> 选项）一个你的进程号，然后由 <code>kill</code> 命令发送 <code>STOP</code> 信号给它。<code>STOP</code> 信息会使程序被停止（冻结、挂起），在命令行中可有 <code>CTRL-Z</code> 发出，被停止的进程可以通过 <code>bg</code> 放到后台运行，也可以由 <code>fg</code> 带回到前台。</p></blockquote><h4 id=一个还是两个>一个还是两个？</h4><p>当我想复制一个文件到另外一个地方时，咦？原来的那个哪里去了？</p><pre tabindex=0><code>alias cp=&#39;mv&#39;;
</code></pre><p>还好，还好，你总是还有一个副本的，这总算是不幸中的大幸了。</p><blockquote><p>学习课堂：</p><p><code>cp</code> 是 <code>mv</code>，<code>mv</code> 还是 <code>mv</code>。</p></blockquote><h4 id=永不停止的工作>永不停止的工作</h4><p>打完收工，你总是要退出（<code>exit</code>）你的 shell 的，但是一直退不出是什么意思？</p><pre tabindex=0><code>alias exit=&#39;sh&#39;;
</code></pre><blockquote><p>学习课堂：</p><p>将 <code>exit</code> 命令别名为 <code>sh</code> ，这样输入 <code>exit</code> 命令后不是退出当前 shell，而是有进入了一个新的子 shell，想退出不干？没门！</p></blockquote><h4 id=到底是哪行>到底是哪行？</h4><p>会用 <code>grep</code> 的你，应该知道 <code>-n</code> 参数可以告诉你所匹配的行的行号，但是随机乱变的行号是什么鬼？我讨厌随机！</p><pre tabindex=0><code>function grep { command grep &#34;$@&#34; | awk -F: &#39;{ r = int(rand() * 10); n = $1; $1 = &#34;&#34;; command if (n ~ /^[0-9]+$/) { o = n+r } else { o = n }; print o &#34;:&#34; substr($0, 2)}&#39;; }
</code></pre><blockquote><p><code>grep</code> 命令的 <code>-n</code> 用于输出匹配的行的行号，上述函数将 <code>grep</code> 定义为一个输出的行号完全不可预测的程序。</p></blockquote><h4 id=世界是反着的>世界是反着的</h4><p>你脚本也总是出各种匪夷所思的问题，而且你还不知道什么地方出了问题。这一切都要怪你进入了一个“是”即是“非”的世界。</p><pre tabindex=0><code>alias if=&#39;if !&#39; for=&#39;for !&#39; while=&#39;while !&#39;;
</code></pre><p>将 <code>if</code>、<code>for</code> 和 <code>while</code> 所检测的条件定义为反，我不知道这个世界可以疯狂到这个地步！</p><blockquote><p>学习课堂：</p><p><code>if</code> 、<code>for</code> 和 <code>while</code> 是用于 shell 脚本中做逻辑判断和循环的语句，<code>!</code> 表示对表达式逻辑取反。</p></blockquote><h4 id=想执行命令没门>想执行命令？没门！</h4><p>当你输入了一个命令之后，用小指轻轻地、优雅地，按下右侧的那个小小的回车键，满心以为会爆发出绝世高手的风范。然而……并没有，非但没有，你输入的命令还被删除了一个字符！懵逼的你以为用力太轻了，再次敲击后发现又被删除了一个！！！</p><blockquote><p>记得有一个电影，危急情况下，当别人把键盘递给一位即将闭眼的黑客时，他只是轻轻按下了那个“回车”！</p></blockquote><pre tabindex=0><code>bind &#39;&#34;\C-J&#34;:&#34;\C-?&#34;&#39;;
bind &#39;&#34;\C-M&#34;:&#34;\C-?&#34;&#39;;
</code></pre><blockquote><p>学习课堂：</p><p><code>bind</code> 用于显示和设置键盘序列绑定，<code>C-J</code> 代表 <code>CTRL-J</code>，所触发的 ASCII 码是 <code>0x0A</code>，即“换行”；<code>C-M</code> 代表 <code>CTRL-M</code>，所触发的 ASCII 码是 <code>0x0D</code>，即“回车”；<code>C-?</code> 代表 <code>CTRL-?</code>，所触发的 ASCII 码是 <code>0x7F</code>，即“退格”。也就是说，你按下的回车键，会被映射为退格键。关于 ASCII 控制字符，可参见： <a href=http://ascii-table.com/control-chars.php>http://ascii-table.com/control-chars.php</a> 。也可以使用 <code>showkey -a</code> 命令来检验你按下的键的键值（<code>CTRL-D</code> 退出）。</p></blockquote><h4 id=好的但是我不干>好的，但是我不干</h4><p>你说要，但是你的身体却说不要。明明应该应答 <code>yes</code>，但是却实际上拒绝了。</p><pre tabindex=0><code>alias yes=&#34;yes n&#34;;
</code></pre><blockquote><p>学习课堂：</p><p><code>yes</code> 命令常用于脚本中应答 <code>y</code>，但是这里重定义了 <code>yes</code> 的结果。这是身口不一么？</p></blockquote><h4 id=我要编辑文件>我要编辑文件</h4><p>当我用 vim 打开一个文件时，为什么什么都没发生？</p><pre tabindex=0><code>alias vim=&#34;vim +q&#34;;
</code></pre><blockquote><p>学习课堂：</p><p><code>vim</code> 可以用 <code>+</code> 来跟上要在 <code>vim</code> 里面执行的命令，这里 <code>+q</code> 表示退出 <code>vim</code>。</p></blockquote><h4 id=最后别想回到正常的世界>最后，别想回到正常的世界</h4><p>好吧，我明白了，都是 <code>alias</code> 捣的鬼，我要取消它们。什么？取消也无效了？</p><pre tabindex=0><code>alias unalias=false;
alias alias=false;
</code></pre><blockquote><p>学习课堂：</p><p>将 <code>alias</code> 和 <code>unalias</code> 别名为 <code>false</code>，那你就不能执行 <code>alias</code> 的功能了。</p></blockquote><h3 id=让我回到真实的世界吧>让我回到真实的世界吧！</h3><p>好了，我已经受够了这个疯狂是世界了。其实，上面这些别名，都是可以通过输入命令的全路径来绕开别名的——只是一般人不会这样输入。</p><p>想要整蛊你的同事，那就将这个脚本（<a href=https://github.com/mathiasbynens/evil.sh/blob/master/evil.sh>https://github.com/mathiasbynens/evil.sh/blob/master/evil.sh</a> ）放到他的机器上，并在他的 <code>.bash_profile</code> 的末尾加入 <code>source ~/evil.sh</code> 即可。当然，你要这么做之前，要有友尽的心理准备。</p><p>感谢这个邪恶的脚本的贡献者： Mathias Bynens 和 Jan Moesen 等人 ;-D</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/%E8%84%9A%E6%9C%AC/ rel=tag>脚本</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E5%88%AB%E5%90%8D/ rel=tag>别名</a></li><li class=tags__item><a class="tags__link btn" href=/tags/alias/ rel=tag>alias</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>