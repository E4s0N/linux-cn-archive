<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Btrfs 详解：子卷 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="Btrfs 详解：子卷"><meta property="og:description" content="在本文中，我们探索了 Btrfs 子卷，它们像是 Btrfs 文件系统内部的独立的 Btrfs 文件系统。"><meta property="og:type" content="article"><meta property="og:url" content="/article-16250-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-10-03T11:13:00+00:00"><meta property="article:modified_time" content="2023-10-03T11:13:00+00:00"><meta itemprop=name content="Btrfs 详解：子卷"><meta itemprop=description content="在本文中，我们探索了 Btrfs 子卷，它们像是 Btrfs 文件系统内部的独立的 Btrfs 文件系统。"><meta itemprop=datePublished content="2023-10-03T11:13:00+00:00"><meta itemprop=dateModified content="2023-10-03T11:13:00+00:00"><meta itemprop=wordCount content="963"><meta itemprop=keywords content="Btrfs,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>Btrfs 详解：子卷</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2023-10-03T11:13:00Z>October 03, 2023</time></div></div></header><div class="content post__content clearfix"><p><img src=https://img.linux.net.cn/data/attachment/album/202310/03/111308vdhzh3ddwwjdmyw0.jpg alt></p><p>这篇文章是《Btrfs 详解》系列文章中的一篇。从 Fedora Linux 33 开始，Btrfs 就是 Fedora Workstation 和 Fedora Silverblue 的默认文件系统。</p><p>以防你忘记，这是系列文章中的前一篇：<a href=/article-16189-1.html>Btrfs 详解：基础概念</a>。</p><h3 id=简介>简介</h3><p>子卷 Subvolume 允许将一个 Btrfs 文件系统划分成多个独立的子文件系统。这意味着你可以从 Btrfs 文件系统挂载子卷，就好像它们是独立的文件系统。除此之外，例如，你还可以通过 限额组 qgroup （我们将在本系列的另一篇文章里介绍）定义子卷能够占据的最大空间，或者用子卷去包含或排除快照中的文件（我们会后面的文章中会讲到）。自 Fedora Linux 33 后每个 Fedora Workstation 和 Fedora Silverblue 默认安装过程中会利用子卷。在这篇文章中我们会介绍它是如何工作的。</p><p>下面你会找到很多关于子卷的例子。如果你想跟着操作，你必须拥有访问某些 Btrfs 文件系统的权限和 root 权限。你可以通过下面命令来验证你的 <code>/home/</code> 目录是否是 Btrfs 。</p><pre tabindex=0><code>$ findmnt -no FSTYPE /home
btrfs
</code></pre><p>这个命令会输出你 <code>/home/</code> 目录的文件系统名。如果它是 btrfs，那就可以了。让我们创建一个新的目录去做实验：</p><pre tabindex=0><code>$ mkdir ~/btrfs-subvolume-test
$ cd ~/btrfs-subvolume-test
</code></pre><p>在下面的文本中，你会看到很多像上面显示的那样的命令输出框。请在阅读/比较命令输出时请记住，<strong>框中的内容在行末会被换行</strong>。这使得识别跨多行的长行变得困难，降低了可读性。如果有疑问，试着调整浏览器窗口的大小，看看文本的变化!</p><h3 id=创建和使用子卷>创建和使用子卷</h3><p>我们可以通过以下命令创建一个 Btrfs 子卷：</p><pre tabindex=0><code>$ sudo btrfs subvolume create first
Create subvolume &#39;./first&#39;
</code></pre><p>当我们检查当前目录，我们可以看到现在有一个名为 <code>first</code> 的新目录。注意到下面输出的第一个字符 <code>d</code>：</p><pre tabindex=0><code>$ ls -l
total 0
drwxr-xr-x. 1 root root 0 Oct 15 18:09 first
</code></pre><p>我们可以像常规目录一样操作它：我们可以重命名它，移动它，在里面创建新文件和目录，等等。注意到目录属于 root，所以我们必须以 root 身份去做这些事情。</p><p>如果它表现和看起来就像个目录，那我们如何知道这是不是一个 Btrfs 子卷呢？我们可以使用 <code>btrfs</code> 工具去列出所有子卷：</p><pre tabindex=0><code>$ sudo btrfs subvolume list .
ID 256 gen 30 top level 5 path home
ID 257 gen 30 top level 5 path root
ID 258 gen 25 top level 257 path root/var/lib/machines
ID 259 gen 29 top level 256 path hartan/btrfs-subvolume-test/first
</code></pre><p>如果你安装的是最新的 Fedora Linux，且未修改过，你很可能会看到和上面一样的输出。我们会在之后检查 <code>home</code> 和 <code>root</code> ，还有全部数字的含义。现在，我们看到在我们指定的路径下有一个子卷。我们可以将输出限制在我们当前位置下面的子卷：</p><pre tabindex=0><code>$ sudo btrfs subvolume list -o .
ID 259 gen 29 top level 256 path home/hartan/btrfs-subvolume-test/first
</code></pre><p>让我们重命名子卷：</p><pre tabindex=0><code>$ sudo mv first second
$ sudo btrfs subvolume list -o .
ID 259 gen 29 top level 256 path home/hartan/btrfs-subvolume-test/second
</code></pre><p>我们还可以嵌套子卷：</p><pre tabindex=0><code>$ sudo btrfs subvolume create second/third
Create subvolume &#39;second/third&#39;
$ sudo btrfs subvolume list .
ID 256 gen 34 top level 5 path home
ID 257 gen 37 top level 5 path root
ID 258 gen 25 top level 257 path root/var/lib/machines
ID 259 gen 37 top level 256 path hartan/btrfs-subvolume-test/second
ID 260 gen 37 top level 259 path hartan/btrfs-subvolume-test/second/third
</code></pre><p>我们也可以移除子卷，就像移除目录一样：</p><pre tabindex=0><code>$ sudo rm -r second/third
</code></pre><p>或者通过特殊的 Btrfs 命令：</p><pre tabindex=0><code>$ sudo btrfs subvolume delete second
Delete subvolume (no-commit): &#39;/home/hartan/btrfs-subvolume-test/second&#39;
</code></pre><h3 id=像单独的文件系统一样操作子卷>像单独的文件系统一样操作子卷</h3><p>前面的简介里说 Btrfs 子卷就好像单独的文件系统。这意味着我们可以挂载子卷并且传递一些挂载选项给它。我们先创建一个小的目录结构去更好的理解发生了什么：</p><pre tabindex=0><code>$ mkdir -p a a/1 a/1/b
$ sudo btrfs subvolume create a/2
Create subvolume &#39;a/2&#39;
$ sudo touch a/1/c a/1/b/d a/2/e
</code></pre><p>这就是目录结构的样子：</p><pre tabindex=0><code>$ tree
.
└── a
    ├── 1
    │   ├── b
    │   │   └── d
    │   └── c
    └── 2
        └── e

4 directories, 3 files
</code></pre><p>验证现在这里有一个新的 Btrfs 子卷：</p><pre tabindex=0><code>$ sudo btrfs subvolume list -o .
ID 261 gen 41 top level 256 path home/hartan/btrfs-subvolume-test/a/2
</code></pre><p>为了挂载子卷，我们必须知道 Btrfs 子卷所在的块设备路径。下面的命令会告诉我们：</p><pre tabindex=0><code>$ findmnt -vno SOURCE /home/
/dev/vda3
</code></pre><p>现在我们挂载子卷。确保你将参数替换成你 PC 上的：</p><pre tabindex=0><code>$ sudo mount -o subvol=home/hartan/btrfs-subvolume-test/a/2 /dev/vda3 a/1/b
</code></pre><p>观察到我们使用 <code>-o</code> 参数去提供额外的选项去挂载程序。在这里我们告诉它挂载在设备 <code>/dev/vda3</code> 上 btrfs 文件系统里名为 <code>home/hartan/btrfs-subvolume-test/a/2</code> 的子卷。这是 Btrfs 特有的选项，在其他文件系统里没有的。</p><p>我们可以看到目录结构变化了：</p><pre tabindex=0><code>$ tree
.
└── a
    ├── 1
    │   ├── b
    │   │   └── e
    │   └── c
    └── 2
        └── e

4 directories, 3 files
</code></pre><p>现在文件 <code>e</code> 出现了两次， <code>d</code> 不见了。我们现在可以用两个不同的路径访问相同的 Btrfs 子卷。在一个路径的所有变化会被立刻反应在其他的位置：</p><pre tabindex=0><code>$ sudo touch a/1/b/x
$ ls -lA a/2
total 0
-rw-r--r--. 1 root root 0 Oct 15 18:14 e
-rw-r--r--. 1 root root 0 Oct 15 18:16 x
</code></pre><p>让我们尝试更多的挂载选项。例如我们可以像这样以只读方式挂载子卷到 <code>a/1/b</code>（插入你 PC 的参数）：</p><pre tabindex=0><code>$ sudo umount a/1/b
$ sudo mount -o subvol=home/hartan/btrfs-subvolume-test/a/2,ro /dev/vda3 a/1/b
</code></pre><p>我们和上面使用相同的命令，除了我们加上了 <code>ro</code> 在末尾。现在我们不能在这个挂载点上创建文件：</p><pre tabindex=0><code>$ sudo touch a/1/b/y
touch: cannot touch &#39;a/1/b/y&#39;: Read-only file system
</code></pre><p>但直接访问子卷仍然像之前一样：</p><pre tabindex=0><code>$ sudo touch a/2/y
$ tree
.
└── a
    ├── 1
    │   ├── b
    │   │   ├── e
    │   │   ├── x
    │   │   └── y
    │   └── c
    └── 2
        ├── e
        ├── x
        └── y

4 directories, 7 files
</code></pre><p>在下一步之前不要忘记进行清理：</p><pre tabindex=0><code>$ sudo rm -rf a
rm: cannot remove &#39;a/1/b/e&#39;: Read-only file system
rm: cannot remove &#39;a/1/b/x&#39;: Read-only file system
rm: cannot remove &#39;a/1/b/y&#39;: Read-only file system
</code></pre><p>天啊，发生了什么？噢，因为我们在上面挂载只读子卷，所以不能删除它。从文件系统的角度来看，删除是一种写入操作：为了删除 <code>a/2/b/e</code>，我们从父目录 <code>a/1/b</code> 的内容中删除目录项 <code>e</code>。换句话来说，我们必须 <em>写入</em> <code>a/1/b</code> 去表明 <code>e</code> 不复存在。所以我们先卸载子卷，然后移除目录：</p><pre tabindex=0><code>$ sudo umount a/1/b
$ sudo rm -rf a
$ tree
.

0 directories, 0 files
</code></pre><h3 id=子卷-id>子卷 ID</h3><p>还记得 <code>btrfs subvolume list</code> 命令的第一次输出吗？那包含了很多数字，让我们看看这些究竟什么。我在这里复制了输出，以便再次查看:</p><pre tabindex=0><code>ID 256 gen 30 top level 5 path home
ID 257 gen 30 top level 5 path root
ID 258 gen 25 top level 257 path root/var/lib/machines
ID 259 gen 29 top level 256 path hartan/btrfs-subvolume-test/first
</code></pre><p>我们看到有三列数字，每个前面有一些字母来描述它们的作用。第一列是子卷 ID 。子卷 ID 在 Btrfs 文件系统是唯一的，而且唯一地标识子卷。这意味着名为 <code>home</code> 的子卷也可以用它的 ID <strong>256</strong> 来引用。之前的挂载命令是这样写的：</p><pre tabindex=0><code>$ sudo mount -o subvol=hartan/...
</code></pre><p>另外一个完全合法的选择是使用子卷 ID ：</p><pre tabindex=0><code>$ sudo mount -o subvolid=...
</code></pre><p>子卷 ID 从 <strong>256</strong> 开始，每创建一个子卷依次递增 1 。但是在这里有一个例外：文件系统的根的子卷名称总是为 <code>/</code>，并且子卷 ID 是 5 。没错，即使文件系统的根技术上也是一个子卷。这是不言而喻的，因此不会出现在 <code>btrfs subvolume</code> 的输出列表里。如果你没有用 <code>subvol</code> 和 <code>subvolid</code> 参数去挂载一个 Btrfs 文件系统，<code>subvolid=5</code> 的顶级子卷就是默认的挂载对象。下面我们会看到一个想要显式挂载文件系统根的例子。</p><p>第二列的数字是生成号，并且在每次 Btrfs 事务中递增。这几乎是一个内部的计数器，我们不会在这里讨论。</p><p>最后，第三列数字是 <em>父</em> 子卷的子卷 ID。在上面的输出我们可以看到子卷 <code>home</code> 和 <code>root</code> 的父子卷 ID 都是 5。记住 ID 5 的特殊含义：这是文件系统的根。所以我们知道 <code>home</code> 和 <code>root</code> 都是顶级子卷的子卷。另一方面 <code>hartan/btrfs-subvolume-test.first</code> 是子卷 ID 256（也就是 <code>home</code>）的子卷。</p><p>在下一节我们会看看子卷 <code>root</code> 和 <code>home</code> 是怎么来的。</p><h3 id=检查-fedora-linux-的默认子卷>检查 Fedora Linux 的默认子卷</h3><p>当你从头创建一个新的 Btrfs 文件系统，里面是没有子卷的（当然，除了顶级子卷）。所以 Fedora Linux 里的 <code>home</code> 和 <code>root</code> 子卷是哪里来的？</p><p>它们是安装程序在安装时创建的。传统的安装经常会为 <code>/</code> 和 <code>/home</code> 目录包含单独的文件系统分区。在启动时，它们通过恰当的挂载组成一个完整的文件系统。但这个方法有一个问题：除非你使用像 lvm 这样的技术，想在将来改变分区的大小是非常难的。因而你可能出现 <code>/</code> 或 <code>/home</code> 用完空间的情况，然而还有很多其他没被使用的分区和空间剩余。</p><p>因为 Btrfs 子卷全都是相同文件系统的一部分，它们共享底层文件系统提供的空间。还记得我们在上面创建的子卷吗？我们从未告诉 Btrfs 它们多大：一个子卷可以占据文件系统拥有的全部空间，默认是不会阻止这种行为的。但是，我们 <em>可以</em> 通过 Btrfs 的 限额组 qgroup 动态地约束其大小，同时也可以在运行时修改（我们将在后续的文章中了解如何做的）。</p><p>另外一个分离 <code>/</code> 和 <code>/home</code> 的优势是我们可以分别进行 <em>快照</em> 。子卷是快照的边界，对一个子卷的快照永远不会包含该子卷下面的其他子卷的内容。快照的更多细节会在后续的文章中介绍。</p><p>理论已经足够了！我们来看看这是怎么回事。首先确保你的根文件系统类型是 Btrfs ：</p><pre tabindex=0><code>$ findmnt -no FSTYPE /
btrfs
</code></pre><p>然后我们获取它所在的分区：</p><pre tabindex=0><code>$ findmnt -vno SOURCE /
/dev/vda3
</code></pre><p>记住我们可以通过特殊的子卷 ID 5 挂载文件系统的根（适应文件系统分区！）：</p><pre tabindex=0><code>$ mkdir fedora-rootsubvol
$ sudo mount -o subvolid=5 /dev/vda3 ./fedora-rootsubvol
$ ls fedora-rootsubvol/
home  root
</code></pre><p>而且还有 Fedora Linux 安装的子卷！但 Fedora Linux 是如何知道子卷 <code>root</code> 属于 <code>/</code> ，而 <code>home</code> 属于 <code>/home</code> 的呢？</p><p>文件 <code>/etc/fstab</code> 包含了所谓的文件系统的静态信息。简而言之，在你系统启动的时候会一行一行地读取这个文件，然后挂载那里列出的所有文件系统。在我的系统上，这个文件长这样：</p><pre tabindex=0><code>$ cat /etc/fstab
# [ ... ]
# /etc/fstab
# Created by anaconda on Sat Oct 15 12:01:57 2022
# [ ... ]
#
UUID=5e4e42bb-4f2f-4f0e-895f-d1a46ea47807 /                       btrfs   subvol=root,compress=zstd:1 0 0
UUID=e3a798a8-b8f2-40ca-9da7-5e292a6412aa /boot                   ext4    defaults        1 2
UUID=5e4e42bb-4f2f-4f0e-895f-d1a46ea47807 /home                   btrfs   subvol=home,compress=zstd:1 0 0
</code></pre><p>（注意上面的 “UUID” 开头行的内容被换行成两行）</p><p>每行开头的 <code>UUID</code> 用于标识你系统上的硬盘和文件系统分区（大概相当于我在上面使用的 <code>/dev/vda3</code> ）。第二列是文件系统应该挂载在文件系统树上的路径。第三列是文件系统类型。我们可以看到 <code>/</code> 和 <code>/home</code> 都是 <code>btrfs</code> 类型，正如我们期望的那样！最后，第四列是：这些是挂载选项，这里说通过 <code>subvol=root</code> 选项去挂载 <code>/</code> 。这正是我们一直在 <code>btrfs subvolume list /</code> 里看到的输出！</p><p>有了这些信息，我们可以重新构建创建这个文件系统项的 <code>mount</code> 命令</p><pre tabindex=0><code>$ sudo mount -o subvol=root,compress=zstd:1 UUID=5e4e42bb-4f2f-4f0e-895f-d1a46ea47807 /
</code></pre><p>（再次，上面的 “UUID” 开头行的内容被换行成两行）</p><p>这就是 Fedora Linux 如何使用 Btrfs 子卷！如果你对好奇 Fedora Linux 为什么选择 Btrfs 作为默认的文件系统，请参阅下面链接的更改提议 [1] 。</p><h3 id=btrfs-子卷的更多内容>Btrfs 子卷的更多内容</h3><p>Btrfs 维基提供了关于子卷的更多信息，其中最重要的是可应用于 Btrfs 子卷的挂载选项。有些选项，比如 <code>compress</code> 只能应用到文件系统的层面，因而会影响一个 Btrfs 文件系统的所有子卷。你可以通过下面的链接找到entry [2] 。</p><p>如果你对哪些目录是普通目录和哪些是子卷有困惑，你可以对你的子卷采用特殊的命名约定。例如，你可以给子卷名加上 <code>@</code> 前缀去方便区分。</p><p>现在你知道子卷表现得就像文件系统，有人可能会问如何才能最好地将子卷放置在特定位置。比如你想要一个 Btrfs 子卷在 <code>~/games</code> 下面，然而你的主目录（<code>~</code>）本身就是一个子卷，你该如何实现呢？鉴于上面的例子，你可以使用像 <code>sudo btrfs subvolume create ~/games</code> 的命令。这样，你创建了所谓的 <em>嵌套</em> 子卷：在你的子卷 <code>~</code> 里，有一个子卷 <code>games</code> 。这正是一种达成目的的方法。</p><p>其他有效的方法就是如同 Fedora 默认行为那样：在根子卷下创建所有子卷（也就是它们的父子卷 ID 是 5 ），然后挂载它们到特定的位置。Btrfs 维基有这些方法的概述和对于各自文件系统管理影响的简短讨论 [3] 。</p><h3 id=总结>总结</h3><p>在本文中，我们探索了 Btrfs 子卷，它们像是 Btrfs 文件系统内部的独立的 Btrfs 文件系统。我们学习了如何创建、挂载和删除子卷。最后，我们探讨了 Fedora Linux 如何在我们完全没有注意到的情况下使用子卷。</p><p>本系列的下一篇文章将讨论：</p><ul><li>快照 - 回到过去</li><li>压缩 - 透明地节省存储空间</li><li>配额组 - 限制文件系统大小</li><li>RAID - 替代 mdadm 配置</li></ul><p>如果你还想了解与 Btrfs 相关的其他主题，请查看 Btrfs 维基 [4] 和文档 [5] 。不要忘记查看本系列的第一篇文章（如果你还没有看过的话）！如果你认为本系列文章缺少了一些内容，请在下面的评论中告诉我们。再会！</p><h3 id=参考资料>参考资料</h3><ol><li><a href=https://fedoraproject.org/wiki/Changes/BtrfsByDefault#Benefit_to_Fedora>https://fedoraproject.org/wiki/Changes/BtrfsByDefault#Benefit_to_Fedora</a> <a href=#fnref1>↩︎</a></li><li><a href=https://btrfs.readthedocs.io/en/latest/Subvolumes.html>https://btrfs.readthedocs.io/en/latest/Subvolumes.html</a> <a href=#fnref2>↩︎</a></li><li><a href=https://btrfs.wiki.kernel.org/index.php/SysadminGuide#Layout>https://btrfs.wiki.kernel.org/index.php/SysadminGuide#Layout</a> <a href=#fnref3>↩︎</a></li><li><a href=https://btrfs.wiki.kernel.org/index.php/Main_Page>https://btrfs.wiki.kernel.org/index.php/Main_Page</a> <a href=#fnref4>↩︎</a></li><li><a href=https://btrfs.readthedocs.io/en/latest/Introduction.html>https://btrfs.readthedocs.io/en/latest/Introduction.html</a> <a href=#fnref5>↩︎</a></li></ol><p><em>（题图：MJ/f047ea87-2490-40e5-9f91-d48d236675e5）</em></p><hr><p>via: <a href=https://fedoramagazine.org/working-with-btrfs-subvolumes/>https://fedoramagazine.org/working-with-btrfs-subvolumes/</a></p><p>作者：<a href=https://fedoramagazine.org/author/hartan/>Andreas Hartmann</a> 选题：<a href=https://github.com/lujun9972>lujun9972</a> 译者：<a href=https://github.com/A2ureStone>A2ureStone</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/btrfs/ rel=tag>Btrfs</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>