<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>在 Linux 上使用 Checksec 识别二进制文件的安全属性 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="在 Linux 上使用 Checksec 识别二进制文件的安全属性"><meta property="og:description" content="这篇文章能让你了解如何使用 Checksec ，来识别一个可执行文件的安全属性，了解安全属性的含义，并知道如何使用它们。"><meta property="og:type" content="article"><meta property="og:url" content="/article-15264-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-11-18T09:57:08+00:00"><meta property="article:modified_time" content="2022-11-18T09:57:08+00:00"><meta itemprop=name content="在 Linux 上使用 Checksec 识别二进制文件的安全属性"><meta itemprop=description content="这篇文章能让你了解如何使用 Checksec ，来识别一个可执行文件的安全属性，了解安全属性的含义，并知道如何使用它们。"><meta itemprop=datePublished content="2022-11-18T09:57:08+00:00"><meta itemprop=dateModified content="2022-11-18T09:57:08+00:00"><meta itemprop=wordCount content="1182"><meta itemprop=keywords content="Checksec,二进制,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>在 Linux 上使用 Checksec 识别二进制文件的安全属性</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2022-11-18T09:57:08Z>November 18, 2022</time></div></div></header><div class="content post__content clearfix"><blockquote><p>这篇文章能让你了解如何使用 Checksec ，来识别一个可执行文件的安全属性，了解安全属性的含义，并知道如何使用它们。</p></blockquote><p><img src=/data/attachment/album/202211/18/095702dzvm482460vnrv6y.jpg alt></p><p>编译源代码会生成一个二进制文件（LCTT 译注：即 <code>.o</code> 文件）。在编译期间，你可以向 <code>gcc</code> 编译器提供 标志 flags ，以启用或禁用二进制文件的某些属性，这些属性与安全性相关。</p><p>Checksec 是一个漂亮的小工具，同时它也是一个 shell 脚本。Checksec 可以识别编译时构建到二进制文件中的安全属性。编译器可能会默认启用一些安全属性，你也可以提供特定的标志，来启用其他的安全属性。</p><p>本文将介绍如何使用 Checksec ，来识别二进制文件的安全属性，包括：</p><ol><li>Checksec 在查找有关安全属性的信息时，使用了什么<strong>底层的命令</strong></li><li>在将源代码编译成二进制文件时，如何使用 GNU 编译器套件 GNU Compiler Collection （即 GCC）来<strong>启用安全属性</strong>。</li></ol><h3 id=安装-checksec>安装 checksec</h3><p>要在 Fedora 和其他基于 RPM 的 Linux 系统上，安装 Checksec，请使用以下命令：</p><pre tabindex=0><code>$ sudo dnf install checksec
</code></pre><p>对于基于 Debian 的 Linux 发行版，使用对应的 <code>apt</code> 命令，来安装 Checksec。</p><pre tabindex=0><code>$ sudo apt install checksec
</code></pre><h3 id=shell-脚本>shell 脚本</h3><p>在安装完 Checksec 后，能够发现 Checksec 是一个<strong>单文件</strong>的 shell 脚本，它位于 <code>/usr/bin/checksec</code>，并且这个文件挺大的。Checksec 的一个优点是你可以通过快速通读这个 shell 脚本，从而了解 Checksec 的执行原理、明白所有能查找有关二进制文件或可执行文件的安全属性的<strong>系统命令</strong>：</p><pre tabindex=0><code>$ file /usr/bin/checksec
/usr/bin/checksec: Bourne-Again shell script, ASCII text executable, with very long lines

$ wc -l /usr/bin/checksec
2111 /usr/bin/checksec
</code></pre><p>以下的命令展示了如何对你每天都会使用的：<code>ls</code> 命令的二进制文件运行 Checksec。Checksec 命令的格式是：<code>checksec --file=</code>，后面再跟上二进制文件的绝对路径：</p><pre tabindex=0><code>$ checksec --file=/usr/bin/ls
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols         FORTIFY Fortified       Fortifiable     FILE
Full RELRO      Canary found      NX enabled    PIE enabled     No RPATH   No RUNPATH   No Symbols        Yes   5       17              /usr/bin/ls
</code></pre><p>当你在终端中对某个二进制文件运行 Checksec 时，你会看到安全属性有颜色上的区分，显示什么是好的安全属性（绿色），什么可能不是好的安全属性（红色）。我在这里说 <strong>“可能”</strong> 是因为即使有些安全属性是红色的，也不一定意味着这个二进制文件很糟糕，它可能只是表明发行版供应商在编译二进制文件时做了一些权衡，从而舍弃了部分安全属性。</p><p>Checksec 输出的第一行提供了二进制文件的各种安全属性，例如 <code>RELRO</code>、<code>STACK CANARY</code>、<code>NX</code> 等（我将在后文进行详细解释）。第二行打印出给定二进制文件（本例中为 <code>ls</code>）在这些安全属性的状态（例如，<code>NX enabled</code> 表示为堆栈中的数据没有执行权限）。</p><h3 id=示例二进制文件>示例二进制文件</h3><p>在本文中，我将使用以下的 “hello world” 程序作为示例二进制文件。</p><pre tabindex=0><code>#include &lt;stdio.h&gt;

int main()
{
        printf(&#34;Hello World\n&#34;);
        return 0;
}
 
</code></pre><p>请注意，在编译源文件 <code>hello.c</code> 的时候，我没有给 <code>gcc</code> 提供任何额外的标志：</p><pre tabindex=0><code>$ gcc hello.c -o hello
 
$ file hello
hello: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=014b8966ba43e3ae47fab5acae051e208ec9074c, for GNU/Linux 3.2.0, not stripped

$ ./hello
Hello World
</code></pre><p>使用 Checksec 运行二进制文件 <code>hello</code>，打印的某些安全属性的状态，与上面的 <code>ls</code> 二进制文件的结果不同（在你的屏幕上，某些属性可能显示为红色）：</p><pre tabindex=0><code>$ checksec --file=./hello
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols         FORTIFY Fortified       Fortifiable     FILE
Partial RELRO   No canary found   NX enabled    No PIE          No RPATH   No RUNPATH   85) Symbols       No    0       0./hello
$
</code></pre><p>（LCTT 译注：在我的 Ubuntu 22.04 虚拟机，使用 11.3.0 版本的 <code>gcc</code>，结果与上述不太相同，利用默认参数进行编译，会得到 RELRO、PIE、NX 保护是全开的情况。）</p><h3 id=更改-checksec-的输出格式>更改 Checksec 的输出格式</h3><p>Checksec 允许自定义各种输出格式，你可以使用 <code>--output</code> 来自定义输出格式。我将选择的输出格式是 JSON 格式，并将输出结果通过管道传输到 <code>jq</code> 实用程序，来得到漂亮的打印。</p><p>接下来，确保你已安装好了 <a href=https://stedolan.github.io/jq/download/>jq</a>，因为本教程会使用 <code>jq</code> 从 Checksec 的输出结果中，用 <code>grep</code> 来快速得到某一特定的安全属性状态，并报告该安全属性是否启动（启动为 <code>yes</code>，未启动为 <code>no</code>）：</p><pre tabindex=0><code>$ checksec --file=./hello --output=json | jq
{
  &#34;hello&#34;: {
    &#34;relro&#34;: &#34;partial&#34;,
    &#34;canary&#34;: &#34;no&#34;,
    &#34;nx&#34;: &#34;yes&#34;,
    &#34;pie&#34;: &#34;no&#34;,
    &#34;rpath&#34;: &#34;no&#34;,
    &#34;runpath&#34;: &#34;no&#34;,
    &#34;symbols&#34;: &#34;yes&#34;,
    &#34;fortify_source&#34;: &#34;no&#34;,
    &#34;fortified&#34;: &#34;0&#34;,
    &#34;fortify-able&#34;: &#34;0&#34;
  }
}
</code></pre><h3 id=看一看所有的安全属性>看一看所有的安全属性</h3><p>上面的二进制文件 <code>hello</code> 包括几个安全属性。我将该二进制文件与 <code>ls</code> 的二进制文件进行比较，以检查启用的安全属性有何不同，并解释 Checksec 是如何找到此信息。</p><h4 id=1符号symbol>1、符号（Symbol）</h4><p>我先从简单的讲起。在编译期间，某些 符号 symbols 包含在二进制文件中，这些符号主要用作于调试。开发软件时，需要用到这些符号，来调试和修复错误。</p><p>这些符号通常会从供用户普遍使用的最终二进制文件中删除。删除这些符号不会影响到二进制文件的执行。删除符号通常是为了节省空间，因为一旦符号被删除了，二进制文件就会稍微小一些。在闭源或专有软件中，符号通常都会被删除，因为把这些符号放在二进制文件中，可以很容易地推断出软件的内部工作原理。</p><p>根据 Checksec 的结果，在二进制文件 <code>hello</code> 中有符号，但在 <code>ls</code> 的二进制文件中不会有符号。同样地，你还可以用 <code>file</code> 命令，来找到符号的信息，在二进制文件 <code>hello</code> 的输出结果的最后，看到 <code>not stripped</code>，表明二进制文件 <code>hello</code> 有符号：</p><pre tabindex=0><code>$ checksec --file=/bin/ls --output=json | jq | grep symbols
    &#34;symbols&#34;: &#34;no&#34;,

$ checksec --file=./hello --output=json | jq | grep symbols
    &#34;symbols&#34;: &#34;yes&#34;,

$ file hello
hello: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=014b8966ba43e3ae47fab5acae051e208ec9074c, for GNU/Linux 3.2.0, not stripped
</code></pre><p>Checksec 是如何找到符号的信息呢？Checksec 提供了一个方便的 <code>--debug</code> 选项，来显示运行了哪些函数。因此，运行以下的命令，会显示在 shell 脚本中运行了哪些函数：</p><pre tabindex=0><code>$ checksec --debug --file=./hello
</code></pre><p>在本教程中，我试图寻找 Checksec 查找安全属性信息时，使用了什么<strong>底层命令</strong>。由于 Checksec 是一个 shell 脚本，因此你始终可以使用 Bash 功能。以下的命令将输出从 shell 脚本中运行的每个命令：</p><pre tabindex=0><code>$ bash -x /usr/bin/checksec --file=./hello
</code></pre><p>如果你滚动浏览上述的输出结果的话，你会看到 <code>echo_message</code> 后面有各个安全属性的类别。以下显示了 Checksec 检测二进制文件是否包含符号时，运行的底层命令：</p><pre tabindex=0><code>+ readelf -W --symbols ./hello
+ grep -q &#39;\\.symtab&#39;
+ echo_message &#39;\033[31m96) Symbols\t\033[m  &#39; Symbols, &#39; symbols=&#34;yes&#34;&#39; &#39;&#34;symbols&#34;:&#34;yes&#34;,&#39;
</code></pre><p>上面的输出显示，Checksec 利用 <code>readelf</code>，来读取二进制文件，并提供一个特殊 <code>--symbols</code> 标志，来列出二进制文件中的所有符号。然后它会查找一个特殊值：<code>.symtab</code>，它提供了所能找到的条目的计数（即符号的个数）。你可以在上面编译的测试二进制文件 <code>hello</code> 上，尝试以下命令，得到与 Checksec 查看二进制文件类似的符号信息：</p><pre tabindex=0><code>$ readelf -W --symbols ./hello
$ readelf -W --symbols ./hello | grep -i symtab
</code></pre><p>（LCTT 译注：也可以通过直接查看 <code>/usr/bin/checksec</code> 下的 Checksec 源文件。）</p><h5 id=如何删除符号>如何删除符号</h5><p>你可以在编译后或编译时删除符号。</p><ul><li><strong>编译后：</strong> 在编译后，你可以使用 <code>strip</code>，手动地来删除二进制文件的符号。删除后，使用 <code>file</code> 命令，来检验是否还有符号，现在显示 <code>stripped</code>，表明二进制文件 <code>hello</code> 无符号了：</li></ul><pre tabindex=0><code>$ gcc hello.c -o hello
$
$ file hello
hello: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=322037496cf6a2029dcdcf68649a4ebc63780138, for GNU/Linux 3.2.0, not stripped
$
$ strip hello
$
$ file hello
hello: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=322037496cf6a2029dcdcf68649a4ebc63780138, for GNU/Linux 3.2.0, stripped
$ 
</code></pre><ul><li><strong>编译时：</strong> 你也可以在编译时，用 <code>-s</code> 参数让 gcc 编译器帮你自动地删除符号：</li></ul><pre tabindex=0><code>$ gcc -s hello.c -o hello
$
$ file hello
hello: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=247de82a8ad84e7d8f20751ce79ea9e0cf4bd263, for GNU/Linux 3.2.0, stripped
$
</code></pre><p>重新运行 Checksec，你可以看到现在二进制文件 <code>hello</code> 的 <code>symbols</code> 这一属性的值是<code>no</code>：</p><pre tabindex=0><code>$ checksec --file=./hello --output=json | jq | grep symbols
    &#34;symbols&#34;: &#34;no&#34;,
$
</code></pre><h4 id=2canary堆栈溢出哨兵>2、Canary（堆栈溢出哨兵）</h4><p>Canary 是放置在缓冲区和 栈 stack 上的控制数据之间的已知值，它用于监视缓冲区是否溢出。当应用程序执行时，会为其分配两种内存，其中之一就是 <em>栈</em>。栈是一个具有两个操作的数据结构：第一个操作 <code>push</code>，将数据压入堆栈；第二个操作 <code>pop</code>，以后进先出的顺序从栈中弹出数据。恶意的输入可能会导致栈溢出，或使用特制的输入破坏栈，并导致程序崩溃：</p><pre tabindex=0><code>$ checksec --file=/bin/ls --output=json | jq | grep canary
    &#34;canary&#34;: &#34;yes&#34;,
$
$ checksec --file=./hello --output=json | jq | grep canary
    &#34;canary&#34;: &#34;no&#34;,
$
</code></pre><p>Checksec 是如何确定二进制文件是否启用了 Canary 的呢？使用上述同样的方法，得到 Checksec 在检测二进制文件是否启用 Canary 时，运行的底层命令：</p><pre tabindex=0><code>$ readelf -W -s ./hello | grep -E &#39;__stack_chk_fail|__intel_security_cookie&#39;
</code></pre><h5 id=启用-canary>启用 Canary</h5><p>为了防止栈溢出等情况，编译器提供了 <code>-stack-protector-all</code> 标志，它向二进制文件添加了额外的代码，来检查缓冲区是否溢出：</p><pre tabindex=0><code>$ gcc -fstack-protector-all hello.c -o hello

$ checksec --file=./hello --output=json | jq | grep canary
    &#34;canary&#34;: &#34;yes&#34;,
</code></pre><p>Checksec 显示 Canary 属性现已启用。你还可以通过以下方式，来验证这一点：</p><pre tabindex=0><code>$ readelf -W -s ./hello | grep -E &#39;__stack_chk_fail|__intel_security_cookie&#39;
     2: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __stack_chk_fail@GLIBC_2.4 (3)
    83: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __stack_chk_fail@@GLIBC_2.4
$
</code></pre><h4 id=3位置无关可执行文件pie>3、位置无关可执行文件（PIE）</h4><p>位置无关可执行文件 Position-Independent Executable （PIE），顾名思义，它指的是放置在内存中某处执行的代码，不管其绝对地址的位置，即代码段、数据段地址随机化（ASLR）：</p><pre tabindex=0><code>$ checksec --file=/bin/ls --output=json | jq | grep pie
    &#34;pie&#34;: &#34;yes&#34;,

$ checksec --file=./hello --output=json | jq | grep pie
    &#34;pie&#34;: &#34;no&#34;,
</code></pre><p>通常，PIE 仅对 库 libraries 启用，并不对独立命令行程序启用 PIE。在下面的输出中，<code>hello</code> 显示为 <code>LSB executable</code>，而 <code>libc</code> 标准库（<code>.so</code>） 文件被标记为 <code>LSB shared object</code>：</p><pre tabindex=0><code>$ file hello
hello: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=014b8966ba43e3ae47fab5acae051e208ec9074c, for GNU/Linux 3.2.0, not stripped

$ file /lib64/libc-2.32.so
/lib64/libc-2.32.so: ELF 64-bit LSB shared object, x86-64, version 1 (GNU/Linux), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=4a7fb374097fb927fb93d35ef98ba89262d0c4a4, for GNU/Linux 3.2.0, not stripped
</code></pre><p>Checksec 查找是否启用 PIE 的底层命令如下：</p><pre tabindex=0><code>$ readelf -W -h ./hello | grep EXEC
  Type:                              EXEC (Executable file)
</code></pre><p>如果你在共享库上尝试相同的命令，你将看到 <code>DYN</code>，而不是 <code>EXEC</code>：</p><pre tabindex=0><code>$ readelf -W -h /lib64/libc-2.32.so | grep DYN
  Type:                              DYN (Shared object file)
</code></pre><h5 id=启用-pie>启用 PIE</h5><p>要在测试程序 <code>hello.c</code> 上启用 PIE，请在编译时，使用以下命令：</p><pre tabindex=0><code>$ gcc -pie -fpie hello.c -o hello`
</code></pre><p>你可以使用 Checksec，来验证 PIE 是否已启用：</p><pre tabindex=0><code>$ checksec --file=./hello --output=json | jq | grep pie
    &#34;pie&#34;: &#34;yes&#34;,
$
</code></pre><p>现在，应该会显示为 “ PIE 可执行 pie executable ”，其类型从 <code>EXEC</code> 更改为 <code>DYN</code>：</p><pre tabindex=0><code>$ file hello
hello: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=bb039adf2530d97e02f534a94f0f668cd540f940, for GNU/Linux 3.2.0, not stripped

$ readelf -W -h ./hello | grep DYN
  Type:                              DYN (Shared object file)
</code></pre><h4 id=4nx堆栈禁止执行>4、NX（堆栈禁止执行）</h4><p>NX 代表 不可执行 non-executable 。它通常在 CPU 层面上启用，因此启用 NX 的操作系统可以将某些内存区域标记为不可执行。通常，缓冲区溢出漏洞将恶意代码放在堆栈上，然后尝试执行它。但是，让堆栈这些可写区域变得不可执行，可以防止这种攻击。在使用 <code>gcc</code> 对源程序进行编译时，默认启用此安全属性：</p><pre tabindex=0><code>$ checksec --file=/bin/ls --output=json | jq | grep nx
    &#34;nx&#34;: &#34;yes&#34;,

$ checksec --file=./hello --output=json | jq | grep nx
    &#34;nx&#34;: &#34;yes&#34;,
</code></pre><p>Checksec 使用以下底层命令，来确定是否启用了 NX。在尾部的 <code>RW</code> 表示堆栈是可读可写的；因为没有 <code>E</code>，所以堆栈是不可执行的：</p><pre tabindex=0><code>$ readelf -W -l ./hello | grep GNU_STACK
  GNU_STACK      0x000000 0x0000000000000000 0x0000000000000000 0x000000 0x000000 RW  0x10
</code></pre><h5 id=演示如何禁用-nx>演示如何禁用 NX</h5><p>我们不建议禁用 NX，但你可以在编译程序时，使用 <code>-z execstack</code> 参数，来禁用 NX：</p><pre tabindex=0><code>$ gcc -z execstack hello.c -o hello

$ checksec --file=./hello --output=json | jq | grep nx
    &#34;nx&#34;: &#34;no&#34;,
</code></pre><p>编译后，堆栈会变为可读可写可执行（<code>RWE</code>），允许在堆栈上的恶意代码执行：</p><pre tabindex=0><code>$ readelf -W -l ./hello | grep GNU_STACK
  GNU_STACK      0x000000 0x0000000000000000 0x0000000000000000 0x000000 0x000000 RWE 0x10
</code></pre><h4 id=5relrogot-写保护>5、RELRO（GOT 写保护）</h4><p>RELRO 代表 “ 重定位只读 Relocation Read-Only ”。可执行链接格式（ELF）二进制文件使用全局偏移表（GOT）来动态地解析函数。启用 RELRO 后，会设置二进制文件中的 GOT 表为只读，从而防止重定位攻击：</p><pre tabindex=0><code>$ checksec --file=/bin/ls --output=json | jq | grep relro
    &#34;relro&#34;: &#34;full&#34;,

$ checksec --file=./hello --output=json | jq | grep relro
    &#34;relro&#34;: &#34;partial&#34;,
</code></pre><p>Checksec 使用以下底层命令，来查找是否启用 RELRO。在二进制文件 <code>hello</code> 仅启用了 RELRO 属性中的一个属性，因此，在 Checksec 验证时，显示 <code>partial</code>：</p><pre tabindex=0><code>$ readelf -W -l ./hello | grep GNU_RELRO
  GNU_RELRO      0x002e10 0x0000000000403e10 0x0000000000403e10 0x0001f0 0x0001f0 R   0x1

$ readelf -W -d ./hello | grep BIND_NOW
</code></pre><h5 id=启用全-relro>启用全 RELRO</h5><p>要启用全 RELRO，请在 <code>gcc</code> 编译时，使用以下命令行参数：</p><pre tabindex=0><code>$ gcc -Wl,-z,relro,-z,now hello.c -o hello

$ checksec --file=./hello --output=json | jq | grep relro
    &#34;relro&#34;: &#34;full&#34;,
</code></pre><p>现在， RELRO 中的第二个属性也被启用，使程序变成全 RELRO：</p><pre tabindex=0><code>$ readelf -W -l ./hello | grep GNU_RELRO
  GNU_RELRO      0x002dd0 0x0000000000403dd0 0x0000000000403dd0 0x000230 0x000230 R   0x1

$ readelf -W -d ./hello | grep BIND_NOW
 0x0000000000000018 (BIND_NOW)       
</code></pre><h4 id=6fortify>6、Fortify</h4><p>Fortify 是另一个安全属性，但它超出了本文的范围。Checksec 是如何在二进制文件中验证 Fortify，以及如何在 <code>gcc</code> 编译时启用 Fortify，作为你需要解决的课后练习。</p><pre tabindex=0><code>$ checksec --file=/bin/ls --output=json | jq  | grep -i forti
    &#34;fortify_source&#34;: &#34;yes&#34;,
    &#34;fortified&#34;: &#34;5&#34;,
    &#34;fortify-able&#34;: &#34;17&#34;

$ checksec --file=./hello --output=json | jq  | grep -i forti
    &#34;fortify_source&#34;: &#34;no&#34;,
    &#34;fortified&#34;: &#34;0&#34;,
    &#34;fortify-able&#34;: &#34;0&#34;
</code></pre><h3 id=其他的-checksec-功能>其他的 Checksec 功能</h3><p>关于安全性的话题是永无止境的，不可能在本文涵盖所有关于安全性的内容，但我还想提一下 Checksec 命令的一些其他功能，这些功能也很好用。</p><h4 id=对多个二进制文件运行-checksec>对多个二进制文件运行 Checksec</h4><p>你不必对每个二进制文件都进行一次 Checksec。相反，你可以提供多个二进制文件所在的目录路径，Checksec 将一次性为你验证所有文件：</p><pre tabindex=0><code>$ checksec --dir=/usr
</code></pre><h4 id=对进程运行-checksec>对进程运行 Checksec</h4><p>Checksec 除了能检查二进制文件的安全属性，Checksec 还能对程序起作用。以下的命令用于查找你系统上所有正在运行的程序的安全属性。如果你希望 Checksec 检查所有正在运行的进程，可以使用 <code>--proc-all</code>，或者你也可以使用进程名称，选择特定的进程进行检查：</p><pre tabindex=0><code>$ checksec --proc-all

$ checksec --proc=bash
</code></pre><h4 id=对内核运行-checksec>对内核运行 Checksec</h4><p>除了本文介绍的用 Checksec 检查用户态应用程序的安全属性之外，你还可以使用它来检查系统内置的 内核属性 kernel properties ：</p><pre tabindex=0><code>$ checksec --kernel
</code></pre><h3 id=快来试一试-checksec-吧>快来试一试 Checksec 吧</h3><p>Checksec 是一个能了解哪些用户空间和内核的安全属性被启用的好方法。现在，你就可以开始使用 Checksec，来了解每个安全属性是什么，并明白启用每个安全属性的原因，以及它能阻止的攻击类型。</p><hr><p>via: <a href=https://opensource.com/article/21/6/linux-checksec>https://opensource.com/article/21/6/linux-checksec</a></p><p>作者：<a href=https://opensource.com/users/gkamathe>Gaurav Kamathe</a> 选题：<a href=https://github.com/lujun9972>lujun9972</a> 译者：<a href=https://github.com/chai001125>chai001125</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/checksec/ rel=tag>Checksec</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/ rel=tag>二进制</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>