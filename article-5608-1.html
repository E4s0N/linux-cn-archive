<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>在Linux命令行下令人惊叹的惊叹号（!） - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="在Linux命令行下令人惊叹的惊叹号（!）"><meta property="og:description" content="&lsquo;!&lsquo;符号在Linux中不但可以用作否定符号，还可以用来从历史命令记录中取出命令或不加修改的执行之前运行的命令。下面的所有命令都已经在Bash Shell中经过确切地检验。尽管我没有试过，但大多都不能在别的Shell中运行。这里我们介绍下Linux命令行中符号&rsquo;!&lsquo;那惊人和奇妙的用法。  1. 使用数字从历史命令列表中找一条命令来执行 您也许没有意识到您可以从历史命令列表（之前已经执行的命令集）中找出一条来运行。首先，通过&#34;history&#34;命令查找之前命令的序号。 $ history   使用history命令找到最后执行的命令 现在，只需要使用历史命令输出中"><meta property="og:type" content="article"><meta property="og:url" content="/article-5608-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2015-06-11T14:02:00+00:00"><meta property="article:modified_time" content="2015-06-11T14:02:00+00:00"><meta itemprop=name content="在Linux命令行下令人惊叹的惊叹号（!）"><meta itemprop=description content="&lsquo;!&lsquo;符号在Linux中不但可以用作否定符号，还可以用来从历史命令记录中取出命令或不加修改的执行之前运行的命令。下面的所有命令都已经在Bash Shell中经过确切地检验。尽管我没有试过，但大多都不能在别的Shell中运行。这里我们介绍下Linux命令行中符号&rsquo;!&lsquo;那惊人和奇妙的用法。  1. 使用数字从历史命令列表中找一条命令来执行 您也许没有意识到您可以从历史命令列表（之前已经执行的命令集）中找出一条来运行。首先，通过&#34;history&#34;命令查找之前命令的序号。 $ history   使用history命令找到最后执行的命令 现在，只需要使用历史命令输出中"><meta itemprop=datePublished content="2015-06-11T14:02:00+00:00"><meta itemprop=dateModified content="2015-06-11T14:02:00+00:00"><meta itemprop=wordCount content="346"><meta itemprop=keywords content="脚本,惊叹号,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>在Linux命令行下令人惊叹的惊叹号（!）</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2015-06-11T14:02:00Z>June 11, 2015</time></div></div></header><div class="content post__content clearfix"><p><code>'!'</code>符号在Linux中不但可以用作否定符号，还可以用来从历史命令记录中取出命令或不加修改的执行之前运行的命令。下面的所有命令都已经在Bash Shell中经过确切地检验。尽管我没有试过，但大多都不能在别的Shell中运行。这里我们介绍下Linux命令行中符号<code>'!'</code>那惊人和奇妙的用法。</p><p><img src=/data/attachment/album/201506/11/140239tazxmmzbpxuqtkyq.png alt></p><h3 id=1-使用数字从历史命令列表中找一条命令来执行>1. 使用数字从历史命令列表中找一条命令来执行</h3><p>您也许没有意识到您可以从历史命令列表（之前已经执行的命令集）中找出一条来运行。首先，通过"history"命令查找之前命令的序号。</p><pre tabindex=0><code>$ history
</code></pre><p><img src=/data/attachment/album/201506/11/140241esssmlz1bllwtv9c.gif alt=使用history命令找到最后执行的命令></p><p><em>使用history命令找到最后执行的命令</em></p><p>现在，只需要使用历史命令输出中显示在该命令前面的数字便可以运行这个命令。例如，运行一个在<code>history</code>输出中编号是1551的命令。</p><pre tabindex=0><code>$ !1551
</code></pre><p><img src=/data/attachment/album/201506/11/140242qgtv17zhghhvhhar.gif alt=使用命令ID来执行最后运行的命令></p><p><em>使用命令ID来执行最后运行的命令</em></p><p>这样，编号为1551的命令（上面的例子是<a href=http://www.tecmint.com/12-top-command-examples-in-linux/>top命令</a>）便运行了。这种通过ID号来执行之前的命令的方式很有用，尤其是在这些命令都很长的情况下。您只需要使用**![history命令输出的序号]**便可以调用它。</p><h3 id=2-运行之前的倒数第二个第七个命令等>2. 运行之前的倒数第二个、第七个命令等</h3><p>您可以以另一种方式来运行之前执行的命令，通过使用-1代表最后的命令，-2代表倒数第二个命令，-7代表倒数第七个命令等。</p><p>首先使用history命令来获得执行过的命令的列表。<strong>history命令的执行很有必要</strong>，因为您可以通过它来确保没有<code>rm command > file</code>或其他会导致危险的命令。接下来执行倒数第六个、第八个、第十个命令。</p><pre tabindex=0><code>$ history
$ !-6
$ !-8
$ !-10
</code></pre><p><img src=/data/attachment/album/201506/11/140244lcmlciihh1hwetlh.gif alt=通过负数序号运行之前执行的命令></p><p><em>通过负数序号运行之前执行的命令</em></p><h3 id=3-传递最后执行的命令的参数以方便的运行新的命令>3. 传递最后执行的命令的参数，以方便的运行新的命令</h3><p>我需要显示<code>/home/$USER/Binary/firefox</code>文件夹的内容，因此我执行：</p><pre tabindex=0><code>$ ls /home/$USER/Binary/firefox
</code></pre><p>接下来，我意识到我应该执行&rsquo;ls -l&rsquo;来查看哪个文件是可执行文件。因此我应该重新输入整个命令么？不，我不需要。我仅需要在新的命令中带上最后的参数，类似：</p><pre tabindex=0><code>$ ls -l !$
</code></pre><p>这里<code>!$</code>将把最后执行的命令的参数传递到这个新的命令中。</p><p><img src=/data/attachment/album/201506/11/140247mp2kjz719gk1yhrj.gif alt=将上一个命令的参数传递给新命令></p><p><em>将上一个命令的参数传递给新命令</em></p><h3 id=4-如何使用来处理两个或更多的参数>4. 如何使用!来处理两个或更多的参数</h3><p>比如说我在桌面创建了一个文本文件file1.txt。</p><pre tabindex=0><code>$ touch /home/avi/Desktop/1.txt
</code></pre><p>然后在cp命令中使用绝对路径将它拷贝到<code>/home/avi/Downloads</code>。</p><pre tabindex=0><code>$ cp /home/avi/Desktop/1.txt /home/avi/downloads
</code></pre><p>这里，我们给cp命令传递了两个参数。第一个是<code>/home/avi/Desktop/1.txt</code>，第二个是<code>/home/avi/Downloads</code>。让我们分别处理他们，使用<code>echo [参数]</code>来打印两个不同的参数。</p><pre tabindex=0><code>$ echo &#34;1st Argument is : !^&#34;
$ echo &#34;2nd Argument is : !cp:2&#34;
</code></pre><p>注意第一个参数可以使用<code>"!^"</code>进行打印，其余的命令可以通过<code>"![命令名]:[参数编号]"</code>打印。</p><p>在上面的例子中，第一个命令是<code>cp</code>，第二个参数也需要被打印。因此是<code>"!cp:2"</code>，如果任何命令比如xyz运行时有5个参数，而您需要获得第四个参数，您可以使用<code>"!xyz:4"</code>。所有的参数都可以通过<code>"!*"</code>来获得。</p><p><img src=/data/attachment/album/201506/11/140247pz7aabxa4c4zzn7m.gif alt=处理两个或更多的参数></p><p><em>处理两个或更多的参数</em></p><h3 id=5-以关键字为基础执行上个的命令>5. 以关键字为基础执行上个的命令</h3><p>我们可以以关键字为基础执行上次执行的命令。可以从下面的例子中理解：</p><pre tabindex=0><code>$ ls /home &gt; /dev/null                      [命令1]
$ ls -l /home/avi/Desktop &gt; /dev/null                       [命令2]   
$ ls -la /home/avi/Downloads &gt; /dev/null                    [命令3]
$ ls -lA /usr/bin &gt; /dev/null                       [命令4]
</code></pre><p>上面我们使用了同样的命令（ls），但有不同的开关和不同的操作文件夹。而且，我们还将输出传递到<code>/dev/null</code>，我们并未显示输出，因而终端依旧很干净。</p><p>现在以关键字为基础执行上个的命令。</p><pre tabindex=0><code>$ ! ls                  [命令1]
$ ! ls -l               [命令2]   
$ ! ls -la              [命令3]
$ ! ls -lA              [命令4]
</code></pre><p>检查输出，您将惊奇发现您仅仅使用关键字<code>ls</code>便执行了您已经执行过的命令。</p><p><img src=/data/attachment/album/201506/11/140247vlv44o94va3gpgaz.gif alt=以关键字为基础执行命令></p><p><em>以关键字为基础执行命令</em></p><p>（LCTT 译注：澄清一下，这种用法会按照命令名来找到最后匹配的命令，不会匹配参数。所以上述执行的四个命令都是执行了 <code>ls -lA /usr/bin > /dev/null</code>，并增加了新的参数而已。）</p><h3 id=6-操作符的威力>6. !!操作符的威力</h3><p>您可以使用<code>(!!)</code>运行/修改您上个运行的命令。它将附带一些修改/调整并调用上个命令。让我给您展示一些实际情境。</p><p>昨天我运行了一行脚本来获得我的私有IP，因此我执行了：</p><pre tabindex=0><code>$ ip addr show | grep inet | grep -v &#39;inet6&#39;| grep -v &#39;127.0.0.1&#39; | awk &#39;{print $2}&#39; | cut -f1 -d/
</code></pre><p>接着，我突然发现我需要将上面脚本的输出重定向到一个ip.txt的文件，因此，我该怎么办呢？我该重新输入整个命令并重定向到一个文件么？一个简单的解决方案是使用向上光标键并添加<code>'> ip.txt'</code>来将输出重定向到文件。</p><pre tabindex=0><code>$ ip addr show | grep inet | grep -v &#39;inet6&#39;| grep -v &#39;127.0.0.1&#39; | awk &#39;{print $2}&#39; | cut -f1 -d/ &gt; ip.txt
</code></pre><p>在这里要感谢救世主"向上光标键"。现在，考虑下面的情况，这次我运行了下面这一行脚本。</p><pre tabindex=0><code>$ ifconfig | grep &#34;inet addr:&#34; | awk &#39;{print $2}&#39; | grep -v &#39;127.0.0.1&#39; | cut -f2 -d:
</code></pre><p>一旦我运行了这个脚本，Bash提示符便返回了错误消息<code>"bash: ifconfig: command not found"</code>。原因并不难猜，我运行了本应以root权限的运行的命令。</p><p>所以，怎么解决呢？以root用户登录并且再次键入整个命令就太麻烦了！而且向上导航键也不管用了（LCTT 译注：当你以新的用户身份登录了，是不能用向上光标键找到之前的另外一个用户的命令历史的）。因此，我们需要调用<code>"!!"</code>（去掉引号），它将为那个用户调用上个命令。</p><pre tabindex=0><code>$ su -c !! root
</code></pre><p>这里su是用来切换到root用户的，<code>-c</code>用来以某用户运行特定的命令，最重要的部分是<code>!!</code>，它将被替换为上次运行的命令。当然！您需要提供root密码。</p><p><img src=/data/attachment/album/201506/11/140249pj3ht83ytvyvv35w.gif alt=!!操作符的威力></p><p><em>!!操作符的威力</em></p><p>我通常在下面的情景中使用<code>!!</code>。</p><p>当我用普通用户来运行apt-get，我通常收到提示说我没有权限来执行。</p><pre tabindex=0><code>$ apt-get upgrade &amp;&amp; apt-get dist-upgrade
</code></pre><p>好吧，有错误。但别担心，使用下面的命令来成功的执行&mldr;</p><pre tabindex=0><code>$ su -c !!
</code></pre><p>同样的适用于：</p><pre tabindex=0><code>$ service apache2 start
</code></pre><p>或</p><pre tabindex=0><code>$ /etc/init.d/apache2 start
</code></pre><p>或</p><pre tabindex=0><code>$ systemctl start apache2
</code></pre><p>普通用户不被授权执行那些任务，这样相当于我运行：</p><pre tabindex=0><code>$ su -c &#39;service apache2 start&#39;
</code></pre><p>或</p><pre tabindex=0><code>$ su -c &#39;/etc/init.d/apache2 start&#39;
</code></pre><p>或</p><pre tabindex=0><code>$ su -c &#39;systemctl start apache2&#39;
</code></pre><p>（LCTT 译注：使用<code>!!</code>之前，一定要确认你执行的是什么命令！另外，在 root 身份下，千万不要养成使用它的习惯，因为你总是会在不合适的目录执行不合适的命令！）</p><h3 id=7运行一个影响所有除了file_name的文件命令>7.运行一个影响所有除了![FILE_NAME]的文件命令</h3><p><code>!</code>（逻辑非）能用来对除了<code>'!'</code>后的文件的所有的文件/扩展名执行命令。</p><p>（LCTT 译注：该功能需要用 shopt 设置 extglob 模式： shopt -s extglob 才行。）</p><p>A.从文件夹移除所有文件，2.txt除外。</p><pre tabindex=0><code>$ rm !(2.txt)
</code></pre><p>B.从文件夹移除所有的文件类型，pdf类型除外。</p><pre tabindex=0><code>$ rm !(*.pdf)
</code></pre><h3 id=8检查某个文件夹比如homeavitecmint是否存在并打印>8.检查某个文件夹（比如/home/avi/Tecmint）是否存在？并打印</h3><p>这里，我们使用<code>'! -d'</code>来验证文件夹是否存在，当文件夹不存在时，将使用其后跟随AND操作符<code>(&&)</code>进行打印，当文件夹存在时，将使用OR操作符<code>(||)</code>进行打印。</p><p>逻辑上，当<code>[ ! -d /home/avi/Tecmint ]</code>的输出为0时，它将执行AND逻辑符后面的内容，否则，它将执行OR逻辑符<code>(||)</code>后面的内容。</p><pre tabindex=0><code>$ [ ! -d /home/avi/Tecmint ] &amp;&amp; printf &#39;\nno such /home/avi/Tecmint directory exist\n&#39; || printf &#39;\n/home/avi/Tecmint directory exist\n&#39;
</code></pre><h3 id=9检查某文件夹是否存在如果不存在则退出该命令>9.检查某文件夹是否存在？如果不存在则退出该命令</h3><p>类似于上面的情况，但这里当期望的文件夹不存在时，该命令会退出。</p><pre tabindex=0><code>$ [ ! -d /home/avi/Tecmint ] &amp;&amp; exit
</code></pre><h3 id=10如果您的home文件夹内不存在一个文件夹比方说test则创建它>10.如果您的home文件夹内不存在一个文件夹（比方说test），则创建它</h3><p>这是脚本语言中的一个常用的实现，当期望的文件夹不存在时，创建一个。</p><pre tabindex=0><code>[ ! -d /home/avi/Tecmint ] &amp;&amp; mkdir /home/avi/Tecmint
</code></pre><p>这便是全部了。如果您知道或偶尔遇到其他值得了解的<code>'!'</code>使用方法，请您在反馈的地方给我们提建议。保持联系！</p><hr><p>via: <a href=http://www.tecmint.com/mysterious-uses-of-symbol-or-operator-in-linux-commands/>http://www.tecmint.com/mysterious-uses-of-symbol-or-operator-in-linux-commands/</a></p><p>作者：<a href=http://www.tecmint.com/author/avishek/>Avishek Kumar</a> 译者：<a href=https://github.com/wwy-hust>wwy-hust</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创翻译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/%E8%84%9A%E6%9C%AC/ rel=tag>脚本</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E6%83%8A%E5%8F%B9%E5%8F%B7/ rel=tag>惊叹号</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>