<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>在 Wireshark 中过滤数据包 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="在 Wireshark 中过滤数据包"><meta property="og:description" content="数据包过滤可让你专注于你感兴趣的确定数据集。如你所见，Wireshark 默认会抓取所有数据包。这可能会妨碍你寻找具体的数据。 Wireshark 提供了两个功能强大的过滤工​​具，让你简单而无痛地获得精确的数据。"><meta property="og:type" content="article"><meta property="og:url" content="/article-8793-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-08-21T09:34:00+00:00"><meta property="article:modified_time" content="2017-08-21T09:34:00+00:00"><meta itemprop=name content="在 Wireshark 中过滤数据包"><meta itemprop=description content="数据包过滤可让你专注于你感兴趣的确定数据集。如你所见，Wireshark 默认会抓取所有数据包。这可能会妨碍你寻找具体的数据。 Wireshark 提供了两个功能强大的过滤工​​具，让你简单而无痛地获得精确的数据。"><meta itemprop=datePublished content="2017-08-21T09:34:00+00:00"><meta itemprop=dateModified content="2017-08-21T09:34:00+00:00"><meta itemprop=wordCount content="139"><meta itemprop=keywords content="Wireshark,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>在 Wireshark 中过滤数据包</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-08-21T09:34:00Z>August 21, 2017</time></div></div></header><div class="content post__content clearfix"><p><img src=/data/attachment/album/201708/19/123750v3fqtsis8v9gc3fs.jpg alt></p><h3 id=介绍>介绍</h3><p>数据包过滤可让你专注于你感兴趣的确定数据集。如你所见，Wireshark 默认会抓取<em>所有</em>数据包。这可能会妨碍你寻找具体的数据。 Wireshark 提供了两个功能强大的过滤工​​具，让你简单而无痛地获得精确的数据。</p><p>Wireshark 可以通过两种方式过滤数据包。它可以通过只收集某些数据包来过滤，或者在抓取数据包后进行过滤。当然，这些可以彼此结合使用，并且它们各自的用处取决于收集的数据和信息的多少。</p><h3 id=布尔表达式和比较运算符>布尔表达式和比较运算符</h3><p>Wireshark 有很多很棒的内置过滤器。当开始输入任何一个过滤器字段时，你将看到它们会自动补完。这些过滤器大多数对应于用户对数据包的常见分组方式，比如仅过滤 HTTP 请求就是一个很好的例子。</p><p>对于其他的，Wireshark 使用布尔表达式和/或比较运算符。如果你曾经做过任何编程，你应该熟悉布尔表达式。他们是使用 <code>and</code>、<code>or</code>、<code>not</code> 来验证声明或表达式的真假。比较运算符要简单得多，它们只是确定两件或更多件事情是否彼此相等、大于或小于。</p><h3 id=过滤抓包>过滤抓包</h3><p>在深入自定义抓包过滤器之前，请先查看 Wireshark 已经内置的内容。单击顶部菜单上的 “Capture” 选项卡，然后点击 “Options”。可用接口下面是可以编写抓包过滤器的行。直接移到左边一个标有 “Capture Filter” 的按钮上。点击它，你将看到一个新的对话框，其中包含内置的抓包过滤器列表。看看里面有些什么。</p><p><img src=/data/attachment/album/201708/19/123807wy6kt2sq8f8fls8t.jpg alt="Wireshark dialog for creating a capture filter"></p><p>在对话框的底部，有一个用于创建并保存抓包过滤器的表单。按左边的 “New” 按钮。它将创建一个填充有默认数据的新的抓包过滤器。要保存新的过滤器，只需将实际需要的名称和表达式替换原来的默认值，然后单击“Ok”。过滤器将被保存并应用。使用此工具，你可以编写并保存多个不同的过滤器，以便它们将来可以再次使用。</p><p>抓包有自己的过滤语法。对于比较，它不使用等于号，并使用 <code>></code> 和 <code>&lt;</code> 来用于大于或小于。对于布尔值来说，它使用 <code>and</code>、<code>or</code> 和 <code>not</code>。</p><p>例如，如果你只想监听 80 端口的流量，你可以使用这样的表达式：<code>port 80</code>。如果你只想从特定的 IP 监听端口 80，你可以使用 <code>port 80 and host 192.168.1.20</code>。如你所见，抓包过滤器有特定的关键字。这些关键字用于告诉 Wireshark 如何监控数据包以及哪一个数据是要找的。例如，<code>host</code> 用于查看来自 IP 的所有流量。<code>src</code> 用于查看源自该 IP 的流量。与之相反，<code>dst</code> 只监听目标到这个 IP 的流量。要查看一组 IP 或网络上的流量，请使用 <code>net</code>。</p><h3 id=过滤结果>过滤结果</h3><p>界面的底部菜单栏是专门用于过滤结果的菜单栏。此过滤器不会更改 Wireshark 收集的数据，它只允许你更轻松地对其进行排序。有一个文本字段用于输入新的过滤器表达式，并带有一个下拉箭头以查看以前输入的过滤器。旁边是一个标为 “Expression” 的按钮，另外还有一些用于清除和保存当前表达式的按钮。</p><p>点击 “Expression” 按钮。你将看到一个小窗口，其中包含多个选项。左边一栏有大量的条目，每个都有附加的折叠子列表。你可以用这些来过滤所有不同的协议、字段和信息。你不可能看完所有，所以最好是大概看下。你应该注意到了一些熟悉的选项，如 HTTP、SSL 和 TCP。</p><p><img src=/data/attachment/album/201708/19/123809we838dvp88nx63e6.jpg alt="Wireshark dailog for creating a results filter"></p><p>子列表包含可以过滤的不同部分和请求方法。你可以看到通过 GET 和 POST 请求过滤 HTTP 请求。</p><p>你还可以在中间看到运算符列表。通过从每列中选择条目，你可以使用此窗口创建过滤器，而不用记住 Wireshark 可以过滤的每个条目。对于过滤结果，比较运算符使用一组特定的符号。 <code>==</code> 用于确定是否相等。<code>></code> 用于确定一件东西是否大于另一个东西，<code>&lt;</code> 找出是否小一些。 <code>>=</code> 和 <code>&lt;=</code> 分别用于大于等于和小于等于。它们可用于确定数据包是否包含正确的值或按大小过滤。使用 <code>==</code> 仅过滤 HTTP GET 请求的示例如下：<code>http.request.method == "GET"</code>。</p><p>布尔运算符基于多个条件将小的表达式串到一起。不像是抓包所使用的单词，它使用三个基本的符号来做到这一点。<code>&&</code> 代表 “与”。当使用时，<code>&&</code> 两边的两个语句都必须为真值才行，以便 Wireshark 来过滤这些包。<code>||</code> 表示 “或”。只要两个表达式任何一个为真值，它就会被过滤。如果你正在查找所有的 GET 和 POST 请求，你可以这样使用 <code>||</code>：<code>(http.request.method == "GET") || (http.request.method == "POST")</code>。<code>!</code> 是 “非” 运算符。它会寻找除了指定的东西之外的所有东西。例如，<code>!http</code> 将展示除了 HTTP 请求之外的所有东西。</p><h3 id=总结思考>总结思考</h3><p>过滤 Wireshark 可以让你有效监控网络流量。熟悉可以使用的选项并习惯你可以创建过滤器的强大表达式需要一些时间。然而一旦你学会了，你将能够快速收集和查找你要的网络数据，而无需梳理长长的数据包或进行大量的工作。</p><hr><p>via: <a href=https://linuxconfig.org/filtering-packets-in-wireshark-on-kali-linux>https://linuxconfig.org/filtering-packets-in-wireshark-on-kali-linux</a></p><p>作者：<a href=https://linuxconfig.org/filtering-packets-in-wireshark-on-kali-linux>Nick Congleton</a> 译者：<a href=https://github.com/geekpi>geekpi</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/wireshark/ rel=tag>Wireshark</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>