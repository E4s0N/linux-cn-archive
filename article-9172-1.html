<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>详解如何用源代码安装软件，以及如何卸载它 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="详解如何用源代码安装软件，以及如何卸载它"><meta property="og:description" content="对于绝大多数的 Linux 用户来说，第一次从源代码中编译和安装一个软件看上去像是一个入门仪式：它让很多人感到恐惧；但是，如果你能克服困难，你将可能进入一个全新的世界，并且，如果你做到了，那么你将成为社区中享有特权的一部分人。"><meta property="og:type" content="article"><meta property="og:url" content="/article-9172-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-12-25T21:50:37+00:00"><meta property="article:modified_time" content="2017-12-25T21:50:37+00:00"><meta itemprop=name content="详解如何用源代码安装软件，以及如何卸载它"><meta itemprop=description content="对于绝大多数的 Linux 用户来说，第一次从源代码中编译和安装一个软件看上去像是一个入门仪式：它让很多人感到恐惧；但是，如果你能克服困难，你将可能进入一个全新的世界，并且，如果你做到了，那么你将成为社区中享有特权的一部分人。"><meta itemprop=datePublished content="2017-12-25T21:50:37+00:00"><meta itemprop=dateModified content="2017-12-25T21:50:37+00:00"><meta itemprop=wordCount content="1189"><meta itemprop=keywords content="编译,安装,源代码,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>详解如何用源代码安装软件，以及如何卸载它</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-12-25T21:50:37Z>December 25, 2017</time></div></div></header><div class="content post__content clearfix"><p><img src=/data/attachment/album/201712/25/215040sjoviquqilz5igl9.jpg alt="How to install software from source code"></p><p><em>简介：这篇文章详细介绍了在 Linux 中怎么用源代码安装程序，以及怎么去卸载用源代码安装的程序。</em></p><p>Linux 发行版的一个最大的优点就是它的包管理器和相关的软件库。通过它们提供的资源和工具，你才能够以完全自动化的方式在你的计算机上下载和安装软件。</p><p>但是，尽管付出了很多的努力，包维护者仍然没法照顾好每种情况，也不可能将所有的可用软件都打包进去。因此，仍然存在需要你自已去编译和安装一个新软件的情形。对于我来说，到目前为止，最主要的原因是，我编译一些软件是我需要去运行一个特定的版本。或者是我想去修改源代码或使用一些想要的编译选项。</p><p>如果你也属于后一种情况，那你已经知道你应该怎么做了。但是，对于绝大多数的 Linux 用户来说，第一次从源代码中编译和安装一个软件看上去像是一个入门仪式：它让很多人感到恐惧；但是，如果你能克服困难，你将可能进入一个全新的世界，并且，如果你做到了，那么你将成为社区中享有特权的一部分人。</p><ul><li><a href=https://itsfoss.com/remove-install-software-ubuntu/>建议阅读：怎样在 Ubuntu 中安装和删除软件（完全指南）</a></li></ul><h3 id=a-在-linux-中从源代码开始安装软件>A. 在 Linux 中从源代码开始安装软件</h3><p>这正是我们要做的。因为这篇文章的需要，我要在我的系统上安装 <a href=https://nodejs.org/en/>NodeJS</a> 8.1.1。它是个完全真实的版本。这个版本在 Debian 仓库中没有：</p><pre tabindex=0><code>sh$ apt-cache madison nodejs | grep amd64
    nodejs | 6.11.1~dfsg-1 | http://deb.debian.org/debian experimental/main amd64 Packages
    nodejs | 4.8.2~dfsg-1 | http://ftp.fr.debian.org/debian stretch/main amd64 Packages
    nodejs | 4.8.2~dfsg-1~bpo8+1 | http://ftp.fr.debian.org/debian jessie-backports/main amd64 Packages
    nodejs | 0.10.29~dfsg-2 | http://ftp.fr.debian.org/debian jessie/main amd64 Packages
    nodejs | 0.10.29~dfsg-1~bpo70+1 | http://ftp.fr.debian.org/debian wheezy-backports/main amd64 Packages
</code></pre><h4 id=第-1-步从-github-上获取源代码>第 1 步：从 GitHub 上获取源代码</h4><p>像大多数开源项目一样，NodeJS 的源代码可以在 GitHub：<a href=https://github.com/nodejs/node>https://github.com/nodejs/node</a> 上找到。</p><p>所以，我们直接开始吧。</p><p><img src=/data/attachment/album/201712/25/215041pz3g8mlejgd9g8hs.png alt="The NodeJS official GitHub repository"></p><p>如果你不熟悉 <a href=https://en.wikipedia.org/wiki/GitHub>GitHub</a>，<a href=https://en.wikipedia.org/wiki/Git>git</a> 或者提到的其它 <a href=https://en.wikipedia.org/wiki/Version_control>版本管理系统</a>包含了这个软件的源代码，以及多年来对该软件的所有修改的历史。甚至可以回溯到该软件的最早版本。对于开发者来说，保留它的历史版本有很多好处。如今对我来说，其中一个好处是可以得到任何一个给定时间点的项目源代码。更准确地说，我可以得到我所要的 8.1.1 发布时的源代码。即便从那之后他们有了很多的修改。</p><p><img src=/data/attachment/album/201712/25/215042bvodebvmz1thejbd.png alt="Choose the v8.1.1 tag in the NodeJS GitHub repository"></p><p>在 GitHub 上，你可以使用 “branch” （分支）按钮导航到这个软件的不同版本。<a href=https://stackoverflow.com/questions/1457103/how-is-a-tag-different-from-a-branch-which-should-i-use-here>“分支” 和 “标签” 是 Git 中一些相关的概念</a>。总的来说，开发者创建 “分支” 和 “标签” 来在项目历史中对重要事件保持跟踪，比如当他们启用一个新特性或者发布一个新版本时。在这里先不详细介绍了，你现在只需要知道我在找被标记为 “v8.1.1” 的版本。</p><p><img src=/data/attachment/album/201712/25/215043xwvw1q088qnenbql.png alt="The NodeJS GitHub repository as it was at the time the v8.1.1 tag was created"></p><p>在选择了 “v8.1.1” 标签后，页面被刷新，最显著的变化是标签现在作为 URL 的一部分出现。另外，你可能会注意到文件改变日期也有所不同。你现在看到的源代码树是创建了 v8.1.1 标签时的代码。在某种意义上，你也可以认为像 git 这样的版本管理工具是一个时光穿梭机，允许你在项目历史中来回穿梭。</p><p><img src=/data/attachment/album/201712/25/215044c9wv58g8z7wgqqqg.png alt="NodeJS GitHub repository download as a ZIP button"></p><p>此时，我们可以下载 NodeJS 8.1.1 的源代码。你不要忘记去点那个建议的大的蓝色按钮来下载一个项目的 ZIP 压缩包。对于我来说，为讲解的目的，我从命令行中下载并解压这个 ZIP 压缩包。但是，如果你更喜欢使用一个 <a href=https://en.wikipedia.org/wiki/Graphical_user_interface>GUI</a> 工具，不用担心，你可以取代下面的命令方式：</p><pre tabindex=0><code>wget https://github.com/nodejs/node/archive/v8.1.1.zip
unzip v8.1.1.zip
cd node-8.1.1/
</code></pre><p>下载一个 ZIP 包就可以，但是如果你希望“像个专家一样”，我建议你直接使用 <code>git</code> 工具去下载源代码。它一点也不复杂 — 并且如果你是第一次使用该工具，它将是一个很好的开端，你以后将经常用到它：</p><pre tabindex=0><code># first ensure git is installed on your system
sh$ sudo apt-get install git
# Make a shallow clone the NodeJS repository at v8.1.1
sh$ git clone --depth 1 \
              --branch v8.1.1 \
              https://github.com/nodejs/node
sh$ cd node/
</code></pre><p>顺便说一下，如果你有任何问题，这篇文章的第一部分只是做一个总体介绍而已。后面，为了帮你排除常见问题，我们将基于 Debian 和基于 RedHat 的发行版更详细地解释。</p><p>不管怎样，在你使用 <code>git</code> 或者作为一个 ZIP 压缩包下载了源代码后，在当前目录下就有了同样的源代码文件：</p><pre tabindex=0><code>sh$ ls
android-configure  BUILDING.md            common.gypi      doc            Makefile   src
AUTHORS            CHANGELOG.md           configure        GOVERNANCE.md  node.gyp   test
benchmark          CODE_OF_CONDUCT.md     CONTRIBUTING.md  lib            node.gypi  tools
BSDmakefile        COLLABORATOR_GUIDE.md  deps             LICENSE        README.md  vcbuild.bat
</code></pre><h4 id=第-2-步理解程序的构建系统>第 2 步：理解程序的构建系统</h4><p>构建系统就是我们通常所说的“编译源代码”，其实，编译只是从源代码中生成一个可使用的软件的其中一个阶段。构建系统是一套工具，用于自动处置不同的任务，以便可以仅通过几个命令就能构建整个软件。</p><p>虽然概念很简单，实际上编译做了很多事情。因为不同的项目或者编程语言也许有不同的要求，或者因为编程者的好恶，或者因为支持的平台、或者因为历史的原因，等等等等 … 选择或创建另外一个构建系统的原因几乎数不清。这方面有许多种不同的解决方案。</p><p>NodeJS 使用一种 <a href=https://en.wikipedia.org/wiki/GNU_Build_System>GNU 风格的构建系统</a>。这在开源社区中这是一个很流行的选择。由此开始，你将进入一段精彩的旅程。</p><p>写出和调优一个构建系统是一个非常复杂的任务。但是，作为 “终端用户” 来说，GNU 风格的构建系统使用两个工具让他们免于此难：<code>configure</code> 和 <code>make</code>。</p><p><code>configure</code> 文件是个项目专用的脚本，它将检查目标系统的配置和可用功能，以确保该项目可以被构建，并最终吻合当前平台的特性。</p><p>一个典型的 <code>configure</code> 任务的重要部分是去构建 <code>Makefile</code>。这个文件包含了有效构建项目所需的指令。</p><p>另一方面，<a href=https://en.wikipedia.org/wiki/Make_%28software><code>make</code> 工具</a>，这是一个可用于任何类 Unix 系统的 POSIX 工具。它将读取项目专用的 <code>Makefile</code> 然后执行所需的操作去构建和安装你的程序。</p><p>但是，在 Linux 的世界中，你仍然有一些定制你自己专用的构建的理由。</p><pre tabindex=0><code>./configure --help
</code></pre><p><code>configure -help</code> 命令将展示你可用的所有配置选项。再强调一下，这是非常的项目专用。说实话，有时候，在你完全理解每个配置选项的作用之前，你需要深入到项目中去好好研究。</p><p>不过，这里至少有一个标准的 GNU 自动化工具选项是你该知道的，它就是众所周知的 <code>--prefix</code> 选项。它与文件系统的层次结构有关，它是你软件要安装的位置。</p><h4 id=第-3-步文件系统层次化标准fhs>第 3 步：文件系统层次化标准（FHS）</h4><p>大部分典型的 Linux 发行版的文件系统层次结构都遵从 <a href=http://www.pathname.com/fhs/>文件系统层次化标准（FHS）</a>。</p><p>这个标准说明了你的系统中各种目录的用途，比如，<code>/usr</code>、<code>/tmp</code>、<code>/var</code> 等等。</p><p>当使用 GNU 自动化工具 <em>和大多数其它的构建系统</em> 时，它会把新软件默认安装在你的系统的 <code>/usr/local</code> 目录中。这是依据 FHS 中 <em>“<code>/usr/local</code> 层级是为系统管理员本地安装软件时使用的，它在系统软件更新覆盖时是安全的。它也可以用于存放在一组主机中共享，但又没有放到 /usr 中的程序和数据”</em>，因此，它是一个非常好的选择。</p><p><code>/usr/local</code> 层级以某种方式复制了根目录，你可以在 <code>/usr/local/bin</code> 这里找到可执行程序，在 <code>/usr/local/lib</code> 中找到库，在 <code>/usr/local/share</code> 中找到架构无关的文件，等等。</p><p>使用 <code>/usr/local</code> 树作为你定制安装的软件位置的唯一问题是，你的软件的文件将在这里混杂在一起。尤其是你安装了多个软件之后，将很难去准确地跟踪 <code>/usr/local/bin</code> 和 <code>/usr/local/lib</code> 中的哪个文件到底属于哪个软件。它虽然不会导致系统的问题。毕竟，<code>/usr/bin</code> 也是一样混乱的。但是，有一天你想去卸载一个手工安装的软件时它会将成为一个问题。</p><p>要解决这个问题，我通常喜欢安装定制的软件到 <code>/opt</code> 子目录下。再次引用 FHS：</p><blockquote><p>“<code>/opt</code> 是为安装附加的应用程序软件包而保留的。</p><p>包安装在 <code>/opt</code> 下的软件包必须将它的静态文件放在单独的 <code>/opt/&lt;package></code> 或者 <code>/opt/&lt;provider></code> 目录中，此处 <code>&lt;package></code> 是所说的那个软件名的名字，而 <code>&lt;provider></code> 处是提供者的 LANANA 注册名字。”（LCTT 译注：LANANA 是指 <a href=http://www.lanana.org/>The Linux Assigned Names And Numbers Authority</a>。 ）</p></blockquote><p>因此，我们将在 <code>/opt</code> 下创建一个子目录，用于我们定制的 NodeJS 安装。并且，如果有一天我想去卸载它，我只是很简单地去删除那个目录：</p><pre tabindex=0><code>sh$ sudo mkdir /opt/node-v8.1.1
sh$ sudo ln -sT node-v8.1.1 /opt/node
# What is the purpose of the symbolic link above?
# Read the article till the end--then try to answer that
# question in the comment section!

sh$ ./configure --prefix=/opt/node-v8.1.1
sh$ make -j9 &amp;&amp; echo ok
# -j9 means run up to 9 parallel tasks to build the software.
# As a rule of thumb, use -j(N+1) where N is the number of cores
# of your system. That will maximize the CPU usage (one task per
# CPU thread/core + a provision of one extra task when a process
# is blocked by an I/O operation.
</code></pre><p>在你运行完成 <code>make</code> 命令之后，如果有任何的除了 “ok” 以外的信息，将意味着在构建过程中有错误。当我们使用一个 <code>-j</code> 选项去运行并行构建时，在构建系统的大量输出过程中，检索错误信息并不是件很容易的事。</p><p>在这种情况下，只能是重新开始 <code>make</code>，并且不要使用 <code>-j</code> 选项。这样错误将会出现在输出信息的最后面：</p><pre tabindex=0><code>sh$ make
</code></pre><p>最终，编译结束后，你可以运行这个命令去安装你的软件：</p><pre tabindex=0><code>sh$ sudo make install
</code></pre><p>然后测试它：</p><pre tabindex=0><code>sh$ /opt/node/bin/node --version
v8.1.1
</code></pre><h3 id=b-如果在源代码安装的过程中出现错误怎么办>B. 如果在源代码安装的过程中出现错误怎么办？</h3><p>我上面介绍的大多是你能在文档完备的项目的“构建指令”页面上看到。但是，本文的目标是让你从源代码开始去编译你的第一个软件，它可能要花一些时间去研究一些常见的问题。因此，我将再次重新开始一遍整个过程，但是，这次是在一个最新的、最小化安装的 Debian 9.0 和 CentOS 7.0 系统上。因此，你可能看到我遇到的错误以及我怎么去解决它。</p><h4 id=从-debian-90-中-stretch-开始>从 Debian 9.0 中 “Stretch” 开始</h4><pre tabindex=0><code>itsfoss@debian:~$ git clone --depth 1 \
                             --branch v8.1.1 \
                             https://github.com/nodejs/node
-bash: git: command not found
</code></pre><p>这个问题非常容易去诊断和解决。去安装这个 <code>git</code> 包即可：</p><pre tabindex=0><code>itsfoss@debian:~$ sudo apt-get install git
</code></pre><pre tabindex=0><code>itsfoss@debian:~$ git clone --depth 1 \
                             --branch v8.1.1 \
                             https://github.com/nodejs/node &amp;&amp; echo ok
[...]
ok
</code></pre><pre tabindex=0><code>itsfoss@debian:~/node$ sudo mkdir /opt/node-v8.1.1
itsfoss@debian:~/node$ sudo ln -sT node-v8.1.1 /opt/node
</code></pre><p>现在没有问题了。</p><pre tabindex=0><code>itsfoss@debian:~/node$ ./configure --prefix=/opt/node-v8.1.1/
WARNING: failed to autodetect C++ compiler version (CXX=g++)
WARNING: failed to autodetect C compiler version (CC=gcc)
Node.js configure error: No acceptable C compiler found!
        Please make sure you have a C compiler installed on your system and/or
        consider adjusting the CC environment variable if you installed
        it in a non-standard prefix.
</code></pre><p>很显然，编译一个项目，你需要一个编译器。NodeJS 是使用 <a href=https://en.wikipedia.org/wiki/C%2B%2B>C++ 语言</a> 写的，我们需要一个 C++ <a href=https://en.wikipedia.org/wiki/Compiler>编译器</a>。在这里我将安装 <code>g++</code>，它就是为这个目的写的 GNU C++ 编译器：</p><pre tabindex=0><code>itsfoss@debian:~/node$ sudo apt-get install g++
itsfoss@debian:~/node$ ./configure --prefix=/opt/node-v8.1.1/ &amp;&amp; echo ok
[...]
ok
</code></pre><pre tabindex=0><code>itsfoss@debian:~/node$ make -j9 &amp;&amp; echo ok
-bash: make: command not found
</code></pre><p>还差一个其它工具。同样的症状。同样的解决方案：</p><pre tabindex=0><code>itsfoss@debian:~/node$ sudo apt-get install make
itsfoss@debian:~/node$ make -j9 &amp;&amp; echo ok
[...]
ok
</code></pre><pre tabindex=0><code>itsfoss@debian:~/node$ sudo make install
[...]
itsfoss@debian:~/node$ /opt/node/bin/node --version
v8.1.1
</code></pre><p>成功！</p><p>请注意：我将一次又一次地安装各种工具去展示怎么去诊断编译问题，以及展示怎么去解决这些问题。但是，如果你搜索关于这个主题的更多文档，或者读其它的教程，你将发现，很多发行版有一个 “meta-packages”，它包罗了安装一些或者全部的用于编译软件的常用工具。在基于 Debian 的系统上，你或许遇到过 <a href=https://packages.debian.org/sid/build-essential>build-essentials</a> 包，它就是这种用作。在基于 Red Hat 的发行版中，它将是 <em>“Development Tools”</em> 组。</p><h4 id=在-centos-70-上>在 CentOS 7.0 上</h4><pre tabindex=0><code>[itsfoss@centos ~]$ git clone --depth 1 \
                               --branch v8.1.1 \
                               https://github.com/nodejs/node
-bash: git: command not found
</code></pre><p>命令没有找到？可以用 <code>yum</code> 包管理器去安装它：</p><pre tabindex=0><code>[itsfoss@centos ~]$ sudo yum install git
</code></pre><pre tabindex=0><code>[itsfoss@centos ~]$ git clone --depth 1 \
                               --branch v8.1.1 \
                               https://github.com/nodejs/node &amp;&amp; echo ok
[...]
ok
</code></pre><pre tabindex=0><code>[itsfoss@centos ~]$ sudo mkdir /opt/node-v8.1.1
[itsfoss@centos ~]$ sudo ln -sT node-v8.1.1 /opt/node
</code></pre><pre tabindex=0><code>[itsfoss@centos ~]$ cd node
[itsfoss@centos node]$ ./configure --prefix=/opt/node-v8.1.1/
WARNING: failed to autodetect C++ compiler version (CXX=g++)
WARNING: failed to autodetect C compiler version (CC=gcc)
Node.js configure error: No acceptable C compiler found!

        Please make sure you have a C compiler installed on your system and/or
        consider adjusting the CC environment variable if you installed
        it in a non-standard prefix.
</code></pre><p>你知道的：NodeJS 是使用 C++ 语言写的，但是，我的系统缺少合适的编译器。Yum 可以帮到你。因为，我不是一个合格的 CentOS 用户，我实际上是在互联网上搜索到包含 g++ 编译器的包的确切名字的。这个页面指导了我：<a href=https://superuser.com/questions/590808/yum-install-gcc-g-doesnt-work-anymore-in-centos-6-4>https://superuser.com/questions/590808/yum-install-gcc-g-doesnt-work-anymore-in-centos-6-4</a> 。</p><pre tabindex=0><code>[itsfoss@centos node]$ sudo yum install gcc-c++
[itsfoss@centos node]$ ./configure --prefix=/opt/node-v8.1.1/ &amp;&amp; echo ok
[...]
ok
</code></pre><pre tabindex=0><code>[itsfoss@centos node]$ make -j9 &amp;&amp; echo ok
[...]
ok
</code></pre><pre tabindex=0><code>[itsfoss@centos node]$ sudo make install &amp;&amp; echo ok
[...]
ok
</code></pre><pre tabindex=0><code>[itsfoss@centos node]$ /opt/node/bin/node --version
v8.1.1
</code></pre><p>再次成功！</p><h3 id=c-从源代码中对要安装的软件做一些改变>C. 从源代码中对要安装的软件做一些改变</h3><p>从源代码中安装一个软件，可能是因为你的分发仓库中没有一个可用的特定版本。或者因为你想去 <em>修改</em> 那个程序。也可能是修复一个 bug 或者增加一个特性。毕竟，开源软件这些都可以做到。因此，我将抓住这个机会，让你亲自体验怎么去编译你自己的软件。</p><p>在这里，我将在 NodeJS 源代码上做一个微小改变。然后，我们将看到我们的改变将被纳入到软件的编译版本中：</p><p>用你喜欢的 <a href=https://en.wikipedia.org/wiki/List_of_text_editors>文本编辑器</a>（如，vim、nano、gedit、 … ）打开文件 <code>node/src/node.cc</code>。然后，尝试找到如下的代码片段：</p><pre tabindex=0><code>   if (debug_options.ParseOption(argv[0], arg)) {
      // Done, consumed by DebugOptions::ParseOption().
    } else if (strcmp(arg, &#34;--version&#34;) == 0 || strcmp(arg, &#34;-v&#34;) == 0) {
      printf(&#34;%s\n&#34;, NODE_VERSION);
      exit(0);
    } else if (strcmp(arg, &#34;--help&#34;) == 0 || strcmp(arg, &#34;-h&#34;) == 0) {
      PrintHelp();
      exit(0);
    }
</code></pre><p>它在 <a href=https://github.com/nodejs/node/blob/v8.1.1/src/node.cc#L3830>文件的 3830 行</a> 附近。然后，修改包含 <code>printf</code> 的行，将它替换成如下内容：</p><pre tabindex=0><code>      printf(&#34;%s (compiled by myself)\n&#34;, NODE_VERSION);
</code></pre><p>然后，返回到你的终端。在继续之前，<em>为了对强大的 Git 支持有更多的了解</em>，你可以去检查一下，你修改是文件是否正确：</p><pre tabindex=0><code>diff --git a/src/node.cc b/src/node.cc
index bbce1022..a5618b57 100644
--- a/src/node.cc
+++ b/src/node.cc
@@ -3828,7 +3828,7 @@ static void ParseArgs(int* argc,
     if (debug_options.ParseOption(argv[0], arg)) {
       // Done, consumed by DebugOptions::ParseOption().
     } else if (strcmp(arg, &#34;--version&#34;) == 0 || strcmp(arg, &#34;-v&#34;) == 0) {
-      printf(&#34;%s\n&#34;, NODE_VERSION);
+      printf(&#34;%s (compiled by myself)\n&#34;, NODE_VERSION);
       exit(0);
     } else if (strcmp(arg, &#34;--help&#34;) == 0 || strcmp(arg, &#34;-h&#34;) == 0) {
       PrintHelp();
</code></pre><p>在你前面改变的那行之前，你将看到一个 “-” （减号标志）。而在改变之后的行前面有一个 “+” （加号标志）。</p><p>现在可以去重新编译并重新安装你的软件了：</p><pre tabindex=0><code>make -j9 &amp;&amp; sudo make install &amp;&amp; echo ok
[...]
ok
</code></pre><p>这个时候，可能失败的唯一原因就是你改变代码时的输入错误。如果就是这种情况，在文本编辑器中重新打开 <code>node/src/node.cc</code> 文件并修复错误。</p><p>一旦你完成了新修改版本的 NodeJS 的编译和安装，就可以去检查你的修改是否包含到软件中：</p><pre tabindex=0><code>itsfoss@debian:~/node$ /opt/node/bin/node --version
v8.1.1 (compiled by myself)
</code></pre><p>恭喜你！你对开源程序做出了你的第一个改变！</p><h3 id=d-让-shell-找到我们定制构建的软件>D. 让 shell 找到我们定制构建的软件</h3><p>到目前为止，你可能注意到，我通常启动我新编译的 NodeJS 软件是通过指定到该二进制文件的绝对路径。</p><pre tabindex=0><code>/opt/node/bin/node
</code></pre><p>这是可以正常工作的。但是，这样太麻烦。实际上有两种办法可以去解决这个问题。但是，去理解它们，你必须首先明白，你的 shell 定位可执行文件是通过在<a href=https://en.wikipedia.org/wiki/Environment_variable>环境变量</a> <code>PATH</code> 中指定的目录里面查找的。</p><pre tabindex=0><code>itsfoss@debian:~/node$ echo $PATH
/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games
</code></pre><p>在这个 Debian 系统上，如果你不指定一个精确的目录做为命令名字的一部分，shell 将首先在 <code>/usr/local/bin</code> 中查找可执行程序；如果没有找到，然后进入 <code>/usr/bin</code> 中查找；如果没有找到，然后进入 <code>/bin</code>查找；如果没有找到，然后进入 <code>/usr/local/games</code> 查找；如果没有找到，然后进入 <code>/usr/games</code> 查找；如果没有找到，那么，shell 将报告一个错误，<em>“command not found”</em>。</p><p>由此，我们可以知道有两种方法去确保命令可以被 shell 访问到：将它（该二进制程序）增加到已经配置好的 <code>PATH</code> 目录中，或者将包含可执行程序的目录添加到 <code>PATH</code> 中。</p><h4 id=从-usrlocalbin-中添加一个链接>从 /usr/local/bin 中添加一个链接</h4><p>只是从 <code>/opt/node/bin</code> 中 <em>拷贝</em> NodeJS 二进制可执行文件到 <code>/usr/local/bin</code> 是一个错误的做法。因为，如果这么做，该可执行程序将无法定位到在 <code>/opt/node/</code> 中的需要的其它组件。（软件以它自己的位置去定位它所需要的资源文件是常见的做法）</p><p>因此，传统的做法是去使用一个符号链接：</p><pre tabindex=0><code>itsfoss@debian:~/node$ sudo ln -sT /opt/node/bin/node /usr/local/bin/node
itsfoss@debian:~/node$ which -a node || echo not found
/usr/local/bin/node
itsfoss@debian:~/node$ node --version
v8.1.1 (compiled by myself)
</code></pre><p>这一个简单而有效的解决办法，尤其是，如果一个软件包是由好几个众所周知的可执行程序组成的，因为，你将为每个用户调用的命令创建一个符号链接。例如，如果你熟悉 NodeJS，你知道应用的 <code>npm</code> 组件，也应该从 <code>/usr/local/bin</code> 做个符号链接。我把这个留给你做练习。</p><h4 id=修改-path>修改 PATH</h4><p>首先，如果你尝试过前面的解决方案，请先移除前面创建的节点符号链接，去从一个干净的状态开始：</p><pre tabindex=0><code>itsfoss@debian:~/node$ sudo rm /usr/local/bin/node
itsfoss@debian:~/node$ which -a node || echo not found
not found
</code></pre><p>现在，这里有一个改变你的 <code>PATH</code> 的魔法命令：</p><pre tabindex=0><code>itsfoss@debian:~/node$ export PATH=&#34;/opt/node/bin:${PATH}&#34;
itsfoss@debian:~/node$ echo $PATH
/opt/node/bin:/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games
</code></pre><p>简单说就是，我用环境变量 <code>PATH</code> 之前的内容前缀了一个 <code>/opt/node/bin</code> 替换了其原先的内容。因此，你可以想像一下，shell 将先进入到 <code>/opt/node/bin</code> 目录中查找可执行程序。我们也可以使用 <code>which</code> 命令去确认一下：</p><pre tabindex=0><code>itsfoss@debian:~/node$ which -a node || echo not found
/opt/node/bin/node
itsfoss@debian:~/node$ node --version
v8.1.1 (compiled by myself)
</code></pre><p>鉴于 “符号链接” 解决方案是永久的，只要创建到 <code>/usr/local/bin</code> 的符号链接就行了，而对 <code>PATH</code> 的改变仅影响到当前的 shell。你可以自己做一些研究，如何做到对 <code>PATH</code> 的永久改变。给你一个提示，可以将它写到你的 “profile” 中。如果你找到这个解决方案，不要犹豫，通过下面的评论区共享给其它的读者！</p><h3 id=e-怎么去卸载刚才从源代码中安装的软件>E. 怎么去卸载刚才从源代码中安装的软件</h3><p>因为我们定制编译的 NodeJS 软件全部在 <code>/opt/node-v8.1.1</code> 目录中，卸载它不需要做太多的工作，仅使用 <code>rm</code> 命令去删除那个目录即可：</p><pre tabindex=0><code>sudo rm -rf /opt/node-v8.1.1
</code></pre><p>注意：<code>sudo</code> 和 <code>rm -rf</code> 是 “非常危险的鸡尾酒”！一定要在按下回车键之前多检查几次你的命令。你不会得到任何的确认信息，并且如果你删除了错误的目录它是不可恢复的 …</p><p>然后，如果你修改了你的 <code>PATH</code>，你可以去恢复这些改变。它一点也不复杂。</p><p>如果你从 <code>/usr/local/bin</code> 创建了一个符号链接，你应该去删除它们：</p><pre tabindex=0><code>itsfoss@debian:~/node$ sudo find /usr/local/bin \
                                 -type l \
                                 -ilname &#34;/opt/node/*&#34; \
                                 -print -delete
/usr/local/bin/node
</code></pre><h3 id=等等-依赖地狱在哪里>等等？ 依赖地狱在哪里？</h3><p>作为最终的讨论，如果你读过有关的编译定制软件的文档，你可能听到关于 依赖地狱 dependency hell 的说法。那是在你能够成功编译一个软件之前，对那种烦人情况的一个别名，你必须首先编译一个前提条件所需要的库，它又可能要求其它的库，而这些库有可能与你的系统上已经安装的其它软件不兼容。</p><p>发行版的软件包维护者的部分工作，就是实际去地解决那些依赖地狱，确保你的系统上的各种软件都使用了兼容的库，并且按正确的顺序去安装。</p><p>在这篇文章中，我特意选择了 NodeJS 去安装，是因为它几乎没有依赖。我说 “几乎” 是因为，实际上，它 <em>有</em> 依赖。但是，这些源代码的依赖已经预置到项目的源仓库中（在 <code>node/deps</code> 子目录下），因此，在你动手编译之前，你不用手动去下载和安装它们。</p><p>如果你有兴趣了解更多关于那个问题的知识和学习怎么去处理它。请在下面的评论区告诉我，它将是更高级别的文章的好主题！</p><hr><p>作者简介：</p><p>充满激情的工程师，职业是教师，我的目标是：热心分享我所教的内容，并让我的学生自己培养它们的技能。你也可以在我的网站上联系到我。</p><hr><p>via: <a href=https://itsfoss.com/install-software-from-source-code/>https://itsfoss.com/install-software-from-source-code/</a></p><p>作者：<a href=https://itsfoss.com/author/sylvain/>Sylvain Leroux</a> 译者：<a href=https://github.com/qhwdw>qhwdw</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/%E7%BC%96%E8%AF%91/ rel=tag>编译</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E5%AE%89%E8%A3%85/ rel=tag>安装</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E6%BA%90%E4%BB%A3%E7%A0%81/ rel=tag>源代码</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>