<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>YAML：可能并不是那么完美 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="YAML：可能并不是那么完美"><meta property="og:description" content="不要误解我的意思，并不是说 YAML 很糟糕 —— 它肯定不像使用 JSON 那么多的问题 —— 但它也不是非常好。"><meta property="og:type" content="article"><meta property="og:url" content="/article-10423-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-01-07T23:51:00+00:00"><meta property="article:modified_time" content="2019-01-07T23:51:00+00:00"><meta itemprop=name content="YAML：可能并不是那么完美"><meta itemprop=description content="不要误解我的意思，并不是说 YAML 很糟糕 —— 它肯定不像使用 JSON 那么多的问题 —— 但它也不是非常好。"><meta itemprop=datePublished content="2019-01-07T23:51:00+00:00"><meta itemprop=dateModified content="2019-01-07T23:51:00+00:00"><meta itemprop=wordCount content="551"><meta itemprop=keywords content="YAML,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>YAML：可能并不是那么完美</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2019-01-07T23:51:00Z>January 07, 2019</time></div></div></header><div class="content post__content clearfix"><p><img src=/data/attachment/album/201901/07/235036g8naktbcmzmnrkpm.jpg alt></p><p>我之前写过<a href=http://arp242.net/weblog/JSON_as_configuration_files-_please_dont.html>为什么将 JSON 用于人类可编辑的配置文件是一个坏主意</a>，今天我们将讨论 YAML 格式的一些常见问题。</p><h3 id=默认情况下不安全>默认情况下不安全</h3><p>YAML 默认是不安全的。加载用户提供的（不可信的）YAML 字符串需要仔细考虑。</p><pre tabindex=0><code>!!python/object/apply:os.system
args: [&#39;ls /&#39;]
</code></pre><p>用 <code>print(yaml.load(open('a.yaml')))</code> 运行它，应该给你这样的东西：</p><pre tabindex=0><code>bin   etc   lib    lost+found  opt   root  sbin  tmp  var sys
boot  dev   efi    home        lib64 mnt   proc  run  srv usr
0
</code></pre><p>许多其他语言（包括 Ruby 和 PHP 1 ）默认情况下也不安全（LCTT 译注：这里应该说的是解析 yaml）。<a href="https://github.com/search?q=yaml.load&amp;type=Code&amp;utf8=%E2%9C%93">在 GitHub 上搜索 yaml.load</a> 会得到惊人的 280 万个结果，而 <a href="https://github.com/search?q=yaml.safe_load&amp;type=Code&amp;utf8=%E2%9C%93">yaml.safe_load</a> 只能得到 26000 个结果。</p><p>提个醒，很多这样的 <code>yaml.load()</code> 都工作的很好，在配置文件中加载 <code>yaml.load()</code> 通常没问题，因为它通常（虽然并不总是！）来自“可靠源”，而且很多都来自静态的 YAML 测试文件。但是，人们还是不禁怀疑在这 280 万个结果中隐藏了多少漏洞。</p><p>这不是一个理论问题。在 2013 年，<a href=https://www.sitepoint.com/anatomy-of-an-exploit-an-in-depth-look-at-the-rails-yaml-vulnerability/>正是由于这个问题，所有的 Ruby on Rails 应用程序都被发现易受</a>远程代码执行攻击。</p><p>有人可能会反驳说这不是 YAML 格式的错误，而是那些库实现错误的的问题，但似乎大多数库默认不是安全的（特别是动态语言），所以事实上这是 YAML 的一个问题。</p><p>有些人可能会反驳认为修复它就像用 <code>safe_load()</code> 替换 <code>load()</code> 一样容易，但是很多人都没有意识到这个问题，即使你知道它，它也是很容易忘记的事情之一。这是非常糟糕的 API 设计。</p><h3 id=可能很难编辑特别是对于大文件>可能很难编辑，特别是对于大文件</h3><p>YAML 文件可能很难编辑，随着文件变大，这个难度会快速增大。</p><p>一个很好的例子是 Ruby on Rails 的本地化翻译文件。例如：</p><pre tabindex=0><code>en:
   formtastic:
     labels:
       title: &#34;Title&#34;  # Default global value
       article:
         body: &#34;Article content&#34;
       post:
         new:
           title: &#34;Choose a title...&#34;
           body: &#34;Write something...&#34;
         edit:
           title: &#34;Edit title&#34;
           body: &#34;Edit body&#34;
</code></pre><p>看起来不错，对吧？但是如果这个文件有 100 行怎么办？或者 1,000 行？在文件中很难看到 “where”，因为它可能在屏幕外。你需要向上滚动，但是你需要跟踪缩进，即使遵循缩进指南也很难，特别是因为 2 个空格缩进是常态而且 <a href=http://www.yaml.org/faq.html>制表符缩进被禁止</a> 2 。</p><p>不小心缩进出错通常不算错误，它通常只是反序列化为你不想要的东西。这样只能祝你调试快乐！</p><p>我已经愉快地编写 Python 长达十多年，所以我已经习惯了显眼的空白，但有时候我仍在和 YAML 抗争。在 Python 中，虽然没有那种长达几页的函数，但数据或配置文件的长度没有这种自然限制，这就带来了缺点和损失了清晰度。</p><p>对于小文件，这不是问题，但它确实无法很好地扩展到较大的文件，特别是如果你以后想编辑它们的话。</p><h3 id=这非常复杂>这非常复杂</h3><p>在浏览一个基本的例子时，YAML 看似“简单”和“显而易见”，但事实证明并非如此。<a href=http://yaml.org/spec/1.2/spec.pdf>YAML 规范</a>有 23449 个单词，为了比较，<a href=https://github.com/toml-lang/toml>TOML</a> 有 3339 个单词，<a href=http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf>Json</a> 有 1969 个单词，<a href=https://www.w3.org/TR/REC-xml/>XML</a> 有 20603 个单词。</p><p>我们中有谁读过全部规范吗？有谁读过并理解了全部？谁阅读过，理解进而<strong>记住</strong>所有这些？</p><p>例如，你知道<a href=http://stackoverflow.com/a/21699210/660921>在 YAML 中编写多行字符串有 9 种方法</a>吗？并且它们具有细微的不同行为。</p><p>是的 :-/</p><p>如果你看一下<a href=http://stackoverflow.com/posts/21699210/revisions>那篇文章的修订历史</a>，它就会变得更加有趣，因为文章的作者发现了越来越多的方法可以实现这一点，以及更多的细微之处。</p><p>它从预览开始告诉我们 YAML 规范，它表明（强调我的）：</p><blockquote><p>本节简要介绍了 YAML 的表达能力。<strong>预计初次阅读的人不可能理解所有的例子</strong>。相反，这些选择用作该规范其余部分的动机。</p></blockquote><h4 id=令人惊讶的行为>令人惊讶的行为</h4><p>以下会解析成什么（<a href=https://github.com/crdoconnor/strictyaml/blob/master/FAQ.rst#what-is-wrong-with-implicit-typing>Colm O’Connor</a> 提供的例子）：</p><pre tabindex=0><code>- Don Corleone: Do you have faith in my judgment?
- Clemenza: Yes
- Don Corleone: Do I have your loyalty?
</code></pre><p>结果为：</p><pre tabindex=0><code>[
    {&#39;Don Corleone&#39;: &#39;Do you have faith in my judgment?&#39;},
    {&#39;Clemenza&#39;: True},
    {&#39;Don Corleone&#39;: &#39;Do I have your loyalty?&#39;}
]
</code></pre><p>那么这个呢：</p><pre tabindex=0><code>python: 3.5.3
postgres: 9.3
</code></pre><p><code>3.5.3</code> 被识别为字符串，但 <code>9.3</code> 被识别为数字而不是字符串：</p><pre tabindex=0><code>{&#39;python&#39;: &#39;3.5.3&#39;, &#39;postgres&#39;: 9.3}
</code></pre><p>这个呢：</p><pre tabindex=0><code>Effenaar: Eindhoven
013: Tilburg
</code></pre><p><code>013</code> 是 蒂尔堡 Tilburg 的一个流行音乐场地，但 YAML 会告诉你错误答案，因为它被解析为八进制数字：</p><pre tabindex=0><code>{11: &#39;Tilburg&#39;, &#39;Effenaar&#39;: &#39;Eindhoven&#39;}
</code></pre><p>所有这一切，以及更多，就是为什么许多经验丰富的 YAMLer 经常会将所有字符串用引号引起来的原因，即使它不是严格要求。许多人不使用引号，而且很容易忘记，特别是如果文件的其余部分（可能由其他人编写）不使用引号。</p><h3 id=它不方便>它不方便</h3><p>因为它太复杂了，它所声称的可移植性被夸大了。例如，考虑以下这个从 YAML 规范中获取的示例：</p><pre tabindex=0><code>? - Detroit Tigers
  - Chicago cubs
:
  - 2001-07-23

? [ New York Yankees,
    Atlanta Braves ]
: [ 2001-07-02, 2001-08-12,
    2001-08-14 ]
</code></pre><p>抛开大多数读者可能甚至不知道这是在做什么之外，请尝试使用 PyYAML 在 Python 中解析它：</p><pre tabindex=0><code>yaml.constructor.ConstructorError: while constructing a mapping
  in &#34;a.yaml&#34;, line 1, column 1
found unhashable key
  in &#34;a.yaml&#34;, line 1, column 3
</code></pre><p>在 Ruby 中，它可以工作：</p><pre tabindex=0><code>{
    [&#34;Detroit Tigers&#34;, &#34;Chicago cubs&#34;] =&gt; [
        #&lt;Date: 2001-07-23 ((2452114j,0s,0n),+0s,2299161j)&gt;
    ],
    [&#34;New York Yankees&#34;, &#34;Atlanta Braves&#34;] =&gt; [
        #&lt;Date: 2001-07-02 ((2452093j,0s,0n),+0s,2299161j)&gt;,
        #&lt;Date: 2001-08-12 ((2452134j,0s,0n),+0s,2299161j)&gt;,
        #&lt;Date: 2001-08-14 ((2452136j,0s,0n),+0s,2299161j)&gt;
    ]
}
</code></pre><p>这个原因是你不能在 Python 中使用列表作为一个字典的键：</p><pre tabindex=0><code>&gt;&gt;&gt; {[&#39;a&#39;]: &#39;zxc&#39;}
Traceback (most recent call last):
  File &#34;&lt;stdin&gt;&#34;, line 1, in &lt;module&gt;
  TypeError: unhashable type: &#39;list&#39;
</code></pre><p>而这种限制并不是 Python 特有的，PHP、JavaScript 和 Go 等常用语言都有此限制。</p><p>因此，在 YAML 文件中使用这种语法，你将无法在大多数语言中解析它。</p><p>这是另一个从 YAML 规范的示例部分中获取的：</p><pre tabindex=0><code># Ranking of 1998 home runs
---
- Mark McGwire
- Sammy Sosa
- Ken Griffey

# Team ranking
---
- Chicago Cubs
- St Louis Cardinals
</code></pre><p>Python 会输出：</p><pre tabindex=0><code>yaml.composer.ComposerError: expected a single document in the stream
  in &#34;a.yaml&#34;, line 3, column 1
but found another document
  in &#34;a.yaml&#34;, line 8, column 1
</code></pre><p>然而 Ruby 输出：</p><pre tabindex=0><code>[&#34;Mark McGwire&#34;, &#34;Sammy Sosa&#34;, &#34;Ken Griffey&#34;]
</code></pre><p>原因是单个文件中有多个 YAML 文档（<code>---</code> 意味开始一个新文档）。在 Python 中，有一个 <code>load_all</code> 函数来解析所有文档，而 Ruby 的 <code>load()</code> 只是加载第一个文档，据我所知，它没有办法加载多个文档。</p><p><a href=https://github.com/cblp/yaml-sucks>在实现之间存在很多不兼容</a>。</p><h3 id=目标实现了吗>目标实现了吗？</h3><p>规范说明：</p><blockquote><p>YAML 的设计目标安装优先级降序排列如下：</p><ol><li>YAML 很容易被人类阅读。</li><li>YAML 数据在编程语言之间是可移植的。</li><li>YAML 匹配敏捷语言的原生数据结构。</li><li>YAML 有一个一致的模型来支持通用工具。</li><li>YAML 支持一次性处理。</li><li>YAML 具有表现力和可扩展性。</li><li>YAML 易于实现和使用。</li></ol></blockquote><p>那么它做的如何呢？</p><blockquote><p>YAML 很容易被人类阅读。</p></blockquote><p>只有坚持一小部分子集时才有效。完整的规则集很复杂 —— 远远超过 XML 或 JSON。</p><blockquote><p>YAML 数据在编程语言之间是可移植的。</p></blockquote><p>事实并非如此，因为创建常见语言不支持的结构太容易了。</p><blockquote><p>YAML 匹配敏捷语言的原生数据结构。</p></blockquote><p>参见上面。另外，为什么只支持敏捷（或动态）语言？其他语言呢？</p><blockquote><p>YAML 有一个一致的模型来支持通用工具。</p></blockquote><p>我甚至不确定这意味着什么，我找不到任何详细说明。</p><blockquote><p>YAML 支持一次性处理。</p></blockquote><p>这点我接受。</p><blockquote><p>YAML 具有表现力和可扩展性。</p></blockquote><p>嗯，是的，但它太富有表现力（例如太复杂）。</p><blockquote><p>YAML 易于实现和使用。</p></blockquote><pre tabindex=0><code>$ cat `ls -1 ~/gocode/src/github.com/go-yaml/yaml/*.go | grep -v _test` | wc -l
9247

$ cat /usr/lib/python3.5/site-packages/yaml/*.py | wc -l
5713
</code></pre><h3 id=结论>结论</h3><p>不要误解我的意思，并不是说 YAML 很糟糕 —— 它肯定不像<a href=http://arp242.net/weblog/JSON_as_configuration_files-_please_dont.html>使用 JSON 那么多的问题</a> —— 但它也不是非常好。有一些一开始并不明显的缺点和惊喜，还有许多更好的替代品，如 <a href=https://github.com/toml-lang/toml>TOML</a> 和其他更专业的格式。</p><p>就个人而言，当我有选择时，我不太可能再次使用它。</p><p>如果你必须使用 YAML，那么我建议你使用 <a href=https://github.com/crdoconnor/strictyaml>StrictYAML</a>，它会删除一些（虽然不是全部）比较麻烦的部分。</p><h3 id=反馈>反馈</h3><p>你可以发送电子邮件至 <a href=mailto:martin@arp242.net>martin@arp242.net</a> 或<a href=https://github.com/Carpetsmoker/arp242.net/issues/new>创建 GitHub issue</a> 以获取反馈、问题等。</p><h3 id=脚注>脚注</h3><ol><li>在 PHP 中你需要修改一个 INI 设置来获得安全的行为，不能只是调用像 <code>yaml_safe()</code> 这样的东西。PHP 想尽办法让愚蠢的东西越发愚蠢。干得漂亮！ <a href=#fnref1>↩</a></li><li>不要在这里做空格与制表符之争，如果这里可以用制表符的话，我可以（临时）增加制表符宽度来使它更易读——这是制表符的一种用途。 <a href=#fnref2>↩</a></li></ol><hr><p>via: <a href=https://arp242.net/weblog/yaml_probably_not_so_great_after_all.html>https://arp242.net/weblog/yaml_probably_not_so_great_after_all.html</a></p><p>作者：<a href=https://arp242.net/>Martin Tournoij</a> 选题：<a href=https://github.com/lujun9972>lujun9972</a> 译者：<a href=https://github.com/MjSeven>MjSeven</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/yaml/ rel=tag>YAML</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>