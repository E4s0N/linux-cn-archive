<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>使用 GraphQL 作为 API 网关来监控微服务 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="使用 GraphQL 作为 API 网关来监控微服务"><meta property="og:description" content="在问题导致关键的微服务瘫痪之前，使用 GraphQL 的监控功能帮助你及早发现问题。"><meta property="og:type" content="article"><meta property="og:url" content="/article-12588-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-09-06T20:51:36+00:00"><meta property="article:modified_time" content="2020-09-06T20:51:36+00:00"><meta itemprop=name content="使用 GraphQL 作为 API 网关来监控微服务"><meta itemprop=description content="在问题导致关键的微服务瘫痪之前，使用 GraphQL 的监控功能帮助你及早发现问题。"><meta itemprop=datePublished content="2020-09-06T20:51:36+00:00"><meta itemprop=dateModified content="2020-09-06T20:51:36+00:00"><meta itemprop=wordCount content="151"><meta itemprop=keywords content="GraphQL,微服务,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>使用 GraphQL 作为 API 网关来监控微服务</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2020-09-06T20:51:36Z>September 06, 2020</time></div></div></header><div class="content post__content clearfix"><blockquote><p>在问题导致关键的微服务瘫痪之前，使用 GraphQL 的监控功能帮助你及早发现问题。</p></blockquote><p><img src=/data/attachment/album/202009/06/205052ve8eebyamcace4v8.jpg alt></p><p><a href=https://opensource.com/resources/what-are-microservices>微服务</a>和 <a href=https://opensource.com/article/19/6/what-is-graphql>GraphQL</a> 就像面包和黄油一样，是一个很好的组合。它们本身都很棒，结合起来就更棒了。了解你的微服务的健康状况是很重要的，因为它们运行着重要的服务。如果等到某个关键的服务崩溃了才诊断问题，那是很愚蠢的。让 GraphQL 帮助你及早发现问题并不需要花费太多精力。</p><p><img src=/data/attachment/album/202009/06/205139mi1icisfjshcgspm.png alt="GraphQL in Microservices" title="GraphQL in Microservices"></p><p>常规的健康检查可以让你观察和测试你的服务，在问题影响到你的业务、客户或项目之前，尽早得到通知。说起来很简单，但健康检查到底要做什么呢？</p><p>以下是我在设计服务检查时考虑的因素：</p><p>服务器健康检查的要求：</p><ol><li>我需要了解我的微服务的可用性状态。</li><li>我希望能够管理服务器的负载。</li><li>我希望对我的微服务进行端到端（e2e）测试。</li><li>我应该能够预测中断。</li></ol><p><img src=/data/attachment/album/202009/06/205142p8u5addu33gzu4gu.png alt="Service health in microservices" title="Service health in microservices"></p><h3 id=做服务器健康检查的方法>做服务器健康检查的方法</h3><p>进行健康检查可能比较棘手，因为理论上，你可以检查的东西几乎是无穷无尽的。我喜欢从小处着手，运行最基本的测试：ping 测试。这只是测试运行应用的服务器是否可用。然后，我加强测试以评估特定问题，思考服务器中最重要的元素。我想到那些如果突然消失的话将是灾难性的事情。</p><ol><li>**Ping 检查：**Ping 是最简单的监控类型。它只是检查你的应用是否在线。</li><li>**脚本化浏览器：**脚本化浏览器比较高级。像 <a href=https://www.selenium.dev/>Selenium</a> 这样的浏览器自动化工具可以让你实现自定义的监控规则集。</li><li>**API 测试：**API 测试用于监控 API 端点。这是 ping 检查模型的高级版本，你可以根据 API 响应来定义监控计划。</li></ol><h3 id=使用-graphql-进行健康检查>使用 GraphQL 进行健康检查</h3><p>在一个典型的基于 REST 的微服务中，你需要从头开始构建健康检查功能。这是一个时间密集型的过程，但使用 GraphQL 就不用担心了。</p><p>根据它的<a href=https://graphql.org/>网站</a>称：</p><blockquote><p>“GraphQL 是一种用于 API 的查询语言，也是一种用现有数据完成这些查询的运行时环境。GraphQL 为你的 API 中的数据提供了一个完整的、可理解的描述，让客户有能力精确地仅查询他们所需要的东西，让 API 更容易随着时间的推移而进化，并实现强大的开发者工具。”</p></blockquote><p>当你启动一个 GraphQL 微服务时，你还可以获得监控微服务的运行状况的供给。这是一个隐藏的宝贝。</p><p>正如我上面提到的，你可以用 GraphQL 端点执行 API 测试以及 ping 检查。</p><p>Apollo GraphQL 服务器提供了一个默认的端点，它可以返回有关你的微服务和服务器健康的信息。它不是很复杂：如果服务器正在运行，它就会返回状态码 200。</p><p>默认端点是 <code>&lt;server-host>/.well-known/apollo/server-health</code>。</p><p><img src=/data/attachment/album/202009/06/205144cpb2h7udbv73bavd.png alt="Health Check with GraphQL" title="Health Check with GraphQL"></p><h3 id=高级健康检查>高级健康检查</h3><p>在某些情况下，基本的健康检查可能不足以确保系统的完整性。例如，紧密耦合的系统需要更多的业务逻辑来确保系统的健康。</p><p>Apollo GraphQL 在定义服务器的同时，通过声明一个 <code>onHealthCheck</code> 函数来有效地管理这种情况。</p><pre tabindex=0><code>* Defining the Apollo Server */
const apollo = new ApolloServer({
  playground: process.env.NODE_ENV !== &#39;production&#39;,
  typeDefs: gqlSchema,
  resolvers: resolver,
  onHealthCheck: () =&gt; {
    return new Promise((resolve, reject) =&gt; {
      // Replace the `true` in this conditional with more specific checks!
      if (true) {
        resolve();
      } else {
        reject();
      }
    });
  }
});
</code></pre><p>当你定义一个 <code>onHealthCheck</code> 方法时，它返回一个 promise，如果服务器准备好了，它就会返回 <code>resolve</code>，如果有错误，它就会返回 <code>reject</code>。</p><p>GraphQL 让监控 API 变得更容易。此外，在你的服务器基础架构中使用它可以使代码变得可扩展。如果你想尝试采用 GraphQL 作为你的新基础设施定义，请参见我的 GitHub 仓库中的<a href=https://github.com/riginoommen/example-graphql>示例代码和配置</a>。</p><hr><p>via: <a href=https://opensource.com/article/20/8/microservices-graphql>https://opensource.com/article/20/8/microservices-graphql</a></p><p>作者：<a href=https://opensource.com/users/riginoommen>Rigin Oommen</a> 选题：<a href=https://github.com/lujun9972>lujun9972</a> 译者：<a href=https://github.com/geekpi>geekpi</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/graphql/ rel=tag>GraphQL</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/ rel=tag>微服务</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>