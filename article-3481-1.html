<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>编程的乐趣：快速终止！ - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="编程的乐趣：快速终止！"><meta property="og:description" content="当软件出现问题的时候，它应该以一种很容易引起注意的方式马上终止。这种快速终止的方式值得借鉴，我们会在这期专栏里谈谈这个重要的概念。 一开始，快速终止看上去是一种会影响可靠性的不好的实践——为什么一个系统在还可以继续运行的时候要崩溃（或者说终止）？对于这个，我们需要理解，快速终止是和Heisenbugs（对于不易复现bug的一种称呼）紧密联系在一起的。考虑一下Bohrbugs（对于能够重现的bug的一种称呼），它们在一个给定输入的条件下总是会出现，比如，访问空指针。这类问题很容易测试、复现并修复。而如今"><meta property="og:type" content="article"><meta property="og:url" content="/article-3481-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2014-07-28T17:37:00+00:00"><meta property="article:modified_time" content="2014-07-28T17:37:00+00:00"><meta itemprop=name content="编程的乐趣：快速终止！"><meta itemprop=description content="当软件出现问题的时候，它应该以一种很容易引起注意的方式马上终止。这种快速终止的方式值得借鉴，我们会在这期专栏里谈谈这个重要的概念。 一开始，快速终止看上去是一种会影响可靠性的不好的实践——为什么一个系统在还可以继续运行的时候要崩溃（或者说终止）？对于这个，我们需要理解，快速终止是和Heisenbugs（对于不易复现bug的一种称呼）紧密联系在一起的。考虑一下Bohrbugs（对于能够重现的bug的一种称呼），它们在一个给定输入的条件下总是会出现，比如，访问空指针。这类问题很容易测试、复现并修复。而如今"><meta itemprop=datePublished content="2014-07-28T17:37:00+00:00"><meta itemprop=dateModified content="2014-07-28T17:37:00+00:00"><meta itemprop=wordCount content="14"><meta itemprop=keywords content="编程,JAVA,Heisenbugs,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>编程的乐趣：快速终止！</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-07-28T17:37:00Z>July 28, 2014</time></div></div></header><div class="content post__content clearfix"><p><img src=/data/attachment/album/201407/28/173756ubb1z2d1d3fs1tlt.jpg alt><br>当软件出现问题的时候，它应该以一种很容易引起注意的方式马上终止。这种“快速终止”的方式值得借鉴，我们会在这期专栏里谈谈这个重要的概念。</p><p>一开始，“快速终止”看上去是一种会影响可靠性的不好的实践——为什么一个系统在还可以继续运行的时候要崩溃（或者说终止）？对于这个，我们需要理解，快速终止是和Heisenbugs（对于不易复现bug的一种称呼）紧密联系在一起的。</p><p>考虑一下Bohrbugs（对于能够重现的bug的一种称呼），它们在一个给定输入的条件下总是会出现，比如，访问空指针。这类问题很容易测试、复现并修复。而如今，所有有经验的程序员应该都面对过这样的情形：导致崩溃的bug在重启软件后就不再出现了。不管花多少时间或努力去重现问题，那个bug就是跟我们捉迷藏。这种bug被称为Heisenbugs。</p><p>花在寻找、修复和测试Heisenbugs上的努力比起Bohrbugs来说，要高出一个数量级。一种避免Heisenbugs的策略是将它们转化为Bohrbugs。怎么做呢？预测可能导致Heisenbugs的因素，然后尝试将它们变成Bohrbugs。是的，这并不简单，而且也并不是一定可行，但是让我们来看一个能产生效果的特殊例子。</p><p>并发编程是Heisenbugs经常出现的一个典范。我们的例子就是一个Java里和并发相关的问题。在遍历一个Java集合的时候，一般要求只能通过Iterator的方法对集合进行操作，比如remove()方法。而在遍历期间，如果有另一个线程尝试修改底层集合（因为编程时留下的错误），那么底层集合就可能会被破坏（例如，导致不正确的状态）。</p><p>类似这种不正确的状态会导致不确定的错误——假如我们幸运的话（实际上，这很不幸！），程序可以继续执行而不会崩溃，但是却给出错误的结果。这种bug很难重现和修复，因为这一类的程序错误都是不确定的。换句话说，这是个Heisenbug。</p><p>幸运的是，Java Iterators会尝试侦测这种并发修改，并且当发现时，会抛出异常ConcurrentModificationException，而不是等到最后再出错——那样也是没有任何迹象的。换句话说，Java Iterators也遵从了“快速终止”的方法。</p><p>如果一个ConcurrentModificationException异常在正式版软件中发生了呢？根据在Javadoc里对这个异常的说明，它“只应该被用于侦测bug”。换句话说，ConcurrentModificationException只应该在开发阶段监听和修复，而不应该泄漏到正式代码中。</p><p>好吧，如果正式软件确实发生了这个异常，那它当然是软件中的bug，应当报告给开发者并修复。至少，我们能够知道曾经发生过一次针对底层数据结构的并发修改尝试，而这是软件出错的原因（而不是让软件产生错误的结果，或是以其他现象延后出错，这样就很难跟踪到根本原因）。</p><p>“防止崩溃”的途径就意味着开发健壮的代码。一个很好的编写容错代码的例子就是使用断言。很可惜的是，关于断言的使用有大量不必要的公开争论。其中主要的批评点是：它在开发版本中使用，而在发布版中却被关掉的。</p><p>不管怎么样，这个批评是错误的：从来没有说要用断言来替代应该放到发布版软件中的防御式检查代码。例如，断言不应该用来检查传递给函数的参数是否为空。相应的，应该用一个if语句来检查这个参数是否正确，否则的话抛出一个异常，或是提前返回，来适合上下文。然而，断言一般可以用于额外检查代码中所作出的假设，这些假设应该一直为真才正常。例如，用一个语句来检查在进行了入栈操作后，栈应该不是空的（例如，对“不变量”的检查）。</p><p>所以，快速终止，随时中断，那么你就走在开发更加健壮代码的道路上了。</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/%E7%BC%96%E7%A8%8B/ rel=tag>编程</a></li><li class=tags__item><a class="tags__link btn" href=/tags/java/ rel=tag>JAVA</a></li><li class=tags__item><a class="tags__link btn" href=/tags/heisenbugs/ rel=tag>Heisenbugs</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>