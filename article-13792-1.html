<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>容器的四大基础技术 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="容器的四大基础技术"><meta property="og:description" content="命名空间、控制组、seccomp 和 SELinux 构成了在系统上构建和运行一个容器进程的 Linux 技术基础。"><meta property="og:type" content="article"><meta property="og:url" content="/article-13792-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-09-17T08:54:44+00:00"><meta property="article:modified_time" content="2021-09-17T08:54:44+00:00"><meta itemprop=name content="容器的四大基础技术"><meta itemprop=description content="命名空间、控制组、seccomp 和 SELinux 构成了在系统上构建和运行一个容器进程的 Linux 技术基础。"><meta itemprop=datePublished content="2021-09-17T08:54:44+00:00"><meta itemprop=dateModified content="2021-09-17T08:54:44+00:00"><meta itemprop=wordCount content="456"><meta itemprop=keywords content="容器,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>容器的四大基础技术</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2021-09-17T08:54:44Z>September 17, 2021</time></div></div></header><div class="content post__content clearfix"><blockquote><p>命名空间、控制组、seccomp 和 SELinux 构成了在系统上构建和运行一个容器进程的 Linux 技术基础。</p></blockquote><p><img src=https://img.linux.net.cn/data/attachment/album/202109/17/085439ye0iq5ynzyhpusy5.jpg alt title="Penguin driving a car with a yellow background"></p><p>在以前的文章中，我介绍过 <a href=/article-13766-1.html>容器镜像</a> 及其 <a href=/article-13772-1.html>运行时</a>。在本文中，我研究了容器是如何在一些特殊的 Linux 技术基础上实现的，这其中包括命名空间和控制组。</p><p><img src=https://img.linux.net.cn/data/attachment/album/202109/17/085446w47ahozm1daudluh.png alt=容器技术的层次 title="layers of linux technologies"></p><p><em>图1：对容器有贡献的 Linux 技术（Nived Velayudhan, <a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA 4.0</a>）</em></p><p>这些 Linux 技术构成了在系统上构建和运行容器进程的基础：</p><ol><li>命名空间</li><li>控制组（cgroups）</li><li>Seccomp</li><li>SELinux</li></ol><h3 id=命名空间>命名空间</h3><p>命名空间 namespace 为容器提供了一个隔离层，给容器提供了一个看起来是独占的 Linux 文件系统的视图。这就限制了进程能访问的内容，从而限制了它所能获得的资源。</p><p>在创建容器时，Docker 或 Podman 和其他容器技术使用了 Linux 内核中的几个命名空间：</p><pre tabindex=0><code>[nivedv@homelab ~]$ docker container run alpine ping 8.8.8.8
[nivedv@homelab ~]$ sudo lsns -p 29413

        NS TYPE   NPROCS   PID USER COMMAND
4026531835 cgroup    299     1 root /usr/lib/systemd/systemd --switched...
4026531837 user      278     1 root /usr/lib/systemd/systemd --switched...
4026533105 mnt         1 29413 root ping 8.8.8.8
4026533106 uts         1 29413 root ping 8.8.8.8
4026533107 ipc         1 29413 root ping 8.8.8.8
4026533108 pid         1 29413 root ping 8.8.8.8
4026533110 net         1 29413 root ping 8.8.8.8
</code></pre><h4 id=用户>用户</h4><p>用户（<code>user</code>）命名空间将用户和组隔离在一个容器内。这是通过分配给容器与宿主系统有不同的 UID 和 GID 范围来实现的。用户命名空间使软件能够以 root 用户的身份在容器内运行。如果入侵者攻击容器，然后逃逸到宿主机上，他们就只能以受限的非 root 身份运行了。</p><h4 id=挂载>挂载</h4><p>挂载（<code>mnt</code>）命名空间允许容器有自己的文件系统层次结构视图。你可以在 Linux 系统中的 <code>/proc/&lt;PID>/mounts</code> 位置找到每个容器进程的挂载点。</p><h4 id=uts>UTS</h4><p>Unix 分时系统 Unix Timeharing System （UTS）命名空间允许容器拥有一个唯一主机名和域名。当你运行一个容器时，即使使用 <code>- name</code> 标签，也会使用一个随机的 ID 作为主机名。你可以使用 <a href=https://opensource.com/article/19/10/namespaces-and-containers-linux>unshare 命令</a> 来了解一下这个工作原理。</p><pre tabindex=0><code>nivedv@homelab ~]$ docker container run -it --name nived alpine sh
/ # hostname 
9c9a5edabdd6
/ # 
nivedv@homelab ~]$ sudo unshare -u sh
sh-5.0# hostname isolated.hostname 
sh-5.0# hostname
isolated.hostname
sh-5.0# 
sh-5.0# exit
exit
[nivedv@homelab ~]$ hostname
homelab.redhat.com
</code></pre><h4 id=ipc>IPC</h4><p>进程间通信 Inter-Process Communication （IPC）命名空间允许不同的容器进程之间，通过访问共享内存或使用共享消息队列来进行通信。</p><pre tabindex=0><code>[root@demo /]# ipcmk -M 10M
Shared memory id: 0
[root@demo /]# ipcmk -M 20M
Shared memory id: 1
[root@demo /]# 
[root@demo /]# ipcs
------ Message Queues --------
key        msqid      owner      perms      used-bytes   messages    
------ Shared Memory Segments --------
key        shmid      owner      perms      bytes      nattch     status      
0xd1df416a 0          root       644        10485760   0                       
0xbd487a9d 1          root       644        20971520   0                       
------ Semaphore Arrays --------
key        semid      owner      perms      nsems
</code></pre><h4 id=pid>PID</h4><p>进程 ID Process ID （PID）命名空间确保运行在容器内的进程与外部隔离。当你在容器内运行 <code>ps</code> 命令时，由于这个命名空间隔离的存在，你只能看到在容器内运行的进程，而不是在宿主机上。</p><h4 id=网络>网络</h4><p>网络（<code>net</code>）命名空间允许容器有自己网络接口、IP 地址、路由表、端口号等视图。容器如何能够与外部通信？你创建的所有容器都会被附加到一个特殊的虚拟网络接口上进行通信。</p><pre tabindex=0><code>[nivedv@homelab ~]$ docker container run --rm -it alpine sh
/ # ping 8.8.8.8
PING 8.8.8.8 (8.8.8.8): 56 data bytes
64 bytes from 8.8.8.8: seq=0 ttl=119 time=21.643 ms
64 bytes from 8.8.8.8: seq=1 ttl=119 time=20.940 ms
^C
[root@homelab ~]# ip link show veth84ea6fc
veth84ea6fc@if22: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue 
master docker0 state UP mode DEFAULT group default
</code></pre><h3 id=控制组>控制组</h3><p>控制组（<code>cgroup</code>）是组成一个容器的基本模块。控制组会分配和限制容器所使用的资源，如 CPU、内存、网络 I/O 等。容器引擎会自动创建每种类型的控制组文件系统，并在容器运行时为每个容器设置配额。</p><pre tabindex=0><code>[root@homelab ~]# lscgroup | grep docker
cpuset:/docker
net_cls,net_prio:/docker
cpu,cpuacct:/docker
hugetlb:/docker
devices:/docker
freezer:/docker
memory:/docker
perf_event:/docker
blkio:/docker
pids:/docker
</code></pre><p>容器运行时为每个容器设置了控制组值，所有信息都存储在 <code>/sys/fs/cgroup/*/docker</code>。下面的命令将确保容器可以使用 50000 微秒的 CPU 时间片，并将内存的软、硬限制分别设置为 500M 和 1G。</p><pre tabindex=0><code>[root@homelab ~]# docker container run -d --name test-cgroups --cpus 0.5 --memory 1G --memory-reservation 500M httpd
[root@homelab ~]# lscgroup cpu,cpuacct:/docker memory:/docker
cpu,cpuacct:/docker/
cpu,cpuacct:/docker/c3503ac704dafea3522d3bb82c77faff840018e857a2a7f669065f05c8b2cc84
memory:/docker/
memory:/docker/c3503ac704dafea3522d3bb82c77faff840018e857a2a7f669065f05c8b2cc84
[root@homelab c....c84]# cat cpu.cfs_period_us 
100000
[root@homelab c....c84]# cat cpu.cfs_quota_us 
50000
[root@homelab c....c84]# cat memory.soft_limit_in_bytes 
524288000
[root@homelab c....c84]# cat memory.limit_in_bytes 
1073741824
</code></pre><h3 id=seccomp>SECCOMP</h3><p>Seccomp 意思是“ 安全计算 secure computing ”。它是一项 Linux 功能，用于限制应用程序进行的系统调用的集合。例如，Docker 的默认 seccomp 配置文件禁用了大约 44 个系统调用（总计超过 300 个）。</p><p>这里的思路是让容器只访问所必须的资源。例如，如果你不需要容器改变主机上的时钟时间，你可能不会使用 <code>clock_adjtime</code> 和 <code>clock_settime</code> 系统调用，屏蔽它们是合理的。同样地，你不希望容器改变内核模块，所以没有必要让它们使用 <code>create_module</code>、 <code>delete_module</code> 系统调用。</p><h3 id=selinux>SELinux</h3><p>SELinux 是“ 安全增强的 Linux security-enhanced Linux ”的缩写。如果你在你的宿主机上运行的是 Red Hat 发行版，那么 SELinux 是默认启用的。SELinux 可以让你限制一个应用程序只能访问它自己的文件，并阻止任何其他进程访问。因此，如果一个应用程序被破坏了，它将限制该应用程序可以影响或控制的文件数量。通过为文件和进程设置上下文环境以及定义策略来实现，这些策略将限制一个进程可以访问和更改的内容。</p><p>容器的 SELinux 策略是由 <code>container-selinux</code> 包定义的。默认情况下，容器以 <code>container_t</code> 标签运行，允许在 <code>/usr</code> 目录下读取（<code>r</code>）和执行（<code>x</code>），并从 <code>/etc</code> 目录下读取大部分内容。标签<code>container_var_lib_t</code> 是与容器有关的文件的通用标签。</p><h3 id=总结>总结</h3><p>容器是当今 IT 基础设施的一个重要组成部分，也是一项相当有趣的技术。即使你的工作不直接涉及容器化，了解一些基本的容器概念和方法，也能让你体会到它们如何帮助你的组织。容器是建立在开源的 Linux 技术之上的，这使它们变得更加美好。</p><p>本文基于 <a href=https://nivedv.medium.com/container-internals-deep-dive-5cc424957413>techbeatly</a> 的文章，并经授权改编。</p><hr><p>via: <a href=https://opensource.com/article/21/8/container-linux-technology>https://opensource.com/article/21/8/container-linux-technology</a></p><p>作者：<a href=https://opensource.com/users/nivedv>Nived V</a> 选题：<a href=https://github.com/lujun9972>lujun9972</a> 译者：<a href=https://github.com/wxy>wxy</a> 校对：<a href=https://github.com/turbokernel>turbokernel</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/%E5%AE%B9%E5%99%A8/ rel=tag>容器</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>