<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>通过禁止比较让 Go 二进制文件变小 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="通过禁止比较让 Go 二进制文件变小"><meta property="og:description" content="本文中我会深入讲解在 Go 程序的上下文中“相等”的意义，以及为什么像这样的修改会对 Go 程序的大小有重大的影响。"><meta property="og:type" content="article"><meta property="og:url" content="/article-12238-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-05-22T10:17:46+00:00"><meta property="article:modified_time" content="2020-05-22T10:17:46+00:00"><meta itemprop=name content="通过禁止比较让 Go 二进制文件变小"><meta itemprop=description content="本文中我会深入讲解在 Go 程序的上下文中“相等”的意义，以及为什么像这样的修改会对 Go 程序的大小有重大的影响。"><meta itemprop=datePublished content="2020-05-22T10:17:46+00:00"><meta itemprop=dateModified content="2020-05-22T10:17:46+00:00"><meta itemprop=wordCount content="275"><meta itemprop=keywords content="Go,相等,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>通过禁止比较让 Go 二进制文件变小</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2020-05-22T10:17:46Z>May 22, 2020</time></div></div></header><div class="content post__content clearfix"><p><img src=/data/attachment/album/202005/22/101617lcha7vvqzhh7d565.jpg alt></p><p>大家常规的认知是，Go 程序中声明的类型越多，生成的二进制文件就越大。这个符合直觉，毕竟如果你写的代码不去操作定义的类型，那么定义一堆类型就没有意义了。然而，链接器的部分工作就是检测没有被程序引用的函数（比如说它们是一个库的一部分，其中只有一个子集的功能被使用），然后把它们从最后的编译产出中删除。常言道，“类型越多，二进制文件越大”，对于多数 Go 程序还是正确的。</p><p>本文中我会深入讲解在 Go 程序的上下文中“相等”的意义，以及为什么<a href=https://github.com/golang/net/commit/e0ff5e5a1de5b859e2d48a2830d7933b3ab5b75f>像这样</a>的修改会对 Go 程序的大小有重大的影响。</p><h3 id=定义两个值相等>定义两个值相等</h3><p>Go 的语法定义了“赋值”和“相等”的概念。赋值是把一个值赋给一个标识符的行为。并不是所有声明的标识符都可以被赋值，如常量和函数就不可以。相等是通过检查标识符的内容是否相等来比较两个标识符的行为。</p><p>作为强类型语言，“相同”的概念从根源上被植入标识符的类型中。两个标识符只有是相同类型的前提下，才有可能相同。除此之外，值的类型定义了如何比较该类型的两个值。</p><p>例如，整型是用算数方法进行比较的。对于指针类型，是否相等是指它们指向的地址是否相同。映射和通道等引用类型，跟指针类似，如果它们指向相同的地址，那么就认为它们是相同的。</p><p>上面都是按位比较相等的例子，即值占用的内存的位模式是相同的，那么这些值就相等。这就是所谓的 memcmp，即内存比较，相等是通过比较两个内存区域的内容来定义的。</p><p>记住这个思路，我过会儿再来谈。</p><h3 id=结构体相等>结构体相等</h3><p>除了整型、浮点型和指针等标量类型，还有复合类型：结构体。所有的结构体以程序中的顺序被排列在内存中。因此下面这个声明：</p><pre tabindex=0><code>type S struct {
    a, b, c, d int64
}
</code></pre><p>会占用 32 字节的内存空间；<code>a</code> 占用 8 个字节，<code>b</code> 占用 8 个字节，以此类推。Go 的规则说如果结构体所有的字段都是可以比较的，那么结构体的值就是可以比较的。因此如果两个结构体所有的字段都相等，那么它们就相等。</p><pre tabindex=0><code>a := S{1, 2, 3, 4}
b := S{1, 2, 3, 4}
fmt.Println(a == b) // 输出 true
</code></pre><p>编译器在底层使用 memcmp 来比较 <code>a</code> 的 32 个字节和 <code>b</code> 的 32 个字节。</p><h3 id=填充和对齐>填充和对齐</h3><p>然而，在下面的场景下过分简单化的按位比较的策略会返回错误的结果：</p><pre tabindex=0><code>type S struct {
    a byte
    b uint64
    c int16
    d uint32
}

func main()
    a := S{1, 2, 3, 4}
    b := S{1, 2, 3, 4}
    fmt.Println(a == b) // 输出 true
}
</code></pre><p>编译代码后，这个比较表达式的结果还是 <code>true</code>，但是编译器在底层并不能仅依赖比较 <code>a</code> 和 <code>b</code> 的位模式，因为结构体有<em>填充</em>。</p><p>Go 要求结构体的所有字段都对齐。2 字节的值必须从偶数地址开始，4 字节的值必须从 4 的倍数地址开始，以此类推 1 。编译器根据字段的类型和底层平台加入了填充来确保字段都<em>对齐</em>。在填充之后，编译器实际上看到的是 2 ：</p><pre tabindex=0><code>type S struct {
    a byte
    _ [7]byte // 填充
    b uint64
    c int16
    _ [2]int16 // 填充
    d uint32
}
</code></pre><p>填充的存在保证了字段正确对齐，而填充确实占用了内存空间，但是填充字节的内容是未知的。你可能会认为在 Go 中 填充字节都是 0，但实际上并不是 — 填充字节的内容是未定义的。由于它们并不是被定义为某个确定的值，因此按位比较会因为分布在 <code>s</code> 的 24 字节中的 9 个填充字节不一样而返回错误结果。</p><p>Go 通过生成所谓的相等函数来解决这个问题。在这个例子中，<code>s</code> 的相等函数只比较函数中的字段略过填充部分，这样就能正确比较类型 <code>s</code> 的两个值。</p><h3 id=类型算法>类型算法</h3><p>呵，这是个很大的设置，说明了为什么，对于 Go 程序中定义的每种类型，编译器都会生成几个支持函数，编译器内部把它们称作类型的算法。如果类型是一个映射的键，那么除相等函数外，编译器还会生成一个哈希函数。为了维持稳定，哈希函数在计算结果时也会像相等函数一样考虑诸如填充等因素。</p><p>凭直觉判断编译器什么时候生成这些函数实际上很难，有时并不明显，（因为）这超出了你的预期，而且链接器也很难消除没有被使用的函数，因为反射往往导致链接器在裁剪类型时变得更保守。</p><h3 id=通过禁止比较来减小二进制文件的大小>通过禁止比较来减小二进制文件的大小</h3><p>现在，我们来解释一下 Brad 的修改。向类型添加一个不可比较的字段 3 ，结构体也随之变成不可比较的，从而强制编译器不再生成相等函数和哈希函数，规避了链接器对那些类型的消除，在实际应用中减小了生成的二进制文件的大小。作为这项技术的一个例子，下面的程序：</p><pre tabindex=0><code>package main

import &#34;fmt&#34;

func main() {
    type t struct {
        // _ [0][]byte // 取消注释以阻止比较
        a byte
        b uint16
        c int32
        d uint64
    }
    var a t
    fmt.Println(a)
}
</code></pre><p>用 Go 1.14.2（darwin/amd64）编译，大小从 2174088 降到了 2174056，节省了 32 字节。单独看节省的这 32 字节似乎微不足道，但是考虑到你的程序中每个类型及其传递闭包都会生成相等和哈希函数，还有它们的依赖，这些函数的大小随类型大小和复杂度的不同而不同，禁止它们会大大减小最终的二进制文件的大小，效果比之前使用 <code>-ldflags="-s -w"</code> 还要好。</p><p>最后总结一下，如果你不想把类型定义为可比较的，可以在源码层级强制实现像这样的奇技淫巧，会使生成的二进制文件变小。</p><hr><p>附录：在 Brad 的推动下，<a href=https://go-review.googlesource.com/c/go/+/231397>Cherry Zhang</a> 和 <a href=https://go-review.googlesource.com/c/go/+/191198>Keith Randall</a> 已经在 Go 1.15 做了大量的改进，修复了最严重的故障，消除了无用的相等和哈希函数（虽然我猜想这也是为了避免这类 CL 的扩散）。</p><h4 id=相关文章>相关文章：</h4><ol><li><a href=https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics title="How the Go runtime implements maps efficiently (without generics)">Go 运行时如何高效地实现映射（不使用泛型）</a></li><li><a href=https://dave.cheney.net/2014/03/25/the-empty-struct title="The empty struct">空结构体</a></li><li><a href=https://dave.cheney.net/2015/10/09/padding-is-hard title="Padding is hard">填充很难</a></li><li><a href=https://dave.cheney.net/2017/08/09/typed-nils-in-go-2 title="Typed nils in Go 2">Go 中有类型的 nil（2）</a></li></ol><hr><ol><li>在 32 位平台上 <code>int64</code> 和 <code>unit64</code> 的值可能不是按 8 字节对齐的，因为平台原生的是以 4 字节对齐的。查看 <a href=https://github.com/golang/go/issues/599>议题 599</a> 了解内部详细信息。 <a href=#fnref1>↩</a></li><li>32 位平台会在 <code>a</code> 和 <code>b</code> 的声明中填充 <code>_ [3]byte</code>。参见前一条。 <a href=#fnref2>↩</a></li><li>Brad 使用的是<code>[0]func()</code>，但是所有能限制和禁止比较的类型都可以。添加了一个有 0 个元素的数组的声明后，结构体的大小和对齐不会受影响。 <a href=#fnref3>↩</a></li></ol><hr><p>via: <a href=https://dave.cheney.net/2020/05/09/ensmallening-go-binaries-by-prohibiting-comparisons>https://dave.cheney.net/2020/05/09/ensmallening-go-binaries-by-prohibiting-comparisons</a></p><p>作者：<a href=https://dave.cheney.net/author/davecheney>Dave Cheney</a> 选题：<a href=https://github.com/lujun9972>lujun9972</a> 译者：<a href=https://github.com/lxbwolf>lxbwolf</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/go/ rel=tag>Go</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E7%9B%B8%E7%AD%89/ rel=tag>相等</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>