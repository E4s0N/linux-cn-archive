<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>不可或缺的 Bash 别名 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="不可或缺的 Bash 别名"><meta property="og:description" content="厌倦了一遍又一遍地输入相同的长命令？你觉得在命令行上工作效率低吗？Bash 别名可以为你创造一个与众不同的世界。"><meta property="og:type" content="article"><meta property="og:url" content="/article-11179-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-08-03T09:59:00+00:00"><meta property="article:modified_time" content="2019-08-03T09:59:00+00:00"><meta itemprop=name content="不可或缺的 Bash 别名"><meta itemprop=description content="厌倦了一遍又一遍地输入相同的长命令？你觉得在命令行上工作效率低吗？Bash 别名可以为你创造一个与众不同的世界。"><meta itemprop=datePublished content="2019-08-03T09:59:00+00:00"><meta itemprop=dateModified content="2019-08-03T09:59:00+00:00"><meta itemprop=wordCount content="757"><meta itemprop=keywords content="别名,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>不可或缺的 Bash 别名</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2019-08-03T09:59:00Z>August 03, 2019</time></div></div></header><div class="content post__content clearfix"><blockquote><p>厌倦了一遍又一遍地输入相同的长命令？你觉得在命令行上工作效率低吗？Bash 别名可以为你创造一个与众不同的世界。</p></blockquote><p><img src=/data/attachment/album/201908/03/095855ip0h0jpi5u9t3r00.jpg alt></p><p>Bash 别名是一种用新的命令补充或覆盖 Bash 命令的方法。Bash 别名使用户可以轻松地在 <a href=https://opensource.com/article/19/7/what-posix-richard-stallman-explains>POSIX</a> 终端中自定义其体验。它们通常定义在 <code>$HOME/.bashrc</code> 或 <code>$HOME/bash_aliases</code> 中（它是由 <code>$HOME/.bashrc</code> 加载的）。</p><p>大多数发行版在新用户帐户的默认 <code>.bashrc</code> 文件中至少添加了一些流行的别名。这些可以用来简单演示 Bash 别名的语法：</p><pre tabindex=0><code>alias ls=&#39;ls -F&#39;
alias ll=&#39;ls -lh&#39;
</code></pre><p>但并非所有发行版都附带预先添加好的别名。如果你想手动添加别名，则必须将它们加载到当前的 Bash 会话中：</p><pre tabindex=0><code>$ source ~/.bashrc
</code></pre><p>否则，你可以关闭终端并重新打开它，以便重新加载其配置文件。</p><p>通过 Bash 初始化脚本中定义的那些别名，你可以键入 <code>ll</code> 而得到 <code>ls -l</code> 的结果，当你键入 <code>ls</code> 时，得到也不是原来的 <a href=https://opensource.com/article/19/7/master-ls-command>ls</a> 的普通输出。</p><p>那些别名很棒，但它们只是浅尝辄止。以下是十大 Bash 别名，一旦你试过它们，你会发现再也不能离开它们。</p><h3 id=首先设置>首先设置</h3><p>在开始之前，创建一个名为 <code>~/.bash_aliases</code> 的文件：</p><pre tabindex=0><code>$ touch ~/.bash_aliases
</code></pre><p>然后，确认这些代码出现在你的 <code>~/.bashrc</code> 文件当中：</p><pre tabindex=0><code>if [ -e $HOME/.bash_aliases ]; then
    source $HOME/.bash_aliases
fi
</code></pre><p>如果你想亲自尝试本文中的任何别名，请将它们输入到 <code>.bash_aliases</code> 文件当中，然后使用 <code>source ~/.bashrc</code> 命令将它们加载到当前 Bash 会话中。</p><h3 id=按文件大小排序>按文件大小排序</h3><p>如果你一开始使用过 GNOME 中的 Nautilus、MacOS 中的 Finder 或 Windows 中的资源管理器等 GUI 文件管理器，那么你很可能习惯了按文件大小排序文件列表。你也可以在终端上做到这一点，但这条命令不是很简洁。</p><p>将此别名添加到 GNU 系统上的配置中：</p><pre tabindex=0><code>alias lt=&#39;ls --human-readable --size -1 -S --classify&#39;
</code></pre><p>此别名将 <code>lt</code> 替换为 <code>ls</code> 命令，该命令在单个列中显示每个项目的大小，然后按大小对其进行排序，并使用符号表示文件类型。加载新别名，然后试一下：</p><pre tabindex=0><code>$ source ~/.bashrc
$ lt
total 344K
140K configure*
 44K aclocal.m4
 36K LICENSE
 32K config.status*
 24K Makefile
 24K Makefile.in
 12K config.log
8.0K README.md
4.0K info.slackermedia.Git-portal.json
4.0K git-portal.spec
4.0K flatpak.path.patch
4.0K Makefile.am*
4.0K dot-gitlab.ci.yml
4.0K configure.ac*
   0 autom4te.cache/
   0 share/
   0 bin/
   0 install-sh@
   0 compile@
   0 missing@
   0 COPYING@
</code></pre><p>在 MacOS 或 BSD 上，<code>ls</code> 命令没有相同的选项，因此这个别名可以改为：</p><pre tabindex=0><code>alias lt=&#39;du -sh * | sort -h&#39;
</code></pre><p>这个版本的结果稍有不同：</p><pre tabindex=0><code>$ du -sh * | sort -h
0       compile
0       COPYING
0       install-sh
0       missing
4.0K    configure.ac
4.0K    dot-gitlab.ci.yml
4.0K    flatpak.path.patch
4.0K    git-portal.spec
4.0K    info.slackermedia.Git-portal.json
4.0K    Makefile.am
8.0K    README.md
12K     config.log
16K     bin
24K     Makefile
24K     Makefile.in
32K     config.status
36K     LICENSE
44K     aclocal.m4
60K     share
140K    configure
476K    autom4te.cache
</code></pre><p>实际上，即使在 Linux上，上面这个命令也很有用，因为使用 <code>ls</code> 列出的目录和符号链接的大小为 0，这可能不是你真正想要的信息。使用哪个看你自己的喜好。</p><p><em>感谢 Brad Alexander 提供的这个别名的思路。</em></p><h3 id=只查看挂载的驱动器>只查看挂载的驱动器</h3><p><code>mount</code> 命令过去很简单。只需一个命令，你就可以获得计算机上所有已挂载的文件系统的列表，它经常用于概览连接到工作站有哪些驱动器。在过去看到超过三、四个条目就会令人印象深刻，因为大多数计算机没有那么多的 USB 端口，因此这个结果还是比较好查看的。</p><p>现在计算机有点复杂，有 LVM、物理驱动器、网络存储和虚拟文件系统，<code>mount</code> 的结果就很难一目了然：</p><pre tabindex=0><code>sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime,seclabel)
proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)
devtmpfs on /dev type devtmpfs (rw,nosuid,seclabel,size=8131024k,nr_inodes=2032756,mode=755)
securityfs on /sys/kernel/security type securityfs (rw,nosuid,nodev,noexec,relatime)
[...]
/dev/nvme0n1p2 on /boot type ext4 (rw,relatime,seclabel)
/dev/nvme0n1p1 on /boot/efi type vfat (rw,relatime,fmask=0077,dmask=0077,codepage=437,iocharset=ascii,shortname=winnt,errors=remount-ro)
[...]
gvfsd-fuse on /run/user/100977/gvfs type fuse.gvfsd-fuse (rw,nosuid,nodev,relatime,user_id=100977,group_id=100977)
/dev/sda1 on /run/media/seth/pocket type ext4 (rw,nosuid,nodev,relatime,seclabel,uhelper=udisks2)
/dev/sdc1 on /run/media/seth/trip type ext4 (rw,nosuid,nodev,relatime,seclabel,uhelper=udisks2)
binfmt_misc on /proc/sys/fs/binfmt_misc type binfmt_misc (rw,relatime)
</code></pre><p>要解决这个问题，试试这个别名：</p><pre tabindex=0><code>alias mnt=&#39;mount | awk -F&#39; &#39; &#39;{ printf &#34;%s\t%s\n&#34;,$1,$3; }&#39; | column -t | egrep ^/dev/ | sort&#39;
</code></pre><p>此别名使用 <code>awk</code> 按列解析 <code>mount</code> 的输出，将输出减少到你可能想要查找的内容（挂载了哪些硬盘驱动器，而不是文件系统）：</p><pre tabindex=0><code>$ mnt
/dev/mapper/fedora-root  /
/dev/nvme0n1p1           /boot/efi
/dev/nvme0n1p2           /boot
/dev/sda1                /run/media/seth/pocket
/dev/sdc1                /run/media/seth/trip
</code></pre><p>在 MacOS 上，<code>mount</code> 命令不提供非常详细的输出，因此这个别名可能过度精简了。但是，如果你更喜欢简洁的报告，请尝试以下方法：</p><pre tabindex=0><code>alias mnt=&#39;mount | grep -E ^/dev | column -t&#39;
</code></pre><p>结果：</p><pre tabindex=0><code>$ mnt
/dev/disk1s1  on  /                (apfs,  local,  journaled)
/dev/disk1s4  on  /private/var/vm  (apfs,  local,  noexec,     journaled,  noatime,  nobrowse)
</code></pre><h3 id=在你的-grep-历史中查找命令>在你的 grep 历史中查找命令</h3><p>有时你好不容易弄清楚了如何在终端完成某件事，并觉得自己永远不会忘记你刚学到的东西。然后，一个小时过去之后你就完全忘记了你做了什么。</p><p>搜索 Bash 历史记录是每个人不时要做的事情。如果你确切地知道要搜索的内容，可以使用 <code>Ctrl + R</code> 对历史记录进行反向搜索，但有时你无法记住要查找的确切命令。</p><p>这是使该任务更容易的别名：</p><pre tabindex=0><code>alias gh=&#39;history|grep&#39;
</code></pre><p>这是如何使用的例子：</p><pre tabindex=0><code>$ gh bash
482 cat ~/.bashrc | grep _alias
498 emacs ~/.bashrc
530 emacs ~/.bash_aliases
531 source ~/.bashrc
</code></pre><h3 id=按修改时间排序>按修改时间排序</h3><p>每个星期一都会这样：你坐在你的电脑前开始工作，你打开一个终端，你发现你已经忘记了上周五你在做什么。你需要的是列出最近修改的文件的别名。</p><p>你可以使用 <code>ls</code> 命令创建别名，以帮助你找到上次离开的位置：</p><pre tabindex=0><code>alias left=&#39;ls -t -1&#39;
</code></pre><p>输出很简单，但如果你愿意，可以使用 <code>--long</code> 选项扩展它。这个别名列出的显示如下：</p><pre tabindex=0><code>$ left
demo.jpeg
demo.xcf
design-proposal.md
rejects.txt
brainstorm.txt
query-letter.xml
</code></pre><h3 id=文件计数>文件计数</h3><p>如果你需要知道目录中有多少文件，那么该解决方案是 UNIX 命令构造的最典型示例之一：使用 <code>ls</code> 命令列出文件，用<code>-1</code> 选项将其输出控制为只有一列，然后输出到 <code>wc</code>（单词计数）命令的管道，以计算有多少行。</p><p>这是 UNIX 理念如何允许用户使用小型的系统组件构建自己的解决方案的精彩演示。如果你碰巧每天都要做几次，这个命令组合也要输入很多字母，如果没有使用 <code>-R</code> 选项，它就不能用于目录，这会为输出引入新行并导致无用的结果。</p><p>而这个别名使这个过程变得简单：</p><pre tabindex=0><code>alias count=&#39;find . -type f | wc -l&#39;
</code></pre><p>这个别名会计算文件，忽略目录，但<strong>不会</strong>忽略目录的内容。如果你有一个包含两个目录的项目文件夹，每个目录包含两个文件，则该别名将返回 4，因为整个项目中有 4 个文件。</p><pre tabindex=0><code>$ ls
foo   bar
$ count
4
</code></pre><h3 id=创建-python-虚拟环境>创建 Python 虚拟环境</h3><p>你用 Python 编程吗？</p><p>你用 Python 编写了很多程序吗？</p><p>如果是这样，那么你就知道创建 Python 虚拟环境至少需要 53 次击键。</p><p>这个数字里有 49 次是多余的，它很容易被两个名为 <code>ve</code> 和 <code>va</code> 的新别名所解决：</p><pre tabindex=0><code>alias ve=&#39;python3 -m venv ./venv&#39;
alias va=&#39;source ./venv/bin/activate&#39;
</code></pre><p>运行 <code>ve</code> 会创建一个名为 <code>venv</code> 的新目录，其中包含 Python 3 的常用虚拟环境文件系统。<code>va</code> 别名在当前 shell 中的激活该环境：</p><pre tabindex=0><code>$ cd my-project
$ ve
$ va
(venv) $
</code></pre><h3 id=增加一个复制进度条>增加一个复制进度条</h3><p>每个人都会吐槽进度条，因为它们似乎总是不合时宜。然而，在内心深处，我们似乎都想要它们。UNIX 的 <code>cp</code> 命令没有进度条，但它有一个 <code>-v</code> 选项用于显示详细信息，它回显了复制的每个文件名到终端。这是一个相当不错的技巧，但是当你复制一个大文件并且想要了解还有多少文件尚未传输时，它的作用就没那么大了。</p><p><code>pv</code> 命令可以在复制期间提供进度条，但它并不常用。另一方面，<code>rsync</code> 命令包含在几乎所有的 POSIX 系统的默认安装中，并且它被普遍认为是远程和本地复制文件的最智能方法之一。</p><p>更好的是，它有一个内置的进度条。</p><pre tabindex=0><code>alias cpv=&#39;rsync -ah --info=progress2&#39;
</code></pre><p>像使用 <code>cp</code> 命令一样使用此别名：</p><pre tabindex=0><code>$ cpv bigfile.flac /run/media/seth/audio/
          3.83M 6%  213.15MB/s    0:00:00 (xfr#4, to-chk=0/4)
</code></pre><p>使用此命令的一个有趣的副作用是 <code>rsync</code> 无需 <code>-r</code> 标志就可以复制文件和目录，而 <code>cp</code> 则需要。</p><h3 id=避免意外删除>避免意外删除</h3><p>你不应该使用 <code>rm</code> 命令。<code>rm</code> 手册甚至这样说：</p><blockquote><p>**警告：**如果使用 <code>rm</code> 删除文件，通常可以恢复该文件的内容。如果你想要更加确保内容真正无法恢复，请考虑使用 <code>shred</code>。</p></blockquote><p>如果要删除文件，则应将文件移动到“废纸篓”，就像使用桌面时一样。</p><p>POSIX 使这很简单，因为垃圾桶是文件系统中可访问的一个实际位置。该位置可能会发生变化，具体取决于你的平台：在 <a href=https://www.freedesktop.org/wiki/>FreeDesktop</a> 上，“垃圾桶”位于 <code>~/.local/share/Trash</code>，而在 MacOS 上则是 <code>~/.Trash</code>，但无论如何，它只是一个目录，你可以将文件藏在那个看不见的地方，直到你准备永久删除它们为止。</p><p>这个简单的别名提供了一种从终端将文件扔进垃圾桶的方法：</p><pre tabindex=0><code>alias tcn=&#39;mv --force -t ~/.local/share/Trash &#39;
</code></pre><p>该别名使用一个鲜为人知的 <code>mv</code> 标志（<code>-t</code>），使你能够提供作为最终移动目标的参数，而忽略了首先列出要移动的文件的通常要求。现在，你可以使用新命令将文件和文件夹移动到系统垃圾桶：</p><pre tabindex=0><code>$ ls
foo  bar
$ tcn foo
$ ls
bar
</code></pre><p>现在文件已“消失”，只有在你一头冷汗的时候才意识到你还需要它。此时，你可以从系统垃圾桶中抢救该文件；这肯定可以给 Bash 和 <code>mv</code> 开发人员提供一些帮助。</p><p>**注意：**如果你需要一个具有更好的 FreeDesktop 兼容性的更强大的垃圾桶命令，请参阅 <a href=https://gitlab.com/trashy/trashy>Trashy</a>。</p><h3 id=简化-git-工作流>简化 Git 工作流</h3><p>每个人都有自己独特的工作流程，但无论如何，通常都会有重复的任务。如果你经常使用 Git，那么你可能会发现自己经常重复的一些操作序列。也许你会发现自己回到主分支并整天一遍又一遍地拉取最新的变化，或者你可能发现自己创建了标签然后将它们推到远端，抑或可能完全是其它的什么东西。</p><p>无论让你厌倦一遍遍输入的 Git 魔咒是什么，你都可以通过 Bash 别名减轻一些痛苦。很大程度上，由于它能够将参数传递给钩子，Git 拥有着丰富的内省命令，可以让你不必在 Bash 中执行那些丑陋冗长的命令。</p><p>例如，虽然你可能很难在 Bash 中找到项目的顶级目录（就 Bash 而言，它是一个完全随意的名称，因为计算机的绝对顶级是根目录），但 Git 可以通过简单的查询找到项目的顶级目录。如果你研究过 Git 钩子，你会发现自己能够找到 Bash 一无所知的各种信息，而你可以利用 Bash 别名来利用这些信息。</p><p>这是一个来查找 Git 项目的顶级目录的别名，无论你当前在哪个项目中工作，都可以将目录改变为顶级目录，切换到主分支，并执行 Git 拉取：</p><pre tabindex=0><code>alias startgit=&#39;cd `git rev-parse --show-toplevel` &amp;&amp; git checkout master &amp;&amp; git pull&#39;
</code></pre><p>这种别名绝不是一个普遍有用的别名，但它演示了一个相对简单的别名如何能够消除大量繁琐的导航、命令和等待提示。</p><p>一个更简单，可能更通用的别名将使你返回到 Git 项目的顶级目录。这个别名非常有用，因为当你在一个项目上工作时，该项目或多或少会成为你的“临时家目录”。它应该像回家一样简单，就像回你真正的家一样，这里有一个别名：</p><pre tabindex=0><code>alias cg=&#39;cd `git rev-parse --show-toplevel`&#39;
</code></pre><p>现在，命令 <code>cg</code> 将你带到 Git 项目的顶部，无论你下潜的目录结构有多深。</p><h3 id=切换目录并同时查看目录内容>切换目录并同时查看目录内容</h3><p>（据称）曾经一位著名科学家提出过，我们可以通过收集极客输入 <code>cd</code> 后跟 <code>ls</code> 消耗的能量来解决地球上的许多能量问题。</p><p>这是一种常见的用法，因为通常当你更改目录时，你都会有查看周围的内容的冲动或需要。</p><p>但是在你的计算机的目录树中移动并不一定是一个走走停停的过程。</p><p>这是一个作弊，因为它根本不是别名，但它是探索 Bash 功能的一个很好的借口。虽然别名非常适合快速替换一个命令，但 Bash 也允许你在 <code>.bashrc</code> 文件中添加本地函数（或者你加载到 <code>.bashrc</code> 中的单独函数文件，就像你的别名文件一样）。</p><p>为了保持模块化，创建一个名为 <code>~/.bash_functions</code> 的新文件，然后让你的 <code>.bashrc</code> 加载它：</p><pre tabindex=0><code>if [ -e $HOME/.bash_functions ]; then
    source $HOME/.bash_functions
fi
</code></pre><p>在该函数文件中，添加这些代码：</p><pre tabindex=0><code>function cl() {
    DIR=&#34;$*&#34;;
    # if no DIR given, go home
    if [ $# -lt 1 ]; then 
        DIR=$HOME;
    fi;
    builtin cd &#34;${DIR}&#34; &amp;&amp; \
    # use your preferred ls command
    ls -F --color=auto
}
</code></pre><p>将函数加载到 Bash 会话中，然后尝试：</p><pre tabindex=0><code>$ source ~/.bash_functions
$ cl Documents
foo bar baz
$ pwd
/home/seth/Documents
$ cl ..
Desktop  Documents  Downloads
[...]
$ pwd
/home/seth
</code></pre><p>函数比别名更灵活，但有了这种灵活性，你就有责任确保代码有意义并达到你的期望。别名是简单的，所以要保持简单而有用。要正式修改 Bash 的行为，请使用保存到 <code>PATH</code> 环境变量中某个位置的函数或自定义的 shell 脚本。</p><p>附注，有一些巧妙的奇技淫巧来实现 <code>cd</code> 和 <code>ls</code> 序列作为别名，所以如果你足够耐心，那么即使是一个简单的别名也永无止限。</p><h3 id=开始别名化和函数化吧>开始别名化和函数化吧</h3><p>可以定制你的环境使得 Linux 变得如此有趣，提高效率使得 Linux 可以改变生活。开始使用简单的别名，进而使用函数，并在评论中发布你必须拥有的别名！</p><hr><p>via: <a href=https://opensource.com/article/19/7/bash-aliases>https://opensource.com/article/19/7/bash-aliases</a></p><p>作者：<a href=https://opensource.com/users/seth>Seth Kenlon</a> 选题：<a href=https://github.com/lujun9972>lujun9972</a> 译者：<a href=https://github.com/wxy>wxy</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/%E5%88%AB%E5%90%8D/ rel=tag>别名</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>