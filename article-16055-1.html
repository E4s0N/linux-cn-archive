<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>使用 GoogleTest 和 CTest 进行单元测试 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="使用 GoogleTest 和 CTest 进行单元测试"><meta property="og:description" content="进行单元测试可以提高代码质量，并且它不会打断你的工作流。"><meta property="og:type" content="article"><meta property="og:url" content="/article-16055-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-08-02T11:15:50+00:00"><meta property="article:modified_time" content="2023-08-02T11:15:50+00:00"><meta itemprop=name content="使用 GoogleTest 和 CTest 进行单元测试"><meta itemprop=description content="进行单元测试可以提高代码质量，并且它不会打断你的工作流。"><meta itemprop=datePublished content="2023-08-02T11:15:50+00:00"><meta itemprop=dateModified content="2023-08-02T11:15:50+00:00"><meta itemprop=wordCount content="495"><meta itemprop=keywords content="单元测试,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>使用 GoogleTest 和 CTest 进行单元测试</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2023-08-02T11:15:50Z>August 02, 2023</time></div></div></header><div class="content post__content clearfix"><blockquote><p>进行单元测试可以提高代码质量，并且它不会打断你的工作流。</p></blockquote><p><img src=https://img.linux.net.cn/data/attachment/album/202308/02/111508h0848o0oi03nih3p.jpg alt title="Team checklist and to dos"></p><p>本文是 <a href=/article-14249-1.html>使用 CMake 和 VSCodium 设置一个构建系统</a> 的后续文章。</p><p>在上一篇文章中我介绍了基于 <a href=https://vscodium.com/>VSCodium</a> 和 <a href=https://cmake.org/>CMake</a> 配置构建系统。本文我将介绍如何通过 <a href=https://github.com/google/googletest>GoogleTest</a> 和 <a href=https://cmake.org/cmake/help/latest/manual/ctest.1.html>CTest</a> 将单元测试集成到这个构建系统中。</p><p>首先克隆 <a href=https://github.com/hANSIc99/cpp_testing_sample>这个仓库</a>，用 VSCodium 打开，切换到 <code>devops_2</code> 标签。你可以通过点击 <code>main</code> 分支符号（红框处），然后选择 <code>devops_2</code> 标签（黄框处）来进行切换：</p><p><img src=https://img.linux.net.cn/data/attachment/album/202308/02/111550ris8qikjc8jivjq8.png alt="VSCodium tag" title="VSCodium tag"></p><p>或者你可以通过命令行来切换：</p><pre tabindex=0><code>$ git checkout tags/devops_2
</code></pre><h3 id=googletest>GoogleTest</h3><p>GoogleTest 是一个平台无关的开源 C++ 测试框架。单元测试是用来验证单个逻辑单元的行为的。尽管 GoogleTest 并不是专门用于单元测试的，我将用它对 <code>Generator</code> 库进行单元测试。</p><p>在 GoogleTest 中，测试用例是通过断言宏来定义的。断言可能产生以下结果：</p><ul><li><em>成功</em>: 测试通过。</li><li><em>非致命失败</em>: 测试失败，但测试继续。</li><li><em>致命失败</em>: 测试失败，且测试终止。</li></ul><p>致命断言和非致命断言通过不同的宏来区分：</p><ul><li><code>ASSERT_*</code>： 致命断言，失败时终止。</li><li><code>EXPECT_*</code>： 非致命断言，失败时不终止。</li></ul><p>谷歌推荐使用 <code>EXPECT_*</code> 宏，因为当测试中包含多个的断言时，它允许继续执行。断言有两个参数：第一个参数是测试分组的名称，第二个参数是测试自己的名称。<code>Generator</code> 只定义了 <code>generate(...)</code> 函数，所以本文中所有的测试都属于同一个测试组：<code>GeneratorTest</code>。</p><p>针对 <code>generate(...)</code> 函数的测试可以从 <a href=https://github.com/hANSIc99/cpp_testing_sample/blob/main/Generator/GeneratorTest.cpp>GeneratorTest.cpp</a> 中找到。</p><h4 id=引用一致性检查>引用一致性检查</h4><p><a href=https://github.com/hANSIc99/cpp_testing_sample/blob/main/Generator/Generator.cpp>generate(&mldr;)</a> 函数有一个 <a href=https://en.cppreference.com/w/cpp/io/basic_stringstream>std::stringstream</a> 的引用作为输入参数，并且它也将这个引用作为返回值。第一个测试就是检查输入的引用和返回的引用是否一致。</p><pre tabindex=0><code>TEST(GeneratorTest, ReferenceCheck){
    const int NumberOfElements = 10;
    std::stringstream buffer;
    EXPECT_EQ(
        std::addressof(buffer),
        std::addressof(Generator::generate(buffer, NumberOfElements))
    );
}
</code></pre><p>在这个测试中我使用 <a href=https://en.cppreference.com/w/cpp/memory/addressof>std::addressof</a> 来获取对象的地址，并用 <code>EXPECT_EQ</code> 来比较输入对象和返回对象是否是同一个。</p><h4 id=检查元素个数>检查元素个数</h4><p>本测试检查作为输入的 <code>std::stringstream</code> 引用中的元素个数与输入参数中指定的个数是否相同。</p><pre tabindex=0><code>TEST(GeneratorTest, NumberOfElements){
    const int NumberOfElements = 50;
    int nCalcNoElements = 0;

    std::stringstream buffer;

    Generator::generate(buffer, NumberOfElements);
    std::string s_no;

    while(std::getline(buffer, s_no, &#39; &#39;)) {
        nCalcNoElements++;
    }

    EXPECT_EQ(nCalcNoElements, NumberOfElements);
}
</code></pre><h4 id=乱序重排>乱序重排</h4><p>本测试检查随机化引擎是否工作正常。如果连续调用两次 <code>generate</code> 函数，应该得到的是两个不同的结果。</p><pre tabindex=0><code>TEST(GeneratorTest, Shuffle){

    const int NumberOfElements = 50;

    std::stringstream buffer_A;
    std::stringstream buffer_B;

    Generator::generate(buffer_A, NumberOfElements);
    Generator::generate(buffer_B, NumberOfElements);

    EXPECT_NE(buffer_A.str(), buffer_B.str());
}
</code></pre><h4 id=求和校验>求和校验</h4><p>与前面的测试相比，这是一个大体量的测试。它检查 1 到 n 的数值序列的和与乱序重排后的序列的和是否相等。 <code>generate(...)</code> 函数应该生成一个 1 到 n 的乱序的序列，这个序列的和应当是不变的。</p><pre tabindex=0><code>TEST(GeneratorTest, CheckSum){

    const int NumberOfElements = 50;
    int nChecksum_in = 0;
    int nChecksum_out = 0;

    std::vector&lt;int&gt; vNumbersRef(NumberOfElements); // Input vector
    std::iota(vNumbersRef.begin(), vNumbersRef.end(), 1); // Populate vector

    // Calculate reference checksum
    for(const int n : vNumbersRef){
        nChecksum_in += n;
    }

    std::stringstream buffer;
    Generator::generate(buffer, NumberOfElements);

    std::vector&lt;int&gt; vNumbersGen; // Output vector
    std::string s_no;

    // Read the buffer back back to the output vector
    while(std::getline(buffer, s_no, &#39; &#39;)) {
        vNumbersGen.push_back(std::stoi(s_no));
    }

    // Calculate output checksum
    for(const int n : vNumbersGen){
        nChecksum_out += n;
    }

    EXPECT_EQ(nChecksum_in, nChecksum_out);
}
</code></pre><p>你可以像对一般 C++ 程序一样调试这些测试。</p><h3 id=ctest>CTest</h3><p>除了嵌入到代码中的测试之外，<a href=https://cmake.org/cmake/help/latest/manual/ctest.1.html>CTest</a> 提供了可执行程序的测试方式。简而言之就是通过给可执行程序传入特定的参数，然后用 <a href=https://en.wikipedia.org/wiki/Regular_expression>正则表达式</a> 对它的输出进行匹配检查。通过这种方式可以很容易检查程序对于不正确的命令行参数的反应。这些测试定义在顶层的 <a href=https://github.com/hANSIc99/cpp_testing_sample/blob/main/CMakeLists.txt>CMakeLists.txt</a> 文件中。下面我详细介绍 3 个测试用例：</p><h4 id=参数正常>参数正常</h4><p>如果输入参数是一个正整数，程序应该输出应该是一个数列：</p><pre tabindex=0><code>add_test(NAME RegularUsage COMMAND Producer 10)
set_tests_properties(RegularUsage
    PROPERTIES PASS_REGULAR_EXPRESSION &#34;^[0-9 ]+&#34;
)
</code></pre><h4 id=没有提供参数>没有提供参数</h4><p>如果没有传入参数，程序应该立即退出并提示错误原因：</p><pre tabindex=0><code>add_test(NAME NoArg COMMAND Producer)
set_tests_properties(NoArg
    PROPERTIES PASS_REGULAR_EXPRESSION &#34;^Enter the number of elements as argument&#34;
)
</code></pre><h4 id=参数错误>参数错误</h4><p>当传入的参数不是整数时，程序应该退出并报错。比如给 <code>Producer</code> 传入参数 <code>ABC</code>：</p><pre tabindex=0><code>add_test(NAME WrongArg COMMAND Producer ABC)
set_tests_properties(WrongArg
    PROPERTIES PASS_REGULAR_EXPRESSION &#34;^Error: Cannot parse&#34;
)
</code></pre><h4 id=执行测试>执行测试</h4><p>可以使用 <code>ctest -R Usage -VV</code> 命令来执行测试。这里给 <code>ctest</code> 的命令行参数：</p><ul><li><code>-R &lt;测试名称></code> : 执行单个测试</li><li><code>-VV</code>：打印详细输出</li></ul><p>测试执行结果如下：</p><pre tabindex=0><code>$ ctest -R Usage -VV
UpdatecTest Configuration from :/home/stephan/Documents/cpp_testing sample/build/DartConfiguration.tcl
UpdateCTestConfiguration from :/home/stephan/Documents/cpp_testing sample/build/DartConfiguration.tcl
Test project /home/stephan/Documents/cpp_testing sample/build
Constructing a list of tests
Done constructing a list of tests
Updating test list for fixtures
Added 0 tests to meet fixture requirements
Checking test dependency graph...
Checking test dependency graph end
</code></pre><p>在这里我执行了名为 <code>Usage</code> 的测试。</p><p>它以无参数的方式调用 <code>Producer</code>：</p><pre tabindex=0><code>test 3
    Start 3: Usage
3: Test command: /home/stephan/Documents/cpp testing sample/build/Producer
</code></pre><p>输出不匹配 <code>[^[0-9]+]</code> 的正则模式，测试未通过。</p><pre tabindex=0><code>3: Enter the number of elements as argument
1/1 test #3. Usage ................

Failed Required regular expression not found.
Regex=[^[0-9]+]

0.00 sec round.

0% tests passed, 1 tests failed out of 1
Total Test time (real) =
0.00 sec
The following tests FAILED:
3 - Usage (Failed)
Errors while running CTest
$
</code></pre><p>如果想要执行所有测试（包括那些用 GoogleTest 生成的），切换到 <code>build</code> 目录中，然后运行 <code>ctest</code> 即可：</p><p><img src=https://img.linux.net.cn/data/attachment/album/202308/02/111550jadr74h0cresps6k.png alt="CTest run" title="CTest run"></p><p>在 VSCodium 中可以通过点击信息栏的黄框处来调用 CTest。如果所有测试都通过了，你会看到如下输出：</p><p><img src=https://img.linux.net.cn/data/attachment/album/202308/02/111550ba2sh1z4z2xp2axe.png alt=VSCodium title=VSCodium></p><h3 id=使用-git-钩子进行自动化测试>使用 Git 钩子进行自动化测试</h3><p>目前为止，运行测试是开发者需要额外执行的步骤，那些不能通过测试的代码仍然可能被提交和推送到代码仓库中。利用 <a href=https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks>Git 钩子</a> 可以自动执行测试，从而防止有瑕疵的代码被提交。</p><p>切换到 <code>.git/hooks</code> 目录，创建 <code>pre-commit</code> 文件，复制粘贴下面的代码：</p><pre tabindex=0><code>#!/usr/bin/sh

(cd build; ctest --output-on-failure -j6)
</code></pre><p>然后，给文件增加可执行权限：</p><pre tabindex=0><code>$ chmod +x pre-commit
</code></pre><p>这个脚本会在提交之前调用 CTest 进行测试。如果有测试未通过，提交过程就会被终止：</p><p><img src=https://img.linux.net.cn/data/attachment/album/202308/02/111551v6fyahwaaf7j77fu.png alt="Commit failed" title="Commit failed"></p><p>只有所有测试都通过了，提交过程才会完成：</p><p><img src=https://img.linux.net.cn/data/attachment/album/202308/02/111551rf63rllf3666sfm6.png alt="Commit succeeded" title="Commit succeeded"></p><p>这个机制也有一个漏洞：可以通过 <code>git commit --no-verify</code> 命令绕过测试。解决办法是配置构建服务器，这能保证只有正常工作的代码才能被提交，但这又是另一个话题了。</p><h3 id=总结>总结</h3><p>本文提到的技术实施简单，并且能够帮你快速发现代码中的问题。做单元测试可以提高代码质量，同时也不会打断你的工作流。GoogleTest 框架提供了丰富的特性以应对各种测试场景，文中我所提到的只是一小部分而已。如果你想进一步了解 GoogleTest，我推荐你阅读 <a href=https://google.github.io/googletest/primer.html>GoogleTest Primer</a>。</p><p><em>（题图：MJ/f212ce43-b60b-4005-b70d-8384f2ba5860）</em></p><hr><p>via: <a href=https://opensource.com/article/22/1/unit-testing-googletest-ctest>https://opensource.com/article/22/1/unit-testing-googletest-ctest</a></p><p>作者：<a href=https://opensource.com/users/hansic99>Stephan Avenwedde</a> 选题：<a href=https://github.com/lujun9972>lujun9972</a> 译者：<a href=https://github.com/toknow-gh>toknow-gh</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/ rel=tag>单元测试</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>