<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>JavaScript 路由器 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="JavaScript 路由器"><meta property="og:description" content="构建单页面应用（SPA）有许多的框架/库，但是我希望它们能少一些。我有一个解决方案，我想共享给大家。"><meta property="og:type" content="article"><meta property="og:url" content="/article-9815-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-07-07T14:46:17+00:00"><meta property="article:modified_time" content="2018-07-07T14:46:17+00:00"><meta itemprop=name content="JavaScript 路由器"><meta itemprop=description content="构建单页面应用（SPA）有许多的框架/库，但是我希望它们能少一些。我有一个解决方案，我想共享给大家。"><meta itemprop=datePublished content="2018-07-07T14:46:17+00:00"><meta itemprop=dateModified content="2018-07-07T14:46:17+00:00"><meta itemprop=wordCount content="396"><meta itemprop=keywords content="SPA,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>JavaScript 路由器</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2018-07-07T14:46:17Z>July 07, 2018</time></div></div></header><div class="content post__content clearfix"><p><img src=/data/attachment/album/201807/07/144603n00b0ma2bmlmnx0l.jpg alt></p><p>构建单页面应用（SPA）有许多的框架/库，但是我希望它们能少一些。我有一个解决方案，我想共享给大家。</p><pre tabindex=0><code>class Router {
    constructor() {
        this.routes = []
    }

    handle(pattern, handler) {
        this.routes.push({ pattern, handler })
    }

    exec(pathname) {
        for (const route of this.routes) {
            if (typeof route.pattern === &#39;string&#39;) {
                if (route.pattern === pathname) {
                    return route.handler()
                }
            } else if (route.pattern instanceof RegExp) {
                const result = pathname.match(route.pattern)
                if (result !== null) {
                    const params = result.slice(1).map(decodeURIComponent)
                    return route.handler(...params)
                }
            }
        }
    }
}
const router = new Router()

router.handle(&#39;/&#39;, homePage)
router.handle(/^\/users\/([^\/]+)$/, userPage)
router.handle(/^\//, notFoundPage)

function homePage() {
    return &#39;home page&#39;
}

function userPage(username) {
    return `${username}&#39;s page`
}

function notFoundPage() {
    return &#39;not found page&#39;
}

console.log(router.exec(&#39;/&#39;)) // home page
console.log(router.exec(&#39;/users/john&#39;)) // john&#39;s page
console.log(router.exec(&#39;/foo&#39;)) // not found page
</code></pre><p>使用它你可以为一个 URL 模式添加处理程序。这个模式可能是一个简单的字符串或一个正则表达式。使用一个字符串将精确匹配它，但是如果使用一个正则表达式将允许你做一些更复杂的事情，比如，从用户页面上看到的 URL 中获取其中的一部分，或者匹配任何没有找到页面的 URL。</p><p>我将详细解释这个 <code>exec</code> 方法 … 正如我前面说的，URL 模式既有可能是一个字符串，也有可能是一个正则表达式，因此，我首先来检查它是否是一个字符串。如果模式与给定的路径名相同，它返回运行处理程序。如果是一个正则表达式，我们与给定的路径名进行匹配。如果匹配成功，它将获取的参数传递给处理程序，并返回运行这个处理程序。</p><h3 id=工作示例>工作示例</h3><p>那个例子正好记录到了控制台。我们尝试将它整合到一个页面，看看它是什么样的。</p><pre tabindex=0><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&#34;en&#34;&gt;
&lt;head&gt;
 &lt;meta charset=&#34;utf-8&#34;&gt;
 &lt;meta name=&#34;viewport&#34; content=&#34;width=device-width, initial-scale=1.0&#34;&gt;
 &lt;title&gt;Router Demo&lt;/title&gt;
 &lt;link rel=&#34;shortcut icon&#34; href=&#34;data:,&#34;&gt;
 &lt;script src=&#34;/main.js&#34; type=&#34;module&#34;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
 &lt;header&gt;
 &lt;a href=&#34;/&#34;&gt;Home&lt;/a&gt;
 &lt;a href=&#34;/users/john_doe&#34;&gt;Profile&lt;/a&gt;
 &lt;/header&gt;
 &lt;main&gt;&lt;/main&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>这是 <code>index.html</code>。对于单页面应用程序来说，你必须在服务器侧做一个特别的工作，因为所有未知的路径都将返回这个 <code>index.html</code>。在开发时，我们使用了一个 npm 工具调用了 <a href=https://npm.im/serve>serve</a>。这个工具去提供静态内容。使用标志 <code>-s</code>/<code>--single</code>，你可以提供单页面应用程序。</p><p>使用 <a href=https://nodejs.org/>Node.js</a> 和安装的 npm（它与 Node 一起安装），运行：</p><pre tabindex=0><code>npm i -g serve
serve -s
</code></pre><p>那个 HTML 文件将脚本 <code>main.js</code> 加载为一个模块。在我们渲染的相关页面中，它有一个简单的 <code>&lt;header></code> 和一个 <code>&lt;main></code> 元素。</p><p>在 <code>main.js</code> 文件中：</p><pre tabindex=0><code>const main = document.querySelector(&#39;main&#39;)
const result = router.exec(location.pathname)
main.innerHTML = result
</code></pre><p>我们调用传递了当前路径名为参数的 <code>router.exec()</code>，然后将 <code>result</code> 设置为 <code>main</code> 元素的 HTML。</p><p>如果你访问 <code>localhost</code> 并运行它，你将看到它能够正常工作，但不是预期中的来自一个单页面应用程序。当你点击链接时，单页面应用程序将不会被刷新。</p><p>我们将在每个点击的链接的锚点上附加事件监听器，防止出现缺省行为，并做出正确的渲染。因为一个单页面应用程序是一个动态的东西，你预期要创建的锚点链接是动态的，因此要添加事件监听器，我使用的是一个叫 <a href=https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_delegation>事件委托</a> 的方法。</p><p>我给整个文档附加一个点击事件监听器，然后去检查在锚点上（或内部）是否有点击事件。</p><p>在 <code>Router</code> 类中，我有一个注册回调的方法，在我们每次点击一个链接或者一个 <code>popstate</code> 事件发生时，这个方法将被运行。每次你使用浏览器的返回或者前进按钮时，<code>popstate</code> 事件将被发送。</p><p>为了方便其见，我们给回调传递与 <code>router.exec(location.pathname)</code> 相同的参数。</p><pre tabindex=0><code>class Router {
    // ...
    install(callback) {
        const execCallback = () =&gt; {
            callback(this.exec(location.pathname))
        }

        document.addEventListener(&#39;click&#39;, ev =&gt; {
            if (ev.defaultPrevented
                || ev.button !== 0
                || ev.ctrlKey
                || ev.shiftKey
                || ev.altKey
                || ev.metaKey) {
                return
            }

            const a = ev.target.closest(&#39;a&#39;)

            if (a === null
                || (a.target !== &#39;&#39; &amp;&amp; a.target !== &#39;_self&#39;)
                || a.hostname !== location.hostname) {
                return
            }

            ev.preventDefault()

            if (a.href !== location.href) {
                history.pushState(history.state, document.title, a.href)
                execCallback()
            }
        })

        addEventListener(&#39;popstate&#39;, execCallback)
        execCallback()
    }
}
</code></pre><p>对于链接的点击事件，除调用了回调之外，我们还使用 <code>history.pushState()</code> 去更新 URL。</p><p>我们将前面的 <code>main</code> 元素中的渲染移动到 <code>install</code> 回调中。</p><pre tabindex=0><code>router.install(result =&gt; {
 main.innerHTML = result
})
</code></pre><h4 id=dom>DOM</h4><p>你传递给路由器的这些处理程序并不需要返回一个字符串。如果你需要更多的东西，你可以返回实际的 DOM。如：</p><pre tabindex=0><code>const homeTmpl = document.createElement(&#39;template&#39;)
homeTmpl.innerHTML = `
 &lt;div class=&#34;container&#34;&gt;
 &lt;h1&gt;Home Page&lt;/h1&gt;
 &lt;/div&gt;
`

function homePage() {
 const page = homeTmpl.content.cloneNode(true)
 // You can do `page.querySelector()` here...
 return page
}
</code></pre><p>现在，在 <code>install</code> 回调中，你可以去检查 <code>result</code> 是一个 <code>string</code> 还是一个 <code>Node</code>。</p><pre tabindex=0><code>router.install(result =&gt; {
    if (typeof result === &#39;string&#39;) {
        main.innerHTML = result
    } else if (result instanceof Node) {
        main.innerHTML = &#39;&#39;
        main.appendChild(result)
    }
})
</code></pre><p>这些就是基本的功能。我希望将它共享出来，因为我将在下篇文章中使用到这个路由器。</p><p>我已经以一个 <a href=https://www.npmjs.com/package/@nicolasparada/router>npm 包</a> 的形式将它发布了。</p><hr><p>via: <a href=https://nicolasparada.netlify.com/posts/js-router/>https://nicolasparada.netlify.com/posts/js-router/</a></p><p>作者：<a href=https://nicolasparada.netlify.com/>Nicolás Parada</a> 选题：<a href=https://github.com/lujun9972>lujun9972</a> 译者：<a href=https://github.com/qhwdw>qhwdw</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/spa/ rel=tag>SPA</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>