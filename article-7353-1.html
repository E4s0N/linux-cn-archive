<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Linux 内核里的数据结构——基数树 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="Linux 内核里的数据结构——基数树"><meta property="og:description" content="基数树是一种 压缩的字典树 （compressed trie） ，而字典树是实现了关联数组接口并允许以 键值对 方式存储值的一种数据结构。"><meta property="og:type" content="article"><meta property="og:url" content="/article-7353-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2016-05-18T08:56:00+00:00"><meta property="article:modified_time" content="2016-05-18T08:56:00+00:00"><meta itemprop=name content="Linux 内核里的数据结构——基数树"><meta itemprop=description content="基数树是一种 压缩的字典树 （compressed trie） ，而字典树是实现了关联数组接口并允许以 键值对 方式存储值的一种数据结构。"><meta itemprop=datePublished content="2016-05-18T08:56:00+00:00"><meta itemprop=dateModified content="2016-05-18T08:56:00+00:00"><meta itemprop=wordCount content="384"><meta itemprop=keywords content="基数树,字典树,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>Linux 内核里的数据结构——基数树</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-05-18T08:56:00Z>May 18, 2016</time></div></div></header><div class="content post__content clearfix"><h3 id=ruby-基数树-rp---rp-rt--radix-tree-rt-rp---rpruby>基数树 （ Radix tree ）</h3><p><img src=/data/attachment/album/201605/18/085613hqkbz7gkpv8lc1ck.jpg alt=Trie></p><p>正如你所知道的，Linux内核提供了许多不同的库和函数，它们实现了不同的数据结构和算法。在这部分，我们将研究其中一种数据结构—— 基数树 （ Radix tree ） 。在 Linux 内核中，有两个文件与基数树的实现和API相关：</p><ul><li><a href=https://github.com/torvalds/linux/blob/master/include/linux/radix-tree.h>include/linux/radix-tree.h</a></li><li><a href=https://github.com/torvalds/linux/blob/master/lib/radix-tree.c>lib/radix-tree.c</a></li></ul><p>让我们先说说什么是 <code>基数树</code> 吧。基数树是一种 压缩的字典树 （ compressed trie ） ，而<a href=http://en.wikipedia.org/wiki/Trie>字典树</a>是实现了关联数组接口并允许以 <code>键值对</code> 方式存储值的一种数据结构。这里的键通常是字符串，但可以使用任意数据类型。字典树因为它的节点而与 <code>n叉树</code> 不同。字典树的节点不存储键，而是存储单个字符的标签。与一个给定节点关联的键可以通过从根遍历到该节点获得。举个例子：</p><pre tabindex=0><code>               +-----------+
               |           |
               |    &#34; &#34;    |
               |           |
        +------+-----------+------+
        |                         |
        |                         |
   +----v------+            +-----v-----+
   |           |            |           |
   |    g      |            |     c     |
   |           |            |           |
   +-----------+            +-----------+
        |                         |
        |                         |
   +----v------+            +-----v-----+
   |           |            |           |
   |    o      |            |     a     |
   |           |            |           |
   +-----------+            +-----------+
                                  |
                                  |
                            +-----v-----+
                            |           |
                            |     t     |
                            |           |
                            +-----------+
</code></pre><p>因此在这个例子中，我们可以看到一个有着两个键 <code>go</code> 和 <code>cat</code> 的 <code>字典树</code> 。压缩的字典树也叫做 <code>基数树</code> ，它和 <code>字典树</code> 的不同之处在于，所有只有一个子节点的中间节点都被删除。</p><p>Linux 内核中的基数树是把值映射到整形键的一种数据结构。<a href=https://github.com/torvalds/linux/blob/master/include/linux/radix-tree.h>include/linux/radix-tree.h</a>文件中的以下结构体描述了基数树：</p><pre tabindex=0><code>struct radix_tree_root {
         unsigned int            height;
         gfp_t                   gfp_mask;
         struct radix_tree_node  __rcu *rnode;
};
</code></pre><p>这个结构体描述了一个基数树的根，它包含了3个域成员：</p><ul><li><code>height</code> - 树的高度;</li><li><code>gfp_mask</code> - 告知如何执行动态内存分配;</li><li><code>rnode</code> - 孩子节点指针.</li></ul><p>我们第一个要讨论的字段是 <code>gfp_mask</code> ：</p><p>底层内核的内存动态分配函数以一组标志作为 <code>gfp_mask</code> ，用于描述如何执行动态内存分配。这些控制分配进程的 <code>GFP_</code> 标志拥有以下值：( <code>GF_NOIO</code> 标志)意味着睡眠以及等待内存，( <code>__GFP_HIGHMEM</code> 标志)意味着高端内存能够被使用，( <code>GFP_ATOMIC</code> 标志)意味着分配进程拥有高优先级并不能睡眠等等。</p><ul><li><code>GFP_NOIO</code> - 睡眠等待内存</li><li><code>__GFP_HIGHMEM</code> - 高端内存能够被使用;</li><li><code>GFP_ATOMIC</code> - 分配进程拥有高优先级并且不能睡眠;</li></ul><p>等等。</p><p>下一个字段是<code>rnode</code>：</p><pre tabindex=0><code>struct radix_tree_node {
        unsigned int    path;
        unsigned int    count;
        union {
                struct {
                        struct radix_tree_node *parent;
                        void *private_data;
                };
                struct rcu_head rcu_head;
        };
        /* For tree user */
        struct list_head private_list;
        void __rcu      *slots[RADIX_TREE_MAP_SIZE];
        unsigned long   tags[RADIX_TREE_MAX_TAGS][RADIX_TREE_TAG_LONGS];
};
</code></pre><p>这个结构体包含的信息有父节点中的偏移以及到底端(叶节点)的高度、子节点的个数以及用于访问和释放节点的字段成员。这些字段成员描述如下：</p><ul><li><code>path</code> - 父节点中的偏移和到底端(叶节点)的高度</li><li><code>count</code> - 子节点的个数;</li><li><code>parent</code> - 父节点指针;</li><li><code>private_data</code> - 由树的用户使用;</li><li><code>rcu_head</code> - 用于释放节点;</li><li><code>private_list</code> - 由树的用户使用;</li></ul><p><code>radix_tree_node</code> 的最后两个成员—— <code>tags</code> 和 <code>slots</code> 非常重要且令人关注。Linux 内核基数树的每个节点都包含了一组 指针槽 （ slots ） ，槽里存储着指向数据的指针。在Linux内核基数树的实现中，空槽存储的是 <code>NULL</code> 。Linux内核中的基数树也支持 标签 （ tags ） ，它与 <code>radix_tree_node</code> 结构体的 <code>tags</code> 字段相关联。有了标签，我们就可以对基数树中存储的记录以单个 比特位 （ bit ） 进行设置。</p><p>既然我们了解了基数树的结构，那么该是时候看一下它的API了。</p><h3 id=linux内核基数树api>Linux内核基数树API</h3><p>我们从结构体的初始化开始。有两种方法初始化一个新的基数树。第一种是使用 <code>RADIX_TREE</code> 宏：</p><pre tabindex=0><code>RADIX_TREE(name, gfp_mask);
</code></pre><p>正如你所看到的，我们传递了 <code>name</code> 参数，所以通过 <code>RADIX_TREE</code> 宏，我们能够定义和初始化基数树为给定的名字。<code>RADIX_TREE</code> 的实现很简单：</p><pre tabindex=0><code>#define RADIX_TREE(name, mask) \
         struct radix_tree_root name = RADIX_TREE_INIT(mask)

#define RADIX_TREE_INIT(mask)   { \
        .height = 0,              \
        .gfp_mask = (mask),       \
        .rnode = NULL,            \
}
</code></pre><p>在 <code>RADIX_TREE</code> 宏的开始，我们使用给定的名字定义 <code>radix_tree_root</code> 结构体实例，并使用给定的 mask 调用 <code>RADIX_TREE_INIT</code> 宏。 而 <code>RADIX_TREE_INIT</code> 宏则是使用默认值和给定的mask对 <code>radix_tree_root</code> 结构体进行了初始化。</p><p>第二种方法是手动定义<code>radix_tree_root</code>结构体，并且将它和mask传给 <code>INIT_RADIX_TREE</code> 宏：</p><pre tabindex=0><code>struct radix_tree_root my_radix_tree;
INIT_RADIX_TREE(my_tree, gfp_mask_for_my_radix_tree);
</code></pre><p><code>INIT_RADIX_TREE</code> 宏的定义如下:</p><pre tabindex=0><code>#define INIT_RADIX_TREE(root, mask)  \
do {                                 \
        (root)-&gt;height = 0;          \
        (root)-&gt;gfp_mask = (mask);   \
        (root)-&gt;rnode = NULL;        \
} while (0)
</code></pre><p>和<code>RADIX_TREE_INIT</code>宏所做的初始化工作一样，<code>INIT_RADIX_TREE</code> 宏使用默认值和给定的 mask 完成初始化工作。</p><p>接下来是用于向基数树插入和删除数据的两个函数：</p><ul><li><code>radix_tree_insert</code>;</li><li><code>radix_tree_delete</code>;</li></ul><p>第一个函数 <code>radix_tree_insert</code> 需要3个参数：</p><ul><li>基数树的根;</li><li>索引键;</li><li>插入的数据;</li></ul><p><code>radix_tree_delete</code> 函数需要和 <code>radix_tree_insert</code> 一样的一组参数，但是不需要传入要删除的数据。</p><p>基数树的搜索以两种方法实现：</p><ul><li><code>radix_tree_lookup</code>;</li><li><code>radix_tree_gang_lookup</code>;</li><li><code>radix_tree_lookup_slot</code>.</li></ul><p>第一个函数<code>radix_tree_lookup</code>需要两个参数：</p><ul><li>基数树的根;</li><li>索引键;</li></ul><p>这个函数尝试在树中查找给定的键，并返回和该键相关联的记录。第二个函数 <code>radix_tree_gang_lookup</code> 有以下的函数签名：</p><pre tabindex=0><code>unsigned int radix_tree_gang_lookup(struct radix_tree_root *root,
                                    void **results,
                                    unsigned long first_index,
                                    unsigned int max_items);
</code></pre><p>它返回的是记录的个数。 <code>results</code> 中的结果，按键排序，并从第一个索引开始。返回的记录个数将不会超过 <code>max_items</code> 的值。</p><p>最后一个函数<code>radix_tree_lookup_slot</code>将会返回包含数据的指针槽。</p><h3 id=链接>链接</h3><ul><li><a href=http://en.wikipedia.org/wiki/Radix_tree>Radix tree</a></li><li><a href=http://en.wikipedia.org/wiki/Trie>Trie</a></li></ul><hr><p>via: <a href=https://github.com/0xAX/linux-insides/blob/master/DataStructures/radix-tree.md>https://github.com/0xAX/linux-insides/blob/master/DataStructures/radix-tree.md</a></p><p>作者：[0xAX] 译者：<a href=https://github.com/cposture>cposture</a> 校对：<a href=https://github.com/tinyeyeser>Mr小眼儿</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创翻译，<a href=http://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/%E5%9F%BA%E6%95%B0%E6%A0%91/ rel=tag>基数树</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E5%AD%97%E5%85%B8%E6%A0%91/ rel=tag>字典树</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>