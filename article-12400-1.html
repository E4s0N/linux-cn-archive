<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>使用 Delve 代替 Println 来调试 Go 程序 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="使用 Delve 代替 Println 来调试 Go 程序"><meta property="og:description" content="Delve 是能让调试变成轻而易举的事的万能工具包。"><meta property="og:type" content="article"><meta property="og:url" content="/article-12400-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-07-09T23:44:18+00:00"><meta property="article:modified_time" content="2020-07-09T23:44:18+00:00"><meta itemprop=name content="使用 Delve 代替 Println 来调试 Go 程序"><meta itemprop=description content="Delve 是能让调试变成轻而易举的事的万能工具包。"><meta itemprop=datePublished content="2020-07-09T23:44:18+00:00"><meta itemprop=dateModified content="2020-07-09T23:44:18+00:00"><meta itemprop=wordCount content="1335"><meta itemprop=keywords content="Go,调试,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>使用 Delve 代替 Println 来调试 Go 程序</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2020-07-09T23:44:18Z>July 09, 2020</time></div></div></header><div class="content post__content clearfix"><blockquote><p>Delve 是能让调试变成轻而易举的事的万能工具包。</p></blockquote><p><img src=/data/attachment/album/202007/09/234357pavw88sbxab0makj.jpg alt></p><p>你上次尝试去学习一种新的编程语言时什么时候？你有没有持之以恒，你是那些在新事物发布的第一时间就勇敢地去尝试的一员吗？不管怎样，学习一种新的语言也许非常有用，也会有很多乐趣。</p><p>你尝试着写简单的 “Hello, world!”，然后写一些示例代码并执行，继续做一些小的修改，之后继续前进。我敢保证我们都有过这个经历，不论我们使用哪种技术。假如你尝试用一段时间一种语言，并且你希望能够精通它，那么有一些事物能在你的进取之路上帮助你。</p><p>其中之一就是调试器。有些人喜欢在代码中用简单的 “print” 语句进行调试，这种方式很适合代码量少的简单程序；然而，如果你处理的是有多个开发者和几千行代码的大型项目，你应该使用调试器。</p><p>最近我开始学习 Go 编程语言了，在本文中，我们将探讨一种名为 Delve 的调试器。Delve 是专门用来调试 Go 程序的工具，我们会借助一些 Go 示例代码来了解下它的一些功能。不要担心这里展示的 Go 示例代码；即使你之前没有写过 Go 代码也能看懂。Go 的目标之一是简单，因此代码是始终如一的，理解和解释起来都很容易。</p><h3 id=delve-介绍>Delve 介绍</h3><p>Delve 是托管在 <a href=https://github.com/go-delve/delve>GitHub</a> 上的一个开源项目。</p><p>它自己的文档中写道：</p><blockquote><p>Delve 是 Go 编程语言的调试器。该项目的目标是为 Go 提供一个简单、全功能的调试工具。Delve 应该是易于调用和易于使用的。当你使用调试器时，事情可能不会按你的思路运行。如果你这样想，那么你不适合用 Delve。</p></blockquote><p>让我们来近距离看一下。</p><p>我的测试系统是运行着 Fedora Linux 的笔记本电脑，Go 编译器版本如下：</p><pre tabindex=0><code>$ cat /etc/fedora-release
Fedora release 30 (Thirty)
$
$ go version
go version go1.12.17 linux/amd64
$
</code></pre><h3 id=golang-安装>Golang 安装</h3><p>如果你没有安装 Go，你可以运行下面的命令，很轻松地就可以从配置的仓库中获取。</p><pre tabindex=0><code>$ dnf install golang.x86_64
</code></pre><p>或者，你可以在<a href=https://golang.org/doc/install>安装页面</a>找到适合你的操作系统的其他安装版本。</p><p>在开始之前，请先确认已经设置好了 Go 工具依赖的下列各个路径。如果这些路径没有设置，有些示例可能不能正常运行。你可以在 SHELL 的 RC 文件中轻松设置这些环境变量，我的机器上是在 <code>$HOME/bashrc</code> 文件中设置的。</p><pre tabindex=0><code>$ go env | grep GOPATH
GOPATH=&#34;/home/user/go&#34;
$
$ go env | grep GOBIN
GOBIN=&#34;/home/user/go/gobin&#34;
$
</code></pre><h3 id=delve-安装>Delve 安装</h3><p>你可以像下面那样，通过运行一个简单的 <code>go get</code> 命令来安装 Delve。<code>go get</code> 是 Golang 从外部源下载和安装需要的包的方式。如果你安装过程中遇到了问题，可以查看 <a href=https://github.com/go-delve/delve/blob/master/Documentation/installation/linux/install.md>Delve 安装教程</a>。</p><pre tabindex=0><code>$ go get -u github.com/go-delve/delve/cmd/dlv
$
</code></pre><p>运行上面的命令，就会把 Delve 下载到你的 <code>$GOPATH</code> 的位置，如果你没有把 <code>$GOPATH</code> 设置成其他值，那么默认情况下 <code>$GOPATH</code> 和 <code>$HOME/go</code> 是同一个路径。</p><p>你可以进入 <code>go/</code> 目录，你可以在 <code>bin/</code> 目录下看到 <code>dlv</code>。</p><pre tabindex=0><code>$ ls -l $HOME/go
total 8
drwxrwxr-x. 2 user user 4096 May 25 19:11 bin
drwxrwxr-x. 4 user user 4096 May 25 19:21 src
$
$ ls -l ~/go/bin/
total 19596
-rwxrwxr-x. 1 user user 20062654 May 25 19:17 dlv
$
</code></pre><p>因为你把 Delve 安装到了 <code>$GOPATH</code>，所以你可以像运行普通的 shell 命令一样运行它，即每次运行时你不必先进入它所在的目录。你可以通过 <code>version</code> 选项来验证 <code>dlv</code> 是否正确安装。示例中安装的版本是 1.4.1。</p><pre tabindex=0><code>$ which dlv
~/go/bin/dlv
$
$ dlv version
Delve Debugger
Version: 1.4.1
Build: $Id: bda606147ff48b58bde39e20b9e11378eaa4db46 $
$
</code></pre><p>现在，我们一起在 Go 程序中使用 Delve 来理解下它的功能以及如何使用它们。我们先来写一个 <code>hello.go</code>，简单地打印一条 <code>Hello, world!</code> 信息。</p><p>记着，我把这些示例程序放到了 <code>$GOBIN</code> 目录下。</p><pre tabindex=0><code>$ pwd
/home/user/go/gobin
$
$ cat hello.go
package main

import &#34;fmt&#34;

func main() {
        fmt.Println(&#34;Hello, world!&#34;)
}
$
</code></pre><p>运行 <code>build</code> 命令来编译一个 Go 程序，它的输入是 <code>.go</code> 后缀的文件。如果程序没有语法错误，Go 编译器把它编译成一个二进制可执行文件。这个文件可以被直接运行，运行后我们会在屏幕上看到 <code>Hello, world!</code> 信息。</p><pre tabindex=0><code>$ go build hello.go
$
$ ls -l hello
-rwxrwxr-x. 1 user user 1997284 May 26 12:13 hello
$
$ ./hello
Hello, world!
$
</code></pre><h3 id=在-delve-中加载程序>在 Delve 中加载程序</h3><p>把一个程序加载进 Delve 调试器有两种方式。</p><h4 id=在源码编译成二进制文件之前使用-debug-参数>在源码编译成二进制文件之前使用 debug 参数</h4><p>第一种方式是在需要时对源码使用 <code>debug</code> 命令。Delve 会为你编译出一个名为 <code>__debug_bin</code> 的二进制文件，并把它加载进调试器。</p><p>在这个例子中，你可以进入 <code>hello.go</code> 所在的目录，然后运行 <code>dlv debug</code> 命令。如果目录中有多个源文件且每个文件都有自己的主函数，Delve 则可能抛出错误，它期望的是单个程序或从单个项目构建成单个二进制文件。如果出现了这种错误，那么你就应该用下面展示的第二种方式。</p><pre tabindex=0><code>$ ls -l
total 4
-rw-rw-r--. 1 user user 74 Jun  4 11:48 hello.go
$
$ dlv debug
Type &#39;help&#39; for list of commands.
(dlv)
</code></pre><p>现在打开另一个终端，列出目录下的文件。你可以看到一个多出来的 <code>__debug_bin</code> 二进制文件，这个文件是由源码编译生成的，并会加载进调试器。你现在可以回到 <code>dlv</code> 提示框继续使用 Delve。</p><pre tabindex=0><code>$ ls -l
total 2036
-rwxrwxr-x. 1 user user 2077085 Jun  4 11:48 __debug_bin
-rw-rw-r--. 1 user user      74 Jun  4 11:48 hello.go
$
</code></pre><h4 id=使用-exec-参数>使用 exec 参数</h4><p>如果你已经有提前编译好的 Go 程序或者已经用 <code>go build</code> 命令编译完成了，不想再用 Delve 编译出 <code>__debug_bin</code> 二进制文件，那么第二种把程序加载进 Delve 的方法在这些情况下会很有用。在上述情况下，你可以使用 <code>exec</code> 命令来把整个目录加载进 Delve 调试器。</p><pre tabindex=0><code>$ ls -l
total 4
-rw-rw-r--. 1 user user 74 Jun  4 11:48 hello.go
$
$ go build hello.go
$
$ ls -l
total 1956
-rwxrwxr-x. 1 user user 1997284 Jun  4 11:54 hello
-rw-rw-r--. 1 user user      74 Jun  4 11:48 hello.go
$
$ dlv exec ./hello
Type &#39;help&#39; for list of commands.
(dlv)
</code></pre><h3 id=查看-delve-帮助信息>查看 delve 帮助信息</h3><p>在 <code>dlv</code> 提示符中，你可以运行 <code>help</code> 来查看 Delve 提供的多种帮助选项。命令列表相当长，这里我们只列举一些重要的功能。下面是 Delve 的功能概览。</p><pre tabindex=0><code>(dlv) help
The following commands are available:

Running the program:

Manipulating breakpoints:

Viewing program variables and memory:

Listing and switching between threads and goroutines:

Viewing the call stack and selecting frames:

Other commands:

Type help followed by a command for full documentation.
(dlv)
</code></pre><h4 id=设置断点>设置断点</h4><p>现在我们已经把 hello.go 程序加载进了 Delve 调试器，我们在主函数处设置断点，稍后来确认它。在 Go 中，主程序从 <code>main.main</code> 处开始执行，因此你需要给这个名字提供个 <code>break</code> 命令。之后，我们可以用 <code>breakpoints</code> 命令来检查断点是否正确设置了。</p><p>不要忘了你还可以用命令简写，因此你可以用 <code>b main.main</code> 来代替 <code>break main.main</code>，两者效果相同，<code>bp</code> 和 <code>breakpoints</code> 同理。你可以通过运行 <code>help</code> 命令查看帮助信息来找到你想要的命令简写。</p><pre tabindex=0><code>(dlv) break main.main
Breakpoint 1 set at 0x4a228f for main.main() ./hello.go:5
(dlv) breakpoints
Breakpoint runtime-fatal-throw at 0x42c410 for runtime.fatalthrow() /usr/lib/golang/src/runtime/panic.go:663 (0)
Breakpoint unrecovered-panic at 0x42c480 for runtime.fatalpanic() /usr/lib/golang/src/runtime/panic.go:690 (0)
        print runtime.curg._panic.arg
Breakpoint 1 at 0x4a228f for main.main() ./hello.go:5 (0)
(dlv)
</code></pre><h4 id=程序继续执行>程序继续执行</h4><p>现在，我们用 <code>continue</code> 来继续运行程序。它会运行到断点处中止，在我们的例子中，会运行到主函数的 <code>main.main</code> 处中止。从这里开始，我们可以用 <code>next</code> 命令来逐行执行程序。请注意，当我们运行到 <code>fmt.Println("Hello, world!")</code> 处时，即使我们还在调试器里，我们也能看到打印到屏幕的 <code>Hello, world!</code>。</p><pre tabindex=0><code>(dlv) continue
&gt; main.main() ./hello.go:5 (hits goroutine(1):1 total:1) (PC: 0x4a228f)
     1: package main
     2:
     3: import &#34;fmt&#34;
     4:
=&gt;   5:      func main() {
     6:         fmt.Println(&#34;Hello, world!&#34;)
     7: }
(dlv) next
&gt; main.main() ./hello.go:6 (PC: 0x4a229d)
     1: package main
     2:
     3: import &#34;fmt&#34;
     4:
     5: func main() {
=&gt;   6:              fmt.Println(&#34;Hello, world!&#34;)
     7: }
(dlv) next
Hello, world!
&gt; main.main() ./hello.go:7 (PC: 0x4a22ff)
     2:
     3: import &#34;fmt&#34;
     4:
     5: func main() {
     6:         fmt.Println(&#34;Hello, world!&#34;)
=&gt;   7:      }
(dlv)
</code></pre><h4 id=退出-delve>退出 Delve</h4><p>你随时可以运行 <code>quit</code> 命令来退出调试器，退出之后你会回到 shell 提示符。相当简单，对吗？</p><pre tabindex=0><code>(dlv) quit
$
</code></pre><h3 id=delve-的其他功能>Delve 的其他功能</h3><p>我们用其他的 Go 程序来探索下 Delve 的其他功能。这次，我们从 <a href=https://tour.golang.org/basics/4>golang 教程</a> 中找了一个程序。如果你要学习 Go 语言，那么 Golang 教程应该是你的第一站。</p><p>下面的程序，<code>functions.go</code> 中简单展示了 Go 程序中是怎样定义和调用函数的。这里，我们有一个简单的把两数相加并返回和值的 <code>add()</code> 函数。你可以像下面那样构建程序并运行它。</p><pre tabindex=0><code>$ cat functions.go
package main

import &#34;fmt&#34;

func add(x int, y int) int {
        return x + y
}

func main() {
        fmt.Println(add(42, 13))
}
$
</code></pre><p>你可以像下面那样构建和运行程序。</p><pre tabindex=0><code>$ go build functions.go  &amp;&amp; ./functions
55
$
</code></pre><h4 id=进入函数>进入函数</h4><p>跟前面展示的一样，我们用前面提到的一个选项来把二进制文件加载进 Delve 调试器，再一次在 <code>main.main</code> 处设置断点，继续运行程序直到断点处。然后执行 <code>next</code> 直到 <code>fmt.Println(add(42, 13))</code> 处；这里我们调用了 <code>add()</code> 函数。我们可以像下面展示的那样，用 Delve 的 <code>step</code> 命令从 <code>main</code> 函数进入 <code>add()</code> 函数。</p><pre tabindex=0><code>$ dlv debug
Type &#39;help&#39; for list of commands.
(dlv) break main.main
Breakpoint 1 set at 0x4a22b3 for main.main() ./functions.go:9
(dlv) c
&gt; main.main() ./functions.go:9 (hits goroutine(1):1 total:1) (PC: 0x4a22b3)
     4:
     5: func add(x int, y int) int {
     6:         return x + y
     7: }
     8:
=&gt;   9:      func main() {
    10:         fmt.Println(add(42, 13))
    11: }
(dlv) next
&gt; main.main() ./functions.go:10 (PC: 0x4a22c1)
     5: func add(x int, y int) int {
     6:         return x + y
     7: }
     8:
     9: func main() {
=&gt;  10:              fmt.Println(add(42, 13))
    11: }
(dlv) step
&gt; main.add() ./functions.go:5 (PC: 0x4a2280)
     1: package main
     2:
     3: import &#34;fmt&#34;
     4:
=&gt;   5:      func add(x int, y int) int {
     6:         return x + y
     7: }
     8:
     9: func main() {
    10:         fmt.Println(add(42, 13))
(dlv)
</code></pre><h4 id=使用文件名行号来设置断点>使用<code>文件名:行号</code>来设置断点</h4><p>上面的例子中，我们经过 <code>main</code> 函数进入了 <code>add()</code> 函数，但是你也可以在你想加断点的地方直接使用“文件名:行号”的组合。下面是在 <code>add()</code> 函数开始处加断点的另一种方式。</p><pre tabindex=0><code>(dlv) break functions.go:5
Breakpoint 1 set at 0x4a2280 for main.add() ./functions.go:5
(dlv) continue
&gt; main.add() ./functions.go:5 (hits goroutine(1):1 total:1) (PC: 0x4a2280)
     1: package main
     2:
     3: import &#34;fmt&#34;
     4:
=&gt;   5:      func add(x int, y int) int {
     6:         return x + y
     7: }
     8:
     9: func main() {
    10:         fmt.Println(add(42, 13))
(dlv)
</code></pre><h4 id=查看当前的栈信息>查看当前的栈信息</h4><p>现在我们运行到了 <code>add()</code> 函数，我们可以在 Delve 中用 <code>stack</code> 命令查看当前栈的内容。这里在 <code>0</code> 位置展示了栈顶的函数 <code>add()</code> ，紧接着在 <code>1</code> 位置展示了调用 <code>add()</code> 函数的 <code>main.main</code>。在 <code>main.main</code> 下面的函数属于 Go 运行时，是用来处理加载和执行该程序的。</p><pre tabindex=0><code>(dlv) stack
0  0x00000000004a2280 in main.add
   at ./functions.go:5
1  0x00000000004a22d7 in main.main
   at ./functions.go:10
2  0x000000000042dd1f in runtime.main
   at /usr/lib/golang/src/runtime/proc.go:200
3  0x0000000000458171 in runtime.goexit
   at /usr/lib/golang/src/runtime/asm_amd64.s:1337
(dlv)
</code></pre><h4 id=在帧之间跳转>在帧之间跳转</h4><p>在 Delve 中我们可以用 <code>frame</code> 命令实现帧之间的跳转。在下面的例子中，我们用 <code>frame</code> 实现了从 <code>add()</code> 帧跳到 <code>main.main</code> 帧，以此类推。</p><pre tabindex=0><code>(dlv) frame 0
&gt; main.add() ./functions.go:5 (hits goroutine(1):1 total:1) (PC: 0x4a2280)
Frame 0: ./functions.go:5 (PC: 4a2280)
     1: package main
     2:
     3: import &#34;fmt&#34;
     4:
=&gt;   5:      func add(x int, y int) int {
     6:         return x + y
     7: }
     8:
     9: func main() {
    10:         fmt.Println(add(42, 13))
(dlv) frame 1
&gt; main.add() ./functions.go:5 (hits goroutine(1):1 total:1) (PC: 0x4a2280)
Frame 1: ./functions.go:10 (PC: 4a22d7)
     5: func add(x int, y int) int {
     6:         return x + y
     7: }
     8:
     9: func main() {
=&gt;  10:              fmt.Println(add(42, 13))
    11: }
(dlv)
</code></pre><h4 id=打印函数参数>打印函数参数</h4><p>一个函数通常会接收多个参数。在 <code>add()</code> 函数中，它的入参是两个整型。Delve 有个便捷的 <code>args</code> 命令，它能打印出命令行传给函数的参数。</p><pre tabindex=0><code>(dlv) args
x = 42
y = 13
~r2 = 824633786832
(dlv)
</code></pre><h4 id=查看反汇编码>查看反汇编码</h4><p>由于我们是调试编译出的二进制文件，因此如果我们能查看编译器生成的汇编语言指令将会非常有用。Delve 提供了一个 <code>disassemble</code> 命令来查看这些指令。在下面的例子中，我们用它来查看 <code>add()</code> 函数的汇编指令。</p><pre tabindex=0><code>(dlv) step
&gt; main.add() ./functions.go:5 (PC: 0x4a2280)
     1: package main
     2:
     3: import &#34;fmt&#34;
     4:
=&gt;   5:      func add(x int, y int) int {
     6:         return x + y
     7: }
     8:
     9: func main() {
    10:         fmt.Println(add(42, 13))
(dlv) disassemble
TEXT main.add(SB) /home/user/go/gobin/functions.go
=&gt;   functions.go:5  0x4a2280   48c744241800000000   mov qword ptr [rsp+0x18], 0x0
        functions.go:6  0x4a2289   488b442408           mov rax, qword ptr [rsp+0x8]
        functions.go:6  0x4a228e   4803442410           add rax, qword ptr [rsp+0x10]
        functions.go:6  0x4a2293   4889442418           mov qword ptr [rsp+0x18], rax
        functions.go:6  0x4a2298   c3                   ret
(dlv)
</code></pre><h4 id=单步退出函数>单步退出函数</h4><p>另一个功能是 <code>stepout</code>，这个功能可以让我们跳回到函数被调用的地方。在我们的例子中，如果我们想回到 <code>main.main</code> 函数，我们只需要简单地运行 <code>stepout</code> 命令，它就会把我们带回去。在我们调试大型代码库时，这个功能会是一个非常便捷的工具。</p><pre tabindex=0><code>(dlv) stepout
&gt; main.main() ./functions.go:10 (PC: 0x4a22d7)
Values returned:
        ~r2: 55

     5: func add(x int, y int) int {
     6:         return x + y
     7: }
     8:
     9: func main() {
=&gt;  10:              fmt.Println(add(42, 13))
    11: }
(dlv)
</code></pre><h4 id=打印变量信息>打印变量信息</h4><p>我们一起通过 <a href=https://tour.golang.org/basics/9>Go 教程</a> 的另一个示例程序来看下 Delve 是怎么处理 Go 中的变量的。下面的示例程序定义和初始化了一些不同类型的变量。你可以构建和运行程序。</p><pre tabindex=0><code>$ cat variables.go
package main

import &#34;fmt&#34;

var i, j int = 1, 2

func main() {
        var c, python, java = true, false, &#34;no!&#34;
        fmt.Println(i, j, c, python, java)
}
$

$ go build variables.go &amp;&amp;; ./variables
1 2 true false no!
$
</code></pre><p>像前面说过的那样，用 <code>delve debug</code> 在调试器中加载程序。你可以在 Delve 中用 <code>print</code> 命令通过变量名来展示他们当前的值。</p><pre tabindex=0><code>(dlv) print c
true
(dlv) print java
&#34;no!&#34;
(dlv)
</code></pre><p>或者，你还可以用 <code>locals</code> 命令来打印函数内所有的局部变量。</p><pre tabindex=0><code>(dlv) locals
python = false
c = true
java = &#34;no!&#34;
(dlv)
</code></pre><p>如果你不知道变量的类型，你可以用 <code>whatis</code> 命令来通过变量名来打印它的类型。</p><pre tabindex=0><code>(dlv) whatis python
bool
(dlv) whatis c
bool
(dlv) whatis java
string
(dlv)
</code></pre><h3 id=总结>总结</h3><p>现在我们只是了解了 Delve 所有功能的皮毛。你可以自己去查看帮助内容，尝试下其它的命令。你还可以把 Delve 绑定到运行中的 Go 程序上（守护进程！），如果你安装了 Go 源码库，你甚至可以用 Delve 导出 Golang 库内部的信息。勇敢去探索吧！</p><hr><p>via: <a href=https://opensource.com/article/20/6/debug-go-delve>https://opensource.com/article/20/6/debug-go-delve</a></p><p>作者：<a href=https://opensource.com/users/gkamathe>Gaurav Kamathe</a> 选题：<a href=https://github.com/lujun9972>lujun9972</a> 译者：<a href=https://github.com/lxbwolf>lxbwolf</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/go/ rel=tag>Go</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E8%B0%83%E8%AF%95/ rel=tag>调试</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>