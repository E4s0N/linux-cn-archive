<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>在没有 Kotlin 的世界与 Android 共舞 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="在没有 Kotlin 的世界与 Android 共舞"><meta property="og:description" content="作为一个专业的工程师，你不能在没有同意的情况下私自去使用那些时髦的技术。我知道这听起来非常恐怖，特别当你已经品尝到 Kotlin 的好处时，不过不要失去生活的信念。"><meta property="og:type" content="article"><meta property="og:url" content="/article-8489-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-05-08T09:46:00+00:00"><meta property="article:modified_time" content="2017-05-08T09:46:00+00:00"><meta itemprop=name content="在没有 Kotlin 的世界与 Android 共舞"><meta itemprop=description content="作为一个专业的工程师，你不能在没有同意的情况下私自去使用那些时髦的技术。我知道这听起来非常恐怖，特别当你已经品尝到 Kotlin 的好处时，不过不要失去生活的信念。"><meta itemprop=datePublished content="2017-05-08T09:46:00+00:00"><meta itemprop=dateModified content="2017-05-08T09:46:00+00:00"><meta itemprop=wordCount content="490"><meta itemprop=keywords content="Android,Kotlin,java,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>在没有 Kotlin 的世界与 Android 共舞</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-05-08T09:46:00Z>May 08, 2017</time></div></div></header><div class="content post__content clearfix"><p><img src=https://img.linux.net.cn/data/attachment/album/201705/08/094713pyiwim50n7ttpfyi.jpg alt></p><blockquote><p>开始投入一件事比远离它更容易。 — Donald Rumsfeld</p></blockquote><p>没有 Kotlin 的生活就像在触摸板上玩魔兽争霸 3。购买鼠标很简单，但如果你的新雇主不想让你在生产中使用 Kotlin，你该怎么办？</p><p>下面有一些选择。</p><ul><li>与你的产品负责人争取获得使用 Kotlin 的权利。</li><li>使用 Kotlin 并且不告诉其他人因为你知道最好的东西是只适合你的。</li><li>擦掉你的眼泪，自豪地使用 Java。</li></ul><p>想象一下，你在和产品负责人的斗争中失败，作为一个专业的工程师，你不能在没有同意的情况下私自去使用那些时髦的技术。我知道这听起来非常恐怖，特别当你已经品尝到 Kotlin 的好处时，不过不要失去生活的信念。</p><p>在文章接下来的部分，我想简短地描述一些 Kotlin 的特征，使你通过一些知名的工具和库，可以应用到你的 Android 里的 Java 代码中去。对于 Kotlin 和 Java 的基本认识是需要的。</p><h3 id=数据类>数据类</h3><p>我想你肯定已经喜欢上 Kotlin 的数据类。对于你来说，得到 <code>equals()</code>、 <code>hashCode()</code>、 <code>toString()</code> 和 <code>copy()</code> 这些是很容易的。具体来说，<code>data</code> 关键字还可以按照声明顺序生成对应于属性的 <code>componentN()</code> 函数。 它们用于解构声明。</p><pre tabindex=0><code>data class Person(val name: String)
val (riddle) = Person(&#34;Peter&#34;)
println(riddle)
</code></pre><p>你知道什么会被打印出来吗？确实，它不会是从 <code>Person</code> 类的 <code>toString()</code> 返回的值。这是解构声明的作用，它赋值从 <code>name</code> 到 <code>riddle</code>。使用园括号 <code>(riddle)</code> 编译器知道它必须使用解构声明机制。</p><pre tabindex=0><code>val (riddle): String = Person(&#34;Peter&#34;).component1()
println(riddle) // prints Peter)
</code></pre><blockquote><p>这个代码没编译。它就是展示了构造声明怎么工作的。</p></blockquote><p>正如你可以看到 <code>data</code> 关键字是一个超级有用的语言特性，所以你能做什么把它带到你的 Java 世界？ 使用注释处理器并修改抽象语法树（Abstract Syntax Tree）。 如果你想更深入，请阅读文章末尾列出的文章（Project Lombok— Trick Explained）。</p><p>使用项目 Lombok 你可以实现 <code>data</code>关键字所提供的几乎相同的功能。 不幸的是，没有办法进行解构声明。</p><pre tabindex=0><code>import lombok.Data;

@Data class Person {
    final String name;
}
</code></pre><p><code>@Data</code> 注解生成 <code>equals()</code>、<code>hashCode()</code> 和 <code>toString()</code>。 此外，它为所有字段创建 getter，为所有非最终字段创建setter，并为所有必填字段（final）创建构造函数。 值得注意的是，Lombok 仅用于编译，因此库代码不会添加到您的最终的 .apk。</p><h3 id=lambda-表达式>Lambda 表达式</h3><p>Android 工程师有一个非常艰难的生活，因为 Android 中缺乏 Java 8 的特性，而且其中之一是 lambda 表达式。 Lambda 是很棒的，因为它们为你减少了成吨的样板。 你可以在回调和流中使用它们。 在 Kotlin 中，lambda 表达式是内置的，它们看起来比它们在 Java 中看起来好多了。 此外，lambda 的字节码可以直接插入到调用方法的字节码中，因此方法计数不会增加。 它可以使用内联函数。</p><pre tabindex=0><code>button.setOnClickListener { println(&#34;Hello World&#34;) }
</code></pre><p>最近 Google 宣布在 Android 中支持 Java 8 的特性，由于 Jack 编译器，你可以在你的代码中使用 lambda。还要提及的是，它们在 API 23 或者更低的级别都可用。</p><pre tabindex=0><code>button.setOnClickListener(view -&gt; System.out.println(&#34;Hello World!&#34;));
</code></pre><p>怎样使用它们？就只用添加下面几行到你的 <code>build.gradle</code> 文件中。</p><pre tabindex=0><code>defaultConfig {
    jackOptions {
        enabled true
    }
}

compileOptions {
    sourceCompatibility JavaVersion.VERSION_1_8
    targetCompatibility JavaVersion.VERSION_1_8
}
</code></pre><p>如果你不喜欢用 Jack 编译器，或者你由于一些原因不能使用它，这里有一个不同的解决方案提供给你。Retrolambda 项目允许你在 Java 7，6 或者 5 上运行带有 lambda 表达式的 Java 8 代码，下面是设置过程。</p><pre tabindex=0><code>dependencies {
    classpath &#39;me.tatarka:gradle-retrolambda:3.4.0&#39;
}

apply plugin: &#39;me.tatarka.retrolambda&#39;

compileOptions {
    sourceCompatibility JavaVersion.VERSION_1_8
    targetCompatibility JavaVersion.VERSION_1_8
}
</code></pre><p>正如我前面提到的，在 Kotlin 下的 lambda 内联函数不增加方法计数，但是如何在 Jack 或者 Retrolambda 下使用它们呢？ 显然，它们不是没成本的，隐藏的成本如下。</p><p><img src=https://img.linux.net.cn/data/attachment/album/201705/08/094725suvvx65mjy56syjr.png alt></p><p><em>该表展示了使用不同版本的 Retrolambda 和 Jack 编译器生成的方法数量。该比较结果来自 Jake Wharton 的“<a href=http://jakewharton.com/exploring-java-hidden-costs/>探索 Java 的隐藏成本</a>” 技术讨论之中。</em></p><h3 id=数据操作>数据操作</h3><p>Kotlin 引入了高阶函数作为流的替代。 当您必须将一组数据转换为另一组数据或过滤集合时，它们非常有用。</p><pre tabindex=0><code>fun foo(persons: MutableList&lt;Person&gt;) {
    persons.filter { it.age &gt;= 21 }
           .filter { it.name.startsWith(&#34;P&#34;) }
           .map { it.name }
           .sorted()
           .forEach(::println)
}

data class Person(val name: String, val age: Int)
</code></pre><p>流也由 Google 通过 Jack 编译器提供。 不幸的是，Jack 不使用 Lombok，因为它在编译代码时跳过生成中间的 <code>.class</code> 文件，而 Lombok 却依赖于这些文件。</p><pre tabindex=0><code>void foo(List&lt;Person&gt; persons) {
    persons.stream()
           .filter(it -&gt; it.getAge() &gt;= 21)
           .filter(it -&gt; it.getName().startsWith(&#34;P&#34;))
           .map(Person::getName)
           .sorted()
           .forEach(System.out::println);
}

class Person {
    final private String name;
    final private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    String getName() { return name; }
    int getAge() { return age; }
}
</code></pre><p>这简直太好了，所以 catch 在哪里？ 令人悲伤的是，流从 API 24 才可用。谷歌做了好事，但哪个应用程序有用 <code>minSdkVersion = 24</code>？</p><p>幸运的是，Android 平台有一个很好的提供许多很棒的库的开源社区。Lightweight-Stream-API 就是其中的一个，它包含了 Java 7 及以下版本的基于迭代器的流实现。</p><pre tabindex=0><code>import lombok.Data;
import com.annimon.stream.Stream;

void foo(List&lt;Person&gt; persons) {
    Stream.of(persons)
          .filter(it -&gt; it.getAge() &gt;= 21)
          .filter(it -&gt; it.getName().startsWith(&#34;P&#34;))
          .map(Person::getName)
          .sorted()
          .forEach(System.out::println);
}

@Data class Person {
    final String name;
    final int age;
}
</code></pre><p>上面的例子结合了 Lombok、Retrolambda 和 Lightweight-Stream-API，它看起来几乎和 Kotlin 一样棒。使用静态工厂方法允许您将任何 Iterable 转换为流，并对其应用 lambda，就像 Java 8 流一样。 将静态调用 <code>Stream.of(persons)</code> 包装为 Iterable 类型的扩展函数是完美的，但是 Java 不支持它。</p><h3 id=扩展函数>扩展函数</h3><p>扩展机制提供了向类添加功能而无需继承它的能力。 这个众所周知的概念非常适合 Android 世界，这就是 Kotlin 在该社区很受欢迎的原因。</p><p>有没有技术或魔术将扩展功能添加到你的 Java 工具箱？ 因 Lombok，你可以使用它们作为一个实验功能。 根据 Lombok 文档的说明，他们想把它从实验状态移出，基本上没有什么变化的话很快。 让我们重构最后一个例子，并将 <code>Stream.of(persons)</code> 包装成扩展函数。</p><pre tabindex=0><code>import lombok.Data;
import lombok.experimental.ExtensionMethod;

@ExtensionMethod(Streams.class)
public class Foo {
    void foo(List&lt;Person&gt; persons) {
        persons.toStream()
               .filter(it -&gt; it.getAge() &gt;= 21)
               .filter(it -&gt; it.getName().startsWith(&#34;P&#34;))
               .map(Person::getName)
               .sorted()
               .forEach(System.out::println);
    }
}

@Data class Person {
    final String name;
    final int age;
}

class Streams {
    static &lt;T&gt; Stream&lt;T&gt; toStream(List&lt;T&gt; list) {
        return Stream.of(list);
    }
}
</code></pre><p>所有的方法是 <code>public</code>、<code>static</code> 的，并且至少有一个参数的类型不是原始的，因而是扩展方法。 <code>@ExtensionMethod</code> 注解允许你指定一个包含你的扩展函数的类。 你也可以传递数组，而不是使用一个 <code>.class</code> 对象。</p><hr><p>我完全知道我的一些想法是非常有争议的，特别是 Lombok，我也知道，有很多的库，可以使你的生活更轻松。请不要犹豫在评论里分享你的经验。干杯!</p><p><img src=https://img.linux.net.cn/data/attachment/album/201705/08/094739s1r09y11ig088s9n.png alt></p><hr><p>作者简介：</p><p>Coder and professional dreamer @ Grid Dynamics</p><hr><p>via: <a href=https://medium.com/proandroiddev/living-android-without-kotlin-db7391a2b170>https://medium.com/proandroiddev/living-android-without-kotlin-db7391a2b170</a></p><p>作者：<a href="https://hackernoon.com/@piotr.slesarew?source=post_header_lockup">Piotr Ślesarew</a> 译者：<a href=https://github.com/DockerChen>DockerChen</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/android/ rel=tag>Android</a></li><li class=tags__item><a class="tags__link btn" href=/tags/kotlin/ rel=tag>Kotlin</a></li><li class=tags__item><a class="tags__link btn" href=/tags/java/ rel=tag>java</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>