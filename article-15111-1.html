<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Java 无服务器函数入门 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="Java 无服务器函数入门"><meta property="og:description" content="Quarkus 令你可以使用类似 Java 的技术开发无服务器的工作负载。"><meta property="og:type" content="article"><meta property="og:url" content="/article-15111-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-10-06T15:47:35+00:00"><meta property="article:modified_time" content="2022-10-06T15:47:35+00:00"><meta itemprop=name content="Java 无服务器函数入门"><meta itemprop=description content="Quarkus 令你可以使用类似 Java 的技术开发无服务器的工作负载。"><meta itemprop=datePublished content="2022-10-06T15:47:35+00:00"><meta itemprop=dateModified content="2022-10-06T15:47:35+00:00"><meta itemprop=wordCount content="407"><meta itemprop=keywords content="Quarkus,无服务器,Java,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>Java 无服务器函数入门</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2022-10-06T15:47:35Z>October 06, 2022</time></div></div></header><div class="content post__content clearfix"><p><img src=/data/attachment/album/202210/06/154731xejvfcai8e0auimh.jpg alt></p><blockquote><p>Quarkus 令你可以使用类似 Java 的技术开发无服务器的工作负载。</p></blockquote><p>对 <a href=/article-13429-1.html>无服务器 Java</a> 的研究始于函数 —— 就是按需求运行的一小段代码。这一阶段并没有持续很长时间。虽然在 1.0 阶段，基于虚拟机架构的函数使这种范式变得很流行，但它仍然有局限性，例如执行时间、协议和糟糕的本地开发体验，都不太理想，如下图所示。</p><p>开发者随后意识到，可以把同样的无服务器特性应用于微服务和 Linux 容器，带来的好处也是一样的。由此进入 1.5 阶段，在这个阶段，一些无服务器容器完全抽象化了 <a href=https://opensource.com/article/19/6/reasons-kubernetes>Kubernetes</a>，通过 <a href=https://cloud.google.com/knative/>Knative</a> 或其它位于它之上的抽象层来提供无服务器的体验。</p><p>在 2.0 阶段，无服务器开始处理更复杂的编排和集成模式，并结合某些层级的状态管理。更重要的是，开发者关注的是能否在旧的系统中使用熟悉的 Java 应用程序运行时来组合运行无服务器和非无服务器的工作负载。</p><p><img src=/data/attachment/album/202210/06/154735b3ijlvyoti4saapv.png alt="The serverless Java journey"></p><p>Java 开发者开始进行无服务器函数开发之前，第一步是要选择一种新的云原生 Java 框架，从而能够以快于传统单体应用程序的速度和较小的内存占用运行 Java 函数。这在各种基础设施环境中，包括物理服务器、虚拟机、多云或混合云环境中的容器，都是适用的。</p><p>开发者也有可能固执地选择 Spring 框架中的 <a href=https://spring.io/serverless>Spring 云函数</a> 来进行命令式和反应式函数的开发。Spring 也支持将 Java 函数部署到可安装的无服务器平台，比如 <a href=https://kubeless.io/>Kubeless</a>、<a href=https://openwhisk.apache.org/>Apache OpenWhisk</a>、<a href=https://fission.io/>Fission</a> 和 <a href=https://projectriff.io/>Project Riff</a>。然而，人们担心 Spring 的启动慢、响应时间长以及内存占用大的问题。在诸如 Kubernetes 这种可扩展的容器环境中运行 Java 函数，这些问题可能会更严重。</p><p><a href=https://quarkus.io/>Quarkus</a> 是一个新推出的开源云原生 Java 框架，它有助于解决这些问题。它的作用是设计无服务器应用程序，以及编写运行于云基础设施（例如 Kubernetes）的云原生微服务。</p><p>Quarkus 重新审视了 Java，它使用了封闭的方法构建和运行 Java 程序。它把 Java 转变为一种可与 Go 相媲美的运行时。Quarkus 也包含 100 多种扩展功能，集成了企业级能力，例如数据库访问、无服务器集成、消息、安全、可观察性和业务自动化。</p><p>这里有一个简单例子，展现如何使用 Quarkus 创建一个 Java 无服务器项目的框架。</p><h3 id=1基于-maven-创建一个-quarkus-无服务器项目>1、基于 Maven 创建一个 Quarkus 无服务器项目</h3><p>安装一个本地 Kubernetes 集群，开发者有多种选择，包括 <a href=https://minikube.sigs.k8s.io/docs/start/>Minikube</a> 和 <a href=https://docs.okd.io/latest/welcome/index.html>OKD</a>。因为使用 OKD 在 Knative 和 DevOps 工具上安装无服务器相关功能较方便，本文使用 OKD 安装集群。这些关于 <a href=https://docs.okd.io/latest/installing/index.html>OKD 安装</a> 和 <a href=https://knative.dev/docs/install/knative-with-operators/>Knative 操作员安装</a> 的相关指南中提供了更多的设置资料。</p><p>下面的命令创建了一个 Quarkus 项目（例如 <code>quarkus-serverless-restapi</code>），对外暴露一个简单的 REST API，并下载 <code>quarkus-openshift</code> 扩展，用于 Knative 服务的部署：</p><pre tabindex=0><code>$ mvn io.quarkus:quarkus-maven-plugin:1.13.4.Final:create \
       -DprojectGroupId=org.acme \
       -DprojectArtifactId=quarkus-serverless-restapi \
       -Dextensions=&#34;openshift&#34; \
       -DclassName=&#34;org.acme.getting.started.GreetingResource&#34;
</code></pre><h3 id=2在本地运行无服务器功能>2、在本地运行无服务器功能</h3><p>使用 Quarkus 开发模式运行程序，检查 REST API 是否有效，稍稍调整一下代码：</p><pre tabindex=0><code>$ ./mvnw quarkus:dev
</code></pre><p>输出如下内容：</p><pre tabindex=0><code>__  ____  __  _____   ___  __ ____  ______ 
 --/ __ \/ / / / _ | / _ \/ //_/ / / / __/ 
 -/ /_/ / /_/ / __ |/ , _/ ,&lt; / /_/ /\ \   
--\___\_\____/_/ |_/_/|_/_/|_|\____/___/   
INFO  [io.quarkus] (Quarkus Main Thread) quarkus-serverless-restapi 1.0.0-SNAPSHOT on JVM (powered by Quarkus xx.xx.xx.) started in 2.386s. Listening on: http://localhost:8080
INFO  [io.quarkus] (Quarkus Main Thread) Profile dev activated. Live Coding activated.
INFO  [io.quarkus] (Quarkus Main Thread) Installed features: [cdi, kubernetes, resteasy]
</code></pre><blockquote><p><strong>注意</strong>: 保持 Quarkus 应用程序运行，需要使用 热部署 Live Coding 。这样，当代码修改后，你就不必重新构建、重新部署以及重启运行时。</p></blockquote><p>现在，你可以使用一个 <code>curl</code> 命令快速访问 REST API。输出结果应当是 <code>Hello RESTEasy</code>:</p><pre tabindex=0><code>$ curl localhost:8080/hello
Hello RESTEasy
</code></pre><p>在 <code>GreetingResource.java</code> 中修改返回值：</p><pre tabindex=0><code>public String hello() {
        return &#34;Quarkus Function on Kubernetes&#34;;
    }
</code></pre><p>再次访问 REST API，输出信息也会相应更新：</p><pre tabindex=0><code>$ curl localhost:8080/hello
Quarkus Function on Kubernetes
</code></pre><p>普通的微服务跟无服务器函数之间的差别并不大。使用 Quarkus 的好处在于：开发者可以使用任何微服务，将 Kubernetes 部署为无服务器函数。</p><h3 id=3在-knative-服务中部署相关的函数>3、在 Knative 服务中部署相关的函数</h3><p>如果你还没有创建命名空间，就在你的 OKD 集群上 <a href=https://docs.okd.io/latest/applications/projects/configuring-project-creation.html>创建命名空间</a>（例如 <code>quarkus-serverless-restapi</code>），用来部署 Java 无服务器函数。</p><p>Quarkus 令开发者可以通过在 <code>src/main/resources/application.properties</code> 中添加以下变量，创建 Knative 和 Kubernetes 资源：</p><pre tabindex=0><code>quarkus.container-image.group=quarkus-serverless-restapi &lt;1&gt;
quarkus.container-image.registry=image-registry.openshift-image-registry.svc:5000 &lt;2&gt;
quarkus.kubernetes-client.trust-certs=true &lt;3&gt;
quarkus.kubernetes.deployment-target=knative &lt;4&gt;
quarkus.kubernetes.deploy=true &lt;5&gt;
quarkus.openshift.build-strategy=docker &lt;6&gt;
</code></pre><p>说明:</p><ul><li>&lt;1> 在你部署无服务器应用程序的位置定义项目名</li><li>&lt;2> 使用容器注册中心</li><li>&lt;3> 在这个简单例子中，使用自签名证书，以便通过相关信任机制</li><li>&lt;4> 允许创建 Knative 资源</li><li>&lt;5> 指示在构建容器映像之后将扩展部署到 OpenShift</li><li>&lt;6> 设置 Docker 构建策略</li></ul><p>执行以下命令，构建应用程序，并直接部署到 OKD 集群：</p><pre tabindex=0><code>$ ./mvnw clean package -DskipTests
</code></pre><blockquote><p><strong>注意:</strong> 应该提前使用 <code>oc login</code> 命令，确保登录到正确的项目（例如<code>quarkus-serverless-restapi</code>）。</p></blockquote><p>输出结果应该以 <code>BUILD SUCCESS</code> 结束。</p><p>在对于 Knative 服务执行的 <code>oc</code> 命令中，加上标签:</p><pre tabindex=0><code>$ oc label rev/quarkus-serverless-restapi-00001 
app.openshift.io/runtime=quarkus --overwrite
</code></pre><p>然后访问 OKD 网页控制台，就能进入 <a href=https://docs.okd.io/latest/applications/application_life_cycle_management/odc-viewing-application-composition-using-topology-view.html>开发人员透视图中的拓扑视图</a>。你可能会看到你的 容器荚 Pod （无服务器函数）已经缩小为零（白线圈）。</p><p><img src=/data/attachment/album/202210/06/154735bjs1llcol5uccjlu.png alt="Topology view"></p><h3 id=4在-kubernetes-环境下测试函数>4、在 Kubernetes 环境下测试函数</h3><p>运行如下 <code>oc</code> 命令，搜索含有无服务器函数的路由：</p><pre tabindex=0><code>$ oc get rt/quarkus-serverless-restapi
[...]
NAME                      URL                             READY   REASON
quarkus-serverless[...]   http://quarkus[...].SUBDOMAIN   True
</code></pre><p>使用 <code>curl</code> 命令访问搜索到的路由：</p><pre tabindex=0><code>$ curl http://quarkus-serverless-restapi-quarkus-serverless-restapi.SUBDOMAIN/hello
</code></pre><p>过几秒钟，你可以得到跟在本地相同的结果：</p><pre tabindex=0><code>Quarkus Function on Kubernetes
</code></pre><p>当你回到 OKD 集群内的拓扑图，Knative 服务会自动扩展。</p><p><img src=/data/attachment/album/202210/06/154736cez3z383x33zg3x3.png alt="Scaling the Knative Function"></p><p>由于 Knative 服务的默认设置，其 pod 在 30 秒后会再次下降至零。</p><h3 id=下一步呢>下一步呢？</h3><p>无服务器不断地在演变，始于运行于虚拟机的函数，到后来的无服务器容器，并与企业原有系统集成。在此过程中，企业开发者借助 Quarkus，仍然可以使用自己熟悉的技术（比如 Java）创建一个项目，然后构建并部署到 Kubernetes。</p><p>本系列的下一篇文章将指导你优化 Kubernetes 中的 Java 无服务器函数，从而令程序启动更快，内存占用更小。</p><p><em>文内图像来自：Daniel Oh, CC BY-SA 4.0</em></p><hr><p>via: <a href=https://opensource.com/article/21/6/java-serverless-functions>https://opensource.com/article/21/6/java-serverless-functions</a></p><p>作者：<a href=https://opensource.com/users/daniel-oh>Daniel Oh</a> 选题：<a href=https://github.com/lkxed>lkxed</a> 译者：<a href=https://github.com/cool-summer-021>cool-summer-021</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/quarkus/ rel=tag>Quarkus</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E6%97%A0%E6%9C%8D%E5%8A%A1%E5%99%A8/ rel=tag>无服务器</a></li><li class=tags__item><a class="tags__link btn" href=/tags/java/ rel=tag>Java</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>