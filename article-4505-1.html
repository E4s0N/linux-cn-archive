<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>systemd的运行级别与服务管理命令简介 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="systemd的运行级别与服务管理命令简介"><meta property="og:description" content="从很久很久以前我们就在使用静态运行级别。而systemd提供了更为动态灵活的机制，来管控你的系统。 在开始介绍systemd命令前，让我们先简单的回顾一下历史。在Linux世界里，有一个很奇怪的现象，一方面Linux和自由软件（FOSS）在不断的向前推进，另一方面人们对这些变化却不断的抱怨。这就是为什么我要在此稍稍提及那些反对systemd所引起的争论的原因，因为我依然记得历史上有不少类似的争论：  软件包（Pacakge）是邪恶的，因为真正的Linux用户会从源码构建他所想要的的一切，并严格的管理系统中安装的软件。 解析依赖关系的包管理器是邪"><meta property="og:type" content="article"><meta property="og:url" content="/article-4505-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2014-12-23T09:35:00+00:00"><meta property="article:modified_time" content="2014-12-23T09:35:00+00:00"><meta itemprop=name content="systemd的运行级别与服务管理命令简介"><meta itemprop=description content="从很久很久以前我们就在使用静态运行级别。而systemd提供了更为动态灵活的机制，来管控你的系统。 在开始介绍systemd命令前，让我们先简单的回顾一下历史。在Linux世界里，有一个很奇怪的现象，一方面Linux和自由软件（FOSS）在不断的向前推进，另一方面人们对这些变化却不断的抱怨。这就是为什么我要在此稍稍提及那些反对systemd所引起的争论的原因，因为我依然记得历史上有不少类似的争论：  软件包（Pacakge）是邪恶的，因为真正的Linux用户会从源码构建他所想要的的一切，并严格的管理系统中安装的软件。 解析依赖关系的包管理器是邪"><meta itemprop=datePublished content="2014-12-23T09:35:00+00:00"><meta itemprop=dateModified content="2014-12-23T09:35:00+00:00"><meta itemprop=wordCount content="175"><meta itemprop=keywords content="systemd,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>systemd的运行级别与服务管理命令简介</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-12-23T09:35:00Z>December 23, 2014</time></div></div></header><div class="content post__content clearfix"><p><img src=/data/attachment/album/201412/23/121925qvuuuzd9t4udjuvo.png alt></p><p>从很久很久以前我们就在使用静态运行级别。而systemd提供了更为动态灵活的机制，来管控你的系统。</p><p>在开始介绍systemd命令前，让我们先简单的回顾一下历史。在Linux世界里，有一个很奇怪的现象，一方面Linux和自由软件（FOSS）在不断的向前推进，另一方面人们对这些变化却不断的抱怨。这就是为什么我要在此稍稍提及那些反对systemd所引起的争论的原因，因为我依然记得历史上有不少类似的争论：</p><ul><li>软件包（Pacakge）是邪恶的，因为真正的Linux用户会从源码构建他所想要的的一切，并严格的管理系统中安装的软件。</li><li>解析依赖关系的包管理器是邪恶的，真正的Linux用户会手动解决这些该死的依赖关系。</li><li>apt-get总能把事情干好，所以只有Yum是邪恶的。</li><li>Red Hat简直就是Linux中的微软。</li><li>好样的，Ubuntu！</li><li>滚蛋吧，Ubuntu！</li></ul><p>诸如此类&mldr;就像我之前常常说的一样，变化总是让人沮丧。这些该死的变化搅乱了我的工作流程，这可不是一件小事情，任何业务流程的中断，都会直接影响到生产力。但是，我们现在还处于计算机发展的婴儿期，在未来的很长的一段时间内将会持续有快速的变化和发展。想必大家应该都认识一些因循守旧的人，在他们的心里，商品一旦买回家以后就是恒久不变的，就像是买了一把扳手、一套家具或是一个粉红色的火烈鸟草坪装饰品。就是这些人，仍然在坚持使用Windows Vista，甚至还有人在使用运行Windows 95的老破烂机器和CRT显示器。他们不能理解为什么要去换一台新机器。老的还能用啊，不是么？</p><p>这让我回忆起了我在维护老电脑上的一项伟大的成就，那台破电脑真的早就该淘汰掉。从前我有个朋友有一台286的老机器，安装了一个极其老的MS-DOS版本。她使用这台电脑来处理一些简单的任务，比如说约会、日记、记账等，我还用BASIC给她写了一个简单的记账软件。她不用关注任何安全更新，是这样么？因为它压根都没有联网。所以我会时不时给她维修一下电脑，更换电阻、电容、电源或者是CMOS电池什么的。它竟然还一直能用。它那袖珍的琥珀CRT显示器变得越来越暗，在使用了20多年后，终于退出了历史舞台。现在我的这位朋友，换了一台运行Linux的老Thinkpad，来干同样的活。</p><p>前面的话题有点偏题了，下面抓紧时间开始介绍systemd。</p><h3 id=运行级别-vs-状态>运行级别 vs. 状态</h3><p>SysVInit使用静态的运行级别来构建不同的启动状态，大部分发布版本中提供了以下5个运行级别：</p><ul><li>单用户模式（Single-user mode）</li><li>多用户模式，不启动网络服务（Multi-user mode without network services started）</li><li>多用户模式，启动网络服务（Multi-user mode with network services started）</li><li>系统关机（System shutdown）</li><li>系统重启（System reboot）</li></ul><p>对于我来说，使用多个运行级别并没有太大的好处，但它们却一直在系统中存在着。 不同于运行级别，systemd可以创建不同的状态，状态提供了灵活的机制来设置启动时的配置项。这些状态是由多个unit文件组成的，状态又叫做启动目标（target）。启动目标有一个清晰的描述性命名，而不是像运行级别那样使用数字。unit文件可以控制服务、设备、套接字和挂载点。参考下/usr/lib/systemd/system/graphical.target，这是CentOS 7默认的启动目标：</p><pre tabindex=0><code>[Unit]
Description=Graphical Interface
Documentation=man:systemd.special(7)
Requires=multi-user.target
After=multi-user.target
Conflicts=rescue.target
Wants=display-manager.service
AllowIsolate=yes
[Install]
Alias=default.target
</code></pre><p>现在再看看unit文件长什么样？ 我来给大家找个例子。 unit文件存放在下面的两个目录下：</p><ul><li>/etc/systemd/system/</li><li>/usr/lib/systemd/system/</li></ul><p>我们可以修改第一个目录中的文件来进行自定义配置，而第二个目录中的文件是包安装时保存的备份。<strong>/etc/systemd/system/<strong>的优先级高于</strong>/usr/lib/systemd/system/</strong>。不错，用户优先级高于机器。下面是Apache Web server的unit文件：</p><pre tabindex=0><code>[Unit]
Description=The Apache HTTP Server
After=network.target remote-fs.target nss-lookup.target
[Service]
Type=notify
EnvironmentFile=/etc/sysconfig/httpd
ExecStart=/usr/sbin/httpd/ $OPTIONS -DFOREGROUND
ExecReload=/usr/sbin/httpd $OPTIONS -k graceful
ExecStop=/bin/kill -WINCH ${MAINPID}
KillSignal=SIGCONT
PrivateTmp=true
[Install]
WantedBy=multi.user.target
</code></pre><p>就算是对于新手而言，上面的文件也是非常简单易懂的。这可比SysVInit的init文件要简单多了，为了便于比较，下面截取了/etc/init.d/apache2的一个片段：</p><pre tabindex=0><code>SCRIPTNAME=&#34;${0##*/}&#34;
SCRIPTNAME=&#34;${SCRIPTNAME##[KS][0-9][0-9]}&#34;
if [ -n &#34;$APACHE_CONFDIR&#34; ] ; then
    if [ &#34;${APACHE_CONFDIR##/etc/apache2-}&#34; != &#34;${APACHE_CONFDIR}&#34; ] ; then
            DIR_SUFFIX=&#34;${APACHE_CONFDIR##/etc/apache2-}&#34;
    else
            DIR_SUFFIX=
</code></pre><p>整个文件一共有410行。</p><p>你可以检查unit文件的依赖关系，我常常被这些复杂的依赖关系给吓到：</p><pre tabindex=0><code>$ systemctl list-dependencies httpd.service
</code></pre><h3 id=cgroups>cgroups</h3><p>cgroups，或者叫控制组，在Linux内核里已经出现好几年了，但直到systemd的出现才被真正使用起来。<a href=https://www.kernel.org/doc/Documentation/cgroups/cgroups.txt>The kernel documentation</a>中是这样描述cgroups的：“控制组提供层次化的机制来管理任务组，使用它可以聚合和拆分任务组，并管理任务组后续产生的子任务。”换句话说，它提供了多种有效的方式来控制、限制和分配资源。systemd使用了cgroups，你可以便捷的查看它，使用下面的命令可以展示你系统中的整个cgroup树：</p><pre tabindex=0><code>$ systemd-cgls
</code></pre><p>你可以使用ps命令来进行查看cgroup树：</p><pre tabindex=0><code>$ ps xawf -eo pid,user,cgroup,args
</code></pre><h3 id=常用命令集>常用命令集</h3><p>下面的命令行展示了如何为守护进程重新装载配置文件，注意不是systemd服务文件。 使用这个命令能够激活新的配置项，且尽可能少的打断业务进程，下面以Apache为例：</p><pre tabindex=0><code># systemctl reload httpd.service
</code></pre><p>重新装载服务文件（service file）需要完全停止和重新启动服务。如果服务挂死了，用下面的命令行可以恢复它：</p><pre tabindex=0><code># systemctl restart httpd.service
</code></pre><p>你还可以用一个命令重启所有的守护进程。这个命令会重新装载所有守护进程的unit文件，然后重新生成依赖关系树：</p><pre tabindex=0><code># systemctl daemon-reload
</code></pre><p>在非特权模式下，你也可以进行重启、挂起、关机操作：</p><pre tabindex=0><code>$ systemctl reboot
$ systemctl suspend
$ systemctl poweroff
</code></pre><p>按照惯例，最后给大家介绍一些systemd的学习材料。<a href=http://www.linux.com/learn/tutorials/524577-here-we-go-again-another-linux-init-intro-to-systemd>Here We Go Again, Another Linux Init: Intro to systemd</a> 和 <a href=http://www.linux.com/learn/tutorials/788613-understanding-and-using-systemd>Understanding and Using Systemd</a> 是不错的入门材料，这两份文档里会链接到更多其他资源。</p><hr><p>via: <a href=http://www.linux.com/learn/tutorials/794615-systemd-runlevels-and-service-management>http://www.linux.com/learn/tutorials/794615-systemd-runlevels-and-service-management</a></p><p>作者：<a href=http://www.linux.com/community/forums/person/3734>Carla Schroder</a> 译者：<a href=https://github.com/coloka>coloka</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创翻译，<a href=http://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/systemd/ rel=tag>systemd</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>