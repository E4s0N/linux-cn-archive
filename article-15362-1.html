<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>GDB 的 7 个单步调试命令 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="GDB 的 7 个单步调试命令"><meta property="og:description" content="即使是复杂的函数，也有几种方法可以单步调试，所以下次在排除代码故障时，可以尝试一下这些 GDB 技术。"><meta property="og:type" content="article"><meta property="og:url" content="/article-15362-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-12-19T09:38:32+00:00"><meta property="article:modified_time" content="2022-12-19T09:38:32+00:00"><meta itemprop=name content="GDB 的 7 个单步调试命令"><meta itemprop=description content="即使是复杂的函数，也有几种方法可以单步调试，所以下次在排除代码故障时，可以尝试一下这些 GDB 技术。"><meta itemprop=datePublished content="2022-12-19T09:38:32+00:00"><meta itemprop=dateModified content="2022-12-19T09:38:32+00:00"><meta itemprop=wordCount content="718"><meta itemprop=keywords content="GDB,调试,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>GDB 的 7 个单步调试命令</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2022-12-19T09:38:32Z>December 19, 2022</time></div></div></header><div class="content post__content clearfix"><p><img src=/data/attachment/album/202212/19/093831nrjrmozx1mixmgii.jpg alt></p><blockquote><p>即使是复杂的函数，也有几种方法可以单步调试，所以下次在排除代码故障时，可以尝试一下这些 GDB 技术。</p></blockquote><p><strong>调试器</strong> 是一个可以运行你的代码并检查问题的软件。<a href=https://opensource.com/article/21/3/debug-code-gdb>GNU Debugger</a>（GBD）是最流行的调试器之一，在这篇文章中，我研究了 GDB 的 <code>step</code> 命令和其他几种常见情况的相关命令。<code>step</code> 是一个被广泛使用的命令，但它有一些人们不太了解的地方，可能会使得他们十分困惑。此外，还有一些方法可以<strong>在不使用 <code>step</code> 命令的情况下进入一个函数</strong>，比如使用不太知名的 <code>advance</code> 命令。</p><h3 id=1无调试符号>1、无调试符号</h3><p>考虑以下这个简单的示例程序：</p><pre tabindex=0><code>#include &lt;stdio.h&gt;


int num() {
    return 2;
}

void bar(int i) {
    printf(&#34;i = %d\n&#34;, i);
}


int main() {
    bar(num());
    return 0;
}
</code></pre><p>如果你在没有 调试符号 debugging sysbols 的情况下进行编译（LCTT 译注：即在使用 <code>gcc</code> 编译程序时没有写 <code>-g</code> 选项），然后在 <code>bar</code> 上设置一个断点，然后尝试在这个函数内使用 <code>step</code> 来单步执行语句。GDB 会给出一个 没有行号信息 no line number information 的错误信息。</p><pre tabindex=0><code>gcc exmp.c -o exmp
gdb ./exmp
(gdb) b bar
Breakpoint 1 at 0x401135
(gdb) r
Starting program: /home/ahajkova/exmp
Breakpoint 1, 0x0000000000401135 in bar ()
(gdb) step
Single stepping until exit from function bar,
which has no line number information.
i = 2
0x0000000000401168 in main ()
</code></pre><h3 id=2stepi-命令>2、stepi 命令</h3><p>但是你仍然可以在没有行号信息的函数内部单步执行语句，但要使用 <code>stepi</code> 命令来代替 <code>step</code>。<code>stepi</code> 一次只执行一条指令。当使用 GDB 的 <code>stepi</code> 命令时，先做 <code>display/i $pc</code> 通常很有用，这会在每一步之后<strong>显示</strong> 程序计数器 program counter 的值和<strong>相应的</strong> 机器指令 machine instruction ：</p><pre tabindex=0><code>(gdb) b bar
Breakpoint 1 at 0x401135
(gdb) r
Starting program: /home/ahajkova/exmp
Breakpoint 1, 0x0000000000401135 in bar ()
(gdb) display/i $pc
1: x/i $pc
=&gt; 0x401135 &lt;bar+4&gt;: sub $0x10,%rsp
</code></pre><p>在上述的 <code>display</code> 命令中，<code>i</code> 代表机器指令，<code>$pc</code> 表示程序计数器寄存器（即 PC 寄存器）。</p><p>使用 <code>info registers</code> 命令，来<strong>打印寄存器的内容</strong>，也是十分有用的。</p><pre tabindex=0><code>(gdb) info registers
rax 0x2 2
rbx 0x7fffffffdbc8 140737488346056
rcx 0x403e18 4210200
(gdb) print $rax
$1 = 2
(gdb) stepi
0x0000000000401139 in bar ()
1: x/i $pc
=&gt; 0x401139 &lt;bar+8&gt;: mov %edi,-0x4(%rbp)
</code></pre><h3 id=3复杂的函数调用>3、复杂的函数调用</h3><p>在带调试符号的 <code>-g</code> 选项，重新编译示例程序后，你可以使用行号在 <code>main</code> 中 <code>bar</code> 调用上设置断点，然后再单步执行 <code>bar</code> 函数的语句：</p><pre tabindex=0><code>gcc -g exmp.c -o exmp
gdb ./exmp
(gdb) b exmp.c:14
Breakpoint 1 at 0x401157: file exmp.c, line 14.
(gdb) r
Starting program: /home/ahajkova/exmp
Breakpoint 1, main () at exmp.c:14
14 bar(num());
</code></pre><p>接下来，用 <code>step</code>，来单步执行 <code>bar()</code> 函数的语句：</p><pre tabindex=0><code>(gdb) step
num () at exmp.c:4
4 return 2;
</code></pre><p>函数调用的参数需要在实际的函数调用之前进行处理，<code>bar()</code> 函数的参数是 <code>num()</code> 函数，所以 <code>num()</code> 会在 <code>bar()</code> 被调用之前执行。但是，通过 GDB 调试，你怎么才能如愿以偿地进入 <code>bar()</code> 函数呢？你可以使用 <code>finish</code> 命令，并再次使用 <code>step</code> 命令。</p><pre tabindex=0><code>(gdb) finish
Run till exit from #0 num () at exmp.c:4
0x0000000000401161 in main () at exmp.c:14
14 bar(num());
Value returned is $1 = 2
(gdb) step
bar (i=2) at exmp.c:9
9 printf(&#34;i = %d\n&#34;, i);
</code></pre><h3 id=4tbreak-命令>4、tbreak 命令</h3><p><code>tbreak</code> 命令会设置一个<strong>临时断点</strong>。如果你不想设置永久断点，那么这个命令是很有用的。举个例子?，你想进入一个复杂的函数调用，例如 <code>f(g(h()), i(j()), ...)</code>，在这种情况下，你需要一个很长的 <code>step/finish/step</code> 序列，才能到达 <code>f</code> 函数。如果你设置一个临时断点，然后再使用 <code>continue</code> 命令，这样就不需要以上的序列了。为了证明这一点，你需要像以前一样将断点设置在 <code>main</code> 的 <code>bar</code> 调用上。然后在 <code>bar</code> 上设置临时断点。当到达该临时断点后，临时断点会被自动删除。</p><pre tabindex=0><code>(gdb) r
Starting program: /home/ahajkova/exmp
Breakpoint 1, main () at exmp.c:14
14 bar(num());
(gdb) tbreak bar
Temporary breakpoint 2 at 0x40113c: file exmp.c, line 9.
</code></pre><p>在调用 <code>bar</code> 的时候遇到断点，并在 <code>bar</code> 上设置临时断点后，你只需要使用 <code>continue</code> 继续运行直到 <code>bar</code> 结束。</p><pre tabindex=0><code>(gdb) continue
Continuing.
Temporary breakpoint 2, bar (i=2) at exmp.c:9
9 printf(&#34;i = %d\n&#34;, i);
</code></pre><h3 id=5disable-命令>5、disable 命令</h3><p>类似地，你也可以在 <code>bar</code> 上设置一个正常的断点，然后执行 <code>continue</code>，然后在不再需要第二个断点时，使用 <code>disable</code> 命令禁用这个断点，这样也能达到与 <code>tbreak</code> 相同的效果。</p><pre tabindex=0><code>(gdb) b exmp.c:14
Breakpoint 1 at 0x401157: file exmp.c, line 14.
(gdb) r
Starting program: /home/ahajkova/exmp
Breakpoint 1, main () at exmp.c:14
14 bar(num());
(gdb) b bar
Breakpoint 2 at 0x40113c: file exmp.c, line 9.
(gdb) c
Continuing.
Breakpoint 2, bar (i=2) at exmp.c:9
9 printf(&#34;i = %d\n&#34;, i);
(gdb) disable 2
</code></pre><p>正如你所看到的，<code>info breakpoints</code> 命令在 <code>Enb</code> 列下显示为 <code>n</code>，这意味着这个断点已被禁用。但你也能在再次需要这个断点时，再启用它。</p><pre tabindex=0><code>(gdb) info breakpoints
Num Type Disp Enb Address What
1 breakpoint keep y 0x0000000000401157 in main at exmp.c:14
breakpoint already hit 1 time
2 breakpoint keep n 0x000000000040113c in bar at exmp.c:9
breakpoint already hit 1 time
(gdb) enable 2
(gdb) info breakpoints
Num Type Disp Enb Address What
1 breakpoint keep y 0x000000000040116a in main at exmp.c:19
breakpoint already hit 1 time
2 breakpoint keep y 0x0000000000401158 in bar at exmp.c:14
breakpoint already hit 1 time
</code></pre><h3 id=6advance-命令运行程序到指定的位置>6、advance 命令运行程序到指定的位置</h3><p>另一个进入函数内部的方法是 <code>advance</code> 命令。你可以简单地用 <code>advance bar</code>，来代替 <code>tbreak bar ; continue</code>。这一命令会将程序继续运行到指定的位置。</p><p><code>advance</code> 命令的一个很棒的地方在于：如果程序并没有到达你试图进入的位置，那么 GDB 将在当前函数运行完成后停止。因此，程序的执行会受到限制：</p><pre tabindex=0><code>Breakpoint 1 at 0x401157: file exmp.c, line 14.
(gdb) r
Starting program: /home/ahajkova/exmp
Breakpoint 1, main () at exmp.c:14
14 bar(num());
(gdb) advance bar
bar (i=2) at exmp.c:9
9 printf(&#34;i = %d\n&#34;, i);
</code></pre><h3 id=7skip-命令>7、skip 命令</h3><p>进入 <code>bar</code> 函数的另一种方式是使用 <code>skip num</code> 命令：</p><pre tabindex=0><code>(gdb) b exmp.c:14
Breakpoint 1 at 0x401157: file exmp.c, line 14.
(gdb) skip num
Function num will be skipped when stepping.
(gdb) r
Starting program: /home/ahajkova/exmp
Breakpoint 1, main () at exmp.c:14
14 bar(num());
(gdb) step
bar (i=2) at exmp.c:9
9 printf(&#34;i = %d\n&#34;, i);
</code></pre><p>请使用 <code>info skip</code> 命令，来了解 GDB 跳过了哪些函数。<code>num()</code> 函数被标记为 <code>y</code>，表示跳过了 <code>num()</code> 函数：</p><pre tabindex=0><code>(gdb) info skip
Num Enb Glob File RE Function
1 y n &lt;none&gt; n num
</code></pre><p>如果不再需要 <code>skip</code>，可以禁用（并稍后重新启用）或完全删除它。你可以添加另一个 <code>skip</code>，并禁用第一个 <code>skip</code>，然后全部删除。要禁用某个 <code>skip</code>，必须指定其编号（例如，<code>skip disable 1</code>），如果没有指定，则会禁用所有的 <code>skip</code>。启用或删除 <code>skip</code> 的工作原理相同：</p><pre tabindex=0><code>(gdb) skip bar
(gdb) skip disable 1
(gdb) info skip
Num Enb Glob File RE Function
1 n n &lt;none&gt; n num
2 y n &lt;none&gt; n bar
(gdb) skip delete
(gdb) info skip
Not skipping any files or functions.
</code></pre><h3 id=gdb-的-step-命令>GDB 的 step 命令</h3><p>使用 GDB 的 <code>step</code> 命令是调试程序的一个有用工具。即使是复杂的函数，也有几种方法可以单步调试这些函数，所以下次你在排除代码问题的时候，可以尝试一下这些 GDB 技术。</p><hr><p>via: <a href=https://opensource.com/article/22/12/gdb-step-command>https://opensource.com/article/22/12/gdb-step-command</a></p><p>作者：<a href=https://opensource.com/users/ahajkova>Alexandra</a> 选题：<a href=https://github.com/lkxed>lkxed</a> 译者：<a href=https://github.com/chai001125>chai001125</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/gdb/ rel=tag>GDB</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E8%B0%83%E8%AF%95/ rel=tag>调试</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>