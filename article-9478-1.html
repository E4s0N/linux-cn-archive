<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>如何安全地生成随机数 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="如何安全地生成随机数"><meta property="og:description" content="太长了，懒得看：直接使用 urandom 吧。"><meta property="og:type" content="article"><meta property="og:url" content="/article-9478-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-03-25T10:33:32+00:00"><meta property="article:modified_time" content="2018-03-25T10:33:32+00:00"><meta itemprop=name content="如何安全地生成随机数"><meta itemprop=description content="太长了，懒得看：直接使用 urandom 吧。"><meta itemprop=datePublished content="2018-03-25T10:33:32+00:00"><meta itemprop=dateModified content="2018-03-25T10:33:32+00:00"><meta itemprop=wordCount content="193"><meta itemprop=keywords content="随机数,加密,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>如何安全地生成随机数</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2018-03-25T10:33:32Z>March 25, 2018</time></div></div></header><div class="content post__content clearfix"><p><img src=/data/attachment/album/201803/25/103321odkv11vbjidznn8d.jpg alt></p><h3 id=使用-urandom>使用 urandom</h3><p>使用 <a href=http://blog.cr.yp.to/20140205-entropy.html>urandom</a>！使用 <a href=http://cr.yp.to/talks/2011.09.28/slides.pdf>urandom</a>！使用 <a href=http://golang.org/src/pkg/crypto/rand/rand_unix.go>urandom</a>！</p><p>使用 <a href=http://security.stackexchange.com/questions/3936/is-a-rand-from-dev-urandom-secure-for-a-login-key>urandom</a>！使用 <a href=http://stackoverflow.com/a/5639631>urandom</a>！使用 <a href=https://twitter.com/bramcohen/status/206146075487240194>urandom</a>！</p><h3 id=但对于密码学密钥呢>但对于密码学密钥呢？</h3><p>仍然使用 <a href=https://twitter.com/bramcohen/status/206146075487240194>urandom</a>。</p><h3 id=为什么不是-securerandomopensslhavaged-或者-c-语言实现呢>为什么不是 SecureRandom、OpenSSL、havaged 或者 c 语言实现呢？</h3><p>这些是用户空间的 CSPRNG（伪随机数生成器）。你应该用内核的 CSPRNG，因为：</p><ul><li>内核可以访问原始设备熵。</li><li>它可以确保不在应用程序之间共享相同的状态。</li><li>一个好的内核 CSPRNG，像 FreeBSD 中的，也可以保证它播种之前不给你随机数据。</li></ul><p>研究过去十年中的随机失败案例，你会看到一连串的用户空间的随机失败案例。<a href=http://research.swtch.com/openssl>Debian 的 OpenSSH 崩溃</a>？用户空间随机！安卓的比特币钱包<a href=http://arstechnica.com/security/2013/08/google-confirms-critical-android-crypto-flaw-used-in-5700-bitcoin-heist/>重复 ECDSA 随机 k 值</a>？用户空间随机！可预测洗牌的赌博网站？用户空间随机！</p><p>用户空间的生成器几乎总是依赖于内核的生成器。即使它们不这样做，整个系统的安全性也会确保如此。<strong>但用户空间的 CSPRNG 不会增加防御深度；相反，它会产生两个单点故障。</strong></p><h3 id=手册页不是说使用-devrandom-嘛>手册页不是说使用 /dev/random 嘛？</h3><p>这个稍后详述，保留你的意见。你应该忽略掉手册页。不要使用 <code>/dev/random</code>。<code>/dev/random</code> 和 <code>/dev/urandom</code> 之间的区别是 Unix 设计缺陷。手册页不想承认这一点，因此它产生了一个并不存在的安全顾虑。把 <code>random(4)</code> 中的密码学上的建议当作传说，继续你的生活吧。</p><h3 id=但是如果我需要的是真随机值而非伪随机值呢>但是如果我需要的是真随机值，而非伪随机值呢？</h3><p>urandom 和 <code>/dev/random</code> 提供的是同一类型的随机。与流行的观念相反，<code>/dev/random</code> 不提供“真正的随机”。从密码学上来说，你通常不需要“真正的随机”。</p><p>urandom 和 <code>/dev/random</code> 都基于一个简单的想法。它们的设计与流密码的设计密切相关：一个小秘密被延伸到不可预测值的不确定流中。 这里的秘密是“熵”，而流是“输出”。</p><p>只在 Linux 上 <code>/dev/random</code> 和 urandom 仍然有意义上的不同。Linux 内核的 CSPRNG 定期进行密钥更新（通过收集更多的熵）。但是 <code>/dev/random</code> 也试图跟踪内核池中剩余的熵，并且如果它没有足够的剩余熵时，偶尔也会罢工。这种设计和我所说的一样蠢；这与基于“密钥流”中剩下多少“密钥”的 AES-CTR 设计类似。</p><p>如果你使用 <code>/dev/random</code> 而非 urandom，那么当 Linux 对自己的 RNG（随机数生成器）如何工作感到困惑时，你的程序将不可预测地（或者如果你是攻击者，非常可预测地）挂起。使用 <code>/dev/random</code> 会使你的程序不太稳定，但这不会让你在密码学上更安全。</p><h3 id=这是个缺陷对吗>这是个缺陷，对吗？</h3><p>不是，但存在一个你可能想要了解的 Linux 内核 bug，即使这并不能改变你应该使用哪一个 RNG。</p><p>在 Linux 上，如果你的软件在引导时立即运行，或者这个操作系统你刚刚安装好，那么你的代码可能会与 RNG 发生竞争。这很糟糕，因为如果你赢了竞争，那么你可能会在一段时间内从 urandom 获得可预测的输出。这是 Linux 中的一个 bug，如果你正在为 Linux 嵌入式设备构建平台级代码，那你需要了解它。</p><p>在 Linux 上，这确实是 urandom（而不是 <code>/dev/random</code>）的问题。这也是 <a href=https://factorable.net/weakkeys12.extended.pdf>Linux 内核中的错误</a>。 但它也容易在用户空间中修复：在引导时，明确地为 urandom 提供种子。长期以来，大多数 Linux 发行版都是这么做的。但<strong>不要</strong>切换到不同的 CSPRNG。</p><h3 id=在其它操作系统上呢>在其它操作系统上呢？</h3><p>FreeBSD 和 OS X 消除了 urandom 和 <code>/dev/random</code> 之间的区别；这两个设备的行为是相同的。不幸的是，手册页在解释为什么这样做上干的很糟糕，并延续了 Linux 上 urandom 可怕的神话。</p><p>无论你使用 <code>/dev/random</code> 还是 urandom，FreeBSD 的内核加密 RNG 都不会停摆。 除非它没有被提供种子，在这种情况下，这两者都会停摆。与 Linux 不同，这种行为是有道理的。Linux 应该采用它。但是，如果你是一名应用程序开发人员，这对你几乎没有什么影响：Linux、FreeBSD、iOS，无论什么：使用 urandom 吧。</p><h3 id=太长了懒得看>太长了，懒得看</h3><p>直接使用 urandom 吧。</p><h3 id=结语>结语</h3><p><a href=https://bugs.ruby-lang.org/issues/9569>ruby-trunk Feature #9569</a></p><blockquote><p>现在，在尝试检测 <code>/dev/urandom</code> 之前，SecureRandom.random_bytes 会尝试检测要使用的 OpenSSL。 我认为这应该反过来。在这两种情况下，你只需要将随机字节进行解压，所以 SecureRandom 可以跳过中间人（和第二个故障点），如果可用的话可以直接与 <code>/dev/urandom</code> 进行交互。</p></blockquote><p>总结：</p><blockquote><p><code>/dev/urandom</code> 不适合用来直接生成会话密钥和频繁生成其他应用程序级随机数据。</p><p>GNU/Linux 上的 random(4) 手册所述&mldr;&mldr;</p></blockquote><p>感谢 Matthew Green、 Nate Lawson、 Sean Devlin、 Coda Hale 和 Alex Balducci 阅读了本文草稿。公正警告：Matthew 只是大多同意我的观点。</p><hr><p>via: <a href=https://sockpuppet.org/blog/2014/02/25/safely-generate-random-numbers/>https://sockpuppet.org/blog/2014/02/25/safely-generate-random-numbers/</a></p><p>作者：<a href=https://sockpuppet.org/blog>Thomas & Erin Ptacek</a> 译者：<a href=https://github.com/kimii>kimii</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/%E9%9A%8F%E6%9C%BA%E6%95%B0/ rel=tag>随机数</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E5%8A%A0%E5%AF%86/ rel=tag>加密</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>