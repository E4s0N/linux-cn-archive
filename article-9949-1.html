<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Linux DNS 查询剖析（第二部分） - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="Linux DNS 查询剖析（第二部分）"><meta property="og:description" content="在第二部分中，我将介绍 resolv.conf 的更新机制、systemctl restart networking 命令的运行机制 ，以及 dhclient 是如何参与其中。"><meta property="og:type" content="article"><meta property="og:url" content="/article-9949-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-08-24T23:23:00+00:00"><meta property="article:modified_time" content="2018-08-24T23:23:00+00:00"><meta itemprop=name content="Linux DNS 查询剖析（第二部分）"><meta itemprop=description content="在第二部分中，我将介绍 resolv.conf 的更新机制、systemctl restart networking 命令的运行机制 ，以及 dhclient 是如何参与其中。"><meta itemprop=datePublished content="2018-08-24T23:23:00+00:00"><meta itemprop=dateModified content="2018-08-24T23:23:00+00:00"><meta itemprop=wordCount content="553"><meta itemprop=keywords content="DNS,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>Linux DNS 查询剖析（第二部分）</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2018-08-24T23:23:00Z>August 24, 2018</time></div></div></header><div class="content post__content clearfix"><p><img src=/data/attachment/album/201808/24/232313rb2ozk8zbbb29bb6.jpeg alt></p><p>在 <a href=/article-9943-1.html>Linux DNS 查询剖析 - 第一部分</a> 中，我介绍了：</p><ul><li><code>nsswitch</code></li><li><code>/etc/hosts</code></li><li><code>/etc/resolv.conf</code></li><li><code>ping</code> 与 <code>host</code> 查询方式对比</li></ul><p>并且发现大多数程序选择要查询的 DNS 服务器时会参考 <code>/etc/resolv.conf</code> 配置文件。</p><p>这种方式在 Linux 上比较普遍 1 。虽然我使用了特定的发行版 Ubuntu，但背后的原理与 Debian 甚至是那些基于 CentOS 的发行版有相通的地方；当然，与更低或更高的 Ubuntu 版本相比，差异还是存在的。</p><p>也就是说，接下来，你主机上的行为很可能与我描述的不一致。</p><p>在第二部分中，我将介绍 <code>resolv.conf</code> 的更新机制、<code>systemctl restart networking</code> 命令的运行机制 ，以及 <code>dhclient</code> 是如何参与其中。</p><h3 id=1-手动更新-etcresolvconf>1) 手动更新 /etc/resolv.conf</h3><p>我们知道 <code>/etc/resolv.conf</code> （有极大的可能性）被用到，故你自然可以通过该文件增加一个 <code>nameserver</code>，那么主机也将会（与已有的 <code>nameserver</code> 一起）使用新加入的 <code>nameserver</code> 吧？</p><p>你可以尝试如下：</p><pre tabindex=0><code>$ echo nameserver 10.10.10.10 &gt;&gt; /etc/resolv.conf
</code></pre><p>看上去新的 <code>nameserver</code> 已经加入：</p><pre tabindex=0><code># Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)
#     DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
nameserver 10.0.2.3
search home
nameserver 10.10.10.10
</code></pre><p>但主机网络服务重启后问题出现了：</p><pre tabindex=0><code>$ systemctl restart networking
$ cat /etc/resolv.conf
# Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)
#     DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
nameserver 10.0.2.3
search home
</code></pre><p>我们的 <code>10.10.10.10</code> 的 <code>nameserver</code> 不见了！</p><p>在上一篇文章中我们忽略了这一点，本文进行补充说明。</p><h3 id=2-resolvconf>2) resolvconf</h3><p>你在 <code>/etc/resolv.conf</code> 文件中看到 <code>generated by resolvconf</code> 词组了吧？这就是我们的线索。</p><p>如果深入研究 <code>systemctl restart networking</code> 命令，你会发现它做了很多事情，结束时调用了 <code>/etc/network/if-up.d/000resolvconf</code> 脚本。在该脚本中，可以发现一次对 <code>resolvconf</code> 命令的调用：</p><pre tabindex=0><code>/sbin/resolvconf -a &#34;${IFACE}.${ADDRFAM}&#34;
</code></pre><p>稍微研究一下 man 手册，发现<code>-a</code> 参数允许我们：</p><pre tabindex=0><code>Add or overwrite the record IFACE.PROG then run the update scripts
if updating is enabled.
</code></pre><p>（增加或覆盖 IFACE.PROG 记录，如果开启更新选项，则运行更新脚本）</p><p>故而也许我们可以直接调用该命令增加 <code>namserver</code>：</p><pre tabindex=0><code>echo &#39;nameserver 10.10.10.10&#39; | /sbin/resolvconf -a enp0s8.inet
</code></pre><p>测试表明确实可以！</p><pre tabindex=0><code>$ cat /etc/resolv.conf&amp;nbsp; | grep nameserver
nameserver 10.0.2.3
nameserver 10.10.10.10
</code></pre><p>是否已经找到答案，这就是 <code>/etc/resolv.conf</code> 更新的逻辑？调用 <code>resolvconf</code> 将 <code>nameserver</code> 添加到某个地方的数据库，然后（“如果配置了更新”，先不管具体什么含义）更新 <code>resolv.conf</code> 文件。</p><p>并非如此。</p><pre tabindex=0><code>$ systemctl restart networking
root@linuxdns1:/etc# cat /etc/resolv.conf 
# Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)
#     DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
nameserver 10.0.2.3
search home
</code></pre><p>呃！（网络服务重启后）新增的 <code>nameserver</code> 再次消失了。</p><p>可见，<code>systemctl restart networking</code> 不仅仅运行了 <code>resolvconf</code>，还在其它地方获取 <code>nameserver</code> 信息。具体是哪里呢？</p><h3 id=3-ifupifdown>3) ifup/ifdown</h3><p>继续深入研究 <code>systemctl restart networking</code>，发现它完成了一系列工作：</p><pre tabindex=0><code>cat /lib/systemd/system/networking.service
[...]
[Service]
Type=oneshot
EnvironmentFile=-/etc/default/networking
ExecStartPre=-/bin/sh -c &#39;[ &#34;$CONFIGURE_INTERFACES&#34; != &#34;no&#34; ] &amp;&amp; [ -n &#34;$(ifquery --read-environment --list --exclude=lo)&#34; ] &amp;&amp; udevadm settle&#39;
ExecStart=/sbin/ifup -a --read-environment
ExecStop=/sbin/ifdown -a --read-environment --exclude=lo
[...]
</code></pre><p>首先，网络服务的重启实质是运行一个 单触发 oneshot 的脚本，脚本包含如下命令：</p><pre tabindex=0><code>/sbin/ifdown -a --read-environment --exclude=lo
/bin/sh -c &#39;[ &#34;$CONFIGURE_INTERFACES&#34; != &#34;no&#34; ] &amp;&amp; [ -n &#34;$(ifquery --read-environment --list --exclude=lo)&#34; ] &amp;&amp; udevadm settle&#39;
/sbin/ifup -a --read-environment
</code></pre><p>第一行使用 <code>ifdown</code> 关闭全部的网络接口，但 本地回环 local, lo 接口除外。 2</p><p>（LCTT 译注：其实这是因为很快就又启动了接口，间隔的时间没有超过 TCP 连接的超时时间，有人在评论中也做了类似回复）</p><p>第二行用于确认系统已经完成关闭网络接口相关的全部工作，以便下一步使用 <code>ifup</code> 启动接口。这也让我们了解到，网络服务实质运行的就是 <code>ifdown</code> 和 <code>ifup</code>。</p><p>文档中没有找到 <code>--read-environment</code> 参数的说明，该参数为 <code>systemctl</code> 正常工作所需。很多人以文档不完善为由不喜欢 <code>systemctl</code>。</p><p>很好。那么 <code>ifup</code> （和其成对出现的 <code>ifdown</code>） 到底做了哪些工作呢？长话短说，它运行了 <code>/etc/network/if-pre-up.d/</code> 和 <code>/etc/network/if-up.d/</code> 目录下的全部脚本；期间，这些脚本也可能会调用另外的脚本，依此类推。</p><p>其中一件工作就是运行了 <code>dhclient</code>，但我还不完全确定具体的机理，也许 <code>udev</code> 参与其中。</p><h3 id=4-dhclient>4) dhclient</h3><p><code>dhclient</code> 是一个程序，用于与 DHCP 服务器协商对应网络接口应该使用的 IP 地址的详细信息。同时，它也可以获取可用的 DNS 服务器并将其替换到 <code>/etc/resolv.conf</code> 中。</p><p>让我们开始跟踪并模拟它的行为，但仅在我实验虚拟机的 <code>enp0s3</code> 接口上。事先已经删除 <code>/etc/resolv.conf</code> 文件中的 nameserver 配置：</p><pre tabindex=0><code>$ sed -i &#39;/nameserver.*/d&#39; /run/resolvconf/resolv.conf
$ cat /etc/resolv.conf | grep nameserver
$ dhclient -r enp0s3 &amp;&amp; dhclient -v enp0s3
Killed old client process
Internet Systems Consortium DHCP Client 4.3.3
Copyright 2004-2015 Internet Systems Consortium.
All rights reserved.
For info, please visit https://www.isc.org/software/dhcp/
Listening on LPF/enp0s8/08:00:27:1c:85:19
Sending on   LPF/enp0s8/08:00:27:1c:85:19
Sending on   Socket/fallback
DHCPDISCOVER on enp0s8 to 255.255.255.255 port 67 interval 3 (xid=0xf2f2513e)
DHCPREQUEST of 172.28.128.3 on enp0s8 to 255.255.255.255 port 67 (xid=0x3e51f2f2)
DHCPOFFER of 172.28.128.3 from 172.28.128.2
DHCPACK of 172.28.128.3 from 172.28.128.2
bound to 172.28.128.3 -- renewal in 519 seconds.

$ cat /etc/resolv.conf | grep nameserver
nameserver 10.0.2.3
</code></pre><p>可见这就是 <code>nameserver</code> 的来源。</p><p>但稍等一下，命令中的 <code>/run/resolvconf/resolv.conf</code> 是哪个文件，不应该是 <code>/etc/resolv.conf</code> 吗？</p><p>事实上，<code>/etc/resolv.conf</code> 并不一定只是一个普通文本文件。</p><p>在我的虚拟机上，它是一个软链接，指向位于 <code>/run/resolvconf</code> 目录下的“真实文件”。这也暗示了我们，该文件是在系统启动时生成的；同时，这也是该文件注释告诉我们不要直接修改该文件的原因。</p><p>（LCTT 译注：在 CentOS 7 中，没有 <code>resolvconf</code> 命令，<code>/etc/resolv.conf</code> 也不是软链接）</p><p>假如上面命令中 <code>sed</code> 命令直接处理 <code>/etc/resolv.conf</code> 文件，效果是不同的，会有警告消息告知待操作的文件不能是软链接（<code>sed -i</code> 无法很好的处理软链接，它只会创建一个新文件）。</p><p>（LCTT 译注：CentOS 7 测试时，<code>sed -i</code> 命令操作软链接并没有警告，但确实创建了新文件取代软链接）</p><p>如果你继续深入查看配置文件 <code>/etc/dhcp/dhclient.conf</code> 的 <code>supersede</code> 部分，你会发现 <code>dhclient</code> 可以覆盖 DHCP 提供的 DNS 服务器。</p><p><img src=/data/attachment/album/201808/24/232326asi1sbyjsylti4s7.png alt="linux-dns-2 (2)"></p><p><em>（大致）准确的关系图</em></p><hr><h3 id=第二部分的结束语>第二部分的结束语</h3><p>第二部分到此结束。信不信由你，这是一个某种程度上简化的流程版本，但我尽量保留重要和值得了解的部分，让你不会感到无趣。大部分内容都是围绕实际脚本的运行展开的。</p><p>但我们的工作还没有结束，在第三部分，我们会介绍这些之上的更多层次。</p><p>让我们简要列出我们已经介绍过的内容：</p><ul><li><code>nsswitch</code></li><li><code>/etc/hosts</code></li><li><code>/etc/resolv.conf</code></li><li><code>/run/resolvconf/resolv.conf</code></li><li><code>systemd</code> 和网络服务</li><li><code>ifup</code> 和 <code>ifdown</code></li><li><code>dhclient</code></li><li><code>resolvconf</code></li></ul><hr><ol><li>事实上，这是相对于 POSIX 标准的，故不限于 Linux （我从上一篇文章的一条极好的<a href=https://zwischenzugs.com/2018/06/08/anatomy-of-a-linux-dns-lookup-part-i/#comment-2312>回复</a>中了解到这一点） <a href=#fnref1>↩</a></li><li>我不明白为何这没有导致我例子中的 vagrant 会话中断 （有谁明白吗？）。 <a href=#fnref2>↩</a></li></ol><hr><p>via: <a href=https://zwischenzugs.com/2018/06/18/anatomy-of-a-linux-dns-lookup-part-ii/>https://zwischenzugs.com/2018/06/18/anatomy-of-a-linux-dns-lookup-part-ii/</a></p><p>作者：<a href=https://zwischenzugs.com/>ZWISCHENZUGS</a><br>译者：<a href=https://github.com/pinewall>pinewall</a><br>校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/dns/ rel=tag>DNS</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>