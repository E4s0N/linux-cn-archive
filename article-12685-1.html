<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>构建一个即时消息应用（五）：实时消息 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="构建一个即时消息应用（五）：实时消息"><meta property="og:description" content="对于实时消息，我们将使用 服务器发送事件。"><meta property="og:type" content="article"><meta property="og:url" content="/article-12685-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-10-05T09:17:27+00:00"><meta property="article:modified_time" content="2020-10-05T09:17:27+00:00"><meta itemprop=name content="构建一个即时消息应用（五）：实时消息"><meta itemprop=description content="对于实时消息，我们将使用 服务器发送事件。"><meta itemprop=datePublished content="2020-10-05T09:17:27+00:00"><meta itemprop=dateModified content="2020-10-05T09:17:27+00:00"><meta itemprop=wordCount content="286"><meta itemprop=keywords content="即时消息,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>构建一个即时消息应用（五）：实时消息</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2020-10-05T09:17:27Z>October 05, 2020</time></div></div></header><div class="content post__content clearfix"><p><img src=/data/attachment/album/202010/05/091113edbuavorm89looja.jpg alt></p><p>本文是该系列的第五篇。</p><ul><li><a href=/article-11396-1.html>第一篇: 模式</a></li><li><a href=/article-11510-1.html>第二篇: OAuth</a></li><li><a href=/article-12056-1.html>第三篇: 对话</a></li><li><a href=/article-12680-1.html>第四篇: 消息</a></li></ul><p>对于实时消息，我们将使用 服务器发送事件 Server-Sent Events 。这是一个打开的连接，我们可以在其中传输数据流。我们会有个端点，用户会在其中订阅发送给他的所有消息。</p><h3 id=消息户端>消息户端</h3><p>在 HTTP 部分之前，让我们先编写一个 映射 map ，让所有客户端都监听消息。 像这样全局初始化：</p><pre tabindex=0><code>type MessageClient struct {
    Messages chan Message
    UserID   string
}

var messageClients sync.Map
</code></pre><h3 id=已创建的新消息>已创建的新消息</h3><p>还记得在 <a href=/article-12680-1.html>上一篇文章</a> 中，当我们创建这条消息时，我们留下了一个 “TODO” 注释。在那里，我们将使用这个函数来调度一个 goroutine。</p><pre tabindex=0><code>go messageCreated(message)
</code></pre><p>把这行代码插入到我们留注释的位置。</p><pre tabindex=0><code>func messageCreated(message Message) error {
    if err := db.QueryRow(`
 SELECT user\_id FROM participants
 WHERE user\_id != $1 and conversation\_id = $2
 `, message.UserID, message.ConversationID).
    Scan(&amp;message.ReceiverID); err != nil {
        return err
    }

    go broadcastMessage(message)

    return nil
}

func broadcastMessage(message Message) {
    messageClients.Range(func(key, \_ interface{}) bool {
        client := key.(\*MessageClient)
        if client.UserID == message.ReceiverID {
            client.Messages &lt;- message
        }
        return true
    })
}
</code></pre><p>该函数查询接收者 ID（其他参与者 ID），并将消息发送给所有客户端。</p><h3 id=订阅消息>订阅消息</h3><p>让我们转到 <code>main()</code> 函数并添加以下路由：</p><pre tabindex=0><code>router.HandleFunc(&#34;GET&#34;, &#34;/api/messages&#34;, guard(subscribeToMessages))
</code></pre><p>此端点处理 <code>/api/messages</code> 上的 GET 请求。请求应该是一个 <a href=https://developer.mozilla.org/en-US/docs/Web/API/EventSource>EventSource</a> 连接。它用一个事件流响应，其中的数据是 JSON 格式的。</p><pre tabindex=0><code>func subscribeToMessages(w http.ResponseWriter, r \*http.Request) {
    if a := r.Header.Get(&#34;Accept&#34;); !strings.Contains(a, &#34;text/event-stream&#34;) {
        http.Error(w, &#34;This endpoint requires an EventSource connection&#34;, http.StatusNotAcceptable)
        return
    }

    f, ok := w.(http.Flusher)
    if !ok {
        respondError(w, errors.New(&#34;streaming unsupported&#34;))
        return
    }

    ctx := r.Context()
    authUserID := ctx.Value(keyAuthUserID).(string)

    h := w.Header()
    h.Set(&#34;Cache-Control&#34;, &#34;no-cache&#34;)
    h.Set(&#34;Connection&#34;, &#34;keep-alive&#34;)
    h.Set(&#34;Content-Type&#34;, &#34;text/event-stream&#34;)

    messages := make(chan Message)
    defer close(messages)

    client := &amp;MessageClient{Messages: messages, UserID: authUserID}
    messageClients.Store(client, nil)
    defer messageClients.Delete(client)

    for {
        select {
        case &lt;-ctx.Done():
            return
        case message := &lt;-messages:
            if b, err := json.Marshal(message); err != nil {
                log.Printf(&#34;could not marshall message: %v\n&#34;, err)
                fmt.Fprintf(w, &#34;event: error\ndata: %v\n\n&#34;, err)
            } else {
                fmt.Fprintf(w, &#34;data: %s\n\n&#34;, b)
            }
            f.Flush()
        }
    }
}
</code></pre><p>首先，它检查请求头是否正确，并检查服务器是否支持流式传输。我们创建一个消息通道，用它来构建一个客户端，并将其存储在客户端映射中。每当创建新消息时，它都会进入这个通道，因此我们可以通过 <code>for-select</code> 循环从中读取。</p><p>服务器发送事件 Server-Sent Events 使用以下格式发送数据：</p><pre tabindex=0><code>data: some data here\n\n
</code></pre><p>我们以 JSON 格式发送：</p><pre tabindex=0><code>data: {&#34;foo&#34;:&#34;bar&#34;}\n\n
</code></pre><p>我们使用 <code>fmt.Fprintf()</code> 以这种格式写入响应 写入器 writter ，并在循环的每次迭代中刷新数据。</p><p>这个循环会一直运行，直到使用请求上下文关闭连接为止。我们延迟了通道的关闭和客户端的删除，因此，当循环结束时，通道将被关闭，客户端不会收到更多的消息。</p><p>注意， 服务器发送事件 Server-Sent Events （EventSource）的 JavaScript API 不支持设置自定义请求头?，所以我们不能设置 <code>Authorization: Bearer &lt;token></code>。这就是为什么 <code>guard()</code> 中间件也会从 URL 查询字符串中读取令牌的原因。</p><hr><p>实时消息部分到此结束。我想说的是，这就是后端的全部内容。但是为了编写前端代码，我将再增加一个登录端点：一个仅用于开发的登录。</p><ul><li><a href=https://github.com/nicolasparada/go-messenger-demo>源代码</a></li></ul><hr><p>via: <a href=https://nicolasparada.netlify.com/posts/go-messenger-realtime-messages/>https://nicolasparada.netlify.com/posts/go-messenger-realtime-messages/</a></p><p>作者：<a href=https://nicolasparada.netlify.com/>Nicolás Parada</a> 选题：<a href=https://github.com/lujun9972>lujun9972</a> 译者：<a href=https://github.com/gxlct008>gxlct008</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/%E5%8D%B3%E6%97%B6%E6%B6%88%E6%81%AF/ rel=tag>即时消息</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>