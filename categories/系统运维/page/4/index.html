<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>系统运维 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="系统运维"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="/categories/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/"><meta itemprop=name content="系统运维"><meta itemprop=description content><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class="main list" role=main><header class=main__header><h1 class=main__title>系统运维</h1></header><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-3215-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201406/17/224823h9y178x8jyro8uy3.png.thumb.jpg alt="Linux终端下 dstat 监控工具"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-3215-1.html rel=bookmark>Linux终端下 dstat 监控工具</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-06-17T22:48:20Z>June 17, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">dstat 是一个可以取代vmstat，iostat，netstat和ifstat这些命令的多功能产品。dstat克服了这些命令的局限并增加了一些另外的功能，增加了监控项，也变得更灵活了。dstat可以很方便监控系统运行状况并用于基准测试和排除故障。 dstat可以让你实时地看到所有系统资源，例如，你能够通过统计IDE控制器当前状态来比较磁盘利用率，或者直接通过网络带宽数值来比较磁盘的吞吐率（在相同的时间间隔内）。 dstat将以列表的形式为你提供选项信息并清晰地告诉你是在何种幅度和单位显示输出。这样更好地避免了信息混乱和误报。更重要的是，它可以让你</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-3195-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201406/14/233330ysxa1afoddk1avcd.png.thumb.jpg alt="Linux script命令 —— 终端里的记录器"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-3195-1.html rel=bookmark>Linux script命令 —— 终端里的记录器</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-06-14T23:33:00Z>June 14, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">当你在终端或者控制台工作时，你可能想要记录在终端中所做的一切。这些记录可以用来当作史料，保存终端所发生的一切。比如说，你和一些Linux管理员们同时管理着相同的机器，或者你让某人远程登陆到了你的服务器上，你可能记录想要终端里发生的一切。要实现这个目标，你可以使用script命令。 script是什么 scirpt就是一个命令，可以制作一份记录输出到终端的记录。对于那些想要真实记录终端会话的人来说，这很有用。该记录可以保存并在以后再打印出来。 怎么用 默认情况下，我们可以通过在终端中输入script来启动scirpt命令。 pungki@dev-</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-3188-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201406/12/154541wrr78rjppzl1zfjw.jpg.thumb.jpg alt=如何使用phpIPAM来管理IP地址和子网></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-3188-1.html rel=bookmark>如何使用phpIPAM来管理IP地址和子网</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-06-12T17:00:00Z>June 12, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">通常，网络或系统管理员有责任来管理其所管理的网络下的一个或多个子网。例如，当一个网段分配了/24子网，那么该子网就有254个IP地址可以用于不同用途。要跟踪某个IP被分配到了哪个主机，就需要通过某种方式记录下来。最简单的方法，就是使用一个电子表格，如Excel来记录IP地址的分配信息。此方法对于只有一个管理员，并且网络很小的情况下比较奏效。然而，对于多个大型网络而言，依赖于电子表格并不方便，而且十分容易出错。更糟糕的是，如果有多个管理员参与管理，更新电子表格就十分麻烦了，因为每个管理员可能生成各种不同版本的文档</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-3160-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201406/06/232653h6oiat39at5lfotb.png.thumb.jpg alt=如何使用netstat命令验证DDOS入侵></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-3160-1.html rel=bookmark>如何使用netstat命令验证DDOS入侵</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-06-07T08:25:00Z>June 07, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">一般来说，服务器非常慢可能原因是多方面的，有可能是配置错误，脚本错误或者是一些奇诡的硬件。当然也有可能是有人对你的服务器进行 Dos (拒绝服务攻击)或者 DDOS (分布式拒绝服务攻击)。 Dos攻击或者DDos攻击目的是使服务器或者网络资源耗尽，使其他用户无法使用。一般来说，这种攻击主要针对重要的网站或服务，比如银行、信用卡支付网关甚至是根域名服务器。Dos攻击主要通过强制目标主机重启或大量消耗其主机资源，使得目标主机无法提供服务或者妨害主机和用户之间的通信的手段，使得主机无法提供正常的服务的。 在本文中你将知道如何</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-3154-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201406/06/153919wzur3cpleplsunlo.jpg.thumb.jpg alt="Collectl: Linux 性能监控的全能冠军"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-3154-1.html rel=bookmark>Collectl: Linux 性能监控的全能冠军</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-06-06T15:39:00Z>June 06, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">对于一个 Linux 系统管理员来说确保自己管理的系统处于一个良好的状态是其首要责任。Linux 系统管理员可以找到有很多工具来帮助自己监控和显示系统中的进程，例如 top 和 htop ,但是这些工具都不能与 collectl 相媲美。 collectl是一款非常优秀并且有着丰富的命令行功能的实用程序，你可以用它来采集描述当前系统状态的性能数据。不同于大多数其它的系统监控工具，collectl 并非仅局限于有限的系统度量，相反，它可以收集许多不同类型系统资源的相关信息，如 cpu 、disk、memory 、network 、sockets 、 tcp 、inodes 、infiniband 、 lu</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-3135-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201406/02/001336i32h4ujue2z4j4e4.png.thumb.jpg alt="findmnt 命令的八个应用实例"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-3135-1.html rel=bookmark>findmnt 命令的八个应用实例</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-06-02T00:13:31Z>June 02, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">已挂载的文件系统和设备 linux 中常用的检查已挂载的文件系统的是 mount 命令，不仅用于列出已挂载的设备，而且可以在需要的时候挂载和卸载。另外还有一个叫做 findmnt 的超赞命令，它可以用于快速查看挂载位置和选项。 安装findmnt findmnt 命令来自 util-linux 软件包，默认安装在大多数发行版中，如 Ubuntu，Fedora，Debian $ aptitude search util-linux i util-linux - Miscellaneous system utilities $ yum info util-linux 使用findmnt 1. 列出文件系统 无任何选项运行 findmnt，只会以树形结构图的方式列出所有已挂载的文件系</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-3113-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201405/29/230834i3tj52nvq0m9t9jj.jpg.thumb.jpg alt="在Ubuntu 14.04上安装 Webmin"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-3113-1.html rel=bookmark>在Ubuntu 14.04上安装 Webmin</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-05-30T08:00:00Z>May 30, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">Webmin是一个开源的基于网页的Unix/Linux系统管理工具。通过使用Webmin，你可以在浏览器上设置和安装所有的系统服务，包括:DNS、DHCP、Apache、NFS和Samba等等。因此，有了这个，你就再也不需要去记住所有的修改配置的命令了。 使用官方软件源在Ubuntu 14.04 LTS上安装Webmin 添加webmin的官方仓库: 修改 /etc/apt/sources.list, sudo vi /etc/apt/sources.list 添加如下内容: deb <a href=http://download.webmin.com/download/repository>http://download.webmin.com/download/repository</a> sarge contrib deb <a href=http://webmin.mirror.somersettechsolutions.co.uk/repository>http://webmin.mirror.somersettechsolutions.co.uk/repository</a> sarge contrib 添加G</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-3101-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201405/27/232841tei4p8m10ywpewb3.png.thumb.jpg alt="Linux Shell脚本的10个有用的“面试问题和解答”"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-3101-1.html rel=bookmark>Linux Shell脚本的10个有用的“面试问题和解答”</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-05-27T23:28:38Z>May 27, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">首先致上每日问候。Linux的浩瀚无垠，使人总能每次都提交与众不同的内容。我们The-Tecmint-Team的工作是给我们的读者提供一些独特的内容，这些内容不仅对他们的职业生涯很有用，同时也让他们增长知识。在此，我们就尝试这么去做，至于能取得多大的成功，就由我们的读者朋友们来判断吧。 我们为各类用户提供了关于Shell脚本语言和面试问题的很多教程，可以访问以下链接去阅读这些文章。 Shell脚本系列 面试问题与解答系列 在此，作为shell脚本的附加内容，在本文中我们将从面试的角度解读与Linux Shell相关的问题。 1. 在shell脚本成功</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-3093-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201405/26/161918yt6ljctt8lljjkkb.jpg.thumb.jpg alt=如何在CentOS中创建辅域名服务器></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-3093-1.html rel=bookmark>如何在CentOS中创建辅域名服务器</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-05-26T16:19:13Z>May 26, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">在上篇教程里，我们为一个测试域exmample.tst创建了一个主域名服务器（ns1）。在本篇中，我们会在CentOS中使用bind包为相同的域创建一个辅域名服务器（ns2）。 当创建一个辅DNS服务器的时候，下面的因素需要仔细考虑。 在辅域名服务器中，你不需要手动创建正向和反向区域文件。这些区域文件会定期从主域名服务器上面同步。 当主域名服务器上的任何区域文件被修改的时候，&lsquo;serial&rsquo;参数也应当被更新。只有当主服务器上面区域文件的serial被修改之后，辅DNS服务器才会进行同步。 我们假设辅DNS服务器的IP地址是172.16.1.4。让我们来进行安</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-3092-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201405/26/151355uzrlxqrp5855qdxy.jpg.thumb.jpg alt=CentOS上配置主DNS服务器的简易指南></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-3092-1.html rel=bookmark>CentOS上配置主DNS服务器的简易指南</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-05-26T15:14:00Z>May 26, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">任何运作中的域名至少有两台DNS服务器，一台称为主域名服务器（比如叫做ns1），而另一台称为从域名服务器（比如叫做ns2）。这些服务器通常用于故障转移：如果一台宕机，另外一台就激活成为DNS服务器（译注：此处译者有不同意见，事实上两个或更多的DNS服务器是共同工作的，并不是第一台停止服务后，第二台才接替工作。解析器是随机选择一个DNS服务器进行询问，如果超时则会询问下一个，这是多个DNS的故障容错机制）。也可以实现包括负载均衡、防火墙和集群在内的更为复杂的故障转移机制。 一个域的所有DNS条目都会被添加到主域名服务器，</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-3027-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201405/15/193721gfftn6yyu3yx4l3s.png.thumb.jpg alt=如何从Web浏览器远程监视Linux服务器和桌面></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-3027-1.html rel=bookmark>如何从Web浏览器远程监视Linux服务器和桌面</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-05-15T19:37:19Z>May 15, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">当你要监视一台Linux机器时，你会有很多的选择。虽然现在有很多产品质量监控方案(比如 Nagios、 Zabbix、 Zenoss)，它们拥有华丽的UI，可扩展监控，易于理解的报告等等，这些方案对于大多数终端用户都太过于强大了。如果你只需检查Linux服务器或桌面的基本状态（比如，CPU负载、内存使用、活跃进程），就请考虑一下linux-dash。 linux-dash是一款面向Linux机器的基于web的轻量级监控面板，可以实时显示不同的系统属性，比如CPU负载、内存使用、磁盘使用、网络速度、网络连接、上下行带宽、登录用户、运行中的进程等等。linux-dash没有后</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-2973-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201405/05/222833xhkahy6yhklyhvaw.png.thumb.jpg alt=五个你可能不了解的killall选项></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-2973-1.html rel=bookmark>五个你可能不了解的killall选项</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-05-05T22:28:00Z>May 05, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">Linux的命令行提供很多命令来杀死进程。比如，你可以向kill命传递一个PID来杀死进程；pkill命令使用一个正则表达式作为输入，所以和该模式匹配的进程都被杀死。 但是还有一个命令叫killall，默认情况下，它精确地匹配参数名，然后杀死匹配进程。在这篇文章中，我们将讨论有关这个命令的实际应用。 Linux 的 killall 命令 killall命令可以用来给一个特定的进程发送一个信号。这个信号默认情况下是SIGTERM，但也可以由killall命令使用参数来指定其它信号。 现在让我们通过一些实际的例子来看看这个命令的实际用法。 1. 基本示例 在这个例子</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-2969-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201405/05/145631e9tm9gtwj7orz7rk.jpg.thumb.jpg alt=如何关闭一个开放的DNS解析器></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-2969-1.html rel=bookmark>如何关闭一个开放的DNS解析器</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-05-05T14:56:00Z>May 05, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">我们在之前的教程中创建的DNS服务器是一个开放DNS解析器。开放解析器不会过滤任何来源请求，并会接受来自所有IP的查询。 不幸的是，开放解析器很容易成为一个攻击目标。比如，攻击者可以对开放DNS服务器发起一个拒绝服务攻击(DoS)或者更糟的分布式拒绝服务攻击(DDoS)。这些也可与IP欺骗结合，将应答包指向受害者被欺骗的IP地址。在另外的场合下称作DNS放大攻击，开放的DNS服务器很容易就会成为攻击的对象。 根据openresolverproject.org，除非有必要，运行一个开放解析器是不明智的。大多数公司要让它们的DNS服务器仅对他们的客户开放。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-2964-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201405/03/130646gn5xng6m59lgy530.png.thumb.jpg alt="值得关注：Ubuntu 14.04服务器版提供了虚拟化、自动化、存储相关更新"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-2964-1.html rel=bookmark>值得关注：Ubuntu 14.04服务器版提供了虚拟化、自动化、存储相关更新</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-05-03T13:06:44Z>May 03, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">这次发布的Ubuntu 14.04，代号Trusty Tahr（值得信赖的塔尔羊），将会给服务器版用户带来新的自动化，虚拟化和存储相关特性。 Ubuntu 14.04, 是由Canonical推出的基于Linux的开源操作系统最新版本，没有为PC和移动用户带来太大改动，对他们来说仅仅是较少的更新。而对服务器用户，这次最新的最重大的Ubuntu版本更新带来了更多功能，特别在自动化，云计算，以及虚拟化等方面。 对桌面和移动用户来说，这次即将在4月17日正式露面的Ubuntu14.04的最重大的改动是，它带来了AppArmor安全系统的更新。这个在桌面/移动版本中最重要的新特性，是</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-2933-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201404/27/104511qdag95sdgsgzd05g.png.thumb.jpg alt="10个 ssh 简单命令选项"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-2933-1.html rel=bookmark>10个 ssh 简单命令选项</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-04-27T10:45:00Z>April 27, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">一个系统管理员可能会同时管理着多台服务器，这些服务器也许会放在不同的地方。要亲自一台一台的去访问来管理它们显然不是最好的方法，通过远程控制的方法应该是最有效的。远程访问最通用的一款应用程序就是 SSH（什么？你还用telnet？&mldr;.$%@%W@$##）。 SSH 是什么 SSH（全称 Secure Shell)是一种加密的网络协议。使用该协议的数据将被加密，如果在传输中间数据泄漏，也可以确保没有人能读取出有用信息。要使用 SSH，目标机器应该安装 SSH 服务端应用程序，因为 SSH 是基于客户-服务模式的。 当你想安全的远程连接到主机，可中间的网络</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-2915-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201404/24/151245h6ijffyvziihhhcm.jpg.thumb.jpg alt=如何在Linux中发现IP地址冲突></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-2915-1.html rel=bookmark>如何在Linux中发现IP地址冲突</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-04-24T15:12:42Z>April 24, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">你们都知道什么是IP地址，是吧？它们被分配给网络上的设备来代表它们。它们通过DHCP服务器分配并且会经常改变。现在有两种IP地址。动态的一种会经常改变（几天一次），而静态的就如它的名字那样是静态的，意味着它们不会改变。 有时这会引发一些冲突。当一个动态IP被分配了并且有另外一台网络设备已经拥有了相同的IP。或者在相同网络子网上有多台分配IP的DHCP服务器。如果你有连通问题并且假设它是由于IP冲突造成的，那么你可以使用一个工具称作arp-scan来扫描它们。 这个工具会在本地网络发送ARP（Address Resolution Protocol）(地址解</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-2871-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201404/18/133553oc7ggu5ho5j75goj.jpg.thumb.jpg alt="在 Linux/UNIX 终端下使用 nload 实时监控网络流量和带宽使用"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-2871-1.html rel=bookmark>在 Linux/UNIX 终端下使用 nload 实时监控网络流量和带宽使用</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-04-18T13:35:51Z>April 18, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">如果你想在命令行界面监控网络吞吐量，nload 应用程序是个不错的选择。它是一个实时监控网络流量和带宽使用的控制台应用程序，使用两个图表可视化地展示接收和发送的流量，并提供诸如数据交换总量、最小/最大网络带宽使用量等附加信息。 安装 在 CentOS/RHEL/Red Hat/Fedora Linux 上安装 nload 首先在 CentOS 或者基于 RHEL 的操作系统上启用 EPEL 仓库，然后键入 yum 命令安装 nload： # yum install nload 在 Debian 或者 Ubuntu Linux 上安装 nload 键入 apt-get 命令： $ sudo apt-get install nload 在 FreeBSD 操作系统上安装 nl</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-2830-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201404/10/151523ivereenrvlay110l.png.thumb.jpg alt=Linux系统监控神器--Collectl></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-2830-1.html rel=bookmark>Linux系统监控神器--Collectl</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-04-10T15:15:00Z>April 10, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">系统资源监控 为使系统良好运转,Linux系统管理员经常需要监测cpu,内存,磁盘,网络等系统信息。Linux上已有iotop,top,free,htop,sar等丰富的常规工具来实现监测功能。今天让我们走进Collectl来了解这个集测试/监控/分析系统性能为一体的Linux工具。 Collectl作为一个轻量级的监控工具,在同类工具中是功能最全的。用户可监测不同的复杂系统矩阵值,并可保留数据以做之后的分析。不同于其他只用来监测特定系统参数的工具,Collectl可以同时监测不同的变量,并以合适的方式记录它们。 摘自Collectl官网 &mldr; 不同于或聚焦于一小组统计数据、采用</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-2794-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201404/02/151244a6i5odiz6ioid16i.jpg.thumb.jpg alt="如何在 Ubuntu server 中设置 RainLoop Webmail"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-2794-1.html rel=bookmark>如何在 Ubuntu server 中设置 RainLoop Webmail</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-04-02T15:12:00Z>April 02, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">Webmail无疑是任何邮件服务器必不可少的一部分。虽然本地邮件客户端通常比Webmail的功能更多，但通过电子邮件客户端从外部可信的网络访问IMAP或SMTP有时会很棘手。再者，当你需要在一个特定的工作站、笔记本电脑或者移动设备去使用一个电子邮件客户端时，你可以在任何地方使用Webmail服务，只要你接入互联网。 本教程的重点是在一个运行 Apache 的 Ubuntu 服务器上安装配置RainLoop Webmail。RainLoop 是基于 PHP 的Webmail，并且有以下功能。 支持apache，nginx和其它网页服务器。 标准接口补充了一个主题库可供选择。 个人和非盈利项目 &mldr;</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-2793-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201404/02/145027irw24dqz45r27p4u.jpg.thumb.jpg alt="Linux 上的 MAC 地址欺骗"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-2793-1.html rel=bookmark>Linux 上的 MAC 地址欺骗</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-04-02T14:50:20Z>April 02, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">网卡生产商在每一张网卡（NIC）在出厂时都会在上面刻上一个48位的全球唯一标识符（GUID，例如08:4f:b5:05:56:a0），这串 GUID 就是网卡的 MAC 地址，用于确定一张网卡的身份。MAC 地址的高24位叫 OUI(Organizationally Unique Identifier 组织唯一标示符)，是为网卡设置 MAC 地址的组织的标识符，这样一来，不同组织设置的 MAC 地址就不会冲突了。（译注：实际生产中，并不是每个网络设备都有不同的MAC地址，有时候地址空间不足，生产商会给发往不同地区国家的产品中用相同的地址空间。） 虽然 MAC 地址由厂商指定，但用户可以改变它，这 &mldr;</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-2782-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201403/31/214404gen07qvynyj3vjzn.jpeg.thumb.jpg alt="Linux 系统实时监控的瑞士军刀 —— Glances"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-2782-1.html rel=bookmark>Linux 系统实时监控的瑞士军刀 —— Glances</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-03-31T21:43:00Z>March 31, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">早些时候，我们提到过有很多可以用来监视系统性能的 Linux 系统监视工具。 但我们估计，或许更多的用户会倾向与绝大多数 Linux 发行版都带的工具 （top 命令）。 top 命令是 Linux 下的一个实时任务管理器， 同时也是用于在 GNU/Linux 发行版中寻找系统性能方面的瓶颈，并帮助我们作出正确操作的常用系统监视工具。 她有着一个极为简洁的界面，并自带少量的可以帮助我们快速了解系统性能的实用选项。 但是，有些时候想要通过她寻找一个占用系统资源比较大的应用或进程可能会比较困难。 因为 top 命令本身并不会帮助我们高亮那些吃太多 CPU</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-2740-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201403/23/085430b7z0qsysl7y4qzee.png.thumb.jpg alt="Linux touch 命令 - 为什么我们需要改变时间戳？"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-2740-1.html rel=bookmark>Linux touch 命令 - 为什么我们需要改变时间戳？</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-03-23T08:52:00Z>March 23, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">我们可能在 Linux 下运用 touch 命令创建一个空文件。当然我们也可以使用其他命令例如 vi, nano 或是任意一个编辑工具来实现。但是你可能需要更多的步骤来完成操作。其实你要知道 touch 命令的主要功能并不是为了创建一个空文件哦。 什么是 touch 命令 众所周知，每个文件都被附有时间戳。这个时间戳记包括访问时间和修改时间。而 Touch 命令主要就是用来修改文件的访问时间和修改时间。 为什么我们需要使用 touch 命令 既然 touch 命令描述的是改变时间戳，那么我们可能会想为什么我们需要去改变时间戳呢?这个问题会引发我们的深思。然 &mldr;</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-2688-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201403/14/135954il4fflauc39amuum.png.thumb.jpg alt="Linux 移动或重命名文件/目录－mv 的10个实用例子"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-2688-1.html rel=bookmark>Linux 移动或重命名文件/目录－mv 的10个实用例子</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-03-14T13:59:00Z>March 14, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">熟悉了 复制命令，下一个相关的命令就是 mv 命令。当你想要将文件从一个位置移动到另一个地方并且不想复制它，那么mv 命令是完成这个任务的首选。 初识 mv 命令 mv 命令是一个与cp类似的命令，但是它并非创建文件或 &mldr;</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-2687-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201403/14/134411r8in1vzsuppvz1wd.png.thumb.jpg alt="Linux cp 命令的15个示例 - 创建文件和目录的副本"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-2687-1.html rel=bookmark>Linux cp 命令的15个示例 - 创建文件和目录的副本</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-03-14T13:44:00Z>March 14, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">拷贝文件和目录是每一个操作系统的基本指令。备份行为基本上是创建文件和目录的副本。在Linux系统下，我们可以用cp命令来实现。 copy 命令是什么 正如我们在上文提到的，cp是一个用来创建文件和目录副本的命令。在 &mldr;</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-2680-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201403/13/102928m2z2n364a66vua66.jpg.thumb.jpg alt="10个 Linux/Unix下 Bash 和 KSH shell 的作业控制实例"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-2680-1.html rel=bookmark>10个 Linux/Unix下 Bash 和 KSH shell 的作业控制实例</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-03-13T10:29:00Z>March 13, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">Linux 和 Unix 属于多任务的操作系统，也就是说一个系统在同一时间段内能运行多重任务(进程)。在这个新的博客系列，我将会列出相关的 Linux 和 Unix 作业（job）控制的命令，你可以通过这些命令在 Bash 或 Korn 还有 &mldr;</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-2647-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201403/07/123318f1vcmhv8c1c7uck6.png.thumb.jpg alt=Linux中的more命令－逐页显示长文本文件></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-2647-1.html rel=bookmark>Linux中的more命令－逐页显示长文本文件</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-03-07T12:33:00Z>March 07, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">如果你已经习惯了在Linux系统上工作，那你一定会发现在Linux世界中存在着大量的文本文件。配置文件和日志文件通常都采用文本格式。这些文件通常都有很长的内容，不能在一屏内全部显示。所以在处理这种文件时，我们需 &mldr;</div></article></main><div class=pagination><a class="pagination__item pagination__item--prev btn" href=/categories/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/page/3/>«</a>
<span class="pagination__item pagination__item--current">4/4</span></div></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>