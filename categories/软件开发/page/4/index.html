<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>软件开发 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="软件开发"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"><meta itemprop=name content="软件开发"><meta itemprop=description content><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class="main list" role=main><header class=main__header><h1 class=main__title>软件开发</h1></header><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-9383-1.html><img class=thumbnail__image src=/data/attachment/album/201802/25/100828w9xu9oaiyptt8oah.jpg.thumb.jpg alt="通过 ncurses 在终端创建一个冒险游戏"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-9383-1.html rel=bookmark>通过 ncurses 在终端创建一个冒险游戏</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2018-02-25T09:38:00Z>February 25, 2018</time></div></div></header><div class="content list__excerpt post__content clearfix">怎样使用 curses 函数读取键盘并操作屏幕。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-9372-1.html><img class=thumbnail__image src=/data/attachment/album/201802/22/235511q1pbibaabi5cx6xf.jpg.thumb.jpg alt="使用 Python 的 urllib.parse 库解析 URL"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-9372-1.html rel=bookmark>使用 Python 的 urllib.parse 库解析 URL</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2018-02-22T23:51:00Z>February 22, 2018</time></div></div></header><div class="content list__excerpt post__content clearfix">Python 中的 urllib.parse 模块提供了很多解析和组建 URL 的函数。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-9367-1.html><img class=thumbnail__image src=/data/attachment/album/201802/21/115419r2ix9xosmaqminbx.jpg.thumb.jpg alt="会话与 Cookie：用户登录的原理是什么?"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-9367-1.html rel=bookmark>会话与 Cookie：用户登录的原理是什么?</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2018-02-21T11:54:00Z>February 21, 2018</time></div></div></header><div class="content list__excerpt post__content clearfix">登录的原理是什么？网站是如何认证的？它怎么知道是哪个用户从哪儿登录进来的？下面我们来对这些问题进行一一解答。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-9362-1.html><img class=thumbnail__image src=/data/attachment/album/201802/20/132105bq9fgubptg9011yu.jpg.thumb.jpg alt=脚本编程之骰子游戏></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-9362-1.html rel=bookmark>脚本编程之骰子游戏</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2018-02-20T13:21:00Z>February 20, 2018</time></div></div></header><div class="content list__excerpt post__content clearfix">Bunco：一个使你的“快艇”游戏看起来更复杂的掷骰子游戏。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-9348-1.html><img class=thumbnail__image src=/data/attachment/album/201802/14/232431itpppd60pa60ps4w.jpg.thumb.jpg alt="ncurses 入门指南"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-9348-1.html rel=bookmark>ncurses 入门指南</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2018-02-16T00:20:00Z>February 16, 2018</time></div></div></header><div class="content list__excerpt post__content clearfix">怎样使用 curses 来绘制终端屏幕？</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-9335-1.html><img class=thumbnail__image src=/data/attachment/album/201802/11/231211xv52948zv3sf242f.png.thumb.jpg alt="TensorFlow 的简单例子"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-9335-1.html rel=bookmark>TensorFlow 的简单例子</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2018-02-11T23:12:08Z>February 11, 2018</time></div></div></header><div class="content list__excerpt post__content clearfix">在本文中，我们将看一些 TensorFlow 的例子，并从中感受到在定义张量和使用张量做数学计算方面有多么容易，我还会举些别的机器学习相关的例子。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-9276-1.html><img class=thumbnail__image src=/data/attachment/album/201801/25/134655pdy41fvu7f6ln61k.jpg.thumb.jpg alt="三步上手 GDB"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-9276-1.html rel=bookmark>三步上手 GDB</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2018-01-25T13:48:07Z>January 25, 2018</time></div></div></header><div class="content list__excerpt post__content clearfix">调试 C 程序，曾让我很困扰。然而当我之前在写我的操作系统时，我有很多的 Bug 需要调试。我很幸运的使用上了 qemu 模拟器，它允许我将调试器附加到我的操作系统。这个调试器就是 gdb。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-9273-1.html><img class=thumbnail__image src=/data/attachment/album/201801/24/114629wxzw91rhxshvr1h2.jpg.thumb.jpg alt=ftrace：跟踪你的内核函数！></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-9273-1.html rel=bookmark>ftrace：跟踪你的内核函数！</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2018-01-24T11:46:58Z>January 24, 2018</time></div></div></header><div class="content list__excerpt post__content clearfix">ftrace 是一个 Linux 内核特性，它可以让你去跟踪 Linux 内核的函数调用。为什么要这么做呢？好吧，假设你调试一个奇怪的问题，而你已经得到了你的内核版本中这个问题在源代码中的开始的位置，而你想知道这里到底发生了什么？</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-9255-1.html><img class=thumbnail__image src=/data/attachment/album/201801/18/184936hk1nkta39t714jt1.jpg.thumb.jpg alt=剖析内存中的程序之秘></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-9255-1.html rel=bookmark>剖析内存中的程序之秘</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2018-01-18T18:49:41Z>January 18, 2018</time></div></div></header><div class="content list__excerpt post__content clearfix">我将从实践出发着眼于内存管理，并深入到它的内部结构。虽然这些概念很通用，但示例大都来自于 32 位 x86 架构的 Linux 和 Windows 上。这第一篇文章描述了在内存中程序如何分布。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-9214-1.html><img class=thumbnail__image src=/data/attachment/album/201801/07/215600pzw0opqvicrvq85z.jpg.thumb.jpg alt="Gitlab CI 常规介绍"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-9214-1.html rel=bookmark>Gitlab CI 常规介绍</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2018-01-09T08:47:00Z>January 09, 2018</time></div></div></header><div class="content list__excerpt post__content clearfix">Gitlab CI 是一个功能非常强大的持续集成系统，有很多不同的功能，而且每次发布都会增加新的功能。它的技术文档也很丰富，但是对那些要在已经配置好的 Gitlab 上使用它的用户来说，它缺乏一个一般性介绍。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-9176-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201712/26/153323ahv8v9bdotohwdtu.png.thumb.jpg alt="GIT 命令“从初学到专业”完整进阶指南"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-9176-1.html rel=bookmark>GIT 命令“从初学到专业”完整进阶指南</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-12-28T10:29:00Z>December 28, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">本教程，我们将讨论如何使用 git，比如与 git 一起使用的各种命令。所以我们开始吧。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-9169-1.html><img class=thumbnail__image src=/data/attachment/album/201712/24/214230mevm8eqvmmqmvvhv.jpg.thumb.jpg alt="动态连接的诀窍：使用 LD_PRELOAD 去欺骗、注入特性和研究程序"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-9169-1.html rel=bookmark>动态连接的诀窍：使用 LD_PRELOAD 去欺骗、注入特性和研究程序</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-12-24T21:42:40Z>December 24, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">我将向你展示一个基本的诀窍，在很大程度上你可以去影响大多数程序的行为，它并不仅是好玩，在有时候也很有用。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-9158-1.html><img class=thumbnail__image src=/data/attachment/album/201712/19/231406e6dheghg1wcdaqg6.jpg.thumb.jpg alt="Neo4j 和图数据库起步"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-9158-1.html rel=bookmark>Neo4j 和图数据库起步</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-12-19T23:14:00Z>December 19, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">我们将安装 Neo4j 并通过网页客户端在图中插入并查询数据。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-9154-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201712/17/185201amly37pj9r33ph5j.png.thumb.jpg alt="Django ORM 简介"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-9154-1.html rel=bookmark>Django ORM 简介</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-12-17T18:51:56Z>December 17, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">学习怎么去使用 Python 的 web 框架中的对象关系映射与你的数据库交互，就像你使用 SQL 一样。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-9142-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201712/13/232720zg4qcuccgx7xcncm.jpg.thumb.jpg alt="怎么使用 SVG 作为一个图像占位符"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-9142-1.html rel=bookmark>怎么使用 SVG 作为一个图像占位符</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-12-13T23:27:00Z>December 13, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">在这篇文章中我们将涉及如下的主题：不同的占位符类型的概述；基于 SVG 的占位符（边缘、形状和轮廓）；自动化处理。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-9117-1.html><img class=thumbnail__image src=/data/attachment/album/201712/06/162148e551uz4iyjotimib.jpg.thumb.jpg alt=并发服务器（三）：事件驱动></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-9117-1.html rel=bookmark>并发服务器（三）：事件驱动</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-12-08T10:20:00Z>December 08, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">另一种常见的实现并发的方法叫做 事件驱动编程，也可以叫做 异步 编程 。这种方法变化万千，因此我们会从最基本的开始，使用一些基本的 API 而非从封装好的高级方法开始。本系列以后的文章会讲高层次抽象，还有各种混合的方法。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-9089-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201711/28/230423v9yp293hhfafy0vf.jpg.thumb.jpg alt="用 coredumpctl 更好地记录 bug"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-9089-1.html rel=bookmark>用 coredumpctl 更好地记录 bug</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-11-28T23:04:18Z>November 28, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">通常开发者要求提供 “回溯（backtrace）” 形式的数据，以显示导致崩溃的指令流。开发人员可以使用它来修复 bug 以改进系统。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-9074-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201711/22/152437d7w0kwfb4rw27kc2.jpg.thumb.jpg alt=肯特·贝克：改变人生的代码整理魔法></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-9074-1.html rel=bookmark>肯特·贝克：改变人生的代码整理魔法</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-11-22T15:24:42Z>November 22, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">本周我一直在整理 Facebook 代码，而且我喜欢这个工作。我的职业生涯中已经整理了数千小时的代码，我有一套使这种整理更加安全、有趣和高效的规则。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-9071-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201711/20/084125nss5x4ubwbpayyky.jpg.thumb.jpg alt="通过构建一个简单的掷骰子游戏去学习怎么用 Python 编程"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-9071-1.html rel=bookmark>通过构建一个简单的掷骰子游戏去学习怎么用 Python 编程</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-11-20T08:41:00Z>November 20, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">不论是经验丰富的老程序员，还是没有经验的新手，Python 都是一个非常好的编程语言。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-9044-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201711/09/180208dcnhwgbjbx1c1sc1.jpg.thumb.jpg alt=如何分析博客中最流行的编程语言></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-9044-1.html rel=bookmark>如何分析博客中最流行的编程语言</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-11-09T18:02:00Z>November 09, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">我一直在想，各种各样的博客每天到底都有多少页面浏览量，以及在博客阅读受众中最受欢迎的是什么编程语言。我也很感兴趣的是，它们在谷歌的网站排名是否与它们的受欢迎程度直接相关。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-9030-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201711/03/214537at1dsdt1tmoddaf2.png.thumb.jpg alt="三种 Python 网络内容抓取工具与爬虫"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-9030-1.html rel=bookmark>三种 Python 网络内容抓取工具与爬虫</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-11-03T21:45:33Z>November 03, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">运用这些很棒的 Python 爬虫工具来获取你需要的数据。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-9008-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201710/29/221744os0mqqlovvv0gdlm.jpg.thumb.jpg alt="每个安卓开发初学者应该了解的 12 个技巧"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-9008-1.html rel=bookmark>每个安卓开发初学者应该了解的 12 个技巧</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-10-29T22:17:43Z>October 29, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">在这篇文章里，我们将介绍一些初学者以及中级开发人员都应该掌握的技巧，以帮助更好地理解安卓框架。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8992-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201710/23/233346q2rwp5pozbopfgij.png.thumb.jpg alt="JavaScript 函数式编程介绍"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8992-1.html rel=bookmark>JavaScript 函数式编程介绍</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-10-26T08:30:00Z>October 26, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">探索函数式编程，通过它让你的程序更具有可读性和易于调试</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-9002-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201710/25/222024zb32ugz3j6zb83p1.jpg.thumb.jpg alt=并发服务器（二）：线程></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-9002-1.html rel=bookmark>并发服务器（二）：线程</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-10-26T08:19:00Z>October 26, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">这一节里，我们来看看怎么用多线程来实现并发，用 C 实现一个最简单的多线程服务器，和用 Python 实现的线程池。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8993-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201710/24/115622i0oaajarc8aaryn6.jpg.thumb.jpg alt=并发服务器（一）：简介></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8993-1.html rel=bookmark>并发服务器（一）：简介</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-10-25T09:46:00Z>October 25, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">这是关于并发网络服务器编程的第一篇教程。我计划测试几个主流的、可以同时处理多个客户端请求的服务器并发模型，基于可扩展性和易实现性对这些模型进行评判。所有的服务器都会监听套接字连接，并且实现一些简单的协议用于与客户端进行通讯。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8987-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201710/22/205831m4we17ipgm7e66us.jpg.thumb.jpg alt=构建你的数据科学作品集：用数据讲故事></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8987-1.html rel=bookmark>构建你的数据科学作品集：用数据讲故事</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-10-22T21:01:00Z>October 22, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">数据科学公司们在决定雇佣一个人时越来越看重其作品集。其中一个原因就是作品集是分析一个人真实技能的最好方式。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8984-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201710/21/232332dxjaxwomx2xjmxbt.png.thumb.jpg alt="如何像 NASA 顶级程序员一样编程 —— 10 条重要原则"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8984-1.html rel=bookmark>如何像 NASA 顶级程序员一样编程 —— 10 条重要原则</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-10-21T23:23:00Z>October 21, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">你知道 NASA 顶级程序员如何编写关键任务代码么？为了确保代码更清楚、更安全、且更容易理解，NASA  的喷气推进实验室制定了 10 条编码规则。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8969-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201710/17/154427lifqhohyri5frun0.jpg.thumb.jpg alt="OpenGL 与 Go 教程（三）实现游戏"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8969-1.html rel=bookmark>OpenGL 与 Go 教程（三）实现游戏</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-10-18T09:43:00Z>October 18, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">到目前为止，你应该懂得如何创建网格系统以及创建代表方格中每一个单元的格子阵列。现在可以开始把网格当作游戏面板实现康威生命游戏。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8951-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201710/12/132540ni4mi77xmr2m27x2.png.thumb.jpg alt="用 C 语言对 Gtk+ 应用进行功能测试"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8951-1.html rel=bookmark>用 C 语言对 Gtk+ 应用进行功能测试</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-10-12T13:25:38Z>October 12, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">这个简单教程教你如何测试你应用的功能。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8943-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201710/08/223932vag1ajxuusf9zjfo.jpg.thumb.jpg alt="开发一个 Linux 调试器（十）：高级主题"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8943-1.html rel=bookmark>开发一个 Linux 调试器（十）：高级主题</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-10-12T10:38:00Z>October 12, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">我将对调试中的一些更高级的概念进行高层的概述：远程调试、共享库支持、表达式计算和多线程支持。这些想法实现起来比较复杂，所以我不会详细说明如何做</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8950-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201710/12/090409dpfqygzrpzuhpnqd.jpg.thumb.jpg alt="关于 HTML5 你需要了解的基础知识"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8950-1.html rel=bookmark>关于 HTML5 你需要了解的基础知识</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-10-12T09:04:00Z>October 12, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">HTML5 是第五个且是当前的 HTML 版本，它是用于在万维网上构建和呈现内容的标记语言。本文将帮助读者了解它。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8946-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201710/10/170748tur07mwv03qd23ow.jpg.thumb.jpg alt="12 件可以用 GitHub 完成的很酷的事情"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8946-1.html rel=bookmark>12 件可以用 GitHub 完成的很酷的事情</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-10-10T17:08:00Z>October 10, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">我希望这里至少有三件事是你此前并不知道的……</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8937-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201710/07/223453r5tqot1qsp0s6ga6.jpg.thumb.jpg alt="OpenGL 与 Go 教程（二）绘制游戏面板"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8937-1.html rel=bookmark>OpenGL 与 Go 教程（二）绘制游戏面板</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-10-07T22:35:00Z>October 07, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">你现在应该能够创造一个漂亮的白色三角形，但我们不会把三角形当成我们游戏的基本单元，是时候把三角形变成正方形了，然后我们会做出一个完整的方格。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8936-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201710/06/180943lioqi6q6ortjfur0.jpg.thumb.jpg alt="开发一个 Linux 调试器（九）：处理变量"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8936-1.html rel=bookmark>开发一个 Linux 调试器（九）：处理变量</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-10-06T18:10:00Z>October 06, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">变量是偷偷摸摸的。有时，它们会很高兴地呆在寄存器中，但是一转头就会跑到堆栈中。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8935-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201710/06/111305ltswozo3cmicl3z6.png.thumb.jpg alt="论 HTTP 性能，Go 与 .NET Core 一争雌雄"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8935-1.html rel=bookmark>论 HTTP 性能，Go 与 .NET Core 一争雌雄</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-10-06T11:13:00Z>October 06, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">如前面所提的，我们会比较它们相同的东西，比如应用程序、预期响应及运行时的稳定性，所以我们不会把像对 JSON 或者 XML 的编码、解码这些烦多的事情加入比较游戏中来，仅仅只会使用简单的文本消息。为了公平起见，我们会分别使用 Go 和 .NET Core 的 MVC 架构模式。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8933-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201710/05/212715clrssdrurc8nnras.jpg.thumb.jpg alt="OpenGL 与 Go 教程（一）Hello, OpenGL"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8933-1.html rel=bookmark>OpenGL 与 Go 教程（一）Hello, OpenGL</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-10-05T21:27:00Z>October 05, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">这个教程的目的是给你一个切入点，让你对 OpenGL 有个基本的了解，然后教你怎么用 Go 操作它。我们最终的目标是用 OpenGL 在桌面窗口绘制游戏面板，进而实现康威生命游戏。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8930-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201710/04/165839gmb9iqdiee2bh3m5.jpg.thumb.jpg alt="开发一个 Linux 调试器（八）：堆栈展开"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8930-1.html rel=bookmark>开发一个 Linux 调试器（八）：堆栈展开</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-10-04T16:59:47Z>October 04, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">有一个 backtrace 命令，它给你提供了程序当前的函数调用链。这篇文章将向你展示如何在 x86_64 上实现堆栈展开以生成这样的回溯。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8922-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201709/30/210213z2e6jblskrsueuzr.jpg.thumb.jpg alt="从 Node 到 Go：一个粗略的比较"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8922-1.html rel=bookmark>从 Node 到 Go：一个粗略的比较</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-10-01T08:46:00Z>October 01, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">这个帖子不是为了证明一种语言比另一种语言更好。由于各种原因，每种编程语言都在软件开发社区中占有一席之地。 我的意图是强调 Go 和 Node 之间的差异，并且促进展示一种新的 Web 开发语言。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8920-1.html><img class=thumbnail__image src=/data/attachment/album/201709/29/153923vd38iudidk83zmt0.jpg.thumb.jpg alt="探索传统 JavaScript 基准测试"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8920-1.html rel=bookmark>探索传统 JavaScript 基准测试</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-09-29T15:40:00Z>September 29, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">现在看看另一方面，所有的静态性能测试——无论是微基准micro-benchmark还是大型应用的宏基准macro-benchmark，都注定要随着时间的推移变成噩梦！</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8907-1.html><img class=thumbnail__image src=/data/attachment/album/201709/28/063459ft521u5xl7u2nfg5.png.thumb.jpg alt=机器学习实践指南></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8907-1.html rel=bookmark>机器学习实践指南</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-09-28T06:34:58Z>September 28, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">在今天的文档中，我会列出 7 个步骤（和 50 多个资源）帮助你开启这个令人兴奋的计算机科学领域的大门，并逐渐成为一个机器学习高手。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8900-1.html><img class=thumbnail__image src=/data/attachment/album/201709/24/150421z8qnabqpphbs1a8o.jpg.thumb.jpg alt="常用 GDB 命令中文速览"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8900-1.html rel=bookmark>常用 GDB 命令中文速览</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-09-24T15:04:31Z>September 24, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">本文整理自《Debugging with GDB: the GNU Source-Level Debugger for GDB (GDB)》</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8890-1.html><img class=thumbnail__image src=/data/attachment/album/201709/22/093850q8zlc89bpd1idpkc.jpg.thumb.jpg alt="开发一个 Linux 调试器（七）：源码级断点"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8890-1.html rel=bookmark>开发一个 Linux 调试器（七）：源码级断点</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-09-22T09:39:25Z>September 22, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">这篇文章将会添加源码级断点到我们的调试器中。通过所有我们已经支持的功能，这要比起最初听起来容易得多。我们还将添加一个命令来获取符号的类型和地址，这对于定位代码或数据以及理解链接概念非常有用。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8870-1.html><img class=thumbnail__image src=/data/attachment/album/201709/16/115559adfoyopxdy6v95oc.jpg.thumb.jpg alt="减少 curl 中内存分配操作（malloc）"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8870-1.html rel=bookmark>减少 curl 中内存分配操作（malloc）</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-09-16T11:55:51Z>September 16, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">今天我在 libcurl 内部又做了一个小改动，使其做更少的 malloc。这一次，泛型链表函数被转换成更少的 malloc (这才是链表函数应有的方式，真的)。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8869-1.html><img class=thumbnail__image src=/data/attachment/album/201709/15/135403erbbhprllibyy6lr.png.thumb.jpg alt=函数式编程简介></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8869-1.html rel=bookmark>函数式编程简介</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-09-15T13:53:59Z>September 15, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">我们来解释函数式编程的什么，它的优点是哪些，并且给出一些函数式编程的学习资源。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8861-1.html><img class=thumbnail__image src=/data/attachment/album/201709/12/150805oxtnywgwkgwct55k.png.thumb.jpg alt="使用 Headless Chrome 进行自动化测试"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8861-1.html rel=bookmark>使用 Headless Chrome 进行自动化测试</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-09-12T15:08:00Z>September 12, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">如果你想使用 Headless Chrome 进行自动化测试，那么就往下！这篇文章将让你完全使用 Karma 作为运行器（runner），并且使用 Mocha+Chai 来编撰测试。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8855-1.html><img class=thumbnail__image src=/data/attachment/album/201709/10/145704nfxpb1k1z9hkfumf.jpg.thumb.jpg alt=如何使用拉取请求（PR）来改善你的代码审查></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8855-1.html rel=bookmark>如何使用拉取请求（PR）来改善你的代码审查</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-09-10T14:57:02Z>September 10, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">通过使用 GitHub 的拉取请求（Pull Request）正确地进行代码审核，把时间更多的花在构建上，而在修复上少用点时间。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8850-1.html><img class=thumbnail__image src=/data/attachment/album/201709/08/113337g9jjamqsizxmie3s.png.thumb.jpg alt="Headless Chrome 入门"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8850-1.html rel=bookmark>Headless Chrome 入门</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-09-08T11:34:00Z>September 08, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">在 Chrome 59　中开始搭载 Headless Chrome。这是一种在无需显示的环境下运行 Chrome 浏览器的方式。从本质上来说，就是不用 chrome 浏览器来运行 Chrome 的功能！它将 Chromium 和 Blink 渲染引擎提供的所有现代 Web 平台的功能都带入了命令行。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8845-1.html><img class=thumbnail__image src=/data/attachment/album/201709/07/093809kb68i4bnllnnsqyg.jpg.thumb.jpg alt="编译器简介： 在 Siri 前时代如何与计算机对话"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8845-1.html rel=bookmark>编译器简介： 在 Siri 前时代如何与计算机对话</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-09-07T09:41:00Z>September 07, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">简单说来，一个编译器（compiler）不过是一个可以翻译其他程序的程序。传统的编译器可以把源代码翻译成你的计算机能够理解的可执行机器代码。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8844-1.html><img class=thumbnail__image src=/data/attachment/album/201709/06/093641llo033walz5k70pk.png.thumb.jpg alt="我对 Go 的错误处理有哪些不满，以及我是如何处理的"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8844-1.html rel=bookmark>我对 Go 的错误处理有哪些不满，以及我是如何处理的</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-09-06T09:36:00Z>September 06, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">写 Go 的人往往对它的错误处理模式有一定的看法。按不同的语言经验，人们可能有不同的习惯处理方法。这就是为什么我决定要写这篇文章，尽管有点固执己见，但我认为听取我的经验是有用的。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8841-1.html><img class=thumbnail__image src=/data/attachment/album/201709/05/142738ef9g209isze0fmv2.png.thumb.jpg alt="一周工作所用的日常 Git 命令"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8841-1.html rel=bookmark>一周工作所用的日常 Git 命令</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-09-05T16:23:00Z>September 05, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">几乎每个开发人员都在使用 Git，当然很可能是 GitHub。但大多数开发者大概有 99％ 的时间只是使用这三个命令</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8824-1.html><img class=thumbnail__image src=/data/attachment/album/201708/30/233911yju25o44rc53x49f.jpg.thumb.jpg alt=听说过时间表，但是你是否知道“哈希表”></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8824-1.html rel=bookmark>听说过时间表，但是你是否知道“哈希表”</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-08-31T08:00:00Z>August 31, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">探索哈希表（hash table）的世界并理解其底层的机制是非常有趣的，并且将会受益匪浅。所以，让我们了解它，并从头开始探索吧。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8819-1.html><img class=thumbnail__image src=/data/attachment/album/201708/29/081540gi5br5ma5tt5urud.png.thumb.jpg alt="如何恢复丢弃的 git stash 数据"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8819-1.html rel=bookmark>如何恢复丢弃的 git stash 数据</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-08-29T08:15:00Z>August 29, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">不要让 git 命令中的错误抹去你数天的工作</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8813-1.html><img class=thumbnail__image src=/data/attachment/album/201708/26/182207drf4dydz6xpyc5jd.jpg.thumb.jpg alt="开发一个 Linux 调试器（六）：源码级逐步执行"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8813-1.html rel=bookmark>开发一个 Linux 调试器（六）：源码级逐步执行</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-08-28T10:21:00Z>August 28, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">在前几篇博文中我们学习了 DWARF 信息以及它如何使我们将机器码和上层源码联系起来。这一次我们通过为我们的调试器添加源码级逐步调试将该知识应用于实际。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8812-1.html><img class=thumbnail__image src=/data/attachment/album/201708/26/175338u3rarihzal14s8sg.jpg.thumb.jpg alt="开发一个 Linux 调试器（五）：源码和信号"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8812-1.html rel=bookmark>开发一个 Linux 调试器（五）：源码和信号</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-08-26T17:55:00Z>August 26, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">在这一部分，我们将进入实践，实现一些我们调试器后面会使用的 DWARF 原语。我们也会利用这个机会，使我们的调试器可以在命中一个断点时打印出当前的源码上下文。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8787-1.html><img class=thumbnail__image src=/data/attachment/album/201708/17/150211n9wjnx9pk91f4wtk.png.thumb.jpg alt="用 R 收集和映射推特数据的初学者向导"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8787-1.html rel=bookmark>用 R 收集和映射推特数据的初学者向导</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-08-17T15:02:07Z>August 17, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">学习使用 R 的 twitteR 和 leaflet 包, 你就可以把任何话题的推文定位画在地图上。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8780-1.html><img class=thumbnail__image src=/data/attachment/album/201708/16/000829y5u4wm1kou8d55z6.jpg.thumb.jpg alt="学习用 Python 编程时要避免的 3 个错误"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8780-1.html rel=bookmark>学习用 Python 编程时要避免的 3 个错误</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-08-16T08:58:00Z>August 16, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">为了让初学 Python 的程序员避免犯同样的错误，以下列出了我学习 Python 时犯的三种错误。这些错误要么是我长期以来经常犯的，要么是造成了需要几个小时解决的麻烦。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8774-1.html><img class=thumbnail__image src=/data/attachment/album/201708/13/132032snqnbgkvt7spgtgb.png.thumb.jpg alt="一篇缺失的 TypeScript 介绍"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8774-1.html rel=bookmark>一篇缺失的 TypeScript 介绍</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-08-13T13:24:07Z>August 13, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">本文的主旨是为了介绍我们是如何看待 TypeScript 的以及它在加强 JavaScript 开发中所起的作用。
我们也将尽可能地给出那些类型和编译方面的那些时髦词汇的准确定义。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8773-1.html><img class=thumbnail__image src=/data/attachment/album/201708/12/183025r3x6x37axwc33e63.jpg.thumb.jpg alt=响应式编程与响应式系统></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8773-1.html rel=bookmark>响应式编程与响应式系统</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-08-12T18:30:00Z>August 12, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">在恒久的迷惑与过多期待的海洋中，登上一组简单响应式设计原则的小岛。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8728-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201707/27/151320s28j8eep22rxee3x.jpg.thumb.jpg alt="Neo4j 图数据库基础"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8728-1.html rel=bookmark>Neo4j 图数据库基础</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-07-27T15:13:00Z>July 27, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">对于海量的各种非结构化信息来说，图数据库已经成为帮助收集、管理和搜索大量数据的技术。在本文中，我将向你展示图数据库的基础知识，帮助你快速了解概念模型。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8719-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201707/24/143821f1phescz20gc8thf.jpg.thumb.jpg alt="开发一个 Linux 调试器（四）：Elves 和 dwarves"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8719-1.html rel=bookmark>开发一个 Linux 调试器（四）：Elves 和 dwarves</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-07-24T14:41:03Z>July 24, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">今天我们会详细介绍源码级的调试信息，作为本指南后面部分使用它的准备。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8705-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201707/18/194802yb63zpb2s2pa0g3s.jpg.thumb.jpg alt="使用 Apex 和 Compose MongoDB 开发 serverless"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8705-1.html rel=bookmark>使用 Apex 和 Compose MongoDB 开发 serverless</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-07-18T19:48:08Z>July 18, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">和大多数事物一样，Apex 和 Lambda 并不是在所有场景下都完美。 但是，在你的工具箱中增加一个完全不需要你来管理底层建设的工具完全没有坏处。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8701-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201707/16/211658sfpp9oa761q4374o.jpg.thumb.jpg alt=如何为安卓开发搭建一个持续集成（CI）服务器></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8701-1.html rel=bookmark>如何为安卓开发搭建一个持续集成（CI）服务器</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-07-17T09:09:00Z>July 17, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">写这篇文章我主要想总结一下安装步骤，好给自己以后作参考，当然，这篇文章也是给同行看的，只要他们感兴趣。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8663-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201707/03/231153g7abc3nedej477u8.jpg.thumb.jpg alt="开发一个 Linux 调试器（三）：寄存器和内存"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8663-1.html rel=bookmark>开发一个 Linux 调试器（三）：寄存器和内存</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-07-04T08:08:00Z>July 04, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">上一篇博文中我们给调试器添加了一个简单的地址断点。这次，我们将添加读写寄存器和内存的功能，这将使我们能够使用我们的程序计数器、观察状态和改变程序的行为。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8645-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201706/27/085227v29kih3cftuftnk5.jpg.thumb.jpg alt="开发一个 Linux 调试器（二）：断点"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8645-1.html rel=bookmark>开发一个 Linux 调试器（二）：断点</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-06-27T08:53:00Z>June 27, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">在这篇博客中，我们会学习在 x86 Linux 上断点是如何工作的，以及如何给我们工具添加设置断点的能力。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8635-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201706/24/215524k9caxmcp8c3ppa39.jpg.thumb.jpg alt="使用 Go 一年的体验"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8635-1.html rel=bookmark>使用 Go 一年的体验</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-06-25T08:51:00Z>June 25, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">在使用 Go 一年之后，我们想要分享我们将一个小小的实验变成处理百万日志的生产服务器的一些想法和经验。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8626-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201706/21/101354vkucgly8917c97g1.jpg.thumb.jpg alt="开发一个 Linux 调试器（一）：准备环境"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8626-1.html rel=bookmark>开发一个 Linux 调试器（一）：准备环境</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-06-21T10:14:00Z>June 21, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">尽管调试器已经得到了广泛的使用，却并没有太多的资源告诉你它们的工作原理以及如何开发，尤其是和其它那些比如编译器等工具链技术相比而言。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8607-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201706/15/052446sud033e31e3wnk0d.jpg.thumb.jpg alt="许多 SQL 性能问题来自于“不必要的强制性工作”"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8607-1.html rel=bookmark>许多 SQL 性能问题来自于“不必要的强制性工作”</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-06-15T08:17:00Z>June 15, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">在编写高效 SQL 时，你可能遇到的最有影响的事情就是索引。但是，一个很重要的事实就是很多 SQL 客户端要求数据库做很多“不必要的强制性工作”。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8604-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201706/13/174644t3bpa2ra424e24e3.jpg.thumb.jpg alt="机器学习的新捷径：通过 SYCL 在 GPU 上加速 C++"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8604-1.html rel=bookmark>机器学习的新捷径：通过 SYCL 在 GPU 上加速 C++</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-06-13T17:47:00Z>June 13, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">不幸的是，对于日常程序员，OpenCL 的学习曲线陡峭；一个简单的 Hello World 程序可能就需要上百行晦涩难懂的代码。因此，为了减轻这种痛苦，Khronos 组织已经开发了一个称为 SYCL 的新标准，这是一个在 OpenCL 之上的 C++ 抽象层。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8600-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201706/12/081112zzoqhsylo41ujshq.jpg.thumb.jpg alt="掌握 Git 之美"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8600-1.html rel=bookmark>掌握 Git 之美</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-06-12T08:15:00Z>June 12, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">使用 7 条简单的 Git 命令开始你的软件开发之旅</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8582-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201706/07/091219dd15wiwukzlubid0.png.thumb.jpg alt="使用 Python 开始你的机器学习之旅"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8582-1.html rel=bookmark>使用 Python 开始你的机器学习之旅</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-06-07T09:12:16Z>June 07, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">从无人驾驶汽车到股市预测，再到在线学习，机器学习通过预测来进行自我提高的方法几乎被用在了每一个领域。由于机器学习的实际运用，目前它已经成为就业市场上最有需求的技能之一。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8579-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201706/06/012000szsjjsm4zobh4xho.jpg.thumb.jpg alt=调试器工作原理（三）：调试信息></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8579-1.html rel=bookmark>调试器工作原理（三）：调试信息</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-06-06T08:16:00Z>June 06, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">本文将解释调试器是如何在机器码中查找它将 C 语言源代码转换成机器语言代码时所需要的 C 语言函数、变量、与数据。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8564-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201706/02/010040jzhp12rlrd2lhktp.jpg.thumb.jpg alt="在 Go 中如何使用切片的容量和长度"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8564-1.html rel=bookmark>在 Go 中如何使用切片的容量和长度</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-06-02T09:49:00Z>June 02, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">在 Go 中同时有数组（array）和切片（slice）。这可能令人困惑，但一旦你习惯了，你会喜欢上它。请相信我。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8552-1.html><img class=thumbnail__image src=/data/attachment/album/201705/29/160211nhmvqbbbpyg8x64q.jpg.thumb.jpg alt=调试器工作原理（二）：断点></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8552-1.html rel=bookmark>调试器工作原理（二）：断点</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-05-29T16:02:00Z>May 29, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">我将会演示如何在调试器中实现断点。断点是调试的两大利器之一，另一个是可以在被调试进程的内存中检查变量值。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8543-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201705/26/171240oyoy6kvyyocgkkky.png.thumb.jpg alt="Go 语言日志指南"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8543-1.html rel=bookmark>Go 语言日志指南</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-05-26T17:15:02Z>May 26, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">你是如何使用 Golang 日志监控你的应用程序的呢？Golang 没有异常，只有错误。因此你的第一印象可能就是开发 Golang 日志策略并不是一件简单的事情。不支持异常事实上并不是什么问题，异常在很多编程语言中已经失去了其异常性：它们过于被滥用以至于它们的作用都被忽视了。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8524-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201705/19/111808se294h4oy3b1bobe.jpg.thumb.jpg alt="GraphQL 用例：使用 Golang 和 PostgreSQL 构建一个博客引擎 API"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8524-1.html rel=bookmark>GraphQL 用例：使用 Golang 和 PostgreSQL 构建一个博客引擎 API</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-05-19T11:18:22Z>May 19, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">我们会比较简单的 GraphQL 实现和纯 REST 替代方案，在一种普通场景（呈现博客文章页面）下对比它们的实现复杂性和效率。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8503-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201705/13/140849bur08pn7r6vwpfu9.jpg.thumb.jpg alt="GitLab 工作流概览"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8503-1.html rel=bookmark>GitLab 工作流概览</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-05-13T14:09:00Z>May 13, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">GitLab 是一个基于 git 的仓库管理程序，也是一个方便软件开发的强大完整应用。
GitLab 拥有一个“用户新人友好”的界面，通过图形界面和命令行界面，使你的工作更加具有效率。GitLab 不仅仅对开发者是一个有用的工具，它甚至可以被集成到你的整个团队中，使得每一个人获得一个独自唯一的平台。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8418-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201704/17/211733w083ii0mgwnyyi0d.jpg.thumb.jpg alt=调试器工作原理（一）：基础篇></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8418-1.html rel=bookmark>调试器工作原理（一）：基础篇</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-04-18T09:04:00Z>April 18, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">我将为大家展示 Linux 中调试器的主要构成模块 - ptrace 系统调用。这篇文章所有代码都是基于 32 位 Ubuntu 操作系统。值得注意的是，尽管这些代码是平台相关的，将它们移植到其它平台应该并不困难。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8416-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201704/17/111508k67c4f45b7bh6nnn.jpg.thumb.jpg alt=深入解析面向数据的哈希表性能></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8416-1.html rel=bookmark>深入解析面向数据的哈希表性能</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-04-17T11:16:00Z>April 17, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">最近几年中，面向数据的设计已经受到了很多的关注 —— 一种强调内存中数据布局的编程风格，包括如何访问以及将会引发多少的 cache 缺失。由于在内存读取操作中缺失所占的数量级要大于命中的数量级，所以缺失的数量通常是优化的关键标准。这不仅仅关乎那些对性能有要求的 code-data 结构设计的软件，由于缺乏对内存效益的重视而成为软件运行缓慢、膨胀的一个很大因素。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8406-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201704/15/162013lycy36ond8py6yzz.jpg.thumb.jpg alt="使用 AWS 的 GO SDK 获取区域与终端节点信息"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8406-1.html rel=bookmark>使用 AWS 的 GO SDK 获取区域与终端节点信息</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-04-15T16:20:21Z>April 15, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">最新发布的 GO 的 SDK v1.6.0 版本，加入了获取区域与终端节点信息的功能。它可以很方便地列出区域、服务和终端节点的相关信息。可以通过 github.com/aws/aws-sdk-go/aws/endpoints 包使用这些功能。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8383-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201704/07/210545tje316vixser13gi.jpg.thumb.jpg alt="JavaScript 即未来：介绍 14 个 JavaScript 的框架和库"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8383-1.html rel=bookmark>JavaScript 即未来：介绍 14 个 JavaScript 的框架和库</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-04-07T21:06:00Z>April 07, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">当今的市场需要快速开发，但是，重复造轮子是没有必要的。不论你是一个 JavaScript 新手还是一个资深的 JavaScript 开发者，使用框架和库都能极大提高你的工作效率。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8345-1.html><img class=thumbnail__image src=/data/attachment/album/201703/28/163806gkdzz3e36e3nkecn.png.thumb.jpg alt="Go 语言编译期断言"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8345-1.html rel=bookmark>Go 语言编译期断言</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-03-28T08:12:00Z>March 28, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">这篇文章是关于一个鲜为人知的让 Go 在编译期断言的方法。你可能不会使用它，但是了解一下也很有趣。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8271-1.html><img class=thumbnail__image src=/data/attachment/album/201703/06/113436faj81soj81kj6thb.jpg.thumb.jpg alt=浅述内核中“挂起到空闲”的实现></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8271-1.html rel=bookmark>浅述内核中“挂起到空闲”的实现</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-03-06T11:34:00Z>March 06, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">它主要通过软件实现。一般平台的挂起过程包括冻结用户空间并将外围设备调至低耗电模式。但是，系统并不是直接关闭和热插拔掉 CPU，而是静静地强制将 CPU 进入空闲（idle）状态。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8267-1.html><img class=thumbnail__image src=/data/attachment/album/201703/04/160319vrfrrsl2x2lrlpzp.jpg.thumb.jpg alt="一个使用 asyncio 协程的网络爬虫（三）"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8267-1.html rel=bookmark>一个使用 asyncio 协程的网络爬虫（三）</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-03-06T10:31:00Z>March 06, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">在最后一个阶段，我们将使用 Python 标准库“asyncio”中功能完整的协程， 并通过异步队列完成这个网络爬虫。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8270-1.html><img class=thumbnail__image src=/data/attachment/album/201703/06/092900g88q8nrmdnq8e9a4.jpg.thumb.jpg alt="使用 Elizabeth 为应用生成随机样本数据"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8270-1.html rel=bookmark>使用 Elizabeth 为应用生成随机样本数据</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-03-06T09:30:00Z>March 06, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">Elizabeth 以 21 个不同本地化信息提供了 18 种数据提供器，可用于生成随机信息（LCTT 译注：不仅是随机数），包括姓名和个人特征、地址、文本数据、交通信息、网络和 Internet 社交媒体数据、数字等等。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8266-1.html><img class=thumbnail__image src=/data/attachment/album/201703/04/160254v6p6n6aae1ywd5xz.jpg.thumb.jpg alt="一个使用 asyncio 协程的网络爬虫（二）"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8266-1.html rel=bookmark>一个使用 asyncio 协程的网络爬虫（二）</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-03-05T10:27:00Z>March 05, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">然后，由于 Python 的协程不仅有效而且可扩展，我们将用 Python 的生成器函数实现一个简单的协程。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8265-1.html><img class=thumbnail__image src=/data/attachment/album/201703/04/160052krxzwz2jepx15pxr.jpg.thumb.jpg alt="一个使用 asyncio 协程的网络爬虫（一）"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8265-1.html rel=bookmark>一个使用 asyncio 协程的网络爬虫（一）</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-03-04T15:59:00Z>March 04, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">首先，我们会实现一个事件循环并用这个事件循环和回调来勾画出一只网络爬虫。它很有效，但是当把它扩展成更复杂的问题时，就会导致无法管理的混乱代码。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8264-1.html><img class=thumbnail__image src=/data/attachment/album/201703/04/104753olrdy3rof336yw75.png.thumb.jpg alt="如何用 R 语言的 Shiny 库编写 web 程序"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8264-1.html rel=bookmark>如何用 R 语言的 Shiny 库编写 web 程序</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-03-04T10:48:16Z>March 04, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">Shiny 是一个来自 RStudio 的工具包，它让创建 web 程序变得更容易。它能从 R 控制台轻松安装，只需要一行，就可以加载好最新的稳定版本来使用。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8196-1.html><img class=thumbnail__image src=/data/attachment/album/201702/12/074546yq265tzih222wt1k.jpg.thumb.jpg alt="编写 android 测试单元该做的和不该做的事"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8196-1.html rel=bookmark>编写 android 测试单元该做的和不该做的事</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-02-12T11:38:00Z>February 12, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">正确的编写测试用例与编写这些测试代码同等重要。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8174-1.html><img class=thumbnail__image src=/data/attachment/album/201702/04/175653ff8gl0f5flw4f518.jpg.thumb.jpg alt="在 Linux 中如何使用 gdb 调试 C 程序"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8174-1.html rel=bookmark>在 Linux 中如何使用 gdb 调试 C 程序</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-02-04T17:56:58Z>February 04, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">GDB - 可以帮你更轻松地调试代码 bug 以及其它问题。在这篇文章中，我们将讨论一下 GDB 调试器的基础知识，包括它提供的一些有用的功能/选项。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8113-1.html><img class=thumbnail__image src=/data/attachment/album/201701/12/094625moon9fmlccxosoka.jpg.thumb.jpg alt="如何在 Docker 中设置 Go 并部署应用"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8113-1.html rel=bookmark>如何在 Docker 中设置 Go 并部署应用</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-01-12T09:46:39Z>January 12, 2017</time></div></div></header><div class="content list__excerpt post__content clearfix">在本教程中，我们将学习如何使用 docker 部署 golang web 应用程序。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8066-1.html><img class=thumbnail__image src=/data/attachment/album/201612/26/204426ezi9djn59j9jiizn.jpg.thumb.jpg alt=安卓平台上的依赖注入（一）></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8066-1.html rel=bookmark>安卓平台上的依赖注入（一）</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-12-27T08:43:00Z>December 27, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">第一种情况是我们在构造器里创建了依赖对象，但在第二种情况下，它作为参数被传递给构造器，这就是我们所说的依赖注入（dependency injection）。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8059-1.html><img class=thumbnail__image src=/data/attachment/album/201612/23/105528l26vr5ht0qt6vh60.jpg.thumb.jpg alt="Webpack 2 入门"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8059-1.html rel=bookmark>Webpack 2 入门</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-12-23T11:07:00Z>December 23, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">简单来说，Webpack 是一个 JavaScript 模块打包器。然而，自从它发布以来，它发展成为了你所有的前端代码的管理工具（或许是有意的，或许是社区的意愿）。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8052-1.html><img class=thumbnail__image src=/data/attachment/album/201612/21/233550femissn1gfi1imiz.jpg.thumb.jpg alt="用带有 Amazon Cognito Identity SDK 的 webpack 打包 JavaScript"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8052-1.html rel=bookmark>用带有 Amazon Cognito Identity SDK 的 webpack 打包 JavaScript</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-12-22T08:32:00Z>December 22, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">通过本文，你将看到如何把 AWS SDK， Amazon Cognito Identity SDK 嵌入到 JavaScript 中，以及如何使用流行的 webpack 模块打包器。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8051-1.html><img class=thumbnail__image src=/data/attachment/album/201612/21/182715ntzpokcnp0m00ytz.jpg.thumb.jpg alt="雾里看花之 Python Asyncio"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8051-1.html rel=bookmark>雾里看花之 Python Asyncio</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-12-21T18:27:00Z>December 21, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">从试用的经历来看，该模块比我预想的复杂许多，我现在可以非常肯定地说，我不知道该如何恰当地使用 asyncio。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8037-1.html><img class=thumbnail__image src=/data/attachment/album/201612/14/165430ads2yka5a5lcyx2z.jpg.thumb.jpg alt=用数据科学搭建一个实时推荐引擎></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8037-1.html rel=bookmark>用数据科学搭建一个实时推荐引擎</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-12-14T16:57:56Z>December 14, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">实时推荐引擎是 Neo4j 中最广泛的用途之一，也是使它如此强大并且容易使用的原因之一。为了探索这个东西，我将通过使用示例数据集来阐述如何将统计学方法并入这些引擎中。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8032-1.html><img class=thumbnail__image src=/data/attachment/album/201612/13/084321p0tmmzbm0x8xlcyk.jpg.thumb.jpg alt="不常见但是很有用的 GCC 命令行选项（二）"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8032-1.html rel=bookmark>不常见但是很有用的 GCC 命令行选项（二）</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-12-13T08:43:34Z>December 13, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">开发者们通常用来生成警告的 -Wall 选项，并不包括一些特殊的警告。如果你不了解这些特殊警告，并且不知道如何生成它们，不用担心，我将在这篇文章中详细讲解关于它们所有的细节。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-8025-1.html><img class=thumbnail__image src=/data/attachment/album/201612/08/205506mhw6nic6wsfihehe.jpeg.thumb.jpg alt="不常见但是很有用的 gcc 命令行选项（一）"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-8025-1.html rel=bookmark>不常见但是很有用的 gcc 命令行选项（一）</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-12-09T09:51:00Z>December 09, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">你知道，你可以让 gcc 保存每个编译阶段的输出吗？你知道用于生成警告的 -Wall 选项，它并不会包含一些特殊的警告吗？gcc 的很多命令行选项都不会经常用到，但是它们在某些特定的情况下会变得非常有用，例如，当你在调试代码的时候。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-7997-1.html><img class=thumbnail__image src=/data/attachment/album/201611/29/175130yorx11s7oo4s9r7o.png.thumb.jpg alt="Git 系列（七）：使用 Git 管理二进制大对象"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-7997-1.html rel=bookmark>Git 系列（七）：使用 Git 管理二进制大对象</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-11-29T09:36:00Z>November 29, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">Git 已经有了可以处理像多媒体文件这样的二进制大对象块（blob）的扩展。因此，今天我们会学习使用 Git 来管理所谓的二进制资产。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-7987-1.html><img class=thumbnail__image src=/data/attachment/album/201611/26/134122vaw54o3wockd1u4c.jpg.thumb.jpg alt="写一个 JavaScript 框架：比 setTimeout 更棒的定时执行"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-7987-1.html rel=bookmark>写一个 JavaScript 框架：比 setTimeout 更棒的定时执行</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-11-26T13:41:30Z>November 26, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">在这一章里，我打算讲一下在浏览器里的异步代码不同执行方式。你将了解定时器和事件循环之间的不同差异，比如 setTimeout 和 Promises。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-7965-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201611/17/134402w3zq9odzzd5sfmh0.jpg.thumb.jpg alt="JavaScript 小模块的开销"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-7965-1.html rel=bookmark>JavaScript 小模块的开销</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-11-17T13:44:16Z>November 17, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">一个大的 JavaScript 包比一百个小 JavaScript 模块要快。尽管这是事实，我依旧希望我们社区能最终发现我们所处的困境————提倡小模块的原则对开发者有利，但是对用户不利。同时希望能优化我们的工具，使得我们可以对两方面都有利。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-7943-1.html><img class=thumbnail__image src=/data/attachment/album/201611/09/130601brm3lwzy3vyphslp.jpg.thumb.jpg alt="Linux 与 Windows 的设备驱动模型对比：架构、API 和开发环境比较"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-7943-1.html rel=bookmark>Linux 与 Windows 的设备驱动模型对比：架构、API 和开发环境比较</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-11-09T13:06:00Z>November 09, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">了解这些差异以及每个系统的具体情况是为您的设备提供有效的驱动程序开发和支持的关键的第一步。我们希望这篇文章对 Windows 和 Linux 设备驱动程序开发做的对比，有助于您理解它们，并在设备驱动程序开发过程的研究中，将此作为一个伟大的起点。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-7931-1.html><img class=thumbnail__image src=/data/attachment/album/201611/03/235451klrr358u5pz8trxu.png.thumb.jpg alt="C++ 程序员 Protocol Buffers 基础指南"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-7931-1.html rel=bookmark>C++ 程序员 Protocol Buffers 基础指南</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-11-04T10:37:00Z>November 04, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">如何序列化和获取结构化的数据？Protocol buffers 是针对这个问题的一种灵活、高效、自动化的解决方案。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-7914-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201610/30/215451lzjhnhy8qquumq8n.jpg.thumb.jpg alt="Python 单元测试：assertTrue 是真值，assertFalse 是假值"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-7914-1.html rel=bookmark>Python 单元测试：assertTrue 是真值，assertFalse 是假值</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-10-31T08:48:00Z>October 31, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">，我们将介绍单元测试的布尔断言方法 assertTrue 和 assertFalse 与身份断言 assertIs 之间的区别。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-7907-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201610/28/102139w8yn68zmpl7ipzn8.jpg.thumb.jpg alt=构建你的数据科学作品集：机器学习项目></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-7907-1.html rel=bookmark>构建你的数据科学作品集：机器学习项目</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-10-28T10:21:55Z>October 28, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">数据科学公司在决定雇佣时越来越关注你在数据科学方面的作品集。这其中的一个原因是，这样的作品集是判断某人的实际技能的最好的方法。好消息是构建这样的作品集完全要看你自己。只要你在这方面付出了努力，你一定可以取得让这些公司钦佩的作品集。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-7865-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201610/15/161556nz01buuwz1gq25zw.jpg.thumb.jpg alt="制作你的第一个 Atom 文本编辑器插件"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-7865-1.html rel=bookmark>制作你的第一个 Atom 文本编辑器插件</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-10-15T16:16:22Z>October 15, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">我们将会制作一个山寨版的 Sourcerer，这是一个从 StackOverflow 查询并使用代码片段的插件。到教程结束时，你将会制作好一个将编程问题（用英语描述的）转换成获取自 StackOverflow 的代码片段的插件</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-7849-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201610/10/145649v0q1bm2a406wmkwq.png.thumb.jpg alt="内容安全策略（CSP），防御 XSS 攻击的好助手"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-7849-1.html rel=bookmark>内容安全策略（CSP），防御 XSS 攻击的好助手</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-10-10T14:58:00Z>October 10, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">CSP 对你的用户来说是尤其重要的：他们在你的网站上不再需要遭受任何的未经请求的脚本，内容或 XSS 的威胁了。对于网站维护者来说 CSP 最重要的优势就是可感知。如果你对图片来源设置了严格的规则，这时一个脚本小子尝试在你的网站上插入一张未授权来源的图片，那么这张图片就会被禁止，并且你会在第一时间收到提醒。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-7847-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201610/09/144117s2djox1sesdiviid.png.thumb.jpg alt="搭个 Web 服务器（三）"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-7847-1.html rel=bookmark>搭个 Web 服务器（三）</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-10-09T14:42:00Z>October 09, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">“你该如何让你的服务器在同一时间处理多个请求呢？”在这篇文章中，你会找到答案。系好安全带，我们要认真起来，全速前进了！</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-7832-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201610/04/075901vg9gcch17v3ghvg4.png.thumb.jpg alt="如何运用 Python 建立你的第一个 Slack 聊天机器人？"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-7832-1.html rel=bookmark>如何运用 Python 建立你的第一个 Slack 聊天机器人？</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-10-04T10:53:00Z>October 04, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">聊天机器人（Bot） 是一种像 Slack 一样的实用的互动聊天服务方式。如果你之前从来没有建立过聊天机器人，那么这篇文章提供了一个简单的入门指南，告诉你如何用 Python 结合 Slack API 建立你第一个聊天机器人。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-7828-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201610/02/182222bybyjg2sk3sm3q2k.png.thumb.jpg alt="零配置部署 React"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-7828-1.html rel=bookmark>零配置部署 React</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-10-02T18:22:20Z>October 02, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">你想使用 React 来构建应用吗？“入门”是很容易的，可是接下来呢？</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-7825-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201610/01/191407toztmksy76nei0t8.jpg.thumb.jpg alt="Instagram 基于 Python 语言的 Web Service 效率提升之道"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-7825-1.html rel=bookmark>Instagram 基于 Python 语言的 Web Service 效率提升之道</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-10-01T19:14:38Z>October 01, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">在过去的六个月，我们已经能够做到无需向我们的 Django 层（Django tiers）添加新的容量来维持我们的用户增长。我们将在本文分享一些由我们构建的工具以及如何使用它们来优化我们的日常部署流程。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-7805-1.html><img class=thumbnail__image src=/data/attachment/album/201609/24/232134nq95qeq4q51f899t.jpg.thumb.jpg alt="Ohm：用两百行 JavaScript 创造你自己的编程语言"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-7805-1.html rel=bookmark>Ohm：用两百行 JavaScript 创造你自己的编程语言</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-09-25T09:00:00Z>September 25, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">我们将探索一种叫做 Ohm 的新的开源库，它使得搭建解析器很简单并且易于重用。在这个系列里，我们使用 Ohm 去识别数字，构建一个计算器等等。在这个系列的最后你将已经用不到 200 行的代码发明了一种完整的编程语言。这个强大的工具将让你能够做到一些你可能过去认为不可能的事情。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-7800-1.html><img class=thumbnail__image src=/data/attachment/album/201609/23/064707gewg8xhse8oygghg.jpg.thumb.jpg alt="Git 系列（六）：如何搭建你自己的 Git 服务器"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-7800-1.html rel=bookmark>Git 系列（六）：如何搭建你自己的 Git 服务器</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-09-23T08:34:00Z>September 23, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">现在我们将要学习如何搭建 git 服务器，如何编写自定义的 Git 钩子来在特定的事件触发相应的动作（例如通知），或者是发布你的代码到一个站点。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-7793-1.html><img class=thumbnail__image src=/data/attachment/album/201609/20/152441d6zf0gfh0kivkfym.jpg.thumb.jpg alt="使用 Python 和 Asyncio 编写在线多人游戏（三）"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-7793-1.html rel=bookmark>使用 Python 和 Asyncio 编写在线多人游戏（三）</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-09-20T15:25:00Z>September 20, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">说实话，我十分享受 Python 最新的异步特性。新的语法做了改善，所以异步代码很容易阅读。可以明显看出哪些调用是非阻塞的，什么时候发生 greenthread 的切换。所以现在我可以宣称 Python 是异步编程的好工具。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-7784-1.html><img class=thumbnail__image src=/data/attachment/album/201609/18/114551xlyhloh0lxxcy9yn.jpg.thumb.jpg alt="使用 Python 和 Asyncio 编写在线多用人游戏（二）"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-7784-1.html rel=bookmark>使用 Python 和 Asyncio 编写在线多用人游戏（二）</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-09-18T11:47:00Z>September 18, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">游戏循环是每一个游戏的核心。它持续地运行以读取玩家的输入、更新游戏的状态，并且在屏幕上渲染游戏结果。在在线游戏中，游戏循环分为客户端和服务端两部分，所以一般有两个循环通过网络通信。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-7767-1.html><img class=thumbnail__image src=/data/attachment/album/201609/14/063325kqmx47j79v9a7egm.jpg.thumb.jpg alt="使用 Python 和 Asyncio 编写在线多人游戏（一）"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-7767-1.html rel=bookmark>使用 Python 和 Asyncio 编写在线多人游戏（一）</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-09-14T06:35:00Z>September 14, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">最近版本的 Python 对 asyncio 的引入和一个特别的 async/await 语法使得异步代码看起来像常规的阻塞代码一样，这使得 Python 成为了一个值得信赖的异步编程语言，所以我将尝试利用这些新特点来创建一个多人在线游戏。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-7765-1.html><img class=thumbnail__image src=/data/attachment/album/201609/13/004302ds55mn8z48je4elv.jpg.thumb.jpg alt="从零构建一个简单的 Python 框架"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-7765-1.html rel=bookmark>从零构建一个简单的 Python 框架</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-09-13T08:25:00Z>September 13, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">这篇文章旨在通过对设计和实现过程一步一步的阐述告诉读者，我在完成一个小型的服务器和框架之后学到了什么。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-7761-1.html><img class=thumbnail__image src=/data/attachment/album/201609/12/072628yni9gnqi3fize9fg.jpg.thumb.jpg alt="使用 Github Pages 发布你的项目文档"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-7761-1.html rel=bookmark>使用 Github Pages 发布你的项目文档</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-09-12T07:26:38Z>September 12, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">你可能比较熟悉如何用 Github Pages 来分享你的工作，又或许你看过一堂教你建立你的第一个 Github Pages 网站的教程。近期 Github Pages 的改进使得从不同的数据源来发布您的网站更加的方便，其中的来源之一就是你的仓库的 /docs 目录。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-7753-1.html><img class=thumbnail__image src=/data/attachment/album/201609/08/141608t7xxxasobisyzxm0.jpg.thumb.jpg alt="用 Python 实现 Python 解释器"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-7753-1.html rel=bookmark>用 Python 实现 Python 解释器</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-09-08T14:16:18Z>September 08, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">Byterun 是一个用 Python 实现的 Python 解释器。随着我对 Byterun 的开发，我惊喜地的发现，这个 Python 解释器的基础结构用 500 行代码就能实现。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-7742-1.html><img class=thumbnail__image src=/data/attachment/album/201609/03/000942s383wh8kbmgfb7hz.jpg.thumb.jpg alt="MySQL 中你应该使用什么数据类型表示时间？"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-7742-1.html rel=bookmark>MySQL 中你应该使用什么数据类型表示时间？</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-09-03T08:01:00Z>September 03, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">当你需要保存日期时间数据时，一个问题来了：你应该使用 MySQL 中的什么类型？使用 MySQL 原生的 DATE 类型还是使用 INT 字段把日期和时间保存为一个纯数字呢？</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-7716-1.html><img class=thumbnail__image src=/data/attachment/album/201608/25/182238kewlm2jjz2vj2mme.png.thumb.jpg alt="Mock 在 Python 单元测试中的使用"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-7716-1.html rel=bookmark>Mock 在 Python 单元测试中的使用</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-08-25T18:22:34Z>August 25, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">即使对它的使用还有点不太熟悉，对单元测试来说，Python 的 mock 库可以说是一个规则改变者。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-7707-1.html><img class=thumbnail__image src=/data/attachment/album/201608/23/110922nrtd4oex2b2eedt8.jpg.thumb.jpg alt="Linux 内核里的数据结构——位数组"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-7707-1.html rel=bookmark>Linux 内核里的数据结构——位数组</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-08-23T11:05:00Z>August 23, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">除了不同的基于链式和树的数据结构以外，Linux 内核也为位数组（或称为位图bitmap）提供了 API。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-7698-1.html><img class=thumbnail__image src=/data/attachment/album/201608/20/161304u56upgp955whzw15.png.thumb.jpg alt="Git 系列（五）：三个 Git 图形化工具"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-7698-1.html rel=bookmark>Git 系列（五）：三个 Git 图形化工具</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-08-20T16:13:52Z>August 20, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">在本文里，我们来了解几个能帮你在日常工作中舒服地用上 Git 的工具。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-7696-1.html><img class=thumbnail__image src=/data/attachment/album/201608/19/172455zlxmmxuz7nv73nj6.png.thumb.jpg alt="Linux 平台下 Python 脚本编程入门（二）"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-7696-1.html rel=bookmark>Linux 平台下 Python 脚本编程入门（二）</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-08-19T17:24:00Z>August 19, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">我们讲解了 Python 中控制流、循环/迭代、和模块的概念。我们也演示了如何利用 Python 中面向对象编程的方法和属性来简化复杂的 shell 脚本。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-7693-1.html><img class=thumbnail__image src=/data/attachment/album/201608/18/011239aa1ovnkazmm4ivq7.png.thumb.jpg alt="Linux 平台下 Python 脚本编程入门（一）"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-7693-1.html rel=bookmark>Linux 平台下 Python 脚本编程入门（一）</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-08-18T08:09:00Z>August 18, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">首先，我们会使用 Python 的命令行工具，还会接触到 Python 的面向对象特性（这篇文章的后半部分会谈到它）。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-7688-1.html><img class=thumbnail__image src=/data/attachment/album/201608/16/174310jzjh4jjjqy8syjsj.jpg.thumb.jpg alt="GCC 内联汇编 HOWTO"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-7688-1.html rel=bookmark>GCC 内联汇编 HOWTO</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-08-16T17:43:00Z>August 16, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">本 HOWTO 文档将讲解 GCC 提供的内联汇编特性的用途和用法。对于阅读这篇文章，这里只有两个前提要求，很明显，就是 x86 汇编语言和 C 语言的基本认识。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-7685-1.html><img class=thumbnail__image src=/data/attachment/album/201608/15/225543dvfgvgu5i21s5s3y.jpg.thumb.jpg alt="搭个 Web 服务器（二）"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-7685-1.html rel=bookmark>搭个 Web 服务器（二）</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-08-16T09:33:00Z>August 16, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">你的 Web 服务器必须实现 WSGI 接口的服务器部分，而现代的 Python Web 框架均已实现了 WSGI 接口的框架部分，这使得你可以直接在 Web 服务器中使用任意框架，而不需要更改任何服务器代码，以对特定的 Web 框架实现兼容。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-7680-1.html><img class=thumbnail__image src=/data/attachment/album/201608/13/225101l86ee927edq8kqqc.png.thumb.jpg alt="Python 高级图像处理"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-7680-1.html rel=bookmark>Python 高级图像处理</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-08-14T09:46:00Z>August 14, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">构建图像搜索引擎并不是一件容易的任务。这里有几个概念、工具、想法和技术需要实现。主要的图像处理概念之一是逆图像查询（reverse image querying ：RIQ）</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-7679-1.html><img class=thumbnail__image src=/data/attachment/album/201608/13/203554du5dylvu5gqdiedb.jpg.thumb.jpg alt="5 个最受人喜爱的开源 Django 包"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-7679-1.html rel=bookmark>5 个最受人喜爱的开源 Django 包</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-08-13T20:35:00Z>August 13, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">Django 具有一个丰富多样的、由可供你使用的可重用应用组建起来的生态系统——PyPI 列出了超过 8000个 Django 应用——可你该如何知道哪些是最好的呢？</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-7677-1.html><img class=thumbnail__image src=/data/attachment/album/201608/12/130554nk96cibkkzuqvq3k.jpg.thumb.jpg alt="Git 系列（四）：在 Git 中进行版本回退"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-7677-1.html rel=bookmark>Git 系列（四）：在 Git 中进行版本回退</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-08-12T13:06:00Z>August 12, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">在这篇文章中，你将学到如何查看项目中的历史版本，如何进行版本回退，以及如何创建 Git 分支以便你可以大胆尝试而不会出现问题。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-7676-1.html><img class=thumbnail__image src=/data/attachment/album/201608/12/085612rc9fpm9tqicacqt4.jpg.thumb.jpg alt="Python 3: 加密简介"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-7676-1.html rel=bookmark>Python 3: 加密简介</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-08-12T08:56:00Z>August 12, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">Python 3 的标准库中没多少用来解决加密的，不过却有用于处理哈希的库。在这里我们会对其进行一个简单的介绍，但重点会放在两个第三方的软件包：PyCrypto 和 cryptography 上。我们将学习如何使用这两个库，来加密和解密字符串。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-7664-1.html><img class=thumbnail__image src=/data/attachment/album/201608/09/082037ijkkjwctadvpk6uc.jpg.thumb.jpg alt="Python 学习：urllib 简介"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-7664-1.html rel=bookmark>Python 学习：urllib 简介</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-08-09T08:20:00Z>August 09, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">Python 3 的 urllib 模块是一堆可以处理 URL 的组件集合。如果你有 Python 2 的知识，那么你就会注意到 Python 2 中有 urllib 和 urllib2 两个版本的模块。这些现在都是 Python 3 的 urllib 包的一部分。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-7662-1.html><img class=thumbnail__image src=/data/attachment/album/201608/08/205045iklb50bmkdkcm408.jpg.thumb.jpg alt="搭个 Web 服务器（一）"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-7662-1.html rel=bookmark>搭个 Web 服务器（一）</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-08-08T20:51:00Z>August 08, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">在这个由三篇文章组成的系列中，我将会教你构建你自己的 Web 服务器。我们开始吧~</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-7647-1.html><img class=thumbnail__image src=/data/attachment/album/201608/04/160452lyu00ee0ze1u5l3n.jpg.thumb.jpg alt="Git 系列（三）：建立你的第一个 Git 仓库"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-7647-1.html rel=bookmark>Git 系列（三）：建立你的第一个 Git 仓库</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-08-04T16:05:00Z>August 04, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">虽然 Git 确实是被许多重要软件选作版本控制工具，但是并不是仅能用于这些重要软件；它也能管理你购物清单（如果它们对你来说很重要的话，当然可以了！）、你的配置文件、周报或日记、项目进展日志、甚至源代码！</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-7645-1.html><img class=thumbnail__image src=/data/attachment/album/201608/03/201537n6mzpexmqwebi33x.png.thumb.jpg alt="如何用 Python 和 Flask 建立部署一个 Facebook Messenger 机器人"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-7645-1.html rel=bookmark>如何用 Python 和 Flask 建立部署一个 Facebook Messenger 机器人</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-08-03T20:15:00Z>August 03, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">这是我建立一个简单的 Facebook Messenger 机器人的记录。功能很简单，它是一个回显机器人，只是打印回用户写了什么。
回显服务器类似于服务器的“Hello World”例子。
这个项目的目的不是建立最好的 Messenger 机器人，而是让你了解如何建立一个小型机器人和每个事物是如何整合起来的。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-7641-1.html><img class=thumbnail__image src=/data/attachment/album/201608/01/234958zcqohc4yhcohrrhe.jpg.thumb.jpg alt="Git 系列（二）：初步了解 Git"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-7641-1.html rel=bookmark>Git 系列（二）：初步了解 Git</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-08-02T09:44:00Z>August 02, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">由于 Git 如此流行，因而如果你能够至少熟悉一些基础的 Git 知识也能为你的生活带来很多便捷。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-7639-1.html><img class=thumbnail__image src=/data/attachment/album/201608/01/072030niil03u1uvi710j1.jpg.thumb.jpg alt="Git 系列（一）：什么是 Git"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-7639-1.html rel=bookmark>Git 系列（一）：什么是 Git</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-08-01T11:12:00Z>August 01, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">忘记你以前所知的 Git，让我们重新走进 Git 世界的大门。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-7601-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201607/21/014359nggjvnaj0zivg5yc.jpg.thumb.jpg alt="使用 OpenCV 识别图片中的猫咪"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-7601-1.html rel=bookmark>使用 OpenCV 识别图片中的猫咪</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-07-21T10:38:00Z>July 21, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">你知道 OpenCV 可以识别在图片中小猫的脸吗？而且是拿来就能用，不需要其它的库之类的。
之前我也不知道。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-7584-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201607/17/164459b44yymryj4lby4yd.jpg.thumb.jpg alt="用 Python、 RabbitMQ 和 Nameko 实现微服务"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-7584-1.html rel=bookmark>用 Python、 RabbitMQ 和 Nameko 实现微服务</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-07-17T16:45:30Z>July 17, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">"微服务是一股新浪潮" - 现如今，将项目拆分成多个独立的、可扩展的服务是保障代码演变的最好选择。在 Python 的世界里，有个叫做 “Nameko” 的框架，它将微服务的实现变得简单并且强大。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-7552-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201607/07/235601nvdjd85mn7h22hd4.jpg.thumb.jpg alt="你应该知道的基础 Git 命令"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-7552-1.html rel=bookmark>你应该知道的基础 Git 命令</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-07-08T13:55:00Z>July 08, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">这个快速指南将向你展示所有的基础 Git 命令以及用法。你可以下载这些命令作为快速参考。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-7480-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201606/20/123606rd6xe34kk2xy392i.jpg.thumb.jpg alt=每个程序员都应该收藏的算法复杂度速查表></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-7480-1.html rel=bookmark>每个程序员都应该收藏的算法复杂度速查表</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-06-20T12:36:00Z>June 20, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">这篇文章覆盖了计算机科学里面常见算法的时间和空间的大 OBig-O 复杂度。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-7354-1.html><img class=thumbnail__image src=/data/attachment/album/201605/18/094209j2djdcataqiri0cz.jpg.thumb.jpg alt="点评五款用于 Linux 编程的内存调试器"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-7354-1.html rel=bookmark>点评五款用于 Linux 编程的内存调试器</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-05-19T09:36:00Z>May 19, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">在这些工具集中，我评估了五款支持 Linux 的、流行的、自由开源的内存调试器： Dmalloc 、 Electric Fence 、 Memcheck 、 Memwatch 以及 Mtrace 。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-7353-1.html><img class=thumbnail__image src=/data/attachment/album/201605/18/085613hqkbz7gkpv8lc1ck.jpg.thumb.jpg alt="Linux 内核里的数据结构——基数树"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-7353-1.html rel=bookmark>Linux 内核里的数据结构——基数树</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-05-18T08:56:00Z>May 18, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">基数树是一种 压缩的字典树 （compressed trie） ，而字典树是实现了关联数组接口并允许以 键值对 方式存储值的一种数据结构。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-7321-1.html><img class=thumbnail__image src=/data/attachment/album/201605/10/053544tvbmvkebls3evvea.jpg.thumb.jpg alt="Linux 内核里的数据结构——双向链表"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-7321-1.html rel=bookmark>Linux 内核里的数据结构——双向链表</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-05-10T14:23:00Z>May 10, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">我们将会首先从双向链表数据结构开始介绍内核里的数据结构。为什么？因为它在内核里使用的很广泛，你只需要在 free-electrons.com 检索一下就知道了。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-7267-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201604/25/191915fryzxzybvavz4m0o.png.thumb.jpg alt="用 Python 打造你的 Eclipse"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-7267-1.html rel=bookmark>用 Python 打造你的 Eclipse</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-04-25T19:19:00Z>April 25, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">Eclipse 高级脚本环境（EASE）项目虽然还在开发中，但是必须要承认它非常强大，它让我们可以快速打造自己的Eclipse 开发环境。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-7200-1.html><img class=thumbnail__image src=https://img.linux.net.cn/data/attachment/album/201604/07/121431g4blm1oczk811umc.jpg.thumb.jpg alt="在 Apache Hive 中轻松生存的12个技巧"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-7200-1.html rel=bookmark>在 Apache Hive 中轻松生存的12个技巧</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2016-04-07T12:14:00Z>April 07, 2016</time></div></div></header><div class="content list__excerpt post__content clearfix">Hive 可以让你在 Hadoop 上使用 SQL，但是在分布式系统上优化 SQL 则有所不同。这里是让你可以轻松驾驭 Hive 的12个技巧。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-6212-1.html><img class=thumbnail__image src=/data/attachment/album/201509/14/150337fbb1xe1b53z770n3.jpg.thumb.jpg alt="Node.js 4.0 中的 ES 6 特性介绍"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-6212-1.html rel=bookmark>Node.js 4.0 中的 ES 6 特性介绍</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2015-09-14T15:03:35Z>September 14, 2015</time></div></div></header><div class="content list__excerpt post__content clearfix">Node.js 4.0.0 已经发布了。这是和 io.js 合并之后的首个稳定版本，它带来了一系列的新特性，支持 ES 6的大部分特性。已经有很多 ES 6 的特性介绍了，这里我们介绍一下该怎么使用它们。 1. 模板字符串 如果你要在 JavaScript 中创建多行字符串，你可能会使用如下的语法： var message = .join(&rsquo;\n&rsquo;); 对于少量字符串这还算合适，但是如果比较多就会显得混乱。不过，有个聪明的开发者提出了一个叫multiline的技巧： var multiline = require(&lsquo;multiline&rsquo;); var message = multiline(function () {/* The quick brown fox jumps over the l</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-5963-1.html><img class=thumbnail__image src=/data/attachment/album/201508/05/155648gil3ndk3885gn331.jpg.thumb.jpg alt=史上最复杂的验证邮件地址的正则表达式></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-5963-1.html rel=bookmark>史上最复杂的验证邮件地址的正则表达式</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2015-08-05T15:56:00Z>August 05, 2015</time></div></div></header><div class="content list__excerpt post__content clearfix">用正则表达式验证邮件地址似乎是一件简单的事情，但是如果要完美的验证一个合规的邮件地址，其实也许很复杂。 邮件地址的规范来自于 RFC 5322。有一个网站 emailregex.com专门列出各种编程语言下的验证邮件地址的正则表达式，其中很多正则表达式都是我听说过而从未见过的复杂我想说，做这个网站的程序员是被邮件验证这件事伤害了多深啊！ 其实，在产品环境中，一般来说并不需要这么复杂的正则表达式来做到99.99%正确。一般来说，从执行效率和测试覆盖率来说，只需要一个简单的版本即可： /^+@+.{2,4}$/i 那么下面我们来看看这些更严谨、</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-5868-1.html><img class=thumbnail__image src=/data/attachment/album/201507/23/005118mdn88qq876c6687a.jpg.thumb.jpg alt="PHP 安全编程建议"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-5868-1.html rel=bookmark>PHP 安全编程建议</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2015-07-23T08:00:00Z>July 23, 2015</time></div></div></header><div class="content list__excerpt post__content clearfix">简介 要提供互联网服务，当你在开发代码的时候必须时刻保持安全意识。可能大部分 PHP 脚本都对安全问题都不在意，这很大程度上是因为有大量的无经验程序员在使用这门语言。但是，没有理由让你因为对你的代码的不确定性而导致不一致的安全策略。当你在服务器上放任何涉及到钱的东西时，就有可能会有人尝试破解它。创建一个论坛程序或者任何形式的购物车，被攻击的可能性就上升到了无穷大。 背景 为了确保你的 web 内容安全，这里有一些常规的安全准则： 别相信表单 攻击表单很简单。通过使用一个简单的 JavaScript 技巧，你可以限制你的表</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-5764-1.html><img class=thumbnail__image src=/data/attachment/album/201507/05/220606jrfr4gjrrmrz1cjr.jpg.thumb.jpg alt=如何用Perl访问SQLite数据库></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-5764-1.html rel=bookmark>如何用Perl访问SQLite数据库</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2015-07-06T10:04:00Z>July 06, 2015</time></div></div></header><div class="content list__excerpt post__content clearfix">SQLite是一个零配置、无服务端、基于文件的事务型数据库系统。由于它的轻量级，自包含和紧凑的设计，所以当你想要集成数据库到你的程序中时，SQLite是一个非常不错的选择。在这篇文章中，我会展示如何用Perl脚本来创建和访问SQLite数据库。我演示的Perl代码片段是完整的，所以你可以很简单地修改并集成到你的项目中。 访问SQLite的准备 我会使用SQLite DBI Perl驱动来连接到SQLite3。因此你需要在Linux中安装它（和SQLite3一起）。 Debian、 Ubuntu 或者 Linux Mint $ sudo apt-get install sqlite3 libdbd-sqlite3-perl CentOS、 Fedor</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-5663-1.html><img class=thumbnail__image src=/data/attachment/album/201506/20/073112f3h66vfvvkpu4qpu.png.thumb.jpg alt="如何在 Ubuntu/Debian/Linux Mint 中编译和安装 wxWidgets"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-5663-1.html rel=bookmark>如何在 Ubuntu/Debian/Linux Mint 中编译和安装 wxWidgets</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2015-06-20T13:28:00Z>June 20, 2015</time></div></div></header><div class="content list__excerpt post__content clearfix">wxWidgets wxWidgets是一个程序开发框架/库， 允许你在Windows、Mac、Linux中使用相同的代码跨平台开发。它主要用C++写成，但也可以与其他语言绑定比如Python、Perl、Ruby。 本教程中我将向你展示如何在基于Debian的linux中如Ubuntu和Linux Mint中编译wxwidgets 3.0+。 从源码编译wxWidgets并不困难，仅仅需要几分钟。库可以按不同的方式来编译，比如静态或者动态库。 1. 下载 wxWidgets 第一步你需要从wxwidgets.org下载wxWidgets源码文件。 做完后，解压到目录。 2. 设置编译环境 要编译wxwidgets，我们需要一些工具包括C++编译器，在L</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-5558-1.html><img class=thumbnail__image src=/data/attachment/album/201506/02/203611yccjqvp03qqnqvsi.png.thumb.jpg alt="如何在Bash Shell脚本中显示对话框"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-5558-1.html rel=bookmark>如何在Bash Shell脚本中显示对话框</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2015-06-02T20:36:00Z>June 02, 2015</time></div></div></header><div class="content list__excerpt post__content clearfix">这个教程给出几个如何使用类似zenity和whiptail的工具在Bash Shell 脚本中提供消息/对话框的例子。使用这些工具，你的脚本能够告知用户当前程序运行的状态并能与用户进行交互。这两个工具的不同之处在于显示消息框或者对话框的方式。Zenity用GTK工具包创建图形用户界面，而whiptail则在终端窗口内创建消息框。 Zenity 工具 在Ubuntu中安装zenity，运行: sudo apt-get install zenity 用zenity创建消息框或者对话框的命令是不言自明的，我们会给你提供一些例子来参考。 创建消息框 zenity &ndash;info &ndash;title "Information Box" &ndash;text "This</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-5428-1.html><img class=thumbnail__image src=/data/attachment/album/201505/11/151113i3lzgnfjk8jkxdwe.jpg.thumb.jpg alt=既然float不能表示所有的int，那为什么在类型转换时C++将int转换成float？></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-5428-1.html rel=bookmark>既然float不能表示所有的int，那为什么在类型转换时C++将int转换成float？</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2015-05-11T15:11:08Z>May 11, 2015</time></div></div></header><div class="content list__excerpt post__content clearfix">问题： 代码如下： int i = 23; float f = 3.14; if (i == f) // 执行某段代码 编译器会将i转换成float类型，然后比较这两个float的大小，但是float能够表示所有的int吗？为什么没有将int和float转换成double类型进行比较呢？ 回答： 在整型数的演变中，当int变成unsigned时，会丢掉负数部分（有趣的是，这样的话，0u -1就是对的了）。 和C语言中的大部分机制（在C++中得到继承）一样，就硬件操作而言，常见的算术转换应该简明易懂。C语言的发明者精通他们所使用机器上的汇编语言，他们编写的C语言对他们和像他们一样编写程序的人有直</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-5223-1.html><img class=thumbnail__image src=/data/attachment/album/201504/07/225546ffzm313q37awa1fk.png.thumb.jpg alt=Linux有问必答：Perl中本地时间和UNIX时间戳间相互转换></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-5223-1.html rel=bookmark>Linux有问必答：Perl中本地时间和UNIX时间戳间相互转换</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2015-04-08T11:52:00Z>April 08, 2015</time></div></div></header><div class="content list__excerpt post__content clearfix">问题: 在Perl语言中，我需要转换易读的日期和时间到对应的UNIX时间戳，反之亦然。你可以给我一些将日期及时间转换到UNIX时间戳的Perl代码例子吗？或者相反，转换UNIX时间戳到可读的日期和时间。 当你的Perl脚本需要解决时间信息，这里有两种方法来表示和处理日期和时间。一种方法是易读的时间表示（例，"Sat Mar 14 10:14:05 EDT 2015"），另外一种是使用UNIX时间戳（也叫新纪元时间），这是从1970年1月1日到今所经过的时间秒数。每一种方法都有它自己的优劣势，取决于你的需要，也许也就需要转换一种格式到另一种。 Perl中转换本地时间</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-5185-1.html><img class=thumbnail__image src=/data/attachment/album/201504/02/220038aewq0e5z640nlwl0.jpg.thumb.jpg alt=C语言数据类型是如何被大多数计算机系统所支持？></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-5185-1.html rel=bookmark>C语言数据类型是如何被大多数计算机系统所支持？</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2015-04-03T07:19:00Z>April 03, 2015</time></div></div></header><div class="content list__excerpt post__content clearfix">问题： 在读KR版的The C Programming Language一书时，我在看到这样一条说明： 因为C语言提供的数据类型和控制结构可以直接被大部分计算机系统所支持，所以在实现自包含程序时所需要的运行库文件一般很小。 这段黑体说明了什么？能否找到一个例子来说明C语言中的某种数据类型或控制结构不被某种计算机系统直接支持呢？ 回答: 事实上，C语言中确实有不被直接支持的数据类型。 在许多嵌入式系统中，硬件上并没有浮点运算单元。因此，如果你写出下面的代码： float x = 1.0f, y = 2.0f; return x + y; 可能会被转化成下面这种形式： unsi</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-5107-1.html><img class=thumbnail__image src=/data/attachment/album/201503/22/214604nkc33p2pv33ps392.jpg.thumb.jpg alt="使用Nemiver调试器来调试 C/C++ 程序"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-5107-1.html rel=bookmark>使用Nemiver调试器来调试 C/C++ 程序</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2015-03-24T11:44:00Z>March 24, 2015</time></div></div></header><div class="content list__excerpt post__content clearfix">如果你读过我写的使用GDB命令行调试器调试C/C++程序，你就会明白一个调试器对一段C/C++程序来说有多么的重要和有用。然而，如果一个像GDB这样的命令行对你而言听起来更像一个问题而不是一个解决方案的话，那么你也许会对Nemiver更感兴趣。Nemiver 是一款基于 GTK+ 的用于C/C++程序的图形化的独立调试器，它以GDB作为其后端。最令人赞赏的是其速度和稳定性，Nemiver是一个非常可靠，具备许多优点的调试工具。 Nemiver的安装 基于Debian发行版，它的安装时非常直接简单，如下： $ sudo apt-get install nemiver 在Arch Linux中安装如下： $</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-5044-1.html><img class=thumbnail__image src=/data/attachment/album/201503/12/153736di7plh4hd2pk2p2l.png.thumb.jpg alt=在Linux上使用Python和Flask创建你的第一个应用></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-5044-1.html rel=bookmark>在Linux上使用Python和Flask创建你的第一个应用</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2015-03-12T15:37:00Z>March 12, 2015</time></div></div></header><div class="content list__excerpt post__content clearfix">无论你在linux上娱乐还是工作，这对你而言都是一个使用python来编程的很好的机会。回到大学我希望他们教我的是Python而不是Java，这学起来很有趣且在实际的应用如yum包管理器中很有用。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-4961-1.html><img class=thumbnail__image src=/data/attachment/album/201503/01/205325gyj2l10yn2zxgm4y.png.thumb.jpg alt="怎样通过 Twitter 的开源库来随处使用 Emoji 表情符号"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-4961-1.html rel=bookmark>怎样通过 Twitter 的开源库来随处使用 Emoji 表情符号</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2015-02-28T20:53:00Z>February 28, 2015</time></div></div></header><div class="content list__excerpt post__content clearfix">通过 GitHub 将它们嵌入到网页和其他项目中。 Emoji, 来自日本的小巧符号，通过图像表达感情，已经征服了移动互联网的信息世界。 现在，你可以在虚拟世界中随处使用它们了。 Twitter 最近开源了他们的 emoji 符号库，使得你可以在你自己的网站，应用，和项目中使用它们。 但这需要一点体力活。 Unicode 已经识别甚至标准化了 emoji 字母表， 然而 emoji 仍然不能完全与所有的网络浏览器相兼容，这意味着大多数情况下，它们将呈现为 豆腐块或空白盒子。当 Twitter 想使得 emoji 到处可用时，这家社交网络联合了一家名为Icon Factory的公</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-4911-1.html><img class=thumbnail__image src=/data/attachment/album/201502/19/231057gbya8lnlz8flrnty.png.thumb.jpg alt=如果使用32位整型会溢出，那么是否可以使用一个40位结构体代替64位长整型？></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-4911-1.html rel=bookmark>如果使用32位整型会溢出，那么是否可以使用一个40位结构体代替64位长整型？</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2015-02-19T23:10:00Z>February 19, 2015</time></div></div></header><div class="content list__excerpt post__content clearfix">问题： 假如说，使用32位的整型会溢出，在不考虑使用长整型的情况下，如果我们只需要表示2的40次方范围内的数，是否可以利用某些40位长的数据类型来表示呢？这样的话，每个整型数就可以节省24位的空间。 如果可以，该怎么做？ 需求是：我现在必须处理数以亿计的数字，所以在存储空间上受到了很大的限制。 回答： 可以是可以，但是 这种方法的确可行，但这么做通常没什么意义（因为几乎没有程序需要处理多达十亿的数字）： #include stdint.h // 不要考虑使用long long类型 struct bad_idea { uint64_t var : 40; }; 在这里，变量var占据</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-4870-1.html><img class=thumbnail__image src=/data/attachment/album/201502/11/150459k4h7nbmnjh4ppy2n.jpg.thumb.jpg alt=在Linux中使用matplotlib进行科学画图></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-4870-1.html rel=bookmark>在Linux中使用matplotlib进行科学画图</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2015-02-11T15:04:55Z>February 11, 2015</time></div></div></header><div class="content list__excerpt post__content clearfix">如果你想要在Linxu中获得一个高效、自动化、高质量的科学画图的解决方案，应该考虑尝试下matplotlib库。Matplotlib是基于python的开源科学测绘包，基于python软件基金会许可证发布。大量的文档和例子、集成了Python和Numpy科学计算包、以及自动化能力，是作为Linux环境中进行科学画图的可靠选择的几个原因。这个教程将提供几个用matplotlib画图的例子。 特性 支持众多的图表类型，如：bar,box,contour,histogram,scatter,line plots&mldr;. 基于python的语法 集成Numpy科学计算包 数据源可以是 python 的列表、键值对和数组 可定制的图表格</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-4491-1.html><img class=thumbnail__image src=/data/attachment/album/201412/21/110721hz9zysfs8dai8p44.png.thumb.jpg alt=一些关于Java的句子></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-4491-1.html rel=bookmark>一些关于Java的句子</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-12-21T11:07:15Z>December 21, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">本文并没有什么新鲜的。我只是收集了一些不太重要的语句，但这些语句可能对初级程序员来说很重要。也就是些无聊的旧东西。 如果以下的这些你都知道的话，那么你比Java的了解已经超过了对一个平常的家庭主妇的了解。我不知道清楚所有的这些是否是有意义的。即使不知道其中的一些特性，你照样也可以成为一个相当不错的Java程序员。然而，本文中许多的新信息可能表明你还有很大的发展空间。 Java中有四种不同的访问类型(而不是三种) 这四种类型包括：private, package private (包访问权限，无修饰符，又叫default, 译者注)。如果你在类中定</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-4489-1.html><img class=thumbnail__image src=/data/attachment/album/201412/21/103252nq0neivincaeeiq0.png.thumb.jpg alt="Shell 脚本基础 - 使用 if 语句进行条件检测"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-4489-1.html rel=bookmark>Shell 脚本基础 - 使用 if 语句进行条件检测</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-12-21T10:31:00Z>December 21, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">Bourne Shell 的 if 语句和大部分编程语言一样 - 检测条件是否真实，如果条件为真，shell 会执行这个 if 语句指定的代码块，如果条件为假，shell 就会跳过 if 代码块，继续执行之后的代码。 if 语句的语法： if then command1 command2 .. last_command fi Example: #!/bin/bash number=150 if then echo "Number is 150" fi if-else 语句: 除了标准的 if 语句之外，我们还可以加入 else 代码块来扩展 if 语句。这么做的主要目的是：如果 if 条件为真，执行 if 语句里的代码块，如果 if 条件为假，执行 else 语句里的代码块。 语法:</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-4406-1.html><img class=thumbnail__image src=/data/attachment/album/201412/09/001536y3ri8ov2jpgi82i0.jpg.thumb.jpg alt="同行代码审查（Peer Code Review）实战经验"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-4406-1.html rel=bookmark>同行代码审查（Peer Code Review）实战经验</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-12-09T09:10:00Z>December 09, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">我有时候会听到我们的团队成员这样议论： "项目的Code review 只是浪费时间。" "我没有时间做Code review。" "我的发布时间延迟了，因为我的同事还没有完成我代码的Code review。" "你相信我的同事居然要求我对我的代码做修改吗？请跟他们说代码中的一些联系会被打断如果在我原来代码的基础之上做修改的话。" (LCTT 译注：Code Review中文可以翻译成代码审查,一般由开发待review的代码的成员以外的团队成员来进行这样的工作。由于是专业术语，没有将Code review用中文代替。) 为什么要做Code review？ 每个专业软件开发者都有一个重要的</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-4377-1.html><img class=thumbnail__image src=/data/attachment/album/201412/04/232938y1l1ttm7mmmjjmmk.png.thumb.jpg alt="如何创建和使用Python CGI脚本"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-4377-1.html rel=bookmark>如何创建和使用Python CGI脚本</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-12-05T10:26:00Z>December 05, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">你是否想使用Python语言创建一个网页，或者处理用户从web表单输入的数据？这些任务可以通过Python CGI(公用网关接口)脚本以及一个Apache web服务器实现。当用户请求一个指定URL或者和网页交互(比如点击""提交"按钮)的时候，CGI脚本就会被web服务器启用。CGI脚本调用执行完毕后，它的输出结果就会被web服务器用来创建显示给用户的网页。 配置Apache web服务器，让其能运行CGI脚本 在这个教程里，我们假设Apache web服务器已经安装好，并已运行。这篇教程使用的Apache web服务器(版本2.2.15，用于CentOS发行版6.5)运行在本地主机(127.0.0.1</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-4302-1.html><img class=thumbnail__image src=/data/attachment/album/201411/25/214812k9he3imidt9z1939.png.thumb.jpg alt=使用GDB命令行调试器调试C/C++程序></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-4302-1.html rel=bookmark>使用GDB命令行调试器调试C/C++程序</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-11-25T21:48:02Z>November 25, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">没有调试器的情况下编写程序时最糟糕的状况是什么？编译时跪着祈祷不要出错？用血祭召唤恶魔帮你运行程序？或者在每一行代码间添加printf("test")语句来定位错误点？如你所知，编写程序时不使用调试器的话是不方便的。幸好，linux下调试还是很方便的。大多数人使用的IDE都集成了调试器，但 linux 最著名的调试器是命令行形式的C/C++调试器GDB。然而，与其他命令行工具一致，DGB需要一定的练习才能完全掌握。这里，我会告诉你GDB的基本情况及使用方法。 安装GDB 大多数的发行版仓库中都有GDB Debian 或 Ubuntu $ sudo apt-get install gdb</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-4292-1.html><img class=thumbnail__image src=/data/attachment/album/201411/24/162415fptso6zpgpt0xpht.gif.thumb.jpg alt=在Github和Git上fork之简单指南></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-4292-1.html rel=bookmark>在Github和Git上fork之简单指南</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-11-24T16:24:00Z>November 24, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">以我的经验来看，刚接触Git和GitHub时，最困扰的一件事情就是尝试解决下面的问题：在Git和GitHub上，我能做什么？ Git教程往往不会解决这个问题，因为它集中篇幅来教你Git命令和概念，并且不认为你会使用GitHub。GitHub帮助教程一定程度上弥补了这一缺陷，但是它每篇文章的关注点都较为狭隘，而且没有提供关于"Git vs GitHub"问题的概念性概述。 如果你是习惯于先理解概念，再着手代码的学习者，而且你也是Git和GitHub的初学者，我建议你先理解清楚什么是fork。为什么呢 ？ Fork是在GitHub起步最普遍的方式。 Fork只需要很少的Git命令，</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-4046-1.html><img class=thumbnail__image src=/data/attachment/album/201410/20/120426xxp4qkbxm5vqylk4.jpg.thumb.jpg alt="Git Rebase教程： 用Git Rebase让时光倒流"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-4046-1.html rel=bookmark>Git Rebase教程： 用Git Rebase让时光倒流</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-10-20T12:04:00Z>October 20, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">想象一下你正在开发一个激进的新功能。这将是很灿烂的但它需要一段时间。您这几天也许是几个星期一直在做这个。 你的功能分支已经超前master有6个提交了。你是一个优秀的开发人员并做了有意义的语义提交。但有一件事情：你开始慢慢意识到，这个疯狂的东西仍需要更多的时间才能真的做好准备被合并回主分支。 m1-m2-m3-m4 (master) \ f1-f2-f3-f4-f5-f6(feature) 你也知道的是，一些地方实际上是交叉不大的新功能。它们可以更早地合并到主分支。不幸的是，你想将部分合并到主分支的内容存在于你六个提交中的某个地方。更糟糕的是，它也包</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-4023-1.html><img class=thumbnail__image src=/data/attachment/album/201410/16/130912bqrggi02r0zolru2.png.thumb.jpg alt=学习VIM之2014></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-4023-1.html rel=bookmark>学习VIM之2014</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-10-16T13:09:04Z>October 16, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">作为一名开发者，你不应该把时间花费在考虑如何去找你所要编辑的代码上。在我转移到完全使用 VIM 的过程中，感到最痛苦的就是它处理文件的方式。从之前主要使用 Eclipse 和 Sublime Text 过渡到 VIM，它没有捆绑一个常驻的文件系统查看器对我造成了不少阻碍，而其内建的打开和切换文件的方式总是让我泪流满面。 就这一点而言，我非常欣赏VIM文件管理功能的深度。在工作环境上我已经装配了这些工具，甚至比起那些视觉编辑器好很多。因为这个是纯键盘操作，可以让我更快地在代码里面穿梭。搭建环境需要花费一些时间，安装几个插件。首先第一</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-3991-1.html><img class=thumbnail__image src=/data/attachment/album/201410/11/115936l9puic922s79s0m7.jpg.thumb.jpg alt=PHP-RSA加密跨域通讯实战></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-3991-1.html rel=bookmark>PHP-RSA加密跨域通讯实战</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-10-11T11:59:00Z>October 11, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">基于POST GET 的http通讯虽然非常成熟，但是很容易被人监听。 并且如果使用跨域jsonp的通讯很容易在历史记录中发现通讯网址以及参数。为了克服这些问题， 并且降低服务器成本，我们没有使用SSL而使用 RSA加密。文章中的php加密解密 JS的加密解密 互相加密解密 都能验证通过。</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-3961-1.html><img class=thumbnail__image src=/data/attachment/album/201410/06/221504j3c30uiwfgvhglig.jpg.thumb.jpg alt=Linux有问必答：如何用Perl检测Linux的发行版本></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-3961-1.html rel=bookmark>Linux有问必答：如何用Perl检测Linux的发行版本</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-10-06T22:15:00Z>October 06, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">提问:我需要写一个Perl程序，它会包含Linux发行版相关的代码。为此，Perl程序需要能够自动检测运行中的Linux的发行版（如Ubuntu、CentOS、Debian、Fedora等等），以及它是什么版本号。如何用Perl检测Linux的发行版本？ 如果要用Perl脚本检测Linux的发行版，你可以使用一个名为Linux::Distribution的Perl模块。该模块通过检查/etc/lsb-release以及其他在/etc下的发行版特定的目录来猜测底层Linux操作系统。它支持检测所有主要的Linux发行版，包括Fedora、CentOS、Arch Linux、Debian、Ubuntu、SUSE、Red Hat、Gentoo、Slackware、Knoppix</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-3938-1.html><img class=thumbnail__image src=/data/attachment/album/201410/01/150801zll88nklqii08100.gif.thumb.jpg alt="Linux 有问必答：如何在Perl中捕捉并处理信号"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-3938-1.html rel=bookmark>Linux 有问必答：如何在Perl中捕捉并处理信号</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-10-01T18:02:00Z>October 01, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">提问: 我需要通过使用Perl的自定义信号处理程序来处理一个中断信号。在一般情况下，我怎么在Perl程序中捕获并处理各种信号（如INT，TERM）？ 作为POSIX标准的异步通知机制，信号由操作系统发送给进程某个事件来通知它。当产生信号时，操作系统会中断目标程序的执行，并且该信号被发送到该程序的信号处理函数。可以定义和注册自己的信号处理程序或使用默认的信号处理程序。 在Perl中，信号可以被捕获，并由一个全局的%SIG哈希变量指定处理函数。这个%SIG哈希变量的键名是信号值，键值是对应的信号处理程序的引用。因此，如果你想为特定的</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-3463-1.html><img class=thumbnail__image src=/data/attachment/album/201407/25/152443ax2ruxfx1e04fr1g.png.thumb.jpg alt=已经会用Git了？不会这十招怎么行></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-3463-1.html rel=bookmark>已经会用Git了？不会这十招怎么行</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-07-25T15:24:00Z>July 25, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">之前我们发了一些教程让你熟悉Git基础和在团队合作环境中使用Git.我们讨论的这些Git命令足够让一个开发者在Git的世界里生存下去。在这篇教程里，我们试着探索如何高效地管理你的时间以及如何充分利用Git提供的特性。 注意：这里介绍的命令中有的包含方括号(例如：git add -p )。在这些例子中，你应该用你自己的数字、标识符等替代方括号里的内容，并且去掉方括号。 1. Git自动补全 如果你在命令行环境中运行Git命令，每次都手动地逐个输入命令是一件很无聊的事。为此，你可以花几分钟时间配置一下Git命令的自动补全功能。 在*nix系统运</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-3433-1.html><img class=thumbnail__image src=/data/attachment/album/201407/19/230554b0939pdp3l619zs9.png.thumb.jpg alt=教你用NeoBundle管理Vim插件></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-3433-1.html rel=bookmark>教你用NeoBundle管理Vim插件</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-07-19T23:05:52Z>July 19, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">NeoBundle 是一个 Vim 的插件管理器，以 Vundle 为基础（Vundle 是一个基于 Pathogen 的 Vim 插件管理器）。在之前的文章中，我非常不推荐使用 Neobundle，原因是它当时还处于高速开发阶段（LCTT：意味着不稳定、变数大），并且当时它的英文文档很少。现在，已经过了一年多了，这两个问题都早已不再是问题。 我们为什么要使用插件管理器？Vim 支持大量插件，但是由于它没有严格定义框架，插件的文件可以胡乱分布在不同目录下，导致用户管理起来会很困难（LCTT：当然，前提是你有很多插件，还有点小小的强迫症，觉得理一理这些插件心里会舒</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-3330-1.html><img class=thumbnail__image src=/data/attachment/album/201407/05/105319ogppbngtut4gbg4t.png.thumb.jpg alt=C编程vim初步配置></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-3330-1.html rel=bookmark>C编程vim初步配置</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-07-05T13:30:33Z>July 05, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">学习时间不长，如有问题请指出！感谢！</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-3254-1.html><img class=thumbnail__image src=/data/attachment/album/201406/24/155116x0fq14fe0f909bde.jpeg.thumb.jpg alt=linux简单之美></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-3254-1.html rel=bookmark>linux简单之美</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-06-24T15:52:40Z>June 24, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix"><p>话说windows也有syscall，这是必须的。但是win的syscall可以直接call吗？可以是
可以但是破费周折，搞成SDT之类的复杂概念。下面看看linux是如何做的吧。</p><p>view plaincopyprint?</p><p>section.data
msgdb"hellohopy!",0x0a</p><p>section.text
global_start</p><p>_start:
moveax,4
movebx,1
movecx,msg
movedx,12
int0x80</p><p>moveax,1
movebx,0
int0x80</p><p>关键是系统调用号要知道，开始找的是usr/include/asm-gen*/unistd.h，
可是都不对。后来找的是usr/include/x86_64_linux_gnu/asm/下的头文件，
有2个，分别对应x86和x64.、编译连接指令如下:
nasm</p></div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-3251-1.html><img class=thumbnail__image src=/data/attachment/album/201406/24/012730cu0k0hhwcu5w5az0.jpg.thumb.jpg alt=黑客内核：编写属于你的第一个Linux内核模块></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-3251-1.html rel=bookmark>黑客内核：编写属于你的第一个Linux内核模块</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-06-24T09:00:00Z>June 24, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">曾经多少次想要在内核游荡？曾经多少次茫然不知方向？你不要再对着它迷惘，让我们指引你走向前方 内核编程常常看起来像是黑魔法，而在亚瑟 C 克拉克的眼中，它八成就是了。Linux内核和它的用户空间是大不相同的：抛开漫不经心，你必须小心翼翼，因为你编程中的一个bug就会影响到整个系统。浮点运算做起来可不容易，堆栈固定而狭小，而你写的代码总是异步的，因此你需要想想并发会导致什么。而除了所有这一切之外，Linux内核只是一个很大的、很复杂的C程序，它对每个人开放，任何人都去读它、学习它并改进它，而你也可以是其中之一。 学</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-3205-1.html><img class=thumbnail__image src=/data/attachment/album/201406/16/133347yossqqn79yj4xdzr.jpg.thumb.jpg alt="ngxtop：在命令行实时监控 Nginx 的神器"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-3205-1.html rel=bookmark>ngxtop：在命令行实时监控 Nginx 的神器</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-06-16T15:00:00Z>June 16, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">Nginx网站服务器在生产环境中运行的时候需要进行实时监控。实际上，诸如Nagios, Zabbix, Munin 的网络监控软件是支持 Nginx 监控的。 如果你不需要以上软件提供的综合性报告或者长期数据统计功能，只是需要一种快速简便的办法去监控 Nginx 服务器的请求的话，我建议你采用一个叫 ngxtop 的命令行工具。 你马上就会发现 ngxtop 从界面和名称都借鉴了著名的top命令。ngxtop 是通过分析 Nginx 或者其他的日志文件，使用类似 top 命令的界面实时展示出来的。你可以说你知道的其他高端监控工具，但是在简洁这方面 ngxtop 无疑是最好的。简单就</div></article><article class="list__item post"><figure class="list__thumbnail thumbnail"><a class=thumbnail__link href=/article-3204-1.html><img class=thumbnail__image src=/data/attachment/album/201406/16/144459khrh6o1s7m1kmjl4.png.thumb.jpg alt="Bash Getopts - 让你的脚本支持命令行参数"></a></figure><header class=list__header><h2 class="list__title post__title"><a href=/article-3204-1.html rel=bookmark>Bash Getopts - 让你的脚本支持命令行参数</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-06-16T12:55:00Z>June 16, 2014</time></div></div></header><div class="content list__excerpt post__content clearfix">以前我总想知道如何为我的Bash脚本创建命令行参数。经过搜索，我发现了2个函数可以处理这个问题，getopt 函数和 getopts 函数。我无意争论哪一个函数更好的。getopts 是一个shell内建命令，而且似乎比 getopt 更容易实现这个功能，所以在这篇文章里我准备讲讲getopts。 bash getopts 开始的时候，我只试着处理传递给脚本的命令行参数。最后，我添加了另外一些有用的功能函数，使得这个脚本可以成为其他任何交互式脚本处理命令行的开始模板。我还添加了一个纯文本格式的帮助函数，让脚本更加容易阅读。 与其来一长段文字解释 getopts 在ba</div></article></main><div class=pagination><a class="pagination__item pagination__item--prev btn" href=/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/page/3/>«</a>
<span class="pagination__item pagination__item--current">4/4</span></div></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>