<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>构建一个即时消息应用（七）：Access 页面 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="构建一个即时消息应用（七）：Access 页面"><meta property="og:description" content="现在我们已经完成了后端，让我们转到前端。 我将采用单页应用程序方案。"><meta property="og:type" content="article"><meta property="og:url" content="/article-12704-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-10-10T10:15:00+00:00"><meta property="article:modified_time" content="2020-10-10T10:15:00+00:00"><meta itemprop=name content="构建一个即时消息应用（七）：Access 页面"><meta itemprop=description content="现在我们已经完成了后端，让我们转到前端。 我将采用单页应用程序方案。"><meta itemprop=datePublished content="2020-10-10T10:15:00+00:00"><meta itemprop=dateModified content="2020-10-10T10:15:00+00:00"><meta itemprop=wordCount content="927"><meta itemprop=keywords content="即时消息,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>构建一个即时消息应用（七）：Access 页面</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2020-10-10T10:15:00Z>October 10, 2020</time></div></div></header><div class="content post__content clearfix"><p><img src=/data/attachment/album/202010/10/101345zj7gfybyee2g9x9e.jpg alt></p><p>本文是该系列的第七篇。</p><ul><li><a href=/article-11396-1.html>第一篇: 模式</a></li><li><a href=/article-11510-1.html>第二篇: OAuth</a></li><li><a href=/article-12056-1.html>第三篇: 对话</a></li><li><a href=/article-12680-1.html>第四篇: 消息</a></li><li><a href=/article-12685-1.html>第五篇: 实时消息</a></li><li><a href=/article-12692-1.html>第六篇: 仅用于开发的登录</a></li></ul><p>现在我们已经完成了后端，让我们转到前端。 我将采用单页应用程序方案。</p><p>首先，我们创建一个 <code>static/index.html</code> 文件，内容如下。</p><pre tabindex=0><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&#34;en&#34;&gt;
&lt;head&gt;
    &lt;meta charset=&#34;utf-8&#34;&gt;
    &lt;meta name=&#34;viewport&#34; content=&#34;width=device-width, initial-scale=1.0&#34;&gt;
    &lt;title&gt;Messenger&lt;/title&gt;
    &lt;link rel=&#34;shortcut icon&#34; href=&#34;data:,&#34;&gt;
    &lt;link rel=&#34;stylesheet&#34; href=&#34;/styles.css&#34;&gt;
    &lt;script src=&#34;/main.js&#34; type=&#34;module&#34;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>这个 HTML 文件必须为每个 URL 提供服务，并且使用 JavaScript 负责呈现正确的页面。</p><p>因此，让我们将注意力转到 <code>main.go</code> 片刻，然后在 <code>main()</code> 函数中添加以下路由：</p><pre tabindex=0><code>router.Handle(&#34;GET&#34;, &#34;/...&#34;, http.FileServer(SPAFileSystem{http.Dir(&#34;static&#34;)}))

type SPAFileSystem struct {
    fs http.FileSystem
}

func (spa SPAFileSystem) Open(name string) (http.File, error) {
    f, err := spa.fs.Open(name)
    if err != nil {
        return spa.fs.Open(&#34;index.html&#34;)
    }
    return f, nil
}
</code></pre><p>我们使用一个自定义的文件系统，因此它不是为未知的 URL 返回 <code>404 Not Found</code>，而是转到 <code>index.html</code>。</p><h3 id=路由器>路由器</h3><p>在 <code>index.html</code> 中我们加载了两个文件：<code>styles.css</code> 和 <code>main.js</code>。我把样式留给你自由发挥。</p><p>让我们移动到 <code>main.js</code>。 创建一个包含以下内容的 <code>static/main.js</code> 文件：</p><pre tabindex=0><code>import { guard } from &#39;./auth.js&#39;
import Router from &#39;./router.js&#39;

let currentPage
const disconnect = new CustomEvent(&#39;disconnect&#39;)
const router = new Router()

router.handle(&#39;/&#39;, guard(view(&#39;home&#39;), view(&#39;access&#39;)))
router.handle(&#39;/callback&#39;, view(&#39;callback&#39;))
router.handle(/^\/conversations\/([^\/]+)$/, guard(view(&#39;conversation&#39;), view(&#39;access&#39;)))
router.handle(/^\//, view(&#39;not-found&#39;))

router.install(async result =&gt; {
    document.body.innerHTML = &#39;&#39;
    if (currentPage instanceof Node) {
        currentPage.dispatchEvent(disconnect)
    }
    currentPage = await result
    if (currentPage instanceof Node) {
        document.body.appendChild(currentPage)
    }
})

function view(pageName) {
    return (...args) =&gt; import(`/pages/${pageName}-page.js`)
        .then(m =&gt; m.default(...args))
}
</code></pre><p>如果你是这个博客的关注者，你已经知道它是如何工作的了。 该路由器就是在 <a href=https://nicolasparada.netlify.com/posts/js-router/>这里</a> 显示的那个。 只需从 <a href=https://unpkg.com/@nicolasparada/router>@nicolasparada/router</a> 下载并保存到 <code>static/router.js</code> 即可。</p><p>我们注册了四条路由。 在根路由 <code>/</code> 处，我们展示 <code>home</code> 或 <code>access</code> 页面，无论用户是否通过身份验证。 在 <code>/callback</code> 中，我们展示 <code>callback</code> 页面。 在 <code>/conversations/{conversationID}</code> 上，我们展示对话或 <code>access</code> 页面，无论用户是否通过验证，对于其他 URL，我们展示一个 <code>not-found</code> 页面。</p><p>我们告诉路由器将结果渲染为文档主体，并在离开之前向每个页面调度一个 <code>disconnect</code> 事件。</p><p>我们将每个页面放在不同的文件中，并使用新的动态 <code>import()</code> 函数导入它们。</p><h3 id=身份验证>身份验证</h3><p><code>guard()</code> 是一个函数，给它两个函数作为参数，如果用户通过了身份验证，则执行第一个函数，否则执行第二个。它来自 <code>auth.js</code>，所以我们创建一个包含以下内容的 <code>static/auth.js</code> 文件：</p><pre tabindex=0><code>export function isAuthenticated() {
    const token = localStorage.getItem(&#39;token&#39;)
    const expiresAtItem = localStorage.getItem(&#39;expires\_at&#39;)
    if (token === null || expiresAtItem === null) {
        return false
    }

    const expiresAt = new Date(expiresAtItem)
    if (isNaN(expiresAt.valueOf()) || expiresAt &lt;= new Date()) {
        return false
    }

    return true
}

export function guard(fn1, fn2) {
    return (...args) =&gt; isAuthenticated()
        ? fn1(...args)
        : fn2(...args)
}

export function getAuthUser() {
    if (!isAuthenticated()) {
        return null
    }

    const authUser = localStorage.getItem(&#39;auth\_user&#39;)
    if (authUser === null) {
        return null
    }

    try {
        return JSON.parse(authUser)
    } catch (_) {
        return null
    }
}
</code></pre><p><code>isAuthenticated()</code> 检查 <code>localStorage</code> 中的 <code>token</code> 和 <code>expires_at</code>，以判断用户是否已通过身份验证。<code>getAuthUser()</code> 从 <code>localStorage</code> 中获取经过身份验证的用户。</p><p>当我们登录时，我们会将所有的数据保存到 <code>localStorage</code>，这样才有意义。</p><h3 id=access-页面>Access 页面</h3><p><img src=/data/attachment/album/202010/10/102809eh88hzc2mhny5dfj.png alt="access page screenshot"></p><p>让我们从 <code>access</code> 页面开始。 创建一个包含以下内容的文件 <code>static/pages/access-page.js</code>：</p><pre tabindex=0><code>const template = document.createElement(&#39;template&#39;)
template.innerHTML = `
 &lt;h1&gt;Messenger&lt;/h1&gt;
 &lt;a href=&#34;/api/oauth/github&#34; onclick=&#34;event.stopPropagation()&#34;&gt;Access with GitHub&lt;/a&gt;
`

export default function accessPage() {
    return template.content
}
</code></pre><p>因为路由器会拦截所有链接点击来进行导航，所以我们必须特别阻止此链接的事件传播。</p><p>单击该链接会将我们重定向到后端，然后重定向到 GitHub，再重定向到后端，然后再次重定向到前端； 到 <code>callback</code> 页面。</p><h3 id=callback-页面>Callback 页面</h3><p>创建包括以下内容的 <code>static/pages/callback-page.js</code> 文件：</p><pre tabindex=0><code>import http from &#39;../http.js&#39;
import { navigate } from &#39;../router.js&#39;

export default async function callbackPage() {
    const url = new URL(location.toString())
    const token = url.searchParams.get(&#39;token&#39;)
    const expiresAt = url.searchParams.get(&#39;expires\_at&#39;)

    try {
        if (token === null || expiresAt === null) {
            throw new Error(&#39;Invalid URL&#39;)
        }

        const authUser = await getAuthUser(token)

        localStorage.setItem(&#39;auth\_user&#39;, JSON.stringify(authUser))
        localStorage.setItem(&#39;token&#39;, token)
        localStorage.setItem(&#39;expires\_at&#39;, expiresAt)
    } catch (err) {
        alert(err.message)
    } finally {
        navigate(&#39;/&#39;, true)
    }
}

function getAuthUser(token) {
    return http.get(&#39;/api/auth\_user&#39;, { authorization: `Bearer ${token}` })
}
</code></pre><p><code>callback</code> 页面不呈现任何内容。这是一个异步函数，它使用 URL 查询字符串中的 token 向 <code>/api/auth_user</code> 发出 GET 请求，并将所有数据保存到 <code>localStorage</code>。 然后重定向到 <code>/</code>。</p><h3 id=http>HTTP</h3><p>这里是一个 HTTP 模块。 创建一个包含以下内容的 <code>static/http.js</code> 文件：</p><pre tabindex=0><code>import { isAuthenticated } from &#39;./auth.js&#39;

async function handleResponse(res) {
    const body = await res.clone().json().catch(() =&gt; res.text())

    if (res.status === 401) {
        localStorage.removeItem(&#39;auth\_user&#39;)
        localStorage.removeItem(&#39;token&#39;)
        localStorage.removeItem(&#39;expires\_at&#39;)
    }

    if (!res.ok) {
        const message = typeof body === &#39;object&#39; &amp;&amp; body !== null &amp;&amp; &#39;message&#39; in body
            ? body.message
            : typeof body === &#39;string&#39; &amp;&amp; body !== &#39;&#39;
                ? body
                : res.statusText
        throw Object.assign(new Error(message), {
            url: res.url,
            statusCode: res.status,
            statusText: res.statusText,
            headers: res.headers,
            body,
        })
    }

    return body
}

function getAuthHeader() {
    return isAuthenticated()
        ? { authorization: `Bearer ${localStorage.getItem(&#39;token&#39;)}` }
        : {}
}

export default {
    get(url, headers) {
        return fetch(url, {
            headers: Object.assign(getAuthHeader(), headers),
        }).then(handleResponse)
    },

    post(url, body, headers) {
        const init = {
            method: &#39;POST&#39;,
            headers: getAuthHeader(),
        }
        if (typeof body === &#39;object&#39; &amp;&amp; body !== null) {
            init.body = JSON.stringify(body)
            init.headers[&#39;content-type&#39;] = &#39;application/json; charset=utf-8&#39;
        }
        Object.assign(init.headers, headers)
        return fetch(url, init).then(handleResponse)
    },

    subscribe(url, callback) {
        const urlWithToken = new URL(url, location.origin)
        if (isAuthenticated()) {
            urlWithToken.searchParams.set(&#39;token&#39;, localStorage.getItem(&#39;token&#39;))
        }
        const eventSource = new EventSource(urlWithToken.toString())
        eventSource.onmessage = ev =&gt; {
            let data
            try {
                data = JSON.parse(ev.data)
            } catch (err) {
                console.error(&#39;could not parse message data as JSON:&#39;, err)
                return
            }
            callback(data)
        }
        const unsubscribe = () =&gt; {
            eventSource.close()
        }
        return unsubscribe
    },
}
</code></pre><p>这个模块是 <a href=https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API>fetch</a> 和 <a href=https://developer.mozilla.org/en-US/docs/Web/API/EventSource>EventSource</a> API 的包装器。最重要的部分是它将 JSON web 令牌添加到请求中。</p><h3 id=home-页面>Home 页面</h3><p><img src=/data/attachment/album/202010/10/101551p69v9wohvxfvvhvm.png alt="home page screenshot"></p><p>因此，当用户登录时，将显示 <code>home</code> 页。 创建一个具有以下内容的 <code>static/pages/home-page.js</code> 文件：</p><pre tabindex=0><code>import { getAuthUser } from &#39;../auth.js&#39;
import { avatar } from &#39;../shared.js&#39;

export default function homePage() {
    const authUser = getAuthUser()
    const template = document.createElement(&#39;template&#39;)
    template.innerHTML = `
 &lt;div&gt;
 &lt;div&gt;
 ${avatar(authUser)}
 &lt;span&gt;${authUser.username}&lt;/span&gt;
 &lt;/div&gt;
 &lt;button id=&#34;logout-button&#34;&gt;Logout&lt;/button&gt;
 &lt;/div&gt;
 &lt;!-- conversation form here --&gt;
 &lt;!-- conversation list here --&gt;
 `
    const page = template.content
    page.getElementById(&#39;logout-button&#39;).onclick = onLogoutClick
    return page
}

function onLogoutClick() {
    localStorage.clear()
    location.reload()
}
</code></pre><p>对于这篇文章，这是我们在 <code>home</code> 页上呈现的唯一内容。我们显示当前经过身份验证的用户和注销按钮。</p><p>当用户单击注销时，我们清除 <code>localStorage</code> 中的所有内容并重新加载页面。</p><h3 id=avatar>Avatar</h3><p>那个 <code>avatar()</code> 函数用于显示用户的头像。 由于已在多个地方使用，因此我将它移到 <code>shared.js</code> 文件中。 创建具有以下内容的文件 <code>static/shared.js</code>：</p><pre tabindex=0><code>export function avatar(user) {
    return user.avatarUrl === null
        ? `&lt;figure class=&#34;avatar&#34; data-initial=&#34;${user.username[0]}&#34;&gt;&lt;/figure&gt;`
        : `&lt;img class=&#34;avatar&#34; src=&#34;${user.avatarUrl}&#34; alt=&#34;${user.username}&#39;s avatar&#34;&gt;`
}
</code></pre><p>如果头像网址为 <code>null</code>，我们将使用用户的姓名首字母作为初始头像。</p><p>你可以使用 <code>attr()</code> 函数显示带有少量 CSS 样式的首字母。</p><pre tabindex=0><code>.avatar[data-initial]::after {
    content: attr(data-initial);
}
</code></pre><h3 id=仅开发使用的登录>仅开发使用的登录</h3><p><img src=/data/attachment/album/202010/10/101625os2hqoeqjrsbr2qr.png alt="access page with login form screenshot"></p><p>在上一篇文章中，我们为编写了一个登录代码。让我们在 <code>access</code> 页面中为此添加一个表单。 进入 <code>static/ages/access-page.js</code>，稍微修改一下。</p><pre tabindex=0><code>import http from &#39;../http.js&#39;

const template = document.createElement(&#39;template&#39;)
template.innerHTML = `
 &lt;h1&gt;Messenger&lt;/h1&gt;
 &lt;form id=&#34;login-form&#34;&gt;
 &lt;input type=&#34;text&#34; placeholder=&#34;Username&#34; required&gt;
 &lt;button&gt;Login&lt;/button&gt;
 &lt;/form&gt;
 &lt;a href=&#34;/api/oauth/github&#34; onclick=&#34;event.stopPropagation()&#34;&gt;Access with GitHub&lt;/a&gt;
`

export default function accessPage() {
    const page = template.content.cloneNode(true)
    page.getElementById(&#39;login-form&#39;).onsubmit = onLoginSubmit
    return page
}

async function onLoginSubmit(ev) {
    ev.preventDefault()

    const form = ev.currentTarget
    const input = form.querySelector(&#39;input&#39;)
    const submitButton = form.querySelector(&#39;button&#39;)

    input.disabled = true
    submitButton.disabled = true

    try {
        const payload = await login(input.value)
        input.value = &#39;&#39;

        localStorage.setItem(&#39;auth\_user&#39;, JSON.stringify(payload.authUser))
        localStorage.setItem(&#39;token&#39;, payload.token)
        localStorage.setItem(&#39;expires\_at&#39;, payload.expiresAt)

        location.reload()
    } catch (err) {
        alert(err.message)
        setTimeout(() =&gt; {
            input.focus()
        }, 0)
    } finally {
        input.disabled = false
        submitButton.disabled = false
    }
}

function login(username) {
    return http.post(&#39;/api/login&#39;, { username })
}
</code></pre><p>我添加了一个登录表单。当用户提交表单时。它使用用户名对 <code>/api/login</code> 进行 POST 请求。将所有数据保存到 <code>localStorage</code> 并重新加载页面。</p><p>记住在前端完成后删除此表单。</p><hr><p>这就是这篇文章的全部内容。在下一篇文章中，我们将继续使用主页添加一个表单来开始对话，并显示包含最新对话的列表。</p><ul><li><a href=https://github.com/nicolasparada/go-messenger-demo>源代码</a></li></ul><hr><p>via: <a href=https://nicolasparada.netlify.com/posts/go-messenger-access-page/>https://nicolasparada.netlify.com/posts/go-messenger-access-page/</a></p><p>作者：<a href=https://nicolasparada.netlify.com/>Nicolás Parada</a> 选题：<a href=https://github.com/lujun9972>lujun9972</a> 译者：<a href=https://github.com/gxlct008>gxlct008</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/%E5%8D%B3%E6%97%B6%E6%B6%88%E6%81%AF/ rel=tag>即时消息</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>