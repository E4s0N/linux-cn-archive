<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>开发一个 Linux 调试器（二）：断点 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="开发一个 Linux 调试器（二）：断点"><meta property="og:description" content="在这篇博客中，我们会学习在 x86 Linux 上断点是如何工作的，以及如何给我们工具添加设置断点的能力。"><meta property="og:type" content="article"><meta property="og:url" content="/article-8645-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-06-27T08:53:00+00:00"><meta property="article:modified_time" content="2017-06-27T08:53:00+00:00"><meta itemprop=name content="开发一个 Linux 调试器（二）：断点"><meta itemprop=description content="在这篇博客中，我们会学习在 x86 Linux 上断点是如何工作的，以及如何给我们工具添加设置断点的能力。"><meta itemprop=datePublished content="2017-06-27T08:53:00+00:00"><meta itemprop=dateModified content="2017-06-27T08:53:00+00:00"><meta itemprop=wordCount content="415"><meta itemprop=keywords content="调试器,断点,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>开发一个 Linux 调试器（二）：断点</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-06-27T08:53:00Z>June 27, 2017</time></div></div></header><div class="content post__content clearfix"><p><img src=https://img.linux.net.cn/data/attachment/album/201706/27/085227v29kih3cftuftnk5.jpg alt></p><p>在该系列的第一部分，我们写了一个小的进程启动器，作为我们调试器的基础。在这篇博客中，我们会学习在 x86 Linux 上断点是如何工作的，以及如何给我们工具添加设置断点的能力。</p><h3 id=系列文章索引>系列文章索引</h3><p>随着后面文章的发布，这些链接会逐渐生效。</p><ol><li><a href=/article-8626-1.html>准备环境</a></li><li><a href=https://github.com/TartanLlama/minidbg/tree/tut_break>断点</a></li><li>寄存器和内存</li><li>Elves 和 dwarves</li><li>源码和信号</li><li>源码层逐步执行</li><li>源码层断点</li><li>调用栈</li><li>读取变量 10.之后步骤</li></ol><h3 id=断点是如何形成的>断点是如何形成的？</h3><p>有两种类型的断点：硬件和软件。硬件断点通常涉及到设置与体系结构相关的寄存器来为你产生断点，而软件断点则涉及到修改正在执行的代码。在这篇文章中我们只会关注软件断点，因为它们比较简单，而且可以设置任意多断点。在 x86 机器上任一时刻你最多只能有 4 个硬件断点，但是它们能让你在读取或者写入给定地址时触发，而不是只有当代码执行到那里的时候。</p><p>我前面说软件断点是通过修改正在执行的代码实现的，那么问题就来了：</p><ul><li>我们如何修改代码？</li><li>为了设置断点我们要做什么修改？</li><li>如何告知调试器？</li></ul><p>第一个问题的答案显然是 <code>ptrace</code>。我们之前已经用它为我们的程序设置跟踪并继续程序的执行，但我们也可以用它来读或者写内存。</p><p>当执行到断点时，我们的更改要让处理器暂停并给程序发送信号。在 x86 机器上这是通过 <code>int 3</code> 重写该地址上的指令实现的。x86 机器有个 中断向量表 （ interrupt vector table ） ，操作系统能用它来为多种事件注册处理程序，例如页故障、保护故障和无效操作码。它就像是注册错误处理回调函数，但是是在硬件层面的。当处理器执行 <code>int 3</code> 指令时，控制权就被传递给断点中断处理器，对于 Linux 来说，就是给进程发送 <code>SIGTRAP</code> 信号。你可以在下图中看到这个进程，我们用 <code>0xcc</code> 覆盖了 <code>mov</code> 指令的第一个字节，它是 <code>init 3</code> 的指令代码。</p><p><img src=https://img.linux.net.cn/data/attachment/album/201706/27/085310slyjyd6m1l01lv25.png alt=断点></p><p>谜题的最后一个部分是调试器如何被告知中断的。如果你回顾前面的文章，我们可以用 <code>waitpid</code> 来监听被发送给被调试的程序的信号。这里我们也可以这样做：设置断点、继续执行程序、调用 <code>waitpid</code> 并等待直到发生 <code>SIGTRAP</code>。然后就可以通过打印已运行到的源码位置、或改变有图形用户界面的调试器中关注的代码行，将这个断点传达给用户。</p><h3 id=实现软件断点>实现软件断点</h3><p>我们会实现一个 <code>breakpoint</code> 类来表示某个位置的断点，我们可以根据需要启用或者停用该断点。</p><pre tabindex=0><code>class breakpoint {
public:
    breakpoint(pid_t pid, std::intptr_t addr)
        : m_pid{pid}, m_addr{addr}, m_enabled{false}, m_saved_data{}
    {}

    void enable();
    void disable();

    auto is_enabled() const -&gt; bool { return m_enabled; }
    auto get_address() const -&gt; std::intptr_t { return m_addr; }

private:
    pid_t m_pid;
    std::intptr_t m_addr;
    bool m_enabled;
    uint64_t m_saved_data; //data which used to be at the breakpoint address
};
</code></pre><p>这里的大部分代码都是跟踪状态；真正神奇的地方是 <code>enable</code> 和 <code>disable</code> 函数。</p><p>正如我们上面学到的，我们要用 <code>int 3</code> 指令 - 编码为 <code>0xcc</code> - 替换当前指定地址的指令。我们还要保存该地址之前的值，以便后面恢复该代码；我们不想忘了执行用户（原来）的代码。</p><pre tabindex=0><code>void breakpoint::enable() {
    m_saved_data = ptrace(PTRACE_PEEKDATA, m_pid, m_addr, nullptr);
    uint64_t int3 = 0xcc;
    uint64_t data_with_int3 = ((m_saved_data &amp; ~0xff) | int3); //set bottom byte to 0xcc
    ptrace(PTRACE_POKEDATA, m_pid, m_addr, data_with_int3);

    m_enabled = true;
}
</code></pre><p><code>PTRACE_PEEKDATA</code> 请求告知 <code>ptrace</code> 如何读取被跟踪进程的内存。我们给它一个进程 ID 和一个地址，然后它返回给我们该地址当前的 64 位内容。 <code>(m_saved_data & ~0xff)</code> 把这个数据的低位字节置零，然后我们用它和我们的 <code>int 3</code> 指令按位或（<code>OR</code>）来设置断点。最后我们通过 <code>PTRACE_POKEDATA</code> 用我们的新数据覆盖那部分内存来设置断点。</p><p><code>disable</code> 的实现比较简单，我们只需要恢复用 <code>0xcc</code> 所覆盖的原始数据。</p><pre tabindex=0><code>void breakpoint::disable() {
    ptrace(PTRACE_POKEDATA, m_pid, m_addr, m_saved_data);
    m_enabled = false;
}
</code></pre><h3 id=在调试器中增加断点>在调试器中增加断点</h3><p>为了支持通过用户界面设置断点，我们要在 debugger 类修改三个地方：</p><ol><li>给 <code>debugger</code> 添加断点存储数据结构</li><li>添加 <code>set_breakpoint_at_address</code> 函数</li><li>给我们的 <code>handle_command</code> 函数添加 <code>break</code> 命令</li></ol><p>我会将我的断点保存到 <code>std::unordered_map&lt;std::intptr_t, breakpoint></code> 结构，以便能简单快速地判断一个给定的地址是否有断点，如果有的话，取回该 breakpoint 对象。</p><pre tabindex=0><code>class debugger {
    //...
    void set_breakpoint_at_address(std::intptr_t addr);
    //...
private:
    //...
    std::unordered_map&lt;std::intptr_t,breakpoint&gt; m_breakpoints;
}
</code></pre><p>在 <code>set_breakpoint_at_address</code> 函数中我们会新建一个 breakpoint 对象，启用它，把它添加到数据结构里，并给用户打印一条信息。如果你喜欢的话，你可以重构所有的输出信息，从而你可以将调试器作为库或者命令行工具使用，为了简便，我把它们都整合到了一起。</p><pre tabindex=0><code>void debugger::set_breakpoint_at_address(std::intptr_t addr) {
    std::cout &lt;&lt; &#34;Set breakpoint at address 0x&#34; &lt;&lt; std::hex &lt;&lt; addr &lt;&lt; std::endl;
    breakpoint bp {m_pid, addr};
    bp.enable();
    m_breakpoints[addr] = bp;
}
</code></pre><p>现在我们会在我们的命令处理程序中增加对我们新函数的调用。</p><pre tabindex=0><code>void debugger::handle_command(const std::string&amp; line) {
    auto args = split(line,&#39; &#39;);
    auto command = args[0];

    if (is_prefix(command, &#34;cont&#34;)) {
        continue_execution();
    }
    else if(is_prefix(command, &#34;break&#34;)) {
        std::string addr {args[1], 2}; //naively assume that the user has written 0xADDRESS
        set_breakpoint_at_address(std::stol(addr, 0, 16));
    }
    else {
        std::cerr &lt;&lt; &#34;Unknown command\n&#34;;
    }
}
</code></pre><p>我删除了字符串中的前两个字符并对结果调用 <code>std::stol</code>，你也可以让该解析更健壮一些。<code>std::stol</code> 可以将字符串按照所给基数转化为整数。</p><h3 id=从断点继续执行>从断点继续执行</h3><p>如果你尝试这样做，你可能会发现，如果你从断点处继续执行，不会发生任何事情。这是因为断点仍然在内存中，因此一直被重复命中。简单的解决办法就是停用这个断点、运行到下一步、再次启用这个断点、然后继续执行。不过我们还需要更改程序计数器，指回到断点前面，这部分内容会留到下一篇关于操作寄存器的文章中介绍。</p><h3 id=测试它>测试它</h3><p>当然，如果你不知道要在哪个地址设置，那么在某些地址设置断点并非很有用。后面我们会学习如何在函数名或者代码行设置断点，但现在我们可以通过手动实现。</p><p>测试你调试器的简单方法是写一个 hello world 程序，这个程序输出到 <code>std::err</code>（为了避免缓存），并在调用输出操作符的地方设置断点。如果你继续执行被调试的程序，执行很可能会停止而不会输出任何东西。然后你可以重启调试器并在调用之后设置一个断点，现在你应该看到成功地输出了消息。</p><p>查找地址的一个方法是使用 <code>objdump</code>。如果你打开一个终端并执行 <code>objdump -d &lt;your program></code>，然后你应该看到你的程序的反汇编代码。你就可以找到 <code>main</code> 函数并定位到你想设置断点的 <code>call</code> 指令。例如，我编译了一个 hello world 程序，反汇编它，然后得到了如下的 <code>main</code> 的反汇编代码：</p><pre tabindex=0><code>0000000000400936 &lt;main&gt;:
  400936:   55                      push   %rbp
  400937:   48 89 e5                mov    %rsp,%rbp
  40093a:   be 35 0a 40 00          mov    $0x400a35,%esi
  40093f:   bf 60 10 60 00          mov    $0x601060,%edi
  400944:   e8 d7 fe ff ff          callq  400820 &lt;_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@plt&gt;
  400949:   b8 00 00 00 00          mov    $0x0,%eax
  40094e:   5d                      pop    %rbp
  40094f:   c3                      retq
</code></pre><p>正如你看到的，要没有输出，我们要在 <code>0x400944</code> 设置断点，要看到输出，要在 <code>0x400949</code> 设置断点。</p><h3 id=总结>总结</h3><p>现在你应该有了一个可以启动程序、允许在内存地址上设置断点的调试器。后面我们会添加读写内存和寄存器的功能。再次说明，如果你有任何问题请在评论框中告诉我。</p><p>你可以在<a href=https://github.com/TartanLlama/minidbg/tree/tut_break>这里</a> 找到该项目的代码。</p><hr><p>via: <a href=http://blog.tartanllama.xyz/c++/2017/03/24/writing-a-linux-debugger-breakpoints/>http://blog.tartanllama.xyz/c++/2017/03/24/writing-a-linux-debugger-breakpoints/</a></p><p>作者：<a href=http://blog.tartanllama.xyz/>Simon Brand</a> 译者：<a href=https://github.com/ictlyh>ictlyh</a> 校对：<a href=https://github.com/jasminepeng>jasminepeng</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/%E8%B0%83%E8%AF%95%E5%99%A8/ rel=tag>调试器</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E6%96%AD%E7%82%B9/ rel=tag>断点</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>