<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>尾调用、优化和 ES6 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="尾调用、优化和 ES6"><meta property="og:description" content="当一个函数 F 调用另一个函数作为它的结束动作时，就发生了一个尾调用。"><meta property="og:type" content="article"><meta property="og:url" content="/article-9746-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-06-14T12:50:16+00:00"><meta property="article:modified_time" content="2018-06-14T12:50:16+00:00"><meta itemprop=name content="尾调用、优化和 ES6"><meta itemprop=description content="当一个函数 F 调用另一个函数作为它的结束动作时，就发生了一个尾调用。"><meta itemprop=datePublished content="2018-06-14T12:50:16+00:00"><meta itemprop=dateModified content="2018-06-14T12:50:16+00:00"><meta itemprop=wordCount content="381"><meta itemprop=keywords content="尾调用,堆栈,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>尾调用、优化和 ES6</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2018-06-14T12:50:16Z>June 14, 2018</time></div></div></header><div class="content post__content clearfix"><p><img src=/data/attachment/album/201806/14/125010urao2rzn7ccn7om0.jpg alt></p><p>在探秘“栈”的倒数第二篇文章中，我们提到了 尾调用 tail call 、编译优化、以及新发布的 JavaScript 上 合理尾调用 proper tail call 。</p><p>当一个函数 F 调用另一个函数作为它的结束动作时，就发生了一个<strong>尾调用</strong>。在那个时间点，函数 F 绝对不会有多余的工作：函数 F 将“球”传给被它调用的任意函数之后，它自己就“消失”了。这就是关键点，因为它打开了尾调用优化的“可能之门”：我们可以简单地重用函数 F 的栈帧，而不是为函数调用 <a href=https://manybutfinite.com/post/journey-to-the-stack>创建一个新的栈帧</a>，因此节省了栈空间并且避免了新建一个栈帧所需要的工作量。下面是一个用 C 写的简单示例，然后使用 <a href=https://github.com/gduarte/blog/blob/master/code/x86-stack/asm-tco.sh>mild 优化</a> 来编译它的结果：</p><pre tabindex=0><code>int add5(int a)
{
    return a + 5;
}

int add10(int a)
{
    int b = add5(a); // not tail
    return add5(b); // tail
}

int add5AndTriple(int a){
    int b = add5(a); // not tail
    return 3 * add5(a); // not tail, doing work after the call
}

int finicky(int a){
    if (a &gt; 10){
        return add5AndTriple(a); // tail
    }

    if (a &gt; 5){
        int b = add5(a); // not tail
        return finicky(b); // tail
    }

    return add10(a); // tail
}
</code></pre><p><em>简单的尾调用 <a href=https://manybutfinite.com/code/x86-stack/tail.c>下载</a></em></p><p>在编译器的输出中，在预期会有一个 <a href=https://github.com/gduarte/blog/blob/master/code/x86-stack/tail.s#L37-L39>调用</a> 的地方，你可以看到一个 <a href=https://github.com/gduarte/blog/blob/master/code/x86-stack/tail-tco.s#L27>跳转</a> 指令，一般情况下你可以发现尾调用优化（以下简称 TCO）。在运行时中，TCO 将会引起调用栈的减少。</p><p>一个通常认为的错误观念是，尾调用必须要 <a href=https://manybutfinite.com/post/recursion/>递归</a>。实际上并不是这样的：一个尾调用可以被递归，比如在上面的 <code>finicky()</code> 中，但是，并不是必须要使用递归的。在调用点只要函数 F 完成它的调用，我们将得到一个单独的尾调用。是否能够进行优化这是一个另外的问题，它取决于你的编程环境。</p><p>“是的，它总是可以！”，这是我们所希望的最佳答案，它是著名的 Scheme 中的方式，就像是在 <a href=https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-11.html>SICP</a>上所讨论的那样（顺便说一声，如果你的程序不像“一个魔法师使用你的咒语召唤你的电脑精灵”那般有效，建议你读一下这本书）。它也是 <a href=http://www.lua.org/pil/6.3.html>Lua</a> 的方式。而更重要的是，它是下一个版本的 JavaScript —— ES6 的方式，这个规范清晰地定义了<a href=https://people.mozilla.org/%7Ejorendorff/es6-draft.html#sec-tail-position-calls>尾的位置</a>，并且明确了优化所需要的几个条件，比如，<a href=https://people.mozilla.org/%7Ejorendorff/es6-draft.html#sec-strict-mode-code>严格模式</a>。当一个编程语言保证可用 TCO 时，它将支持 合理尾调用 proper tail call 。</p><p>现在，我们中的一些人不能抛开那些 C 的习惯，心脏出血，等等，而答案是一个更复杂的“有时候”，它将我们带进了编译优化的领域。我们看一下上面的那个 <a href=https://github.com/gduarte/blog/blob/master/code/x86-stack/tail.c>简单示例</a>；把我们 <a href=/article-9609-1.html>上篇文章</a> 的阶乘程序重新拿出来：</p><pre tabindex=0><code>#include  &lt;stdio.h&gt;

int factorial(int n)
{
    int previous = 0xdeadbeef;

    if (n == 0 || n == 1) {
        return 1;
    }

    previous = factorial(n-1);
    return n * previous;
}

int main(int argc)
{
    int answer = factorial(5);
    printf(&#34;%d\n&#34;, answer);
}
</code></pre><p><em>递归阶乘 <a href=https://manybutfinite.com/code/x86-stack/factorial.c>下载</a></em></p><p>像第 11 行那样的，是尾调用吗？答案是：“不是”，因为它被后面的 <code>n</code> 相乘了。但是，如果你不去优化它，GCC 使用 <a href=https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html>O2 优化</a> 的 <a href=https://github.com/gduarte/blog/blob/master/code/x86-stack/factorial-o2.s>结果</a> 会让你震惊：它不仅将阶乘转换为一个 <a href=https://github.com/gduarte/blog/blob/master/code/x86-stack/factorial-o2.s#L16-L19>无递归循环</a>，而且 <code>factorial(5)</code> 调用被整个消除了，而以一个 120 (<code>5! == 120</code>) 的 <a href=https://github.com/gduarte/blog/blob/master/code/x86-stack/factorial-o2.s#L38>编译时常数</a>来替换。这就是调试优化代码有时会很难的原因。好的方面是，如果你调用这个函数，它将使用一个单个的栈帧，而不会去考虑 n 的初始值。编译算法是非常有趣的，如果你对它感兴趣，我建议你去阅读 <a href=http://www.amazon.com/Building-Optimizing-Compiler-Bob-Morgan-ebook/dp/B008COCE9G/>构建一个优化编译器</a> 和 <a href=http://www.amazon.com/Advanced-Compiler-Design-Implementation-Muchnick-ebook/dp/B003VM7GGK/>ACDI</a>。</p><p>但是，这里<strong>没有</strong>做尾调用优化时到底发生了什么？通过分析函数的功能和无需优化的递归发现，GCC 比我们更聪明，因为一开始就没有使用尾调用。由于过于简单以及很确定的操作，这个任务变得很简单。我们给它增加一些可以引起混乱的东西（比如，<code>getpid()</code>），我们给 GCC 增加难度：</p><pre tabindex=0><code>#include &lt;stdio.h&gt; 
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

int pidFactorial(int n)
{
    if (1 == n) {
        return getpid(); // tail
    }

    return n * pidFactorial(n-1) * getpid(); // not tail
}

int main(int argc)
{
    int answer = pidFactorial(5);
    printf(&#34;%d\n&#34;, answer);
}
</code></pre><p><em>递归 PID 阶乘 <a href=https://manybutfinite.com/code/x86-stack/pidFactorial.c>下载</a></em></p><p>优化它，unix 精灵！现在，我们有了一个常规的 <a href=https://github.com/gduarte/blog/blob/master/code/x86-stack/pidFactorial-o2.s#L20>递归调用</a> 并且这个函数分配 O(n) 栈帧来完成工作。GCC 在递归的基础上仍然 <a href=https://github.com/gduarte/blog/blob/master/code/x86-stack/pidFactorial-o2.s#L43>为 getpid 使用了 TCO</a>。如果我们现在希望让这个函数尾调用递归，我需要稍微变一下：</p><pre tabindex=0><code>#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

int tailPidFactorial(int n, int acc)
{
    if (1 == n) {
        return acc * getpid(); // not tail
    }

    acc = (acc * getpid() * n);
    return tailPidFactorial(n-1, acc); // tail
}

int main(int argc)
{
    int answer = tailPidFactorial(5, 1);
    printf(&#34;%d\n&#34;, answer);
}
</code></pre><p><em>tailPidFactorial.c <a href=https://manybutfinite.com/code/x86-stack/tailPidFactorial.c>下载</a></em></p><p>现在，结果的累加是 <a href=https://github.com/gduarte/blog/blob/master/code/x86-stack/tailPidFactorial-o2.s#L22-L27>一个循环</a>，并且我们获得了真实的 TCO。但是，在你庆祝之前，我们能说一下关于在 C 中的一般情形吗？不幸的是，虽然优秀的 C 编译器在大多数情况下都可以实现 TCO，但是，在一些情况下它们仍然做不到。例如，正如我们在 <a href=https://manybutfinite.com/post/epilogues-canaries-buffer-overflows/>函数序言</a> 中所看到的那样，函数调用者在使用一个标准的 C 调用规则调用一个函数之后，它要负责去清理栈。因此，如果函数 F 带了两个参数，它只能使 TCO 调用的函数使用两个或者更少的参数。这是 TCO 的众多限制之一。Mark Probst 写了一篇非常好的论文，他们讨论了 <a href=http://www.complang.tuwien.ac.at/schani/diplarb.ps>在 C 中的合理尾递归</a>，在这篇论文中他们讨论了这些属于 C 栈行为的问题。他也演示一些 <a href=http://www.complang.tuwien.ac.at/schani/jugglevids/index.html>疯狂的、很酷的欺骗方法</a>。</p><p>“有时候” 对于任何一种关系来说都是不坚定的，因此，在 C 中你不能依赖 TCO。它是一个在某些地方可以或者某些地方不可以的离散型优化，而不是像合理尾调用一样的编程语言的特性，虽然在实践中可以使用编译器来优化绝大部分的情形。但是，如果你想必须要实现 TCO，比如将 Scheme 转译 transpilation 成 C，你将会 <a href=http://en.wikipedia.org/wiki/Tail_call#Through_trampolining>很痛苦</a>。</p><p>因为 JavaScript 现在是非常流行的转译对象，合理尾调用比以往更重要。因此，对 ES6 及其提供的许多其它的重大改进的赞誉并不为过。它就像 JS 程序员的圣诞节一样。</p><p>这就是尾调用和编译优化的简短结论。感谢你的阅读，下次再见！</p><hr><p>via:<a href=https://manybutfinite.com/post/tail-calls-optimization-es6/>https://manybutfinite.com/post/tail-calls-optimization-es6/</a></p><p>作者：<a href=http://duartes.org/gustavo/blog/about/>Gustavo Duarte</a> 译者：<a href=https://github.com/qhwdw>qhwdw</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/%E5%B0%BE%E8%B0%83%E7%94%A8/ rel=tag>尾调用</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E5%A0%86%E6%A0%88/ rel=tag>堆栈</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>