<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>使用 strace 查找 Emacs 启动阻塞的原因 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="使用 strace 查找 Emacs 启动阻塞的原因"><meta property="og:description" content="刚好最近在学习使用 strace 工具，因此决定使用 strace 来看看 Emacs 到底卡在哪里。"><meta property="og:type" content="article"><meta property="og:url" content="/article-11401-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-09-29T11:53:24+00:00"><meta property="article:modified_time" content="2019-09-29T11:53:24+00:00"><meta itemprop=name content="使用 strace 查找 Emacs 启动阻塞的原因"><meta itemprop=description content="刚好最近在学习使用 strace 工具，因此决定使用 strace 来看看 Emacs 到底卡在哪里。"><meta itemprop=datePublished content="2019-09-29T11:53:24+00:00"><meta itemprop=dateModified content="2019-09-29T11:53:24+00:00"><meta itemprop=wordCount content="772"><meta itemprop=keywords content="Emacs,strace,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>使用 strace 查找 Emacs 启动阻塞的原因</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2019-09-29T11:53:24Z>September 29, 2019</time></div></div></header><div class="content post__content clearfix"><p><img src=/data/attachment/album/201909/29/115250bgndkvezdds7q24j.jpg alt></p><p>之前就觉得我的 Emacs 启动好慢，查看启动日志会发现启动到一般的时候会有一个比较长时间的卡顿。 之前一直没有理会它，今天花了点时间探索了一下，发现罪魁祸首居然是 exec-path-from-shell 这个包。</p><p>现将探索的过程记录如下： 由于使用了 spacemacs 的配置，配置上比较复杂，不太想通过实验缩减配置的方式来摸索出问题的地方。刚好最近在学习使用 <code>strace</code> 工具，因此决定使用 <code>strace</code> 来看看 Emacs 到底卡在哪里。</p><pre tabindex=0><code>strace emacs --fg-daemon
</code></pre><p>输出的内容特别多，这里只截取卡顿前的部分内容</p><pre tabindex=0><code>readlinkat(AT_FDCWD, &#34;/home&#34;, 0x7ffd1d3abb50, 1024) = -1 EINVAL (无效的参数)
readlinkat(AT_FDCWD, &#34;/home/lujun9972&#34;, 0x7ffd1d3abf00, 1024) = -1 EINVAL (无效的参数)
readlinkat(AT_FDCWD, &#34;/home/lujun9972/.emacs.d&#34;, 0x7ffd1d3ac2b0, 1024) = -1 EINVAL (无效的参数)
readlinkat(AT_FDCWD, &#34;/home/lujun9972/.emacs.d/elpa&#34;, 0x7ffd1d3ac660, 1024) = -1 EINVAL (无效的参数)
readlinkat(AT_FDCWD, &#34;/home/lujun9972/.emacs.d/elpa/exec-path-from-shell-20180323.1904&#34;, 0x7ffd1d3aca10, 1024) = -1 EINVAL (无效的参数)
readlinkat(AT_FDCWD, &#34;/home/lujun9972/.emacs.d/elpa/exec-path-from-shell-20180323.1904/exec-path-from-shell.elc&#34;, 0x7ffd1d3acdc0, 1024) = -1 EINVAL (无效的参数)
lseek(7, -2655, SEEK_CUR)               = 1441
read(7, &#34;\n(defvar exec-path-from-shell-de&#34;..., 4096) = 4096
lseek(7, 5537, SEEK_SET)                = 5537
lseek(7, 5537, SEEK_SET)                = 5537
lseek(7, 5537, SEEK_SET)                = 5537
lseek(7, 5537, SEEK_SET)                = 5537
lseek(7, 5537, SEEK_SET)                = 5537
lseek(7, 5537, SEEK_SET)                = 5537
brk(0x7507000)                          = 0x7507000
lseek(7, 5537, SEEK_SET)                = 5537
lseek(7, 5537, SEEK_SET)                = 5537
lseek(7, 5537, SEEK_SET)                = 5537
read(7, &#34;230\\205\26\0\t\22\\307\\310\t!\vC\\\&#34;\\211\24\\2&#34;..., 4096) = 2430
lseek(7, 7967, SEEK_SET)                = 7967
lseek(7, 7967, SEEK_SET)                = 7967
lseek(7, 7967, SEEK_SET)                = 7967
lseek(7, 7967, SEEK_SET)                = 7967
read(7, &#34;&#34;, 4096)                       = 0
close(7)                                = 0
getpid()                                = 10818
faccessat(AT_FDCWD, &#34;/home/lujun9972/bin/printf&#34;, X_OK) = -1 ENOENT (没有那个文件或目录)
faccessat(AT_FDCWD, &#34;/usr/local/sbin/printf&#34;, X_OK) = -1 ENOENT (没有那个文件或目录)
faccessat(AT_FDCWD, &#34;/usr/local/bin/printf&#34;, X_OK) = -1 ENOENT (没有那个文件或目录)
faccessat(AT_FDCWD, &#34;/usr/bin/printf&#34;, X_OK) = 0
stat(&#34;/usr/bin/printf&#34;, {st_mode=S_IFREG|0755, st_size=51176, ...}) = 0
openat(AT_FDCWD, &#34;/dev/null&#34;, O_RDONLY|O_CLOEXEC) = 7
faccessat(AT_FDCWD, &#34;/proc/5070/fd/.&#34;, F_OK) = 0
faccessat(AT_FDCWD, &#34;/proc/5070/fd/.&#34;, F_OK) = 0
faccessat(AT_FDCWD, &#34;/bin/bash&#34;, X_OK)  = 0
stat(&#34;/bin/bash&#34;, {st_mode=S_IFREG|0755, st_size=903440, ...}) = 0
pipe2([8, 9], O_CLOEXEC)                = 0
rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
vfork()                                 = 10949
rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
close(9)                                = 0
close(7)                                = 0
read(8, &#34;bash: \346\227\240\346\263\225\350\256\276\345\256\232\347\273\210\347\253\257\350\277\233\347\250\213\347\273&#34;..., 16384) = 74
read(8, &#34;bash: \346\255\244 shell \344\270\255\346\227\240\344\273\273\345\212\241\346\216\247\345&#34;..., 16310) = 35
read(8, &#34;setterm: \347\273\210\347\253\257 xterm-256color \344&#34;..., 16275) = 51
read(8, &#34;Couldn&#39;t get a file descriptor r&#34;..., 16224) = 56
read(8, &#34;bash: [: \357\274\232\351\234\200\350\246\201\346\225\264\346\225\260\350\241\250\350\276\276\345\274&#34;..., 16168) = 34
read(8, &#34;Your display number is 0\n&#34;, 16134) = 25
read(8, &#34;Test whether fcitx is running co&#34;..., 16109) = 53
read(8, &#34;Fcitx is running correctly.\n\n===&#34;..., 16056) = 87
read(8, &#34;Launch fbterm...\n&#34;, 15969)    = 17
read(8, &#34;stdin isn&#39;t a tty!\n&#34;, 15952)  = 19
read(8, &#34;__RESULT\0/home/lujun9972/bin:/ho&#34;..., 15933) = 298
read(8, 0x7ffd1d39ce9d, 15635)          = ? ERESTARTSYS (To be restarted if SA_RESTART is set)
--- SIGCHLD {si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=10949, si_uid=1000, si_status=0, si_utime=10, si_stime=7} ---
rt_sigreturn({mask=[]})                 = -1 EINTR (被中断的系统调用)
read(8, &#34;&#34;, 15635)                      = 0
wait4(10949, [{WIFEXITED(s) &amp;&amp; WEXITSTATUS(s) == 0}], 0, NULL) = 10949
close(8)                                = 0
getpid()                                = 10818
faccessat(AT_FDCWD, &#34;/home/lujun9972/bin/printf&#34;, X_OK) = -1 ENOENT (没有那个文件或目录)
faccessat(AT_FDCWD, &#34;/usr/local/sbin/printf&#34;, X_OK) = -1 ENOENT (没有那个文件或目录)
faccessat(AT_FDCWD, &#34;/usr/local/bin/printf&#34;, X_OK) = -1 ENOENT (没有那个文件或目录)
faccessat(AT_FDCWD, &#34;/usr/bin/printf&#34;, X_OK) = 0
stat(&#34;/usr/bin/printf&#34;, {st_mode=S_IFREG|0755, st_size=51176, ...}) = 0
openat(AT_FDCWD, &#34;/dev/null&#34;, O_RDONLY|O_CLOEXEC) = 7
faccessat(AT_FDCWD, &#34;/proc/5070/fd/.&#34;, F_OK) = 0
faccessat(AT_FDCWD, &#34;/proc/5070/fd/.&#34;, F_OK) = 0
faccessat(AT_FDCWD, &#34;/bin/bash&#34;, X_OK)  = 0
stat(&#34;/bin/bash&#34;, {st_mode=S_IFREG|0755, st_size=903440, ...}) = 0
pipe2([8, 9], O_CLOEXEC)                = 0
rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
vfork()                                 = 11679
rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
close(9)                                = 0
close(7)                                = 0
read(8, &#34;setterm: \347\273\210\347\253\257 xterm-256color \344&#34;..., 16384) = 51
read(8, &#34;Couldn&#39;t get a file descriptor r&#34;..., 16333) = 56
read(8, &#34;/home/lujun9972/.bash_profile: \347&#34;..., 16277) = 72
read(8, &#34;Your display number is 0\nTest wh&#34;..., 16205) = 78
read(8, &#34;Fcitx is running correctly.\n\n===&#34;..., 16127) = 104
read(8, &#34;stdin isn&#39;t a tty!\n&#34;, 16023)  = 19
read(8, &#34;__RESULT\0b269cd09e7ec4e8a115188c&#34;..., 16004) = 298
read(8, 0x7ffd1d39cba6, 15706)          = ? ERESTARTSYS (To be restarted if SA_RESTART is set)
--- SIGCHLD {si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=11679, si_uid=1000, si_status=0, si_utime=1, si_stime=1} ---
rt_sigreturn({mask=[]})                 = -1 EINTR (被中断的系统调用)
read(8, 
</code></pre><p>很容易就可以看出，当 Emacs 卡顿时，它在尝试从 8 号文件句柄中读取内容。</p><p>那么 8 号文件句柄在哪里定义的呢？往前看可以看到：</p><pre tabindex=0><code>pipe2([8, 9], O_CLOEXEC)                = 0
rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
vfork()                                 = 11679
rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
close(9)                                = 0
</code></pre><p>可以推测出，Emacs 主进程 <code>fork</code> 出一个子进程（进程号为 11679），并通过管道读取子进程的内容。</p><p>然而，从</p><pre tabindex=0><code>--- SIGCHLD {si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=11679, si_uid=1000, si_status=0, si_utime=1, si_stime=1} ---
rt_sigreturn({mask=[]})                 = -1 EINTR (被中断的系统调用)
read(8, 
</code></pre><p>可以看出，实际上子进程已经退出了（父进程收到 SIGCHLD 信号），父进程确依然在尝试从管道中读取内容，导致的阻塞。</p><p>而且从</p><pre tabindex=0><code>read(8, &#34;setterm: \347\273\210\347\253\257 xterm-256color \344&#34;..., 16384) = 51
read(8, &#34;Couldn&#39;t get a file descriptor r&#34;..., 16333) = 56
read(8, &#34;/home/lujun9972/.bash_profile: \347&#34;..., 16277) = 72
read(8, &#34;Your display number is 0\nTest wh&#34;..., 16205) = 78
read(8, &#34;Fcitx is running correctly.\n\n===&#34;..., 16127) = 104
read(8, &#34;stdin isn&#39;t a tty!\n&#34;, 16023)  = 19
read(8, &#34;__RESULT\0b269cd09e7ec4e8a115188c&#34;..., 16004) = 298
read(8, 0x7ffd1d39cba6, 15706)          = ? ERESTARTSYS (To be restarted if SA_RESTART is set)
</code></pre><p>看到，子进程的输出似乎是我的交互式登录 bash 启动时的输出（加载了 <code>.bash_profile</code>）</p><p>在往前翻发现这么一段信息：</p><pre tabindex=0><code>readlinkat(AT_FDCWD, &#34;/home&#34;, 0x7ffd1d3abb50, 1024) = -1 EINVAL (无效的参数)
readlinkat(AT_FDCWD, &#34;/home/lujun9972&#34;, 0x7ffd1d3abf00, 1024) = -1 EINVAL (无效的参数)
readlinkat(AT_FDCWD, &#34;/home/lujun9972/.emacs.d&#34;, 0x7ffd1d3ac2b0, 1024) = -1 EINVAL (无效的参数)
readlinkat(AT_FDCWD, &#34;/home/lujun9972/.emacs.d/elpa&#34;, 0x7ffd1d3ac660, 1024) = -1 EINVAL (无效的参数)
readlinkat(AT_FDCWD, &#34;/home/lujun9972/.emacs.d/elpa/exec-path-from-shell-20180323.1904&#34;, 0x7ffd1d3aca10, 1024) = -1 EINVAL (无效的参数)
readlinkat(AT_FDCWD, &#34;/home/lujun9972/.emacs.d/elpa/exec-path-from-shell-20180323.1904/exec-path-from-shell.elc&#34;, 0x7ffd1d3acdc0, 1024) = -1 EINVAL (无效的参数)
lseek(7, -2655, SEEK_CUR)               = 1441
read(7, &#34;\n(defvar exec-path-from-shell-de&#34;..., 4096) = 4096
</code></pre><p>这很明显是跟 <code>exec-path-from-shell</code> 有关啊。</p><p>通过查看 <code>exec-path-from-shell</code> 的实现，发现 <code>exec-path-from-shell</code> 的实现原理是通过实际调启一个 shell，然后输出 <code>PATH</code> 和 <code>MANPATH</code> 的值的。 而且对于 <code>bash</code> 来说，默认的启动参数为 <code>-i -l</code>（可以通过<code>exec-path-from-shell-arguments</code>来设置）。也就是说 <code>bash</code> 会作为交互式的登录shell来启动的，因此会加载 <code>.bash_profile</code> 和 <code>.bashrc</code>。</p><p>既然发现跟 <code>exec-path-from-shell</code> 这个包有关，而且据说这个包对 Linux 其实意义不大，那不如直接禁用掉好了。</p><pre tabindex=0><code>dotspacemacs-excluded-packages &#39;(exec-path-from-shell)
</code></pre><p>再次重启Emacs，发现这次启动速度明显快了许多了。</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/emacs/ rel=tag>Emacs</a></li><li class=tags__item><a class="tags__link btn" href=/tags/strace/ rel=tag>strace</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>