<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>在不到 30 分钟内构建一个树莓派监控仪表盘 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="在不到 30 分钟内构建一个树莓派监控仪表盘"><meta property="og:description" content="使用 Python 制作一个 API 来监控你的树莓派硬件，并使用 Appsmith 建立一个仪表盘。"><meta property="og:type" content="article"><meta property="og:url" content="/article-15984-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-07-10T10:29:00+00:00"><meta property="article:modified_time" content="2023-07-10T10:29:00+00:00"><meta itemprop=name content="在不到 30 分钟内构建一个树莓派监控仪表盘"><meta itemprop=description content="使用 Python 制作一个 API 来监控你的树莓派硬件，并使用 Appsmith 建立一个仪表盘。"><meta itemprop=datePublished content="2023-07-10T10:29:00+00:00"><meta itemprop=dateModified content="2023-07-10T10:29:00+00:00"><meta itemprop=wordCount content="1101"><meta itemprop=keywords content="监控,仪表盘,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>在不到 30 分钟内构建一个树莓派监控仪表盘</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2023-07-10T10:29:00Z>July 10, 2023</time></div></div></header><div class="content post__content clearfix"><p><img src=https://img.linux.net.cn/data/attachment/album/202307/10/102705vfe3pb0wbqnf0see.jpg alt></p><blockquote><p>使用 Python 制作一个 API 来监控你的树莓派硬件，并使用 Appsmith 建立一个仪表盘。</p></blockquote><p>如果你想知道你的树莓派的性能如何，那么你可能需要一个树莓派的仪表盘。在本文中，我将演示如何快速构建一个按需监控仪表盘，以实时查看你的树莓派的 CPU 性能、内存和磁盘使用情况，并根据需要随时添加更多视图和操作。</p><p>如果你已经使用 Appsmith，你还可以直接导入 <a href=https://github.com/appsmithorg/foundry/tree/main/resources/blogs/Raspberry%20Pi%20Dashboard>示例应用程序</a> 并开始使用。</p><h3 id=appsmith>Appsmith</h3><p>Appsmith 是一个开源的 <a href="https://www.redhat.com/architect/low-code-platform?intcmp=7013a000002qLH8AAM">低代码</a> 应用构建工具，帮助开发人员轻松快速地构建内部应用，如仪表盘和管理面板。它是一个用于仪表盘的很好选择，并减少了传统编码方法所需的时间和复杂性。</p><p>在此示例的仪表盘中，我显示以下统计信息：</p><ul><li>CPU<ul><li>占用百分比</li><li>频率或时钟速度</li><li>计数</li><li>温度</li></ul></li><li>内存<ul><li>占用百分比</li><li>可用内存百分比</li><li>总内存</li><li>空闲内存</li></ul></li><li>磁盘<ul><li>磁盘使用百分比</li><li>绝对磁盘空间使用量</li><li>可用磁盘空间</li><li>总磁盘空间</li></ul></li></ul><h3 id=创建一个端点>创建一个端点</h3><p>你需要一种从树莓派获取这些数据并传递给 Appsmith 的方法。<a href=https://psutil.readthedocs.io/en/latest/>psutil</a> 是一个用于监控和分析的 Python 库，而 <a href=https://flask-restful.readthedocs.io/en/latest/>Flask-RESTful</a> 是一个创建 <a href="https://www.redhat.com/en/topics/api/what-is-a-rest-api?intcmp=7013a000002qLH8AAM">REST API</a> 的 Flask 扩展。</p><p>Appsmith 每隔几秒钟调用 REST API 以自动刷新数据，并以 JSON 对象作为响应，其中包含所有所需的统计信息，如下所示：</p><pre tabindex=0><code>{ &#34;cpu_count&#34;: 4,
&#34;cpu_freq&#34;: [
600.0,
600.0,
1200.0 ],
&#34;cpu_mem_avail&#34;: 463953920,
&#34;cpu_mem_free&#34;: 115789824,
&#34;cpu_mem_total&#34;: 971063296,
&#34;cpu_mem_used&#34;: 436252672,
&#34;cpu_percent&#34;: 1.8,
&#34;disk_usage_free&#34;: 24678121472,
&#34;disk_usage_percent&#34;: 17.7,
&#34;disk_usage_total&#34;: 31307206656,
&#34;disk_usage_used&#34;: 5292728320,
&#34;sensor_temperatures&#34;: 52.616 }
</code></pre><h4 id=1设置-rest-api>1、设置 REST API</h4><p>如果你的树莓派尚未安装 Python，请在树莓派上打开终端并运行此安装命令：</p><pre tabindex=0><code>$ sudo apt install python3
</code></pre><p>现在为你的开发设置一个 <a href=https://opensource.com/article/20/10/venv-python>Python 虚拟环境</a>：</p><pre tabindex=0><code>$ python -m venv PiData
</code></pre><p>接下来，激活该环境。你必须在重新启动树莓派后执行此操作。</p><pre tabindex=0><code>$ source PiData/bin/activate
$ cd PiData
</code></pre><p>为了安装 Flask、Flask-RESTful 和以后需要的依赖项，请在你的 Python 虚拟环境中创建一个名为 <code>requirements.txt</code> 的文件，并将以下内容添加到其中：</p><pre tabindex=0><code>flask
flask-restful
gunicorn
</code></pre><p>保存文件，然后使用 <code>pip</code> 一次性安装它们。你必须在重新启动树莓派后执行此操作。</p><pre tabindex=0><code>(PyData)$ python -m pip install -r requirements.txt
</code></pre><p>接下来，创建一个名为 <code>pi_stats.py</code> 的文件来存放使用 <code>psutil</code> 检索树莓派系统统计信息的逻辑。将以下代码粘贴到 <code>pi_stats.py</code> 文件中：</p><pre tabindex=0><code>from flask import Flask
from flask_restful import Resource, Api
import psutil
app = Flask(__name__)

api = Api(app)
class PiData(Resource):
    def get(self):
        return &#34;RPI Stat dashboard&#34;

api.add_resource(PiData, &#39;/get-stats&#39;)

if __name__ == &#39;__main__&#39;:
    app.run(debug=True)
</code></pre><p>这段代码的作用如下：</p><ul><li>使用 <code>app = Flask(name)</code> 来定义嵌套 API 对象的应用程序。</li><li>使用 Flask-RESTful 的 <a href=https://flask-restful.readthedocs.io/en/latest/api.html#id1>API 方法</a> 来定义 API 对象。</li><li>在 Flask-RESTful 中将 <code>PiData</code> 定义为具体的 <a href=https://flask-restful.readthedocs.io/en/latest/api.html#flask_restful.Resource>Resource 类</a> ，以公开每个支持的 HTTP 方法。</li><li>使用 <code>api.add_resource(PiData, '/get-stats')</code> 将资源 <code>PiData</code> 附加到 API 对象 <code>api</code>。</li><li>每当你访问 URL <code>/get-stats</code> 时，将返回 <code>PiData</code> 作为响应。</li></ul><h4 id=2使用-psutil-读取统计信息>2、使用 psutil 读取统计信息</h4><p>要从你的树莓派获取统计信息，你可以使用 <code>psutil</code> 提供的这些内置函数：</p><ul><li><code>cpu_percentage</code>、<code>cpu_count</code>、<code>cpu_freq</code> 和 <code>sensors_temperatures</code> 函数分别用于获取 CPU 的占用百分比、计数、时钟速度和温度。<code>sensors_temperatures</code> 报告了与树莓派连接的所有设备的温度。要仅获取 CPU 的温度，请使用键 <code>cpu-thermal</code>。</li><li><code>virtual_memory</code> 函数可返回总内存、可用内存、已使用内存和空闲内存的统计信息（以字节为单位）。</li><li><code>disk_usage</code> 函数可返回总磁盘空间、已使用空间和可用空间的统计信息（以字节为单位）。</li></ul><p>将所有函数组合到一个 Python 字典中的示例如下：</p><pre tabindex=0><code>system_info_data = {
&#39;cpu_percent&#39;: psutil.cpu_percent(1),
&#39;cpu_count&#39;: psutil.cpu_count(),
&#39;cpu_freq&#39;: psutil.cpu_freq(),
&#39;cpu_mem_total&#39;: memory.total,
&#39;cpu_mem_avail&#39;: memory.available,
&#39;cpu_mem_used&#39;: memory.used,
&#39;cpu_mem_free&#39;: memory.free,
&#39;disk_usage_total&#39;: disk.total,
&#39;disk_usage_used&#39;: disk.used,
&#39;disk_usage_free&#39;: disk.free,
&#39;disk_usage_percent&#39;: disk.percent,
&#39;sensor_temperatures&#39;: psutil.sensors_temperatures()[&#39;cpu-thermal&#39;][0].current,
}
</code></pre><p>下一节将使用该字典。</p><h4 id=3从-flask-restful-api-获取数据>3、从 Flask-RESTful API 获取数据</h4><p>为了在 API 响应中看到来自树莓派的数据，请更新 <code>pi_stats.py</code> 文件，将字典 <code>system_info_data</code> 包含在 <code>PiData</code> 类中：</p><pre tabindex=0><code>from flask import Flask
from flask_restful import Resource, Api
import psutil
app = Flask(__name__)
api = Api(app)

class PiData(Resource):
    def get(self):
        memory = psutil.virtual_memory()
        disk = psutil.disk_usage(&#39;/&#39;)
        system_info_data = {
            &#39;cpu_percent&#39;: psutil.cpu_percent(1),
            &#39;cpu_count&#39;: psutil.cpu_count(),
            &#39;cpu_freq&#39;: psutil.cpu_freq(),
            &#39;cpu_mem_total&#39;: memory.total,
            &#39;cpu_mem_avail&#39;: memory.available,
            &#39;cpu_mem_used&#39;: memory.used,
            &#39;cpu_mem_free&#39;: memory.free,
            &#39;disk_usage_total&#39;: disk.total,
            &#39;disk_usage_used&#39;: disk.used,
            &#39;disk_usage_free&#39;: disk.free,
            &#39;disk_usage_percent&#39;: disk.percent,
            &#39;sensor_temperatures&#39;: psutil.sensors_temperatures()[&#39;cpu-thermal&#39;][0].current, }

    return system_info_data

api.add_resource(PiData, &#39;/get-stats&#39;)

if __name__ == &#39;__main__&#39;:
    app.run(debug=True)
</code></pre><p>你的脚本已经就绪，下面运行 <code>PiData.py</code>：</p><pre tabindex=0><code>$ python PyData.py
 * Serving Flask app &#34;PiData&#34; (lazy loading)
 * Environment: production
 WARNING: This is a development server. Do not run this in a production environment.
 
 * Debug mode: on
 * Running on http://127.0.0.1:5000 (Press CTRL+C to quit)
 * Restarting with stat
 * Debugger is active!
</code></pre><p>你有了一个可以工作的 API。</p><h4 id=4将-api-提供给互联网>4、将 API 提供给互联网</h4><p>你可以在本地网络中与 API 进行交互。然而，要在互联网上访问它，你必须在防火墙中打开一个端口，并将传入的流量转发到由 Flask 提供的端口。然而，正如你的测试输出建议的那样，在 Flask 中运行 Flask 应用程序仅适用于开发，而不适用于生产。为了安全地将 API 提供给互联网，你可以使用安装过程中安装的 <code>gunicorn</code> 生产服务器。</p><p>现在，你可以启动 Flask API。每次重新启动树莓派时都需要执行此操作。</p><pre tabindex=0><code>$ gunicorn -w 4 &#39;PyData:app&#39;
Serving on http://0.0.0.0:8000
</code></pre><p>要从外部世界访问你的树莓派，请在网络防火墙中打开一个端口，并将流量定向到你树莓派的 IP 地址，端口为 8000。</p><p>首先，获取树莓派的内部 IP 地址：</p><pre tabindex=0><code>$ ip addr show | grep inet
</code></pre><p>内部 IP 地址通常以 10 或 192 或 172 开头。</p><p>接下来，你必须配置防火墙。通常，你从互联网服务提供商（ISP）获取的路由器中嵌入了防火墙。通常，你可以通过网络浏览器访问家用路由器。路由器的地址有时会打印在路由器的底部，它以 192.168 或 10 开头。不过，每个设备都不同，因此我无法告诉你需要点击哪些选项来调整设置。关于如何配置防火墙的完整描述，请阅读 Seth Kenlon 的文章 《<a href=https://opensource.com/article/20/9/firewall>打开端口并通过你的防火墙路由流量</a>》。</p><p>或者，你可以使用 <a href=https://theboroer.github.io/localtunnel-www/>localtunnel</a> 来使用动态端口转发服务。</p><p>一旦你的流量到达树莓派，你就可以查询你的 API：</p><pre tabindex=0><code>$ curl https://example.com/get-stats
{
   &#34;cpu_count&#34;: 4,
   &#34;cpu_freq&#34;: [
      600.0,
      600.0,
      1200.0 ],
   &#34;cpu_mem_avail&#34;: 386273280,
   ...
</code></pre><p>如果你已经执行到这一步，那么最困难的部分已经过去了。</p><h4 id=5重复步骤>5、重复步骤</h4><p>如果你重新启动了树莓派，你必须按照以下步骤进行操作：</p><ul><li>使用 <code>source</code> 重新激活 Python 环境</li><li>使用 <code>pip</code> 刷新应用程序的依赖项</li><li>使用 <code>gunicorn</code> 启动 Flask 应用程序</li></ul><p>你的防火墙设置是持久的，但如果你使用了 localtunnel，则必须在重新启动后启动新的隧道。</p><p>如果你愿意，可以自动化这些任务，但那是另一个教程的内容。本教程的最后一部分是在 Appsmith 上构建一个用户界面，使用拖放式小部件和一些 JavaScript，将你的树莓派数据绑定到用户界面。相信我，从现在开始很容易！</p><h3 id=在-appsmith-上构建仪表盘>在 Appsmith 上构建仪表盘</h3><p><img src=https://img.linux.net.cn/data/attachment/album/202307/10/102926j2mkk9aak9n92rxk.png alt=硬件监控仪表盘></p><p>要制作一个像这样的仪表盘，你需要将公开的 API 端点连接到 Appsmith，使用 Appsmith 的小部件库构建用户界面，并将 API 的响应绑定到小部件上。如果你已经使用 Appsmith，你可以直接导入 <a href=https://github.com/appsmithorg/foundry/tree/main/resources/blogs/Raspberry%20Pi%20Dashboard>示例应用程序</a> 并开始使用。</p><p>如果你还没有，请 <a href=https://appsmith.com/sign-up>注册</a> 一个免费的 Appsmith 帐户。或者，你可以选择 <a href=https://docs.appsmith.com/getting-started/setup>自托管 Appsmith</a>。</p><h3 id=将-api-作为-appsmith-数据源连接>将 API 作为 Appsmith 数据源连接</h3><p>登录到你的 Appsmith 帐户。</p><ul><li>在左侧导航栏中找到并点击 “ 查询或 JS QUERIES/JS ” 旁边的 “+” 按钮。</li><li>点击 “ 创建一个空白 API Create a blank API ”。</li><li>在页面顶部，将你的项目命名为 “PiData”。</li><li>获取你的 API 的 URL。如果你使用的是 localtunnel，则是一个 <code>localtunnel.me</code> 地址，总是在末尾添加 <code>/get-stats</code> 以获取统计数据。将其粘贴到页面的第一个空白字段中，然后点击 “RUN” 按钮。</li></ul><p>确保在 “ 响应 Response ” 面板中看到成功的响应。</p><p><img src=https://img.linux.net.cn/data/attachment/album/202307/10/103200q8rrrn082ar0rrwr.jpg alt="Appsmith 界面"></p><h3 id=构建用户界面>构建用户界面</h3><p>Appsmith 的界面非常直观，但如果你感到迷失，我建议你查看 <a href=https://docs.appsmith.com/getting-started/start-building>在 Appsmith 上构建你的第一个应用程序</a> 教程。</p><p>对于标题，将 “ 文本 Text ”、“ 图像 Image ” 和 “ 分隔线 Divider ” 小部件拖放到画布上。将它们排列如下：</p><p><img src=https://img.linux.net.cn/data/attachment/album/202307/10/103210gz1ksff34zn66n11.jpg alt=设置项目标题></p><p>“ 文本 Text ” 小部件包含你页面的实际标题。键入比“Raspberry Pi Stats”更酷的内容。</p><p>“ 图像 Image ” 小部件用于展示仪表盘的独特标志。你可以使用你喜欢的任何标志。</p><p>使用 “ 开关 Switch ” 小部件来切换实时数据模式。在 “ 属性 Property ” 面板中进行配置，以从你构建的 API 获取数据。</p><p>对于主体部分，使用来自左侧的小部件库的以下小部件创建一个 CPU 统计信息区域，使用以下小部件：</p><ul><li>进度条 Progress Bar</li><li>统计框 Stat Box</li><li>图表 Chart</li></ul><p>对于内存和磁盘统计信息部分，重复相同的步骤。磁盘统计信息部分不需要图表，但如果你能找到用途，那也可以使用它。</p><p>你的最终小部件布局应该类似于以下：</p><p><img src=https://img.linux.net.cn/data/attachment/album/202307/10/103222zc4h4yb8h4fog2wx.jpg alt="Appsmith 中的属性设置"></p><p>最后一步是将 API 的数据绑定到你的小部件上。</p><h3 id=将数据绑定到小部件上>将数据绑定到小部件上</h3><p>返回到画布，并在三个类别的部分中找到你的小部件。首先设置 CPU 统计信息。</p><p>要将数据绑定到 “ 进度条 Progress Bar ” 小部件：</p><ul><li>单击 “ 进度条 Progress Bar ” 小部件，以打开右侧的 “ 属性 Property ” 面板。</li><li>查找 “ 进度 Progress ” 属性。</li><li>单击 “JS” 按钮以激活 JavaScript。</li><li>在 “ 进度 Progress ” 字段中粘贴 <code>{{PiData.data.cpu_percent ?? 0}}</code>。此代码引用了你的 API 的数据流，名为 <code>PiData</code>。Appsmith 将响应数据缓存在 <code>PiData</code> 的 <code>.data</code> 运算符内。键 <code>cpu_percent</code> 包含了 Appsmith 用来显示 CPU 利用率百分比的数据。</li><li>在 “ 进度条 Progress Bar ” 小部件下方添加一个 “ 文本 Text ” 小部件作为标签。</li></ul><p><img src=https://img.linux.net.cn/data/attachment/album/202307/10/103234kbryjjgjsk060bkb.jpg alt=在配置屏幕中绑定数据></p><p>在 CPU 部分有三个 “ 统计框 Stat Box ” 小部件。将数据绑定到每个小部件的步骤与绑定 “ 进度条 Progress Bar ” 小部件的步骤完全相同，只是你需要从 <code>.data</code> 运算符中绑定不同的数据属性。按照相同的步骤进行操作，但有以下例外：</p><ul><li>使用 <code>{{${PiData.data.cpu_freq[0]} ?? 0 }}</code> 来显示时钟速度。</li><li>使用 <code>{{${PiData.data.cpu_count} ?? 0 }}</code> 来显示 CPU 计数。</li><li>使用 <code>{{${(PiData.data.sensor_temperatures).toPrecision(3)} ?? 0 }}</code> 来显示 CPU 温度数据。</li></ul><p>如果一切顺利，你将得到一个漂亮的仪表盘，如下所示：</p><p><img src=https://img.linux.net.cn/data/attachment/album/202307/10/103242jiiam03mki3i0r60.jpg alt=树莓派的仪表盘></p><h3 id=cpu-利用率趋势图>CPU 利用率趋势图</h3><p>你可以使用 “ 图表 Chart ” 小部件将 CPU 利用率显示为趋势线，并使其随时间自动更新。</p><p>首先，单击小部件，在右侧找到 “ 图表类型 Chart Type ” 属性，并将其更改为 “ 折线图 LINE CHART ”。为了显示趋势线，需要将 <code>cpu_percent</code> 存储在数据点数组中。你的 API 目前将其作为单个时间数据点返回，因此可以使用 Appsmith 的 <code>storeValue</code> 函数（Appsmith 内置的 <code>setItem</code> 方法的一个原生实现）来获取一个数组。</p><p>在 “ 查询或 JS QUERIES/JS ” 旁边单击 “+” 按钮，并将其命名为 “utils”。</p><p>将以下 JavaScript 代码粘贴到 “ 代码 Code ” 字段中：</p><pre tabindex=0><code>export default {
  getLiveData: () =&gt; {
  //When switch is on:
    if (Switch1.isSwitchedOn) {
      setInterval(() =&gt; {
        let utilData = appsmith.store.cpu_util_data;

        PiData.run()
          storeValue(&#34;cpu_util_data&#34;, [...utilData, {
            x: PiData.data.cpu_percent,
            y: PiData.data.cpu_percent
          }]);           
        }, 1500, &#39;timerId&#39;)
      } else {
    clearInterval(&#39;timerId&#39;);
  }
},
initialOnPageLoad: () =&gt; {
  storeValue(&#34;cpu_util_data&#34;, []);
  }
}
</code></pre><p>为了初始化 <code>Store</code>，你在 <code>initialOnPageLoad</code> 对象中创建了一个 JavaScript 函数，并将 <code>storeValue</code> 函数放在其中。</p><p>你使用 <code>storeValue("cpu_util_data", []);</code> 将 <code>cpu_util_data</code> 中的值存储到 <code>storeValue</code> 函数中。此函数在页面加载时运行。</p><p>到目前为止，每次刷新页面时，代码都会将 <code>cpu_util_data</code> 中的一个数据点存储到 <code>Store</code> 中。为了存储一个数组，你使用了 <code>x</code> 和 <code>y</code> 的下标变量，两者都存储了来自 <code>cpu_percent</code> 数据属性的值。</p><p>你还希望通过设定存储值之间的固定时间间隔来自动存储这些数据。当执行 <a href=https://docs.appsmith.com/reference/appsmith-framework/widget-actions/intervals-time-events#setinterval>setInterval</a> 函数时：</p><ul><li>获取存储在 <code>cpu_util_data</code> 中的值。</li><li>调用 API <code>PiData</code>。</li><li>使用返回的最新 <code>cpu_percent</code> 数据将 <code>cpu_util_data</code> 更新为 <code>x</code> 和 <code>y</code> 变量。</li><li>将 <code>cpu_util_data</code> 的值存储在键 <code>utilData</code> 中。</li><li>仅当设置为自动执行函数时，才重复执行步骤 1 到 4。你使用 Switch 小部件将其设置为自动执行，这就解释了为什么有一个 <code>getLiveData</code> 父函数。</li></ul><p>在 “ 设置 Settings ” 选项卡中，找到对象中的所有父函数，并在 “ 页面加载时运行 RUN ON PAGE LOAD ” 选项中将 <code>initialOnPageLoad</code> 设置为 “Yes（是）”。</p><p><img src=https://img.linux.net.cn/data/attachment/album/202307/10/103253apiwjbjbiu6fj3wp.jpg alt=设置页面加载时要执行的函数></p><p>现在刷新页面进行确认。</p><p>返回到画布。单击 “ 图表 Chart ” 小部件，并找到 “ 图表数据 Chart Data ” 属性。将绑定 <code>{{ appsmith.store.disk_util_data }}</code> 粘贴到其中。这样，如果你自己多次运行对象 <code>utils</code>，就可以获得图表数据。要自动运行此操作：</p><ul><li>查找并单击仪表盘标题中的 “ 实时数据开关 Live Data Switch ” 小部件。</li><li>查找 <code>onChange</code> 事件。</li><li>将其绑定到 <code>{{ utils.getLiveData() }}</code>。JavaScript 对象是 <code>utils</code>，而 <code>getLiveData</code> 是在你切换开关时激活的函数，它会从你的树莓派获取实时数据。但是还有其他实时数据，因此同一开关也适用于它们。继续阅读以了解详情。</li></ul><p>将数据绑定到内存和磁盘部分的小部件与你在 CPU 统计信息部分所做的方式类似。</p><p>对于内存部分，绑定如下所示：</p><ul><li>进度条中的绑定为：<code>{{( PiData.data.cpu_mem_avail/1000000000).toPrecision(2) \* 100 ?? 0 }}</code>。</li><li>三个统计框小部件的绑定分别为：<code>{{ \${(PiData.data.cpu_mem_used/1000000000).toPrecision(2)} ?? 0 }} GB</code>、<code>{{ \${(PiData.data.cpu_mem_free/1000000000).toPrecision(2)} ?? 0}} GB</code> 和 <code>{{ \${(PiData.data.cpu_mem_total/1000000000).toPrecision(2)} ?? 0 }} GB</code>。</li></ul><p>对于磁盘部分，进度条和统计框小部件的绑定分别变为：</p><ul><li>进度条的绑定为：<code>{{ PiData.data.disk_usage_percent ?? 0 }}</code>。</li><li>三个统计框小部件的绑定分别为：<code>{{ \${(PiData.data.disk_usage_used/1000000000).toPrecision(2)} ?? 0 }} GB</code>、<code>{{ \${(PiData.data.disk_usage_free/1000000000).toPrecision(2)} ?? 0 }} GB</code> 和 <code>{{ \${(PiData.data.disk_usage_total/1000000000).toPrecision(2)} ?? 0 }} GB</code>。</li></ul><p>这里的图表需要更新你为 CPU 统计信息创建的 <code>utils</code> 对象，使用 <code>storeValue</code> 键名为 <code>disk_util_data</code>，嵌套在 <code>getLiveData</code> 下面，其逻辑与 <code>cpu_util_data</code> 类似。对于磁盘利用率图表，我们存储的 <code>disk_util_data</code> 的逻辑与 CPU 利用率趋势图的逻辑相同。</p><pre tabindex=0><code>export default {
  getLiveData: () =&gt; {
  //When switch is on:
    if (Switch1.isSwitchedOn) {
      setInterval(() =&gt; {
       const cpuUtilData = appsmith.store.cpu_util_data;
       const diskUtilData = appsmith.store.disk_util_data;                   
       
       PiData.run();
       
       storeValue(&#34;cpu_util_data&#34;, [...cpuUtilData, { x: PiData.data.cpu_percent,y: PiData.data.cpu_percent }]);
       storeValue(&#34;disk_util_data&#34;, [...diskUtilData, { x: PiData.data.disk_usage_percent,y: PiData.data.disk_usage_percent }]);
    }, 1500, &#39;timerId&#39;)
  } else {
    clearInterval(&#39;timerId&#39;);
  }
},
  initialOnPageLoad: () =&gt; {
    storeValue(&#34;cpu_util_data&#34;, []);
    storeValue(&#34;disk_util_data&#34;, []);
  }
}
</code></pre><p>通过使用 <code>utils</code> JavaScript 对象在打开和关闭真实数据开关时触发的数据流可视化如下所示：</p><p><img src=https://img.linux.net.cn/data/attachment/album/202307/10/102928s4lkngonzh787bkh.gif alt=切换></p><p>在打开实时数据开关时，图表会变成这样：</p><p><img src=https://img.linux.net.cn/data/attachment/album/202307/10/102932vh4s65lhjlhjppzp.gif alt=显示实时数据></p><p>整体上，它既漂亮，又简约，而且非常有用。</p><h3 id=祝你使用愉快>祝你使用愉快！</h3><p>当你对 <code>psutils</code>、JavaScript 和 Appsmith 更加熟悉时，我相信你会发现可以轻松无限地调整你的仪表板，实现非常酷的功能，例如：</p><ul><li>查看先前一周、一个月、一个季度、一年或根据你的树莓派数据允许的任何自定义范围的趋势</li><li>为任何统计数据的阈值违规构建报警机制</li><li>监控连接到你的树莓派的其他设备</li><li>将 <code>psutils</code> 扩展到另一台安装有 Python 的计算机上</li><li>使用其他库监控你家庭或办公室的网络</li><li>监控你的花园</li><li>跟踪你自己的生活习惯</li></ul><p>在下一个令人兴奋的项目中，祝你玩得愉快！</p><p><em>（题图：MJ/9754eb1f-1722-4897-9c35-3f20c285c332）</em></p><hr><p>via: <a href=https://opensource.com/article/23/3/build-raspberry-pi-dashboard-appsmith>https://opensource.com/article/23/3/build-raspberry-pi-dashboard-appsmith</a></p><p>作者：<a href=https://opensource.com/users/keyur-paralkar>Keyur Paralkar</a> 选题：<a href=https://github.com/lkxed/>lkxed</a> 译者：ChatGPT 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/%E7%9B%91%E6%8E%A7/ rel=tag>监控</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E4%BB%AA%E8%A1%A8%E7%9B%98/ rel=tag>仪表盘</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>