<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>使用 Jupyter 改善你的时间管理 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="使用 Jupyter 改善你的时间管理"><meta property="og:description" content="在 Jupyter 里使用 Python 来分析日历，以了解你是如何使用时间的。"><meta property="og:type" content="article"><meta property="og:url" content="/article-13212-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-03-18T09:55:48+00:00"><meta property="article:modified_time" content="2021-03-18T09:55:48+00:00"><meta itemprop=name content="使用 Jupyter 改善你的时间管理"><meta itemprop=description content="在 Jupyter 里使用 Python 来分析日历，以了解你是如何使用时间的。"><meta itemprop=datePublished content="2021-03-18T09:55:48+00:00"><meta itemprop=dateModified content="2021-03-18T09:55:48+00:00"><meta itemprop=wordCount content="482"><meta itemprop=keywords content="Jupyter,日历,Python,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>使用 Jupyter 改善你的时间管理</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2021-03-18T09:55:48Z>March 18, 2021</time></div></div></header><div class="content post__content clearfix"><blockquote><p>在 Jupyter 里使用 Python 来分析日历，以了解你是如何使用时间的。</p></blockquote><p><img src=https://img.linux.net.cn/data/attachment/album/202103/18/095530cxx6663ptypyzvmx.jpg alt title="Calendar close up snapshot"></p><p><a href=https://opensource.com/resources/python>Python</a> 在探索数据方面具有令人难以置信的可扩展性。利用 <a href=https://pandas.pydata.org/>Pandas</a> 或 <a href=https://dask.org/>Dask</a>，你可以将 <a href=https://jupyter.org/>Jupyter</a> 扩展到大数据领域。但是小数据、个人资料、私人数据呢？</p><p>JupyterLab 和 Jupyter Notebook 为我提供了一个绝佳的环境，可以让我审视我的笔记本电脑生活。</p><p>我的探索是基于以下事实：我使用的几乎每个服务都有一个 Web API。我使用了诸多此类服务：待办事项列表、时间跟踪器、习惯跟踪器等。还有一个几乎每个人都会使用到：<em>日历</em>。相同的思路也可以应用于其他服务，但是日历具有一个很酷的功能：几乎所有 Web 日历都支持的开放标准 —— CalDAV。</p><h3 id=在-jupyter-中使用-python-解析日历>在 Jupyter 中使用 Python 解析日历</h3><p>大多数日历提供了导出为 CalDAV 格式的方法。你可能需要某种身份验证才能访问这些私有数据。按照你的服务说明进行操作即可。如何获得凭据取决于你的服务，但是最终，你应该能够将这些凭据存储在文件中。我将我的凭据存储在根目录下的一个名为 <code>.caldav</code> 的文件中：</p><pre tabindex=0><code>import os
with open(os.path.expanduser(&#34;~/.caldav&#34;)) as fpin:
    username, password = fpin.read().split()
</code></pre><p>切勿将用户名和密码直接放在 Jupyter Notebook 的笔记本中！它们可能会很容易因 <code>git push</code> 的错误而导致泄漏。</p><p>下一步是使用方便的 PyPI <a href=https://pypi.org/project/caldav/>caldav</a> 库。我找到了我的电子邮件服务的 CalDAV 服务器（你可能有所不同）：</p><pre tabindex=0><code>import caldav
client = caldav.DAVClient(url=&#34;https://caldav.fastmail.com/dav/&#34;, username=username, password=password)
</code></pre><p>CalDAV 有一个称为 <code>principal</code>（主键）的概念。它是什么并不重要，只要知道它是你用来访问日历的东西就行了：</p><pre tabindex=0><code>principal = client.principal()
calendars = principal.calendars()
</code></pre><p>从字面上讲，日历就是关于时间的。访问事件之前，你需要确定一个时间范围。默认一星期就好：</p><pre tabindex=0><code>from dateutil import tz
import datetime
now = datetime.datetime.now(tz.tzutc())
since = now - datetime.timedelta(days=7)
</code></pre><p>大多数人使用的日历不止一个，并且希望所有事件都在一起出现。<code>itertools.chain.from_iterable</code> 方法使这一过程变得简单：</p><pre tabindex=0><code>import itertools

raw_events = list(
    itertools.chain.from_iterable(
        calendar.date_search(start=since, end=now, expand=True)
        for calendar in calendars
    )
)
</code></pre><p>将所有事件读入内存很重要，以 API 原始的本地格式进行操作是重要的实践。这意味着在调整解析、分析和显示代码时，无需返回到 API 服务刷新数据。</p><p>但 “原始” 真的是原始，事件是以特定格式的字符串出现的：</p><pre tabindex=0><code>print(raw_events[12].data)
</code></pre><pre tabindex=0><code>    BEGIN:VCALENDAR
    VERSION:2.0
    PRODID:-//CyrusIMAP.org/Cyrus
     3.3.0-232-g4bdb081-fm-20200825.002-g4bdb081a//EN
    BEGIN:VEVENT
    DTEND:20200825T230000Z
    DTSTAMP:20200825T181915Z
    DTSTART:20200825T220000Z
    SUMMARY:Busy
    UID:
     1302728i-040000008200E00074C5B7101A82E00800000000D939773EA578D601000000000
     000000010000000CD71CC3393651B419E9458134FE840F5
    END:VEVENT
    END:VCALENDAR
</code></pre><p>幸运的是，PyPI 可以再次使用另一个辅助库 <a href=https://pypi.org/project/vobject/>vobject</a> 解围：</p><pre tabindex=0><code>import io
import vobject

def parse_event(raw_event):
    data = raw_event.data
    parsed = vobject.readOne(io.StringIO(data))
    contents = parsed.vevent.contents
    return contents
</code></pre><pre tabindex=0><code>parse_event(raw_events[12])
</code></pre><pre tabindex=0><code>    {&#39;dtend&#39;: [&lt;DTEND{}2020-08-25 23:00:00+00:00&gt;],
     &#39;dtstamp&#39;: [&lt;DTSTAMP{}2020-08-25 18:19:15+00:00&gt;],
     &#39;dtstart&#39;: [&lt;DTSTART{}2020-08-25 22:00:00+00:00&gt;],
     &#39;summary&#39;: [&lt;SUMMARY{}Busy&gt;],
     &#39;uid&#39;: [&lt;UID{}1302728i-040000008200E00074C5B7101A82E00800000000D939773EA578D601000000000000000010000000CD71CC3393651B419E9458134FE840F5&gt;]}
</code></pre><p>好吧，至少好一点了。</p><p>仍有一些工作要做，将其转换为合理的 Python 对象。第一步是 <em>拥有</em> 一个合理的 Python 对象。<a href=https://opensource.com/article/19/5/python-attrs>attrs</a> 库提供了一个不错的开始：</p><pre tabindex=0><code>import attr
from __future__ import annotations
@attr.s(auto_attribs=True, frozen=True)
class Event:
    start: datetime.datetime
    end: datetime.datetime
    timezone: Any
    summary: str
</code></pre><p>是时候编写转换代码了！</p><p>第一个抽象从解析后的字典中获取值，不需要所有的装饰：</p><pre tabindex=0><code>def get_piece(contents, name):
    return contents[name][0].value
get_piece(_, &#34;dtstart&#34;)
    datetime.datetime(2020, 8, 25, 22, 0, tzinfo=tzutc())
</code></pre><p>日历事件总有一个“开始”、有一个“结束”、有一个 “持续时间”。一些谨慎的解析逻辑可以将两者协调为同一个 Python 对象：</p><pre tabindex=0><code>def from_calendar_event_and_timezone(event, timezone):
    contents = parse_event(event)
    start = get_piece(contents, &#34;dtstart&#34;)
    summary = get_piece(contents, &#34;summary&#34;)
    try:
        end = get_piece(contents, &#34;dtend&#34;)
    except KeyError:
        end = start + get_piece(contents, &#34;duration&#34;)
    return Event(start=start, end=end, summary=summary, timezone=timezone)
</code></pre><p>将事件放在 <em>本地</em> 时区而不是 UTC 中很有用，因此使用本地时区：</p><pre tabindex=0><code>my_timezone = tz.gettz()
from_calendar_event_and_timezone(raw_events[12], my_timezone)
    Event(start=datetime.datetime(2020, 8, 25, 22, 0, tzinfo=tzutc()), end=datetime.datetime(2020, 8, 25, 23, 0, tzinfo=tzutc()), timezone=tzfile(&#39;/etc/localtime&#39;), summary=&#39;Busy&#39;)
</code></pre><p>既然事件是真实的 Python 对象，那么它们实际上应该具有附加信息。幸运的是，可以将方法添加到类中。</p><p>但是要弄清楚哪个事件发生在哪一天不是很直接。你需要在 <em>本地</em> 时区中选择一天：</p><pre tabindex=0><code>def day(self):
    offset = self.timezone.utcoffset(self.start)
    fixed = self.start + offset
    return fixed.date()
Event.day = property(day)
</code></pre><pre tabindex=0><code>print(_.day)
    2020-08-25
</code></pre><p>事件在内部始终是以“开始”/“结束”的方式表示的，但是持续时间是有用的属性。持续时间也可以添加到现有类中：</p><pre tabindex=0><code>def duration(self):
    return self.end - self.start
Event.duration = property(duration)
</code></pre><pre tabindex=0><code>print(_.duration)
    1:00:00
</code></pre><p>现在到了将所有事件转换为有用的 Python 对象了：</p><pre tabindex=0><code>all_events = [from_calendar_event_and_timezone(raw_event, my_timezone)
              for raw_event in raw_events]
</code></pre><p>全天事件是一种特例，可能对分析生活没有多大用处。现在，你可以忽略它们：</p><pre tabindex=0><code># ignore all-day events
all_events = [event for event in all_events if not type(event.start) == datetime.date]
</code></pre><p>事件具有自然顺序 —— 知道哪个事件最先发生可能有助于分析：</p><pre tabindex=0><code>all_events.sort(key=lambda ev: ev.start)
</code></pre><p>现在，事件已排序，可以将它们加载到每天：</p><pre tabindex=0><code>import collections
events_by_day = collections.defaultdict(list)
for event in all_events:
    events_by_day[event.day].append(event)
</code></pre><p>有了这些，你就有了作为 Python 对象的带有日期、持续时间和序列的日历事件。</p><h3 id=用-python-报到你的生活>用 Python 报到你的生活</h3><p>现在是时候编写报告代码了！带有适当的标题、列表、重要内容以粗体显示等等，有醒目的格式是很意义。</p><p>这就是一些 HTML 和 HTML 模板。我喜欢使用 <a href=https://chameleon.readthedocs.io/en/latest/>Chameleon</a>：</p><pre tabindex=0><code>template_content = &#34;&#34;&#34;
&lt;html&gt;&lt;body&gt;
&lt;div tal:repeat=&#34;item items&#34;&gt;
&lt;h2 tal:content=&#34;item[0]&#34;&gt;Day&lt;/h2&gt;
&lt;ul&gt;
    &lt;li tal:repeat=&#34;event item[1]&#34;&gt;&lt;span tal:replace=&#34;event&#34;&gt;Thing&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;&#34;&#34;&#34;
</code></pre><p>Chameleon 的一个很酷的功能是使用它的 <code>html</code> 方法渲染对象。我将以两种方式使用它：</p><ul><li>摘要将以粗体显示</li><li>对于大多数活动，我都会删除摘要（因为这是我的个人信息）</li></ul><pre tabindex=0><code>def __html__(self):
    offset = my_timezone.utcoffset(self.start)
    fixed = self.start + offset
    start_str = str(fixed).split(&#34;+&#34;)[0]
    summary = self.summary
    if summary != &#34;Busy&#34;:
        summary = &#34;&amp;lt;REDACTED&amp;gt;&#34;
    return f&#34;&lt;b&gt;{summary[:30]}&lt;/b&gt; -- {start_str} ({self.duration})&#34;
Event.__html__ = __html__
</code></pre><p>为了简洁起见，将该报告切成每天的：</p><pre tabindex=0><code>import chameleon
from IPython.display import HTML
template = chameleon.PageTemplate(template_content)
html = template(items=itertools.islice(events_by_day.items(), 3, 4))
HTML(html)
</code></pre><p>渲染后，它将看起来像这样：</p><p><strong>2020-08-25</strong></p><ul><li><strong></strong>&ndash; 2020-08-25 08:30:00 (0:45:00)</li><li><strong></strong>&ndash; 2020-08-25 10:00:00 (1:00:00)</li><li><strong></strong>&ndash; 2020-08-25 11:30:00 (0:30:00)</li><li><strong></strong>&ndash; 2020-08-25 13:00:00 (0:25:00)</li><li>Busy &ndash; 2020-08-25 15:00:00 (1:00:00)</li><li><strong></strong>&ndash; 2020-08-25 15:00:00 (1:00:00)</li><li><strong></strong>&ndash; 2020-08-25 19:00:00 (1:00:00)</li><li><strong></strong>&ndash; 2020-08-25 19:00:12 (1:00:00)</li></ul><h3 id=python-和-jupyter-的无穷选择>Python 和 Jupyter 的无穷选择</h3><p>通过解析、分析和报告各种 Web 服务所拥有的数据，这只是你可以做的事情的表面。</p><p>为什么不对你最喜欢的服务试试呢？</p><hr><p>via: <a href=https://opensource.com/article/20/9/calendar-jupyter>https://opensource.com/article/20/9/calendar-jupyter</a></p><p>作者：<a href=https://opensource.com/users/moshez>Moshe Zadka</a> 选题：<a href=https://github.com/lujun9972>lujun9972</a> 译者：<a href=https://github.com/stevenzdg988>stevenzdg988</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/jupyter/ rel=tag>Jupyter</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E6%97%A5%E5%8E%86/ rel=tag>日历</a></li><li class=tags__item><a class="tags__link btn" href=/tags/python/ rel=tag>Python</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>