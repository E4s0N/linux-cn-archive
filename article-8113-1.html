<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>如何在 Docker 中设置 Go 并部署应用 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="如何在 Docker 中设置 Go 并部署应用"><meta property="og:description" content="在本教程中，我们将学习如何使用 docker 部署 golang web 应用程序。"><meta property="og:type" content="article"><meta property="og:url" content="/article-8113-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-01-12T09:46:39+00:00"><meta property="article:modified_time" content="2017-01-12T09:46:39+00:00"><meta itemprop=name content="如何在 Docker 中设置 Go 并部署应用"><meta itemprop=description content="在本教程中，我们将学习如何使用 docker 部署 golang web 应用程序。"><meta itemprop=datePublished content="2017-01-12T09:46:39+00:00"><meta itemprop=dateModified content="2017-01-12T09:46:39+00:00"><meta itemprop=wordCount content="544"><meta itemprop=keywords content="Docker,golang,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>如何在 Docker 中设置 Go 并部署应用</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-01-12T09:46:39Z>January 12, 2017</time></div></div></header><div class="content post__content clearfix"><p>嗨，在本教程中，我们将学习如何使用 docker 部署 golang web 应用程序。 你可能已经知道，由于 golang 的高性能和可靠性，docker 是完全是用 golang 写的。在我们详细介绍之前，请确保你已经安装了 docker 以及 golang 并对它们有基本了解。</p><p><img src=/data/attachment/album/201701/12/094625moon9fmlccxosoka.jpg alt></p><h3 id=关于-docker>关于 docker</h3><p>Docker 是一个开源程序，它可以将应用及其完整的依赖包捆绑到一起，并打包为容器，与宿主机共享相同的 Linux 内核。另一方面，像 VMware 这样的基于 hypervisor 的虚拟化操作系统容器提供了高级别的隔离和安全性，这是由于客户机和主机之间的通信是通过 hypervisor 来实现的，它们不共享内核空间。但是硬件仿真也导致了性能的开销，所以容器虚拟化诞生了，以提供一个轻量级的虚拟环境，它将一组进程和资源与主机以及其它容器分组及隔离，因此，容器内部的进程无法看到容器外部的进程或资源。</p><h3 id=用-go-语言创建一个-hello-world-web-应用>用 Go 语言创建一个 “Hello World” web 应用</h3><p>首先我们为 Go 应用创建一个目录，它会在浏览器中显示 “Hello World”。创建一个 <code>web-app</code> 目录并使它成为当前目录。进入 <code>web-app</code> 应用目录并编辑一个名为 <code>main.go</code> 的文件。</p><pre tabindex=0><code>root@demohost:~# mkdir web-app
root@demohost:~# cd web-app/
root@demohost:~/web-app# vim.tiny main.go

package main
import (
    &#34;fmt&#34;
    &#34;net/http&#34;
)

func handler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, &#34;Hello %s&#34;, r.URL.Path[1:])
}

func main() {
    http.HandleFunc(&#34;/World&#34;, handler)
    http.ListenAndServe(&#34;:8080&#34;, nil)
}
</code></pre><p>使用下面的命令运行上面的 “Hello World” Go 程序。在浏览器中输入 <code>http://127.0.0.1:8080/World</code> 测试，你会在浏览器中看到 “Hello World”。</p><pre tabindex=0><code>root@demohost:~/web-app# PORT=8080 go run main.go
</code></pre><p>下一步是将上面的应用在 docker 中容器化。因此我们会创建一个 dockerfile 文件，它会告诉 docker 如何容器化我们的 web 应用。</p><pre tabindex=0><code>root@demohost:~/web-app# vim.tiny Dockerfile

# 得到最新的 golang docker 镜像
FROM golang:latest

# 在容器内部创建一个目录来存储我们的 web 应用，接着使它成为工作目录。
RUN mkdir -p /go/src/web-app
WORKDIR /go/src/web-app

# 复制 web-app 目录到容器中
COPY . /go/src/web-app

# 下载并安装第三方依赖到容器中
RUN go-wrapper download
RUN go-wrapper install

# 设置 PORT 环境变量
ENV PORT 8080

# 给主机暴露 8080 端口，这样外部网络可以访问你的应用
EXPOSE 8080

# 告诉 Docker 启动容器运行的命令
CMD [&#34;go-wrapper&#34;, &#34;run&#34;]
</code></pre><h3 id=构建运行容器>构建/运行容器</h3><p>使用下面的命令构建你的 Go web-app，你会在成功构建后获得确认。</p><pre tabindex=0><code>root@demohost:~/web-app# docker build --rm -t web-app .
Sending build context to Docker daemon 3.584 kB
Step 1 : FROM golang:latest
latest: Pulling from library/golang
386a066cd84a: Already exists
75ea84187083: Pull complete
88b459c9f665: Pull complete
a31e17eb9485: Pull complete
1b272d7ab8a4: Pull complete
eca636a985c1: Pull complete
08158782d330: Pull complete
Digest: sha256:02718aef869a8b00d4a36883c82782b47fc01e774d0ac1afd434934d8ccfee8c
Status: Downloaded newer image for golang:latest
---&gt; 9752d71739d2
Step 2 : RUN mkdir -p /go/src/web-app
---&gt; Running in 9aef92fff9e8
---&gt; 49936ff4f50c
Removing intermediate container 9aef92fff9e8
Step 3 : WORKDIR /go/src/web-app
---&gt; Running in 58440a93534c
---&gt; 0703574296dd
Removing intermediate container 58440a93534c
Step 4 : COPY . /go/src/web-app
---&gt; 82be55bc8e9f
Removing intermediate container cae309ac7757
Step 5 : RUN go-wrapper download
---&gt; Running in 6168e4e96ab1
+ exec go get -v -d
---&gt; 59664b190fee
Removing intermediate container 6168e4e96ab1
Step 6 : RUN go-wrapper install
---&gt; Running in e56f093b6f03
+ exec go install -v
web-app
---&gt; 584cd410fdcd
Removing intermediate container e56f093b6f03
Step 7 : ENV PORT 8080
---&gt; Running in 298e2a415819
---&gt; c87fd2b43977
Removing intermediate container 298e2a415819
Step 8 : EXPOSE 8080
---&gt; Running in 4f639a3790a7
---&gt; 291167229d6f
Removing intermediate container 4f639a3790a7
Step 9 : CMD go-wrapper run
---&gt; Running in 6cb6bc28e406
---&gt; b32ca91bdfe0
Removing intermediate container 6cb6bc28e406
Successfully built b32ca91bdfe0
</code></pre><p>现在可以运行我们的 web-app 了，可以执行下面的命令。</p><pre tabindex=0><code>root@demohost:~/web-app# docker run -p 8080:8080 --name=&#34;test&#34; -d web-app
7644606b9af28a3ef1befd926f216f3058f500ffad44522c1d4756c576cfa85b
</code></pre><p>进入 <code>http://localhost:8080/World</code> 浏览你的 web 应用。你已经成功容器化了一个可重复的/确定性的 Go web 应用。使用下面的命令来启动、停止并检查容器的状态。</p><pre tabindex=0><code>### 列出所有容器
root@demohost:~/ docker ps -a

### 使用 id 启动容器
root@demohost:~/ docker start CONTAINER_ID_OF_WEB_APP

### 使用 id 停止容器
root@demohost:~/ docker stop CONTAINER_ID_OF_WEB_APP
</code></pre><h3 id=重新构建镜像>重新构建镜像</h3><p>假设你正在开发 web 应用程序并在更改代码。现在要在更新代码后查看结果，你需要重新生成 docker 镜像、停止旧镜像并运行新镜像，并且每次更改代码时都要这样做。为了使这个过程自动化，我们将使用 docker 卷在主机和容器之间共享一个目录。这意味着你不必为在容器内进行更改而重新构建镜像。容器如何检测你是否对 web 程序的源码进行了更改？答案是有一个名为 “Gin” 的好工具 <a href=https://github.com/codegangsta/gin>https://github.com/codegangsta/gin</a>，它能检测是否对源码进行了任何更改，然后重建镜像/二进制文件并在容器内运行更新过代码的进程。</p><p>要使这个过程自动化，我们将编辑 Dockerfile 并安装 Gin 将其作为入口命令来执行。我们将开放 <code>3030</code> 端口（Gin 代理），而不是 <code>8080</code>。 Gin 代理将转发流量到 web 程序的 <code>8080</code> 端口。</p><pre tabindex=0><code>root@demohost:~/web-app# vim.tiny Dockerfile

# 得到最新的 golang docker 镜像
FROM golang:latest

# 在容器内部创建一个目录来存储我们的 web 应用，接着使它称为工作目录。
RUN mkdir -p /go/src/web-app
WORKDIR /go/src/web-app

# 复制 web 程序到容器中
COPY . /go/src/web-app

# 下载并安装第三方依赖到容器中
RUN go get github.com/codegangsta/gin
RUN go-wrapper download
RUN go-wrapper install

# 设置 PORT 环境变量
ENV PORT 8080

# 给主机暴露 8080 端口，这样外部网络可以访问你的应用
EXPOSE 3030

# 启动容器时运行 Gin
CMD gin run

# 告诉 Docker 启动容器运行的命令
CMD [&#34;go-wrapper&#34;, &#34;run&#34;]
</code></pre><p>现在构建镜像并启动容器：</p><pre tabindex=0><code>root@demohost:~/web-app# docker build --rm -t web-app .
</code></pre><p>我们会在当前 web 程序的根目录下运行 docker，并通过暴露的 <code>3030</code> 端口链接 CWD （当前工作目录）到容器中的应用目录下。</p><pre tabindex=0><code>root@demohost:~/web-app# docker run -p 3030:3030 -v `pwd`:/go/src/web-app --name=&#34;test&#34; -d web-app
</code></pre><p>打开 <code>http://localhost:3030/World</code>， 你就能看到你的 web 程序了。现在如果你改变了任何代码，会在浏览器刷新后反映在你的浏览器中。</p><h3 id=总结>总结</h3><p>就是这样，我们的 Go web 应用已经运行在 Ubuntu 16.04 Docker 容器中运行了！你可以通过使用 Go 框架来快速开发 API、网络应用和后端服务，从而扩展当前的网络应用。</p><hr><p>via: <a href=http://linoxide.com/containers/setup-go-docker-deploy-application/>http://linoxide.com/containers/setup-go-docker-deploy-application/</a></p><p>作者：<a href=http://linoxide.com/author/dwijadasd/>Dwijadas Dey</a> 译者：<a href=https://github.com/geekpi>geekpi</a> 校对：<a href=https://github.com/jasminepeng>jasminepeng</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/docker/ rel=tag>Docker</a></li><li class=tags__item><a class="tags__link btn" href=/tags/golang/ rel=tag>golang</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>