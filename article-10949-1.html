<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>如何写好 C main 函数 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="如何写好 C main 函数"><meta property="og:description" content="学习如何构造一个 C 文件并编写一个 C main 函数来成功地处理命令行参数。"><meta property="og:type" content="article"><meta property="og:url" content="/article-10949-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-06-08T21:15:00+00:00"><meta property="article:modified_time" content="2019-06-08T21:15:00+00:00"><meta itemprop=name content="如何写好 C main 函数"><meta itemprop=description content="学习如何构造一个 C 文件并编写一个 C main 函数来成功地处理命令行参数。"><meta itemprop=datePublished content="2019-06-08T21:15:00+00:00"><meta itemprop=dateModified content="2019-06-08T21:15:00+00:00"><meta itemprop=wordCount content="945"><meta itemprop=keywords content="C语言,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>如何写好 C main 函数</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2019-06-08T21:15:00Z>June 08, 2019</time></div></div></header><div class="content post__content clearfix"><blockquote><p>学习如何构造一个 C 文件并编写一个 C main 函数来成功地处理命令行参数。</p></blockquote><p><img src=/data/attachment/album/201906/08/211422umrzznnvmapcwuc3.jpg alt></p><p>我知道，现在孩子们用 Python 和 JavaScript 编写他们的疯狂“应用程序”。但是不要这么快就否定 C 语言 —— 它能够提供很多东西，并且简洁。如果你需要速度，用 C 语言编写可能就是你的答案。如果你正在寻找稳定的职业或者想学习如何捕获<a href=https://www.owasp.org/index.php/Null_Dereference>空指针解引用</a>，C 语言也可能是你的答案！在本文中，我将解释如何构造一个 C 文件并编写一个 C main 函数来成功地处理命令行参数。</p><p>我：一个顽固的 Unix 系统程序员。</p><p>你：一个有编辑器、C 编译器，并有时间打发的人。</p><p>让我们开工吧。</p><h3 id=一个无聊但正确的-c-程序>一个无聊但正确的 C 程序</h3><p><img src=/data/attachment/album/201906/08/211510o46awqki5uwc8rd9.png alt="Parody O&rsquo;Reilly book cover, &ldquo;Hating Other People&rsquo;s Code&rdquo;" title="Parody O'Reilly book cover, &#34;Hating Other People's Code&#34;"></p><p>C 程序以 <code>main()</code> 函数开头，通常保存在名为 <code>main.c</code> 的文件中。</p><pre tabindex=0><code>/* main.c */
int main(int argc, char *argv[]) {

}
</code></pre><p>这个程序可以<em>编译</em>但不<em>干</em>任何事。</p><pre tabindex=0><code>$ gcc main.c
$ ./a.out -o foo -vv
$
</code></pre><p>正确但无聊。</p><h3 id=main-函数是唯一的>main 函数是唯一的。</h3><p><code>main()</code> 函数是开始执行时所执行的程序的第一个函数，但不是第一个执行的函数。<em>第一个</em>函数是 <code>_start()</code>，它通常由 C 运行库提供，在编译程序时自动链入。此细节高度依赖于操作系统和编译器工具链，所以我假装没有提到它。</p><p><code>main()</code> 函数有两个参数，通常称为 <code>argc</code> 和 <code>argv</code>，并返回一个有符号整数。大多数 Unix 环境都希望程序在成功时返回 <code>0</code>（零），失败时返回 <code>-1</code>（负一）。</p><table><thead><tr><th>参数</th><th>名称</th><th>描述</th></tr></thead><tbody><tr><td><code>argc</code></td><td>参数个数</td><td>参数向量的个数</td></tr><tr><td><code>argv</code></td><td>参数向量</td><td>字符指针数组</td></tr></tbody></table><p>参数向量 <code>argv</code> 是调用你的程序的命令行的标记化表示形式。在上面的例子中，<code>argv</code> 将是以下字符串的列表：</p><pre tabindex=0><code>argv = [ &#34;/path/to/a.out&#34;, &#34;-o&#34;, &#34;foo&#34;, &#34;-vv&#34; ];
</code></pre><p>参数向量在其第一个索引 <code>argv[0]</code> 中确保至少会有一个字符串，这是执行程序的完整路径。</p><h3 id=mainc-文件的剖析>main.c 文件的剖析</h3><p>当我从头开始编写 <code>main.c</code> 时，它的结构通常如下：</p><pre tabindex=0><code>/* main.c */
/* 0 版权/许可证 */
/* 1 包含 */
/* 2 定义 */
/* 3 外部声明 */
/* 4 类型定义 */
/* 5 全局变量声明 */
/* 6 函数原型 */

int main(int argc, char *argv[]) {
/* 7 命令行解析 */
}

/* 8 函数声明 */
</code></pre><p>下面我将讨论这些编号的各个部分，除了编号为 0 的那部分。如果你必须把版权或许可文本放在源代码中，那就放在那里。</p><p>另一件我不想讨论的事情是注释。</p><pre tabindex=0><code>“评论谎言。”
- 一个愤世嫉俗但聪明又好看的程序员。
</code></pre><p>与其使用注释，不如使用有意义的函数名和变量名。</p><p>鉴于程序员固有的惰性，一旦添加了注释，维护负担就会增加一倍。如果更改或重构代码，则需要更新或扩充注释。随着时间的推移，代码会变得面目全非，与注释所描述的内容完全不同。</p><p>如果你必须写注释，不要写关于代码正在做<em>什么</em>，相反，写下代码<em>为什么</em>要这样写。写一些你将要在五年后读到的注释，那时你已经将这段代码忘得一干二净。世界的命运取决于你。<em>不要有压力。</em></p><h4 id=1包含>1、包含</h4><p>我添加到 <code>main.c</code> 文件的第一个东西是包含文件，它们为程序提供大量标准 C 标准库函数和变量。C 标准库做了很多事情。浏览 <code>/usr/include</code> 中的头文件，你可以了解到它们可以做些什么。</p><p><code>#include</code> 字符串是 <a href=https://en.wikipedia.org/wiki/C_preprocessor>C 预处理程序</a>（cpp）指令，它会将引用的文件完整地包含在当前文件中。C 中的头文件通常以 <code>.h</code> 扩展名命名，且不应包含任何可执行代码。它只有宏、定义、类型定义、外部变量和函数原型。字符串 <code>&lt;header.h></code> 告诉 cpp 在系统定义的头文件路径中查找名为 <code>header.h</code> 的文件，它通常在 <code>/usr/include</code> 目录中。</p><pre tabindex=0><code>/* main.c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;libgen.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;getopt.h&gt;
#include &lt;sys/types.h&gt;
</code></pre><p>这是我默认会全局包含的最小包含集合，它将引入：</p><table><thead><tr><th>#include 文件</th><th>提供的东西</th></tr></thead><tbody><tr><td>stdio</td><td>提供 <code>FILE</code>、<code>stdin</code>、<code>stdout</code>、<code>stderr</code> 和 <code>fprint()</code> 函数系列</td></tr><tr><td>stdlib</td><td>提供 <code>malloc()</code>、<code>calloc()</code> 和 <code>realloc()</code></td></tr><tr><td>unistd</td><td>提供 <code>EXIT_FAILURE</code>、<code>EXIT_SUCCESS</code></td></tr><tr><td>libgen</td><td>提供 <code>basename()</code> 函数</td></tr><tr><td>errno</td><td>定义外部 <code>errno</code> 变量及其可以接受的所有值</td></tr><tr><td>string</td><td>提供 <code>memcpy()</code>、<code>memset()</code> 和 <code>strlen()</code> 函数系列</td></tr><tr><td>getopt</td><td>提供外部 <code>optarg</code>、<code>opterr</code>、<code>optind</code> 和 <code>getopt()</code> 函数</td></tr><tr><td>sys/types</td><td>类型定义快捷方式，如 <code>uint32_t</code> 和 <code>uint64_t</code></td></tr></tbody></table><h4 id=2定义>2、定义</h4><pre tabindex=0><code>/* main.c */
&lt;...&gt;

#define OPTSTR &#34;vi:o:f:h&#34;
#define USAGE_FMT  &#34;%s [-v] [-f hexflag] [-i inputfile] [-o outputfile] [-h]&#34;
#define ERR_FOPEN_INPUT  &#34;fopen(input, r)&#34;
#define ERR_FOPEN_OUTPUT &#34;fopen(output, w)&#34;
#define ERR_DO_THE_NEEDFUL &#34;do_the_needful blew up&#34;
#define DEFAULT_PROGNAME &#34;george&#34;
</code></pre><p>这在现在没有多大意义，但 <code>OPTSTR</code> 定义我这里会说明一下，它是程序推荐的命令行开关。参考 <a href=https://linux.die.net/man/3/getopt>getopt(3)</a> man 页面，了解 <code>OPTSTR</code> 将如何影响 <code>getopt()</code> 的行为。</p><p><code>USAGE_FMT</code> 定义了一个 <code>printf()</code> 风格的格式字符串，它用在 <code>usage()</code> 函数中。</p><p>我还喜欢将字符串常量放在文件的 <code>#define</code> 这一部分。如果需要，把它们收集在一起可以更容易地修正拼写、重用消息和国际化消息。</p><p>最后，在命名 <code>#define</code> 时全部使用大写字母，以区别变量和函数名。如果需要，可以将单词放连在一起或使用下划线分隔，只要确保它们都是大写的就行。</p><h4 id=3外部声明>3、外部声明</h4><pre tabindex=0><code>/* main.c */
&lt;...&gt;

extern int errno;
extern char *optarg;
extern int opterr, optind;
</code></pre><p><code>extern</code> 声明将该名称带入当前编译单元的命名空间（即 “文件”），并允许程序访问该变量。这里我们引入了三个整数变量和一个字符指针的定义。<code>opt</code> 前缀的几个变量是由 <code>getopt()</code> 函数使用的，C 标准库使用 <code>errno</code> 作为带外通信通道来传达函数可能的失败原因。</p><h4 id=4类型定义>4、类型定义</h4><pre tabindex=0><code>/* main.c */
&lt;...&gt;

typedef struct {
  int           verbose;
  uint32_t      flags;
  FILE         *input;
  FILE         *output;
} options_t;
</code></pre><p>在外部声明之后，我喜欢为结构、联合和枚举声明 <code>typedef</code>。命名一个 <code>typedef</code> 是一种传统习惯。我非常喜欢使用 <code>_t</code> 后缀来表示该名称是一种类型。在这个例子中，我将 <code>options_t</code> 声明为一个包含 4 个成员的 <code>struct</code>。C 是一种空格无关的编程语言，因此我使用空格将字段名排列在同一列中。我只是喜欢它看起来的样子。对于指针声明，我在名称前面加上星号，以明确它是一个指针。</p><h4 id=5全局变量声明>5、全局变量声明</h4><pre tabindex=0><code>/* main.c */
&lt;...&gt;

int dumb_global_variable = -11;
</code></pre><p>全局变量是一个坏主意，你永远不应该使用它们。但如果你必须使用全局变量，请在这里声明，并确保给它们一个默认值。说真的，<em>不要使用全局变量</em>。</p><h4 id=6函数原型>6、函数原型</h4><pre tabindex=0><code>/* main.c */
&lt;...&gt;

void usage(char *progname, int opt);
int do_the_needful(options_t *options);
</code></pre><p>在编写函数时，将它们添加到 <code>main()</code> 函数之后而不是之前，在这里放函数原型。早期的 C 编译器使用单遍策略，这意味着你在程序中使用的每个符号（变量或函数名称）必须在使用之前声明。现代编译器几乎都是多遍编译器，它们在生成代码之前构建一个完整的符号表，因此并不严格要求使用函数原型。但是，有时你无法选择代码要使用的编译器，所以请编写函数原型并继续这样做下去。</p><p>当然，我总是包含一个 <code>usage()</code> 函数，当 <code>main()</code> 函数不理解你从命令行传入的内容时，它会调用这个函数。</p><h4 id=7命令行解析>7、命令行解析</h4><pre tabindex=0><code>/* main.c */
&lt;...&gt;

int main(int argc, char *argv[]) {
    int opt;
    options_t options = { 0, 0x0, stdin, stdout };

    opterr = 0;

    while ((opt = getopt(argc, argv, OPTSTR)) != EOF) 
       switch(opt) {
           case &#39;i&#39;:
              if (!(options.input = fopen(optarg, &#34;r&#34;)) ){
                 perror(ERR_FOPEN_INPUT);
                 exit(EXIT_FAILURE);
                 /* NOTREACHED */
              }
              break;

           case &#39;o&#39;:
              if (!(options.output = fopen(optarg, &#34;w&#34;)) ){
                 perror(ERR_FOPEN_OUTPUT);
                 exit(EXIT_FAILURE);
                 /* NOTREACHED */
              }    
              break;
              
           case &#39;f&#39;:
              options.flags = (uint32_t )strtoul(optarg, NULL, 16);
              break;

           case &#39;v&#39;:
              options.verbose += 1;
              break;

           case &#39;h&#39;:
           default:
              usage(basename(argv[0]), opt);
              /* NOTREACHED */
              break;
       }

    if (do_the_needful(&amp;options) != EXIT_SUCCESS) {
       perror(ERR_DO_THE_NEEDFUL);
       exit(EXIT_FAILURE);
       /* NOTREACHED */
    }

    return EXIT_SUCCESS;
}
</code></pre><p>好吧，代码有点多。这个 <code>main()</code> 函数的目的是收集用户提供的参数，执行最基本的输入验证，然后将收集到的参数传递给使用它们的函数。这个示例声明一个使用默认值初始化的 <code>options</code> 变量，并解析命令行，根据需要更新 <code>options</code>。</p><p><code>main()</code> 函数的核心是一个 <code>while</code> 循环，它使用 <code>getopt()</code> 来遍历 <code>argv</code>，寻找命令行选项及其参数（如果有的话）。文件前面定义的 <code>OPTSTR</code> 是驱动 <code>getopt()</code> 行为的模板。<code>opt</code> 变量接受 <code>getopt()</code> 找到的任何命令行选项的字符值，程序对检测命令行选项的响应发生在 <code>switch</code> 语句中。</p><p>如果你注意到了可能会问，为什么 <code>opt</code> 被声明为 32 位 <code>int</code>，但是预期是 8 位 <code>char</code>？事实上 <code>getopt()</code> 返回一个 <code>int</code>，当它到达 <code>argv</code> 末尾时取负值，我会使用 <code>EOF</code>（<em>文件末尾</em>标记）匹配。<code>char</code> 是有符号的，但我喜欢将变量匹配到它们的函数返回值。</p><p>当检测到一个已知的命令行选项时，会发生特定的行为。在 <code>OPTSTR</code> 中指定一个以冒号结尾的参数，这些选项可以有一个参数。当一个选项有一个参数时，<code>argv</code> 中的下一个字符串可以通过外部定义的变量 <code>optarg</code> 提供给程序。我使用 <code>optarg</code> 来打开文件进行读写，或者将命令行参数从字符串转换为整数值。</p><p>这里有几个关于代码风格的要点：</p><ul><li>将 <code>opterr</code> 初始化为 <code>0</code>，禁止 <code>getopt</code> 触发 <code>?</code>。</li><li>在 <code>main()</code> 的中间使用 <code>exit(EXIT_FAILURE);</code> 或 <code>exit(EXIT_SUCCESS);</code>。</li><li><code>/* NOTREACHED */</code> 是我喜欢的一个 lint 指令。</li><li>在返回 int 类型的函数末尾使用 <code>return EXIT_SUCCESS;</code>。</li><li>显示强制转换隐式类型。</li></ul><p>这个程序的命令行格式，经过编译如下所示：</p><pre tabindex=0><code>$ ./a.out -h
a.out [-v] [-f hexflag] [-i inputfile] [-o outputfile] [-h]
</code></pre><p>事实上，在编译后 <code>usage()</code> 就会向 <code>stderr</code> 发出这样的内容。</p><h4 id=8函数声明>8、函数声明</h4><pre tabindex=0><code>/* main.c */
&lt;...&gt;

void usage(char *progname, int opt) {
   fprintf(stderr, USAGE_FMT, progname?progname:DEFAULT_PROGNAME);
   exit(EXIT_FAILURE);
   /* NOTREACHED */
}

int do_the_needful(options_t *options) {

   if (!options) {
     errno = EINVAL;
     return EXIT_FAILURE;
   }

   if (!options-&gt;input || !options-&gt;output) {
     errno = ENOENT;
     return EXIT_FAILURE;
   }

   /* XXX do needful stuff */

   return EXIT_SUCCESS;
}
</code></pre><p>我最后编写的函数不是个样板函数。在本例中，函数 <code>do_the_needful()</code> 接受一个指向 <code>options_t</code> 结构的指针。我验证 <code>options</code> 指针不为 <code>NULL</code>，然后继续验证 <code>input</code> 和 <code>output</code> 结构成员。如果其中一个测试失败，返回 <code>EXIT_FAILURE</code>，并且通过将外部全局变量 <code>errno</code> 设置为常规错误代码，我可以告知调用者常规的错误原因。调用者可以使用便捷函数 <code>perror()</code> 来根据 <code>errno</code> 的值发出便于阅读的错误消息。</p><p>函数几乎总是以某种方式验证它们的输入。如果完全验证代价很大，那么尝试执行一次并将验证后的数据视为不可变。<code>usage()</code> 函数使用 <code>fprintf()</code> 调用中的条件赋值验证 <code>progname</code> 参数。接下来 <code>usage()</code> 函数就退出了，所以我不会费心设置 <code>errno</code>，也不用操心是否使用正确的程序名。</p><p>在这里，我要避免的最大错误是解引用 <code>NULL</code> 指针。这将导致操作系统向我的进程发送一个名为 <code>SYSSEGV</code> 的特殊信号，导致不可避免的死亡。用户最不希望看到的是由 <code>SYSSEGV</code> 而导致的崩溃。最好是捕获 <code>NULL</code> 指针以发出更合适的错误消息并优雅地关闭程序。</p><p>有些人抱怨在函数体中有多个 <code>return</code> 语句，他们喋喋不休地说些“控制流的连续性”之类的东西。老实说，如果函数中间出现错误，那就应该返回这个错误条件。写一大堆嵌套的 <code>if</code> 语句只有一个 <code>return</code> 绝不是一个“好主意”™。</p><p>最后，如果你编写的函数接受四个以上的参数，请考虑将它们绑定到一个结构中，并传递一个指向该结构的指针。这使得函数签名更简单，更容易记住，并且在以后调用时不会出错。它还可以使调用函数速度稍微快一些，因为需要复制到函数堆栈中的东西更少。在实践中，只有在函数被调用数百万或数十亿次时，才会考虑这个问题。如果认为这没有意义，那也无所谓。</p><h3 id=等等你不是说没有注释吗>等等，你不是说没有注释吗！？！！</h3><p>在 <code>do_the_needful()</code> 函数中，我写了一种特殊类型的注释，它被是作为占位符设计的，而不是为了说明代码：</p><pre tabindex=0><code>/* XXX do needful stuff */
</code></pre><p>当你写到这里时，有时你不想停下来编写一些特别复杂的代码，你会之后再写，而不是现在。那就是我留给自己再次回来的地方。我插入一个带有 <code>XXX</code> 前缀的注释和一个描述需要做什么的简短注释。之后，当我有更多时间的时候，我会在源代码中寻找 <code>XXX</code>。使用什么前缀并不重要，只要确保它不太可能在另一个上下文环境（如函数名或变量）中出现在你代码库里。</p><h3 id=把它们组合在一起>把它们组合在一起</h3><p>好吧，当你编译这个程序后，它<em>仍然</em>几乎没有任何作用。但是现在你有了一个坚实的骨架来构建你自己的命令行解析 C 程序。</p><pre tabindex=0><code>/* main.c - the complete listing */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;libgen.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;getopt.h&gt;

#define OPTSTR &#34;vi:o:f:h&#34;
#define USAGE_FMT  &#34;%s [-v] [-f hexflag] [-i inputfile] [-o outputfile] [-h]&#34;
#define ERR_FOPEN_INPUT  &#34;fopen(input, r)&#34;
#define ERR_FOPEN_OUTPUT &#34;fopen(output, w)&#34;
#define ERR_DO_THE_NEEDFUL &#34;do_the_needful blew up&#34;
#define DEFAULT_PROGNAME &#34;george&#34;

extern int errno;
extern char *optarg;
extern int opterr, optind;

typedef struct {
  int           verbose;
  uint32_t      flags;
  FILE         *input;
  FILE         *output;
} options_t;

int dumb_global_variable = -11;

void usage(char *progname, int opt);
int  do_the_needful(options_t *options);

int main(int argc, char *argv[]) {
    int opt;
    options_t options = { 0, 0x0, stdin, stdout };

    opterr = 0;

    while ((opt = getopt(argc, argv, OPTSTR)) != EOF) 
       switch(opt) {
           case &#39;i&#39;:
              if (!(options.input = fopen(optarg, &#34;r&#34;)) ){
                 perror(ERR_FOPEN_INPUT);
                 exit(EXIT_FAILURE);
                 /* NOTREACHED */
              }
              break;

           case &#39;o&#39;:
              if (!(options.output = fopen(optarg, &#34;w&#34;)) ){
                 perror(ERR_FOPEN_OUTPUT);
                 exit(EXIT_FAILURE);
                 /* NOTREACHED */
              }    
              break;
              
           case &#39;f&#39;:
              options.flags = (uint32_t )strtoul(optarg, NULL, 16);
              break;

           case &#39;v&#39;:
              options.verbose += 1;
              break;

           case &#39;h&#39;:
           default:
              usage(basename(argv[0]), opt);
              /* NOTREACHED */
              break;
       }

    if (do_the_needful(&amp;options) != EXIT_SUCCESS) {
       perror(ERR_DO_THE_NEEDFUL);
       exit(EXIT_FAILURE);
       /* NOTREACHED */
    }

    return EXIT_SUCCESS;
}

void usage(char *progname, int opt) {
   fprintf(stderr, USAGE_FMT, progname?progname:DEFAULT_PROGNAME);
   exit(EXIT_FAILURE);
   /* NOTREACHED */
}

int do_the_needful(options_t *options) {

   if (!options) {
     errno = EINVAL;
     return EXIT_FAILURE;
   }

   if (!options-&gt;input || !options-&gt;output) {
     errno = ENOENT;
     return EXIT_FAILURE;
   }

   /* XXX do needful stuff */

   return EXIT_SUCCESS;
}
</code></pre><p>现在，你已经准备好编写更易于维护的 C 语言。如果你有任何问题或反馈，请在评论中分享。</p><hr><p>via: <a href=https://opensource.com/article/19/5/how-write-good-c-main-function>https://opensource.com/article/19/5/how-write-good-c-main-function</a></p><p>作者：<a href=https://opensource.com/users/jnyjny>Erik O&rsquo;Shaughnessy</a> 选题：<a href=https://github.com/lujun9972>lujun9972</a> 译者：<a href=https://github.com/MjSeven>MjSeven</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/c%E8%AF%AD%E8%A8%80/ rel=tag>C语言</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>