<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Bash Shell 脚本新手指南（二） - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="Bash Shell 脚本新手指南（二）"><meta property="og:description" content="我们会用到一些 上篇 中已经熟悉的命令（如果遇到新命令，会给出讲解），进而涵盖一些标准输出、标准输入、标准错误、“管道”和数据重定向的相关知识。"><meta property="og:type" content="article"><meta property="og:url" content="/article-14198-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-01-20T11:41:37+00:00"><meta property="article:modified_time" content="2022-01-20T11:41:37+00:00"><meta itemprop=name content="Bash Shell 脚本新手指南（二）"><meta itemprop=description content="我们会用到一些 上篇 中已经熟悉的命令（如果遇到新命令，会给出讲解），进而涵盖一些标准输出、标准输入、标准错误、“管道”和数据重定向的相关知识。"><meta itemprop=datePublished content="2022-01-20T11:41:37+00:00"><meta itemprop=dateModified content="2022-01-20T11:41:37+00:00"><meta itemprop=wordCount content="816"><meta itemprop=keywords content="Bash,脚本,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>Bash Shell 脚本新手指南（二）</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2022-01-20T11:41:37Z>January 20, 2022</time></div></div></header><div class="content post__content clearfix"><p><img src=/data/attachment/album/202201/20/114139q5a9uuiv0u95kvey.jpg alt></p><p>欢迎来到面向初学者的 Bash Shell 脚本知识第二部分。本篇将就 Bash 脚本一些更独特的方面进行深入探讨。我们会用到一些 <a href=/article-14131-1.html>上篇</a> 中已经熟悉的命令（如果遇到新命令，会给出讲解），进而涵盖一些标准输出、标准输入、标准错误、“管道”和数据重定向的相关知识。</p><h3 id=使用--添加注释>使用 # 添加注释</h3><p>随着脚本变得愈加复杂和实用，我们需要添加注释，以便记住程序在做什么。如果与其他人分享你的脚本，注释也将帮助他们理解思考过程，以及更好理解你的脚本实现的功能。想一想上篇文章中的数学方程，我们在新版脚本中添加了一些注释。注意，在 <code>learnToScript.sh</code> 文件（如下所示）中，注释是前面带有 <code>#</code> 号的行。当脚本运行时，这些注释行并不会出现。</p><pre tabindex=0><code>#!/bin/bash

#Let&#39;s pick up from our last article. We
#learned how to use mathematical equations
#in bash scripting.

echo $((5+3))
echo $((5-3))
echo $((5*3))
echo $((5/3))
</code></pre><pre tabindex=0><code>[zexcon ~]$ ./learnToScript.sh
8
2
15
1
</code></pre><h3 id=管道符->管道符 |</h3><p>我们将使用另一个名为 <code>grep</code> 的工具来介绍管道运算符。</p><blockquote><p><code>grep</code> 可以在输入文件中搜索可以匹配指定模式的行。默认情况下，<code>grep</code> 会输出相应的匹配行。</p><p><a href=https://www.gnu.org/software/grep/>https://www.gnu.org/software/grep/</a></p></blockquote><p>Paul W. Frields 在 《Fedora 杂志》上的文章很好地介绍了关于 <em>grep</em> 的知识。</p><blockquote><p><a href=https://fedoramagazine.org/command-line-quick-tips-searching-with-grep/>命令行快速小技巧：使用 grep 进行搜索</a></p></blockquote><p>管道键在键盘上位于回车键上方，可以在英文状态下按 <code>Shift + \</code> 输入。</p><p>现在你已经略微熟悉了 <code>grep</code>，接下来看一个使用管道命令的示例。在命令行输入 <code>ls -l | grep learn</code>。</p><pre tabindex=0><code>[zexcon ~]$ ls -l | grep learn
-rwxrw-rw-. 1 zexcon zexcon   70 Sep 17 10:10 learnToScript.sh
</code></pre><p>通常 <code>ls -l</code> 命令会在屏幕上显示文件列表。这里 <code>ls -l</code> 命令的完整结果通过管道传送到搜索字符串 <code>learn</code> 的 <code>grep</code> 命令中。你可以将管道命令想象成一个过滤器。先运行一个命令（本例中为 <code>ls -l</code>，结果会给出目录中的文件），这些结果通过管道命令给到 <code>grep</code>，后者会在其中搜索 <code>learn</code>，并且只显示符合条件的目标行。</p><p>下面再看一个例子以巩固相关知识。<code>less</code> 命令可以让用户查看超出一个屏幕尺寸的命令结果。以下是命令手册页中关于 <code>less</code> 的简要说明。</p><blockquote><p><code>less</code> 是一个类似于 <code>more</code> 的程序，但它允许在文件中向后或向前进行翻页移动。此外，<code>less</code> 不必在开始之前读取整个输入文件，因此对于大型输入文件而言，它比 <code>vi</code> 等文本编辑器启动更快。该命令较少使用 termcap（或某些系统上的 terminfo），因此可以在各种终端上运行。甚至还在一定程度上支持用于硬拷贝终端的端口。（在硬拷贝终端上，显示在屏幕顶部的行会以插入符号为前缀。）</p><p>Fedora 34 手册页</p></blockquote><p>下面让我们看看管道命令和 <code>less</code> 命令结合使用会是什么样子。</p><pre tabindex=0><code>[zexcon ~]$ ls -l /etc | less
</code></pre><pre tabindex=0><code>total 1504
drwxr-xr-x. 1 root root       126 Jul  7 17:46 abrt
-rw-r--r--. 1 root root        18 Jul  7 16:04 adjtime
-rw-r--r--. 1 root root      1529 Jun 23  2020 aliases
drwxr-xr-x. 1 root root        70 Jul  7 17:47 alsa
drwxr-xr-x. 1 root root        14 Apr 23 05:58 cron.d
drwxr-xr-x. 1 root root         0 Jan 25  2021 cron.daily
:
:
</code></pre><p>为便于阅读，此处对结果进行了修剪。用户可以使用键盘上的箭头键向上或向下滚动，进而控制显示。如果使用命令行，结果超出屏幕的话，用户可能会看不到结果的开头行。要退出 <code>less</code> 屏幕，只需点击 <code>q</code> 键。</p><h3 id=标准输出stdout重定向-11>标准输出（stdout）重定向 >、&#187;、1>、1&#187;</h3><p><code>></code> 或 <code>>></code> 符号之前的命令输出结果，会被写入到紧跟的文件名对应的文件中。<code>></code> 和 <code>1></code> 具有相同的效果，因为 <code>1</code> 就代表着标准输出。如果不显式指定 <code>1</code>，则默认为标准输出。<code>>></code> 和 <code>1>></code> 将数据附加到文件的末尾。使用 <code>></code> 或 <code>>></code> 时，如果文件不存在，则会创建对应文件。</p><p>例如，如果你想查看 <code>ping</code> 命令的输出，以查看它是否丢弃了数据包。与其关注控制台，不如将输出结果重定向到文件中，这样你就可以稍后再回来查看数据包是否被丢弃。下面是使用 <code>></code> 的重定向测试。</p><pre tabindex=0><code>[zexcon ~]$ ls -l ~ &gt; learnToScriptOutput
</code></pre><p>该命令会获取本应输出到终端的结果（<code>~</code> 代表家目录），并将其重定向到 <code>learnToScriptOutput</code> 文件。注意，我们并未手动创建 <code>learnToScriptOutput</code>，系统会自动创建该文件。</p><pre tabindex=0><code>total 128
drwxr-xr-x. 1 zexcon zexcon   268 Oct  1 16:02 Desktop
drwxr-xr-x. 1 zexcon zexcon    80 Sep 16 08:53 Documents
drwxr-xr-x. 1 zexcon zexcon     0 Oct  1 15:59 Downloads
-rw-rw-r--. 1 zexcon zexcon   685 Oct  4 16:00 learnToScriptAllOutput
-rw-rw-r--. 1 zexcon zexcon    23 Oct  4 12:42 learnToScriptInput
-rw-rw-r--. 1 zexcon zexcon     0 Oct  4 16:42 learnToScriptOutput
-rw-rw-r--. 1 zexcon zexcon    52 Oct  4 16:07 learnToScriptOutputError
-rwxrw-rw-. 1 zexcon zexcon   477 Oct  4 15:01 learnToScript.sh
drwxr-xr-x. 1 zexcon zexcon     0 Jul  7 16:04 Videos
</code></pre><h3 id=标准错误stderr重定向-22>标准错误（stderr）重定向 <code>2></code>、<code>2>></code></h3><p><code>></code> 或 <code>>></code> 符号之前命令的错误信息输出，会被写入到紧跟的文件名对应的文件中。<code>2></code> 和 <code>2>></code> 具有相同的效果，但 <code>2>></code> 是将数据追加到文件末尾。你可能会想，这有什么用？不妨假象一下用户只想捕获错误信息的场景，然后你就会意识到 <code>2></code> 或 <code>2>></code> 的作用。数字 <code>2</code> 表示本应输出到终端的标准错误信息输出。现在我们试着追踪一个不存在的文件，以试试这个知识点。</p><pre tabindex=0><code>[zexcon ~]$ ls -l /etc/invalidTest 2&gt; learnToScriptOutputError
</code></pre><p>这会生成错误信息，并将错误信息重定向输入到 <code>learnToScriptOutputError</code> 文件中。</p><pre tabindex=0><code>ls: cannot access &#39;/etc/invalidTest&#39;: No such file or directory
</code></pre><h3 id=所有输出重定向->所有输出重定向 &>、&&#187;、|&</h3><p>如果你不想将标准输出（<code>stdout</code>）和标准错误信息（<code>stderr</code>）写入不同的文件，那么在 Bash 5 中，你可以使用 <code>&></code> 将标准输出和标准错误重定向到同一个文件，或者使用 <code>&>></code> 追加到文件末尾。</p><pre tabindex=0><code>[zexcon ~]$ ls -l ~ &amp;&gt;&gt; learnToScriptAllOutput
[zexcon ~]$ ls -l /etc/invalidTest &amp;&gt;&gt; learnToScriptAllOutput
</code></pre><p>运行这些命令后，两者的输出都会进入同一个文件中，而不会区分是错误信息还是标准输出。</p><pre tabindex=0><code>total 128
drwxr-xr-x. 1 zexcon zexcon   268 Oct  1 16:02 Desktop
drwxr-xr-x. 1 zexcon zexcon    80 Sep 16 08:53 Documents
drwxr-xr-x. 1 zexcon zexcon     0 Oct  1 15:59 Downloads
-rw-rw-r--. 1 zexcon zexcon   685 Oct  4 16:00 learnToScriptAllOutput
-rw-rw-r--. 1 zexcon zexcon    23 Oct  4 12:42 learnToScriptInput
-rw-rw-r--. 1 zexcon zexcon     0 Oct  4 16:42 learnToScriptOutput
-rw-rw-r--. 1 zexcon zexcon    52 Oct  4 16:07 learnToScriptOutputError
-rwxrw-rw-. 1 zexcon zexcon   477 Oct  4 15:01 learnToScript.sh
drwxr-xr-x. 1 zexcon zexcon     0 Jul  7 16:04 Videos
ls: cannot access &#39;/etc/invalidTest&#39;: No such file or directory
</code></pre><p>如果你直接使用命令行操作，并希望将所有结果通过管道传输到另一个命令，可以选择使用 <code>|&</code> 实现。</p><pre tabindex=0><code>[zexcon ~]$ ls -l |&amp; grep learn
-rw-rw-r--. 1 zexcon zexcon    1197 Oct 18 09:46 learnToScriptAllOutput
-rw-rw-r--. 1 zexcon zexcon     343 Oct 14 10:47 learnToScriptError
-rw-rw-r--. 1 zexcon zexcon       0 Oct 14 11:11 learnToScriptOut
-rw-rw-r--. 1 zexcon zexcon     348 Oct 14 10:27 learnToScriptOutError
-rwxr-x---. 1 zexcon zexcon     328 Oct 18 09:46 learnToScript.sh
[zexcon ~]$
</code></pre><h3 id=标准输入stdin>标准输入（stdin）</h3><p>在本篇和上篇文章中，我们已经多次使用过标准输入（stdin），因为在每次使用键盘输入时，我们都在使用标准输入。为了区别通常意义上的“键盘即标准输入”，这次我们尝试在脚本中使用 <code>read</code> 命令。下面的脚本中就使用了 <code>read</code> 命令，字面上就像“读取标准输入”。</p><pre tabindex=0><code>#!/bin/bash

#Here we are asking a question to prompt the user for standard input. i.e.keyboard
echo &#39;Please enter your name.&#39;

#Here we are reading the standard input and assigning it to the variable name with the read command.
read name

#We are now going back to standard output, by using echo and printing your name to the command line.
echo &#34;With standard input you have told me your name is: $name&#34;
</code></pre><p>这个示例通过标准输出给出提示，提醒用户输入信息，然后从标准输入（键盘）获取信息，使用 <code>read</code> 将其存储在 <code>name</code> 变量中，并通过标准输出显示出 <code>name</code> 中的值。</p><pre tabindex=0><code>[zexcon@fedora ~]$ ./learnToScript.sh
Please enter your name.
zexcon
With standard input you have told me your name is: zexcon
[zexcon@fedora ~]$
</code></pre><h3 id=在脚本中使用>在脚本中使用</h3><p>现在我们把学到的东西放入脚本中，学习一下如何实际应用。下面是增加了几行后的新版本 <code>learnToScript.sh</code> 文件。它用追加的方式将标准输出、标准错误信息，以及两者混合后的信息，分别写入到三个不同文件。它将标准输出写入 <code>learnToScriptStandardOutput</code>，标准错误信息写入 <code>learnToScriptStandardError</code>，二者共同都写入 <code>learnToScriptAllOutput</code> 文件。</p><pre tabindex=0><code>#!/bin/bash

#As we know this article is about scripting. So let&#39;s
#use what we learned in a script. 

#Let&#39;s get some information from the user and add it to our scripts with stanard input and read

echo &#34;What is your name? &#34;
read name


#Here standard output directed to append a file to learnToScirptStandardOutput
echo &#34;$name, this will take standard output with append &gt;&gt; and redirect to learnToScriptStandardOutput.&#34; 1&gt;&gt; learnToScriptStandardOutput


#Here we are taking the standard error and appending it to learnToScriptStandardError but to see this we need to #create an error.
eco &#34;Standard error with append &gt;&gt; redirect to learnToScriptStandardError.&#34; 2&gt;&gt; learnToScriptStandardError

#Here we are going to create an error and a standard output and see they go to the same place.
echo &#34;Standard output with append &gt;&gt; redirect to learnToScriptAllOutput.&#34; &amp;&gt;&gt; learnToScriptAllOutput
eco &#34;Standard error with append &gt;&gt; redirect to learnToScriptAllOutput.&#34; &amp;&gt;&gt; learnToScriptAllOutput
</code></pre><p>脚本在同一目录中创建了三个文件。命令 <code>echo</code> 故意输入错误（LCTT 译注：缺少了字母 h）以产生错误信息。如果查看三个文件，你会在 <code>learnToScriptStandardOutput</code> 中看到一条信息，在 <code>learnToScriptStandardError</code> 中看到一条信息，在 <code>learnToScriptAllOutput</code> 中看到两条信息。另外，该脚本还会再次提示输入的 <code>name</code> 值，再将其写入 <code>learnToScriptStandardOutput</code> 中。</p><h3 id=结语>结语</h3><p>至此你应该能够明确，可以在命令行中执行的操作，都可以在脚本中执行。在编写可能供他人使用的脚本时，文档非常重要。如果继续深入研究脚本，标准输出会显得更有意义，因为你将会控制它们的生成。在脚本中，你可以与命令行中操作时应用相同的内容。下一篇文章我们会讨论函数、循环，以及在此基础上进一步构建的结构。</p><hr><p>via: <a href=https://fedoramagazine.org/bash-shell-scripting-for-beginners-part-2/>https://fedoramagazine.org/bash-shell-scripting-for-beginners-part-2/</a></p><p>作者：<a href=https://fedoramagazine.org/author/zexcon/>Matthew Darnell</a> 选题：<a href=https://github.com/lujun9972>lujun9972</a> 译者：<a href=https://github.com/unigeorge>unigeorge</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/bash/ rel=tag>Bash</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E8%84%9A%E6%9C%AC/ rel=tag>脚本</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>