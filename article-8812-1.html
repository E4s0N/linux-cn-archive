<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>开发一个 Linux 调试器（五）：源码和信号 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="开发一个 Linux 调试器（五）：源码和信号"><meta property="og:description" content="在这一部分，我们将进入实践，实现一些我们调试器后面会使用的 DWARF 原语。我们也会利用这个机会，使我们的调试器可以在命中一个断点时打印出当前的源码上下文。"><meta property="og:type" content="article"><meta property="og:url" content="/article-8812-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-08-26T17:55:00+00:00"><meta property="article:modified_time" content="2017-08-26T17:55:00+00:00"><meta itemprop=name content="开发一个 Linux 调试器（五）：源码和信号"><meta itemprop=description content="在这一部分，我们将进入实践，实现一些我们调试器后面会使用的 DWARF 原语。我们也会利用这个机会，使我们的调试器可以在命中一个断点时打印出当前的源码上下文。"><meta itemprop=datePublished content="2017-08-26T17:55:00+00:00"><meta itemprop=dateModified content="2017-08-26T17:55:00+00:00"><meta itemprop=wordCount content="639"><meta itemprop=keywords content="调试器,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>开发一个 Linux 调试器（五）：源码和信号</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-08-26T17:55:00Z>August 26, 2017</time></div></div></header><div class="content post__content clearfix"><p><img src=/data/attachment/album/201708/26/175338u3rarihzal14s8sg.jpg alt></p><p>在上一部分我们学习了关于 DWARF 的信息，以及它如何被用于读取变量和将被执行的机器码与我们的高级语言的源码联系起来。在这一部分，我们将进入实践，实现一些我们调试器后面会使用的 DWARF 原语。我们也会利用这个机会，使我们的调试器可以在命中一个断点时打印出当前的源码上下文。</p><h3 id=系列文章索引>系列文章索引</h3><p>随着后面文章的发布，这些链接会逐渐生效。</p><ol><li><a href=/article-8626-1.html>准备环境</a></li><li><a href=/article-8645-1.html>断点</a></li><li><a href=/article-8663-1.html>寄存器和内存</a></li><li><a href=/article-8719-1.html>Elves 和 dwarves</a></li><li><a href=https://blog.tartanllama.xyz/c++/2017/04/24/writing-a-linux-debugger-source-signal/>源码和信号</a></li><li><a href=https://blog.tartanllama.xyz/c++/2017/05/06/writing-a-linux-debugger-dwarf-step/>源码级逐步执行</a></li><li>源码级断点</li><li>调用栈展开</li><li>读取变量</li><li>下一步</li></ol><h3 id=设置我们的-dwarf-解析器>设置我们的 DWARF 解析器</h3><p>正如我在这系列文章开始时备注的，我们会使用 <a href=https://github.com/TartanLlama/libelfin/tree/fbreg>libelfin</a> 来处理我们的 DWARF 信息。希望你已经在<a href=/article-8626-1.html>第一部分</a>设置好了这些，如果没有的话，现在做吧，确保你使用我仓库的 <code>fbreg</code> 分支。</p><p>一旦你构建好了 <code>libelfin</code>，就可以把它添加到我们的调试器。第一步是解析我们的 ELF 可执行程序并从中提取 DWARF 信息。使用 <code>libelfin</code> 可以轻易实现，只需要对<code>调试器</code>作以下更改：</p><pre tabindex=0><code>class debugger {
public:
    debugger (std::string prog_name, pid_t pid)
         : m_prog_name{std::move(prog_name)}, m_pid{pid} {
        auto fd = open(m_prog_name.c_str(), O_RDONLY);

        m_elf = elf::elf{elf::create_mmap_loader(fd)};
        m_dwarf = dwarf::dwarf{dwarf::elf::create_loader(m_elf)};
    }
    //...

private:
    //...
    dwarf::dwarf m_dwarf;
    elf::elf m_elf;
};
</code></pre><p>我们使用了 <code>open</code> 而不是 <code>std::ifstream</code>，因为 elf 加载器需要传递一个 UNIX 文件描述符给 <code>mmap</code>，从而可以将文件映射到内存而不是每次读取一部分。</p><h3 id=调试信息原语>调试信息原语</h3><p>下一步我们可以实现从程序计数器的值中提取行条目（line entry）以及函数 DWARF 信息条目（function DIE）的函数。我们从 <code>get_function_from_pc</code> 开始：</p><pre tabindex=0><code>dwarf::die debugger::get_function_from_pc(uint64_t pc) {
    for (auto &amp;cu : m_dwarf.compilation_units()) {
        if (die_pc_range(cu.root()).contains(pc)) {
            for (const auto&amp; die : cu.root()) {
                if (die.tag == dwarf::DW_TAG::subprogram) {
                    if (die_pc_range(die).contains(pc)) {
                        return die;
                    }
                }
            }
        }
    }

    throw std::out_of_range{&#34;Cannot find function&#34;};
}
</code></pre><p>这里我采用了朴素的方法，迭代遍历编译单元直到找到一个包含程序计数器的，然后迭代遍历它的子节点直到我们找到相关函数（<code>DW_TAG_subprogram</code>）。正如我在上一篇中提到的，如果你想要的话你可以处理类似的成员函数或者内联等情况。</p><p>接下来是 <code>get_line_entry_from_pc</code>：</p><pre tabindex=0><code>dwarf::line_table::iterator debugger::get_line_entry_from_pc(uint64_t pc) {
    for (auto &amp;cu : m_dwarf.compilation_units()) {
        if (die_pc_range(cu.root()).contains(pc)) {
            auto &amp;lt = cu.get_line_table();
            auto it = lt.find_address(pc);
            if (it == lt.end()) {
                throw std::out_of_range{&#34;Cannot find line entry&#34;};
            }
            else {
                return it;
            }
        }
    }

    throw std::out_of_range{&#34;Cannot find line entry&#34;};
}
</code></pre><p>同样，我们可以简单地找到正确的编译单元，然后查询行表获取相关的条目。</p><h3 id=打印源码>打印源码</h3><p>当我们命中一个断点或者逐步执行我们的代码时，我们会想知道处于源码中的什么位置。</p><pre tabindex=0><code>void debugger::print_source(const std::string&amp; file_name, unsigned line, unsigned n_lines_context) {
    std::ifstream file {file_name};

    //获得一个所需行附近的窗口
    auto start_line = line &lt;= n_lines_context ? 1 : line - n_lines_context;
    auto end_line = line + n_lines_context + (line &lt; n_lines_context ? n_lines_context - line : 0) + 1;

    char c{};
    auto current_line = 1u;
    //跳过 start_line 之前的行
    while (current_line != start_line &amp;&amp; file.get(c)) {
        if (c == &#39;\n&#39;) {
            ++current_line;
        }
    }

    //如果我们在当前行则输出光标
    std::cout &lt;&lt; (current_line==line ? &#34;&gt; &#34; : &#34;  &#34;);

    //输出行直到 end_line
    while (current_line &lt;= end_line &amp;&amp; file.get(c)) {
        std::cout &lt;&lt; c;
        if (c == &#39;\n&#39;) {
            ++current_line;
            //如果我们在当前行则输出光标
            std::cout &lt;&lt; (current_line==line ? &#34;&gt; &#34; : &#34;  &#34;);
        }
    }

    //输出换行确保恰当地清空了流
    std::cout &lt;&lt; std::endl;
}
</code></pre><p>现在我们可以打印出源码了，我们需要将这些通过钩子添加到我们的调试器。实现这个的一个好地方是当调试器从一个断点或者（最终）逐步执行得到一个信号时。到了这里，我们可能想要给我们的调试器添加一些更好的信号处理。</p><h3 id=更好的信号处理>更好的信号处理</h3><p>我们希望能够得知什么信号被发送给了进程，同样我们也想知道它是如何产生的。例如，我们希望能够得知是否由于命中了一个断点从而获得一个 <code>SIGTRAP</code>，还是由于逐步执行完成、或者是产生了一个新线程等等导致的。幸运的是，我们可以再一次使用 <code>ptrace</code>。可以给 <code>ptrace</code> 的一个命令是 <code>PTRACE_GETSIGINFO</code>，它会给你被发送给进程的最后一个信号的信息。我们类似这样使用它：</p><pre tabindex=0><code>siginfo_t debugger::get_signal_info() {
    siginfo_t info;
    ptrace(PTRACE_GETSIGINFO, m_pid, nullptr, &amp;info);
    return info;
}
</code></pre><p>这会给我们一个 <code>siginfo_t</code> 对象，它能提供以下信息：</p><pre tabindex=0><code>siginfo_t {
    int      si_signo;     /* 信号编号 */
    int      si_errno;     /* errno 值 */
    int      si_code;      /* 信号代码 */
    int      si_trapno;    /* 导致生成硬件信号的陷阱编号
                              （大部分架构中都没有使用） */
    pid_t    si_pid;       /* 发送信号的进程 ID */
    uid_t    si_uid;       /* 发送信号进程的用户 ID */
    int      si_status;    /* 退出值或信号 */
    clock_t  si_utime;     /* 消耗的用户时间 */
    clock_t  si_stime;     /* 消耗的系统时间 */
    sigval_t si_value;     /* 信号值 */
    int      si_int;       /* POSIX.1b 信号 */
    void    *si_ptr;       /* POSIX.1b 信号 */
    int      si_overrun;   /* 计时器 overrun 计数;
                              POSIX.1b 计时器 */
    int      si_timerid;   /* 计时器 ID; POSIX.1b 计时器 */
    void    *si_addr;      /* 导致错误的内存地址 */
    long     si_band;      /* Band event (在 glibc 2.3.2 和之前版本中是 int 类型) */
    int      si_fd;        /* 文件描述符 */
    short    si_addr_lsb;  /* 地址的最不重要位
                              (自 Linux 2.6.32) */
    void    *si_lower;     /* 出现地址违规的下限 (自 Linux 3.19) */
    void    *si_upper;     /* 出现地址违规的上限 (自 Linux 3.19) */
    int      si_pkey;      /* PTE 上导致错误的保护键 (自 Linux 4.6) */
    void    *si_call_addr; /* 系统调用指令的地址
                              (自 Linux 3.5) */
    int      si_syscall;   /* 系统调用尝试次数
                              (自 Linux 3.5) */
    unsigned int si_arch;  /* 尝试系统调用的架构
                              (自 Linux 3.5) */
}
</code></pre><p>我只需要使用 <code>si_signo</code> 就可以找到被发送的信号，使用 <code>si_code</code> 来获取更多关于信号的信息。放置这些代码的最好位置是我们的 <code>wait_for_signal</code> 函数：</p><pre tabindex=0><code>void debugger::wait_for_signal() {
    int wait_status;
    auto options = 0;
    waitpid(m_pid, &amp;wait_status, options);

    auto siginfo = get_signal_info();

    switch (siginfo.si_signo) {
    case SIGTRAP:
        handle_sigtrap(siginfo);
        break;
    case SIGSEGV:
        std::cout &lt;&lt; &#34;Yay, segfault. Reason: &#34; &lt;&lt; siginfo.si_code &lt;&lt; std::endl;
        break;
    default:
        std::cout &lt;&lt; &#34;Got signal &#34; &lt;&lt; strsignal(siginfo.si_signo) &lt;&lt; std::endl;
    }
}
</code></pre><p>现在再来处理 <code>SIGTRAP</code>。知道当命中一个断点时会发送 <code>SI_KERNEL</code> 或 <code>TRAP_BRKPT</code>，而逐步执行结束时会发送 <code>TRAP_TRACE</code> 就足够了：</p><pre tabindex=0><code>void debugger::handle_sigtrap(siginfo_t info) {
    switch (info.si_code) {
    //如果命中了一个断点其中的一个会被设置
    case SI_KERNEL:
    case TRAP_BRKPT:
    {
        set_pc(get_pc()-1); //将程序计数器的值设置为它应该指向的地方
        std::cout &lt;&lt; &#34;Hit breakpoint at address 0x&#34; &lt;&lt; std::hex &lt;&lt; get_pc() &lt;&lt; std::endl;
        auto line_entry = get_line_entry_from_pc(get_pc());
        print_source(line_entry-&gt;file-&gt;path, line_entry-&gt;line);
        return;
    }
    //如果信号是由逐步执行发送的，这会被设置
    case TRAP_TRACE:
        return;
    default:
        std::cout &lt;&lt; &#34;Unknown SIGTRAP code &#34; &lt;&lt; info.si_code &lt;&lt; std::endl;
        return;
    }
}
</code></pre><p>这里有一大堆不同风格的信号你可以处理。查看 <code>man sigaction</code> 获取更多信息。</p><p>由于当我们收到 <code>SIGTRAP</code> 信号时我们已经修正了程序计数器的值，我们可以从 <code>step_over_breakpoint</code> 中移除这些代码，现在它看起来类似：</p><pre tabindex=0><code>void debugger::step_over_breakpoint() {
    if (m_breakpoints.count(get_pc())) {
        auto&amp; bp = m_breakpoints[get_pc()];
        if (bp.is_enabled()) {
            bp.disable();
            ptrace(PTRACE_SINGLESTEP, m_pid, nullptr, nullptr);
            wait_for_signal();
            bp.enable();
        }
    }
}
</code></pre><h3 id=测试>测试</h3><p>现在你应该可以在某个地址设置断点，运行程序然后看到打印出了源码，而且正在被执行的行被光标标记了出来。</p><p>后面我们会添加设置源码级别断点的功能。同时，你可以从<a href=https://github.com/TartanLlama/minidbg/tree/tut_source>这里</a>获取该博文的代码。</p><hr><p>via: <a href=https://blog.tartanllama.xyz/c++/2017/04/24/writing-a-linux-debugger-source-signal/>https://blog.tartanllama.xyz/c++/2017/04/24/writing-a-linux-debugger-source-signal/</a></p><p>作者：<a href=https://www.twitter.com/TartanLlama>TartanLlama</a> 译者：<a href=https://github.com/ictlyh>ictlyh</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/%E8%B0%83%E8%AF%95%E5%99%A8/ rel=tag>调试器</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>