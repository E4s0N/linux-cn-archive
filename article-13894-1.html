<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>C 语言编程中的 5 个常见错误及对应解决方案 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="C 语言编程中的 5 个常见错误及对应解决方案"><meta property="og:description" content="增强 C 语言程序的弹性和可靠性的五种方法。"><meta property="og:type" content="article"><meta property="og:url" content="/article-13894-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-10-18T17:41:00+00:00"><meta property="article:modified_time" content="2021-10-18T17:41:00+00:00"><meta itemprop=name content="C 语言编程中的 5 个常见错误及对应解决方案"><meta itemprop=description content="增强 C 语言程序的弹性和可靠性的五种方法。"><meta itemprop=datePublished content="2021-10-18T17:41:00+00:00"><meta itemprop=dateModified content="2021-10-18T17:41:00+00:00"><meta itemprop=wordCount content="902"><meta itemprop=keywords content="C语言,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>C 语言编程中的 5 个常见错误及对应解决方案</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2021-10-18T17:41:00Z>October 18, 2021</time></div></div></header><div class="content post__content clearfix"><blockquote><p>增强 C 语言程序的弹性和可靠性的五种方法。</p></blockquote><p><img src=https://img.linux.net.cn/data/attachment/album/202110/18/174123p4cz99skp9zz4nf4.jpg alt title="Bug tracking magnifying glass on computer screen"></p><p>即使是最好的程序员也无法完全避免错误。这些错误可能会引入安全漏洞、导致程序崩溃或产生意外操作，具体影响要取决于程序的运行逻辑。</p><p>C 语言有时名声不太好，因为它不像近期的编程语言（比如 Rust）那样具有内存安全性。但是通过额外的代码，一些最常见和严重的 C 语言错误是可以避免的。下文讲解了可能影响应用程序的五个错误以及避免它们的方法：</p><h3 id=1未初始化的变量>1、未初始化的变量</h3><p>程序启动时，系统会为其分配一块内存以供存储数据。这意味着程序启动时，变量将获得内存中的一个随机值。</p><p>有些编程环境会在程序启动时特意将内存“清零”，因此每个变量都得以有初始的零值。程序中的变量都以零值作为初始值，听上去是很不错的。但是在 C 编程规范中，系统并不会初始化变量。</p><p>看一下这个使用了若干变量和两个数组的示例程序：</p><pre tabindex=0><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int
main()
{
  int i, j, k;
  int numbers[5];
  int *array;

  puts(&#34;These variables are not initialized:&#34;);

  printf(&#34;  i = %d\n&#34;, i);
  printf(&#34;  j = %d\n&#34;, j);
  printf(&#34;  k = %d\n&#34;, k);

  puts(&#34;This array is not initialized:&#34;);

  for (i = 0; i &lt; 5; i++) {
    printf(&#34;  numbers[%d] = %d\n&#34;, i, numbers[i]);
  }

  puts(&#34;malloc an array ...&#34;);
  array = malloc(sizeof(int) * 5);

  if (array) {
    puts(&#34;This malloc&#39;ed array is not initialized:&#34;);

    for (i = 0; i &lt; 5; i++) {
      printf(&#34;  array[%d] = %d\n&#34;, i, array[i]);
    }

    free(array);
  }

  /* done */

  puts(&#34;Ok&#34;);
  return 0;
}
</code></pre><p>这个程序不会初始化变量，所以变量以系统内存中的随机值作为初始值。在我的 Linux 系统上编译和运行这个程序，会看到一些变量恰巧有“零”值，但其他变量并没有：</p><pre tabindex=0><code>These variables are not initialized:
  i = 0
  j = 0
  k = 32766
This array is not initialized:
  numbers[0] = 0
  numbers[1] = 0
  numbers[2] = 4199024
  numbers[3] = 0
  numbers[4] = 0
malloc an array ...
This malloc&#39;ed array is not initialized:
  array[0] = 0
  array[1] = 0
  array[2] = 0
  array[3] = 0
  array[4] = 0
Ok
</code></pre><p>很幸运，<code>i</code> 和 <code>j</code> 变量是从零值开始的，但 <code>k</code> 的起始值为 32766。在 <code>numbers</code> 数组中，大多数元素也恰好从零值开始，只有第三个元素的初始值为 4199024。</p><p>在不同的系统上编译相同的程序，可以进一步显示未初始化变量的危险性。不要误以为“全世界都在运行 Linux”，你的程序很可能某天在其他平台上运行。例如，下面是在 FreeDOS 上运行相同程序的结果：</p><pre tabindex=0><code>These variables are not initialized:
  i = 0
  j = 1074
  k = 3120
This array is not initialized:
  numbers[0] = 3106
  numbers[1] = 1224
  numbers[2] = 784
  numbers[3] = 2926
  numbers[4] = 1224
malloc an array ...
This malloc&#39;ed array is not initialized:
  array[0] = 3136
  array[1] = 3136
  array[2] = 14499
  array[3] = -5886
  array[4] = 219
Ok
</code></pre><p>永远都要记得初始化程序的变量。如果你想让变量将以零值作为初始值，请额外添加代码将零分配给该变量。预先编好这些额外的代码，这会有助于减少日后让人头疼的调试过程。</p><h3 id=2数组越界>2、数组越界</h3><p>C 语言中，数组索引从零开始。这意味着对于长度为 10 的数组，索引是从 0 到 9；长度为 1000 的数组，索引则是从 0 到 999。</p><p>程序员有时会忘记这一点，他们从索引 1 开始引用数组，产生了 “大小差一” off by one 错误。在长度为 5 的数组中，程序员在索引“5”处使用的值，实际上并不是数组的第 5 个元素。相反，它是内存中的一些其他值，根本与此数组无关。</p><p>这是一个数组越界的示例程序。该程序使用了一个只含有 5 个元素的数组，但却引用了该范围之外的数组元素：</p><pre tabindex=0><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int
main()
{
  int i;
  int numbers[5];
  int *array;

  /* test 1 */

  puts(&#34;This array has five elements (0 to 4)&#34;);

  /* initalize the array */
  for (i = 0; i &lt; 5; i++) {
    numbers[i] = i;
  }

  /* oops, this goes beyond the array bounds: */
  for (i = 0; i &lt; 10; i++) {
    printf(&#34;  numbers[%d] = %d\n&#34;, i, numbers[i]);
  }

  /* test 2 */

  puts(&#34;malloc an array ...&#34;);

  array = malloc(sizeof(int) * 5);

  if (array) {
    puts(&#34;This malloc&#39;ed array also has five elements (0 to 4)&#34;);

    /* initalize the array */
    for (i = 0; i &lt; 5; i++) {
      array[i] = i;
    }

    /* oops, this goes beyond the array bounds: */
    for (i = 0; i &lt; 10; i++) {
      printf(&#34;  array[%d] = %d\n&#34;, i, array[i]);
    }

    free(array);
  }

  /* done */

  puts(&#34;Ok&#34;);
  return 0;
}
</code></pre><p>可以看到，程序初始化了数组的所有值（从索引 0 到 4），然后从索引 0 开始读取，结尾是索引 9 而不是索引 4。前五个值是正确的，再后面的值会让你不知所以：</p><pre tabindex=0><code>This array has five elements (0 to 4)
  numbers[0] = 0
  numbers[1] = 1
  numbers[2] = 2
  numbers[3] = 3
  numbers[4] = 4
  numbers[5] = 0
  numbers[6] = 4198512
  numbers[7] = 0
  numbers[8] = 1326609712
  numbers[9] = 32764
malloc an array ...
This malloc&#39;ed array also has five elements (0 to 4)
  array[0] = 0
  array[1] = 1
  array[2] = 2
  array[3] = 3
  array[4] = 4
  array[5] = 0
  array[6] = 133441
  array[7] = 0
  array[8] = 0
  array[9] = 0
Ok
</code></pre><p>引用数组时，始终要记得追踪数组大小。将数组大小存储在变量中；不要对数组大小进行 硬编码 hard-code 。否则，如果后期该标识符指向另一个不同大小的数组，却忘记更改硬编码的数组长度时，程序就可能会发生数组越界。</p><h3 id=3字符串溢出>3、字符串溢出</h3><p>字符串只是特定类型的数组。在 C 语言中，字符串是一个由 <code>char</code> 类型值组成的数组，其中用一个零字符表示字符串的结尾。</p><p>因此，与数组一样，要注意避免超出字符串的范围。有时也称之为 <em>字符串溢出</em>。</p><p>使用 <code>gets</code> 函数读取数据是一种很容易发生字符串溢出的行为方式。<code>gets</code> 函数非常危险，因为它不知道在一个字符串中可以存储多少数据，只会机械地从用户那里读取数据。如果用户输入像 <code>foo</code> 这样的短字符串，不会发生意外；但是当用户输入的值超过字符串长度时，后果可能是灾难性的。</p><p>下面是一个使用 <code>gets</code> 函数读取城市名称的示例程序。在这个程序中，我还添加了一些未使用的变量，来展示字符串溢出对其他数据的影响：</p><pre tabindex=0><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int
main()
{
  char name[10];                       /* Such as &#34;Chicago&#34; */
  int var1 = 1, var2 = 2;

  /* show initial values */

  printf(&#34;var1 = %d; var2 = %d\n&#34;, var1, var2);

  /* this is bad .. please don&#39;t use gets */

  puts(&#34;Where do you live?&#34;);
  gets(name);

  /* show ending values */

  printf(&#34;&lt;%s&gt; is length %d\n&#34;, name, strlen(name));
  printf(&#34;var1 = %d; var2 = %d\n&#34;, var1, var2);

  /* done */

  puts(&#34;Ok&#34;);
  return 0;
}
</code></pre><p>当你测试类似的短城市名称时，该程序运行良好，例如伊利诺伊州的 <code>Chicago</code> 或北卡罗来纳州的<code>Raleigh</code>：</p><pre tabindex=0><code>var1 = 1; var2 = 2
Where do you live?
Raleigh
&lt;Raleigh&gt; is length 7
var1 = 1; var2 = 2
Ok
</code></pre><p>威尔士的小镇 <code>Llanfairpwllgwyngyllgogerychwyrndrobwllllantysiliogogogoch</code> 有着世界上最长的名字之一。这个字符串有 58 个字符，远远超出了 <code>name</code> 变量中保留的 10 个字符。结果，程序将值存储在内存的其他区域，覆盖了 <code>var1</code> 和 <code>var2</code> 的值：</p><pre tabindex=0><code>var1 = 1; var2 = 2
Where do you live?
Llanfairpwllgwyngyllgogerychwyrndrobwllllantysiliogogogoch
&lt;Llanfairpwllgwyngyllgogerychwyrndrobwllllantysiliogogogoch&gt; is length 58
var1 = 2036821625; var2 = 2003266668
Ok
Segmentation fault (core dumped)
</code></pre><p>在运行结束之前，程序会用长字符串覆盖内存的其他部分区域。注意，<code>var1</code> 和 <code>var2</code> 的值不再是起始的 <code>1</code> 和 <code>2</code>。</p><p>避免使用 <code>gets</code> 函数，改用更安全的方法来读取用户数据。例如，<code>getline</code> 函数会分配足够的内存来存储用户输入，因此不会因输入长值而发生意外的字符串溢出。</p><h3 id=4重复释放内存>4、重复释放内存</h3><p>“分配的内存要手动释放”是良好的 C 语言编程原则之一。程序可以使用 <code>malloc</code> 函数为数组和字符串分配内存，该函数会开辟一块内存，并返回一个指向内存中起始地址的指针。之后，程序可以使用 <code>free</code> 函数释放内存，该函数会使用指针将内存标记为未使用。</p><p>但是，你应该只使用一次 <code>free</code> 函数。第二次调用 <code>free</code> 会导致意外的后果，可能会毁掉你的程序。下面是一个针对此点的简短示例程序。程序分配了内存，然后立即释放了它。但为了模仿一个健忘但有条理的程序员，我在程序结束时又一次释放了内存，导致两次释放了相同的内存：</p><pre tabindex=0><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int
main()
{
  int *array;

  puts(&#34;malloc an array ...&#34;);

  array = malloc(sizeof(int) * 5);

  if (array) {
    puts(&#34;malloc succeeded&#34;);

    puts(&#34;Free the array...&#34;);
    free(array);
  }

  puts(&#34;Free the array...&#34;);
  free(array);

  puts(&#34;Ok&#34;);
}
</code></pre><p>运行这个程序会导致第二次使用 <code>free</code> 函数时出现戏剧性的失败：</p><pre tabindex=0><code>malloc an array ...
malloc succeeded
Free the array...
Free the array...
free(): double free detected in tcache 2
Aborted (core dumped)
</code></pre><p>要记得避免在数组或字符串上多次调用 <code>free</code>。将 <code>malloc</code> 和 <code>free</code> 函数定位在同一个函数中，这是避免重复释放内存的一种方法。</p><p>例如，一个纸牌游戏程序可能会在主函数中为一副牌分配内存，然后在其他函数中使用这副牌来玩游戏。记得在主函数，而不是其他函数中释放内存。将 <code>malloc</code> 和 <code>free</code> 语句放在一起有助于避免多次释放内存。</p><h3 id=5使用无效的文件指针>5、使用无效的文件指针</h3><p>文件是一种便捷的数据存储方式。例如，你可以将程序的配置数据存储在 <code>config.dat</code> 文件中。Bash shell 会从用户家目录中的 <code>.bash_profile</code> 读取初始化脚本。GNU Emacs 编辑器会寻找文件 <code>.emacs</code> 以从中确定起始值。而 Zoom 会议客户端使用 <code>zoomus.conf</code> 文件读取其程序配置。</p><p>所以，从文件中读取数据的能力几乎对所有程序都很重要。但是假如要读取的文件不存在，会发生什么呢？</p><p>在 C 语言中读取文件，首先要用 <code>fopen</code> 函数打开文件，该函数会返回指向文件的流指针。你可以结合其他函数，使用这个指针来读取数据，例如 <code>fgetc</code> 会逐个字符地读取文件。</p><p>如果要读取的文件不存在或程序没有读取权限，<code>fopen</code> 函数会返回 <code>NULL</code> 作为文件指针，这表示文件指针无效。但是这里有一个示例程序，它机械地直接去读取文件，不检查 <code>fopen</code> 是否返回了 <code>NULL</code>：</p><pre tabindex=0><code>#include &lt;stdio.h&gt;

int
main()
{
  FILE *pfile;
  int ch;

  puts(&#34;Open the FILE.TXT file ...&#34;);

  pfile = fopen(&#34;FILE.TXT&#34;, &#34;r&#34;);

  /* you should check if the file pointer is valid, but we skipped that */

  puts(&#34;Now display the contents of FILE.TXT ...&#34;);

  while ((ch = fgetc(pfile)) != EOF) {
    printf(&#34;&lt;%c&gt;&#34;, ch);
  }

  fclose(pfile);

  /* done */

  puts(&#34;Ok&#34;);
  return 0;
}
</code></pre><p>当你运行这个程序时，第一次调用 <code>fgetc</code> 会失败，程序会立即中止：</p><pre tabindex=0><code>Open the FILE.TXT file ...
Now display the contents of FILE.TXT ...
Segmentation fault (core dumped)
</code></pre><p>始终检查文件指针以确保其有效。例如，在调用 <code>fopen</code> 打开一个文件后，用类似 <code>if (pfile != NULL)</code> 的语句检查指针，以确保指针是可以使用的。</p><p>人都会犯错，最优秀的程序员也会产生编程错误。但是，遵循上面这些准则，添加一些额外的代码来检查这五种类型的错误，就可以避免最严重的 C 语言编程错误。提前编写几行代码来捕获这些错误，可能会帮你节省数小时的调试时间。</p><hr><p>via: <a href=https://opensource.com/article/21/10/programming-bugs>https://opensource.com/article/21/10/programming-bugs</a></p><p>作者：<a href=https://opensource.com/users/jim-hall>Jim Hall</a> 选题：<a href=https://github.com/lujun9972>lujun9972</a> 译者：<a href=https://github.com/unigeorge>unigeorge</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/c%E8%AF%AD%E8%A8%80/ rel=tag>C语言</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>