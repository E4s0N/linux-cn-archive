<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>UNIX 的怪东西 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="UNIX 的怪东西"><meta property="og:description" content="最近我在用我编写的各种工具做更多 UNIX 下的事情，我遇到了两个有趣的问题。这些都不是 “bug”，而是我没想到的行为。"><meta property="og:type" content="article"><meta property="og:url" content="/article-9928-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-08-17T17:02:44+00:00"><meta property="article:modified_time" content="2018-08-17T17:02:44+00:00"><meta itemprop=name content="UNIX 的怪东西"><meta itemprop=description content="最近我在用我编写的各种工具做更多 UNIX 下的事情，我遇到了两个有趣的问题。这些都不是 “bug”，而是我没想到的行为。"><meta itemprop=datePublished content="2018-08-17T17:02:44+00:00"><meta itemprop=dateModified content="2018-08-17T17:02:44+00:00"><meta itemprop=wordCount content="157"><meta itemprop=keywords content="Unix,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>UNIX 的怪东西</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2018-08-17T17:02:44Z>August 17, 2018</time></div></div></header><div class="content post__content clearfix"><p><img src=/data/attachment/album/201808/17/170055yst2s94aslim9hbe.jpg alt></p><p>最近我在用我编写的各种工具做更多 UNIX 下的事情，我遇到了两个有趣的问题。这些都不是 “bug”，而是我没想到的行为。</p><h3 id=线程安全的-printf>线程安全的 printf</h3><p>我有一个 C 程序从磁盘读取一些图像，进行一些处理，并将有关这些图像的输出写入 STDOUT。伪代码：</p><pre tabindex=0><code>for(imagefilename in images)
{
    results = process(imagefilename);
    printf(results);
}
</code></pre><p>对于每个图像都是独立处理的，因此我自然希望将处理任务分配在各个 CPU 之间以加快速度。我通常使用 <code>fork()</code>，所以我写了这个：</p><pre tabindex=0><code>for(child in children)
{
    pipe = create_pipe();
    worker(pipe);
}

// main parent process
for(imagefilename in images)
{
    write(pipe[i_image % N_children], imagefilename)
}

worker()
{
    while(1)
    {
        imagefilename = read(pipe);
        results = process(imagefilename);
        printf(results);
    }
}
</code></pre><p>这是正常的做法：我为 IPC 创建管道，并通过这些管道给子进程 worker 发送图像名。每个 worker <em>能够</em>通过另一组管道将其结果写回主进程，但这很痛苦，所以每个 worker 都直接写入共享 STDOUT。这工作正常，但正如人们所预料的那样，对 STDOUT 的写入发生冲突，因此各种图像的结果最终会混杂在一起。那很糟糕。我不想自己设置个锁，但幸运的是 GNU libc 为它提供了函数：<a href=https://www.gnu.org/software/libc/manual/html_node/Streams-and-Threads.html>flockfile()</a>。我把它们放进去了……但是没有用！为什么？因为 <code>flockfile()</code> 最终因为 <code>fork()</code> 的写时复制行为而被限制在单个子进程中。即 <code>fork()</code>提供的额外安全性（与线程相比），这实际上最终破坏了锁。</p><p>我没有尝试使用其他锁机制（例如 pthread 互斥锁），但我可以想象它们会遇到类似的问题。我想保持简单，所以将输出发送回父输出是不可能的：这给程序员和运行程序的计算机制造了更多的工作。</p><p>解决方案：使用线程而不是 <code>fork()</code>。这有制造冗余管道的好的副作用。最终的伪代码：</p><pre tabindex=0><code>for(children)
{
    pthread_create(worker, child_index);
}
for(children)
{
    pthread_join(child);
}

worker(child_index)
{
    for(i_image = child_index; i_image &lt; N_images; i_image += N_children)
    {
        results = process(images[i_image]);
        flockfile(stdout);
        printf(results);
        funlockfile(stdout);
    }
}
</code></pre><p>这更简单，如预期的那样工作。我猜有时线程更好。</p><h3 id=将部分读取的文件传递给子进程>将部分读取的文件传递给子进程</h3><p>对于各种 <a href=http://www.github.com/dkogan/vnlog>vnlog</a> 工具，我需要实现这个操作序列：</p><ol><li>进程打开一个关闭 <code>O_CLOEXEC</code> 标志的文件</li><li>进程读取此文件的一部分（在 vnlog 的情况下直到图例的末尾）</li><li>进程调用 <code>exec()</code> 以调用另一个程序来处理已经打开的文件的其余部分</li></ol><p>第二个程序可能需要命令行中的文件名而不是已打开的文件描述符，因为第二个程序可能自己调用 <code>​​open()</code>。如果我传递文件名，这个新程序将重新打开文件，然后从头开始读取文件，而不是从原始程序停止的位置开始读取。在我的程序上不可以这样做，因此将文件名传递给第二个程序是行不通的。</p><p>所以我真的需要以某种方式传递已经打开的文件描述符。我在使用 Linux（其他操作系统可能在这里表现不同），所以我理论上可以通过传递 <code>/dev/fd/N</code> 而不是文件名来实现。但事实证明这也不起作用。在 Linux上（再说一次，也许是特定于 Linux）对于普通文件 <code>/dev/fd/N</code> 是原始文件的符号链接。所以这最终做的是与传递文件名完全相同的事情。</p><p>但有一个临时方案！如果我们正在读取管道而不是文件，那么没有什么可以符号链接，并且 <code>/dev/fd/N</code> 最终将原始管道传递给第二个进程，然后程序正常工作。我可以通过将上面的 <code>open("filename")</code> 更改为 <code>popen("cat filename")</code> 之类的东西来伪装。呸！这真的是我们所能做到最好的吗？这在 BSD 上看上去会怎么样？</p><hr><p>via: <a href=http://notes.secretsauce.net/notes/2018/08/03_unix-curiosities.html>http://notes.secretsauce.net/notes/2018/08/03_unix-curiosities.html</a></p><p>作者：<a href=http://notes.secretsauce.net/>Dima Kogan</a> 选题：<a href=https://github.com/lujun9972>lujun9972</a> 译者：<a href=https://github.com/geekpi>geekpi</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/unix/ rel=tag>Unix</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>