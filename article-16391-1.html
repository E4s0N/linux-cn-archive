<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>使用 dialog 和 jq 在 Linux 上编写高效终端 TUI - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="使用 dialog 和 jq 在 Linux 上编写高效终端 TUI"><meta property="og:description" content="许多人每日都在使用终端，因此，文字用户界面（TUI）逐渐显示出其价值。"><meta property="og:type" content="article"><meta property="og:url" content="/article-16391-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-11-18T07:15:00+00:00"><meta property="article:modified_time" content="2023-11-18T07:15:00+00:00"><meta itemprop=name content="使用 dialog 和 jq 在 Linux 上编写高效终端 TUI"><meta itemprop=description content="许多人每日都在使用终端，因此，文字用户界面（TUI）逐渐显示出其价值。"><meta itemprop=datePublished content="2023-11-18T07:15:00+00:00"><meta itemprop=dateModified content="2023-11-18T07:15:00+00:00"><meta itemprop=wordCount content="724"><meta itemprop=keywords content="TUI,jq,dialog,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>使用 dialog 和 jq 在 Linux 上编写高效终端 TUI</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2023-11-18T07:15:00Z>November 18, 2023</time></div></div></header><div class="content post__content clearfix"><p><img src=https://img.linux.net.cn/data/attachment/album/202311/18/071418mc44bs42keebfe1c.png alt></p><h3 id=为何选择文字用户界面tui>为何选择文字用户界面（TUI）？</h3><p>许多人每日都在使用终端，因此， 文字用户界面 Text User Interface （TUI）逐渐显示出其价值。它能减少用户输入命令时的误差，让终端操作更高效，提高生产力。</p><p>以我的个人使用情况为例：我每日会通过家用电脑远程连接到我使用 Linux 系统的实体 PC。所有的远程网络连接都通过私有 VPN 加密保护。然而，当我需要频繁重复输入命令进行连接时，这种经历实在令人烦躁。</p><p>于是，我创建了下面这个 Bash 函数，从而有所改进：</p><pre tabindex=0><code>export REMOTE_RDP_USER=&#34;myremoteuser&#34;
function remote_machine() {
  /usr/bin/xfreerdp /cert-ignore /sound:sys:alsa /f /u:$REMOTE_RDP_USER /v:$1 /p:$2
}
</code></pre><p>但后来，我发现自己还是频繁地执行下面这条命令（在一行中）：</p><pre tabindex=0><code>remote_pass=(/bin/cat/.mypassfile) remote_machine $remote_machine $remote_pass
</code></pre><p>这太烦了。更糟糕的是，我的密码被明文存储在我的电脑上（我虽然使用了加密驱动器，但这点依然令人不安）。</p><p>因此，我决定投入一些时间，编写一个实用的脚本，从而更好地满足我的基本需求。</p><h4 id=我需要哪些信息才能连接到远程桌面>我需要哪些信息才能连接到远程桌面？</h4><p>实际上，要连接到远程桌面，你只需提供少量信息。这些信息需要进行结构化处理，所以一个简单的 JSON 文件就能够满足要求：</p><pre tabindex=0><code>{&#34;machines&#34;: [
  {
  &#34;name&#34;: &#34;machine1.domain.com&#34;,
  &#34;description&#34;: &#34;Personal-PC&#34;
  },
  {
  &#34;name&#34;: &#34;machine2.domain.com&#34;,
  &#34;description&#34;: &#34;Virtual-Machine&#34;
  }
  ],
&#34;remote_user&#34;: &#34;MYUSER@DOMAIN&#34;,
&#34;title&#34; : &#34;MY COMPANY RDP connection&#34;
}
</code></pre><p>尽管在各种配置文件格式中，JSON 并非最佳选择（例如，它不支持注解），但是 Linux 提供了许多工具通过命令行方式解析 JSON 内容。其中，特别值得一提的工具就是 <a href=https://stedolan.github.io/jq/>jq</a>。下面我要向你展示如何利用它来提取机器列表：</p><pre tabindex=0><code>/usr/bin/jq --compact-output --raw-output &#39;.machines[]| .name&#39; \
  $HOME/.config/scripts/kodegeek_rdp.json) \
  &#34;machine1.domain.com&#34; &#34;machine2.domain.com&#34;
</code></pre><p><code>jq</code> 的文档可以在 <a href=https://jqlang.github.io/jq/manual/>这里</a> 找到。另外，你也可以直接将你的 JSON 文件复制粘贴到 <a href=https://jqplay.org/>jq play</a>，试用你的表达式，然后在你的脚本中使用这些表达式。</p><p>既然已经准备好了连接远程计算机所需的所有信息，那现在就让我们来创建一个美观实用的 TUI 吧。</p><h4 id=dialog-的帮助>Dialog 的帮助</h4><p><a href=https://invisible-island.net/dialog/>Dialog</a> 是那些你可能希望早些认识的、被低评估的 Linux 工具之一。你可以利用它构建出一个井然有序、简介易懂，并且完美适用于你终端的用户界面。</p><p>比如，我可以创建一个包含我喜欢的编程语言的简单的复选框列表，且默认选择 Python：</p><pre tabindex=0><code>dialog --clear --checklist &#34;Favorite programming languages:&#34; 10 30 7\
  1 Python on 2 Java off 3 Bash off 4 Perl off 5 Ruby off
</code></pre><p><img src=https://img.linux.net.cn/data/attachment/album/202311/18/071514x77uf8703an1307f.png alt></p><p>我们通过这条命令向 <code>dialog</code> 下达了几个指令：</p><ul><li>清除屏幕（所有选项都以 <code>--</code> 开头）</li><li>创建一个带有标题的复选框（第一个位置参数）</li><li>决定窗口尺寸（高度、宽度和列表高度，共 3 个参数）</li><li>列表中的每条选项都由一个标签和一个值组成。</li></ul><p>惊人的是，仅仅一行代码，就带来了简洁直观和视觉友好的选择列表。</p><p>关于 <code>dialog</code> 的详细文档，你可以在 <a href=https://invisible-island.net/dialog/#documentation>这里</a> 阅读。</p><h4 id=整合所有元素使用-dialog-和-jq-编写-tui>整合所有元素：使用 Dialog 和 JQ 编写 TUI</h4><p>我编写了一个 TUI，它使用 <code>jq</code> 从我的 JSON 文件中提取配置详细信息，并且使用 <code>dialog</code> 来组织流程。每次运行，我都会要求输入密码，并将其保存在一个临时文件中，脚本使用后便会删除这个临时文件。</p><p>这个脚本非常基础，但它更安全，也使我能够专注于更重要的任务 ?</p><p>那么 <a href=https://raw.githubusercontent.com/josevnz/scripts/main/kodegeek_rdp.sh>脚本</a> 看起来是怎样的呢？下面是代码：</p><pre tabindex=0><code>#!/bin/bash
# Author Jose Vicente Nunez
# Do not use this script on a public computer. It is not secure...
# https://invisible-island.net/dialog/
# Below some constants to make it easier to handle Dialog
# return codes
: ${DIALOG_OK=0}
: ${DIALOG_CANCEL=1}
: ${DIALOG_HELP=2}
: ${DIALOG_EXTRA=3}
: ${DIALOG_ITEM_HELP=4}
: ${DIALOG_ESC=255}
# Temporary file to store sensitive data. Use a &#39;trap&#39; to remove
# at the end of the script or if it gets interrupted
declare tmp_file=$(/usr/bin/mktemp 2&gt;/dev/null) || declare tmp_file=/tmp/test$$
trap &#34;/bin/rm -f $tmp_file&#34; QUIT EXIT INT
/bin/chmod go-wrx ${tmp_file} &gt; /dev/null 2&gt;&amp;1
:&lt;&lt;DOC
Extract details like title, remote user and machines using jq from the JSON file
Use a subshell for the machine list
DOC
declare TITLE=$(/usr/bin/jq --compact-output --raw-output &#39;.title&#39; $HOME/.config/scripts/kodegeek_rdp.json)|| exit 100
declare REMOTE_USER=$(/usr/bin/jq --compact-output --raw-output &#39;.remote_user&#39; $HOME/.config/scripts/kodegeek_rdp.json)|| exit 100
declare MACHINES=$(
    declare tmp_file2=$(/usr/bin/mktemp 2&gt;/dev/null) || declare tmp_file2=/tmp/test$$
    # trap &#34;/bin/rm -f $tmp_file2&#34; 0 1 2 5 15 EXIT INT
    declare -a MACHINE_INFO=$(/usr/bin/jq --compact-output --raw-output &#39;.machines[]| join(&#34;,&#34;)&#39; $HOME/.config/scripts/kodegeek_rdp.json &gt; $tmp_file2)
    declare -i i=0
    while read line; do
        declare machine=$(echo $line| /usr/bin/cut -d&#39;,&#39; -f1)
        declare desc=$(echo $line| /usr/bin/cut -d&#39;,&#39; -f2)
        declare toggle=off
        if [ $i -eq 0 ]; then
            toggle=on
            ((i=i+1))
        fi
        echo $machine $desc $toggle
    done &lt; $tmp_file2
    /bin/cp /dev/null $tmp_file2
) || exit 100
# Create a dialog with a radio list and let the user select the
# remote machine
/usr/bin/dialog \
    --clear \
    --title &#34;$TITLE&#34; \
    --radiolist &#34;Which machine do you want to use?&#34; 20 61 2 \
    $MACHINES 2&gt; ${tmp_file}
return_value=$?
# Handle the return codes from the machine selection in the
# previous step
export remote_machine=&#34;&#34;
case $return_value in
  $DIALOG_OK)
    export remote_machine=$(/bin/cat ${tmp_file})
    ;;
  $DIALOG_CANCEL)
    echo &#34;Cancel pressed.&#34;;;
  $DIALOG_HELP)
    echo &#34;Help pressed.&#34;;;
  $DIALOG_EXTRA)
    echo &#34;Extra button pressed.&#34;;;
  $DIALOG_ITEM_HELP)
    echo &#34;Item-help button pressed.&#34;;;
  $DIALOG_ESC)
    if test -s $tmp_file ; then
      /bin/rm -f $tmp_file
    else
      echo &#34;ESC pressed.&#34;
    fi
    ;;
esac

# No machine selected? No service ...
if [ -z &#34;${remote_machine}&#34; ]; then
  /usr/bin/dialog \
        --clear  \
        --title &#34;Error, no machine selected?&#34; --clear &#34;$@&#34; \
        --msgbox &#34;No machine was selected!. Will exit now...&#34; 15 30
  exit 100
fi

# Send 4 packets to the remote machine. I assume your network
# administration allows ICMP packets
# If there is an error show  message box
/bin/ping -c 4 ${remote_machine} &gt;/dev/null 2&gt;&amp;1
if [ $? -ne 0 ]; then
  /usr/bin/dialog \
        --clear  \
        --title &#34;VPN issues or machine is off?&#34; --clear &#34;$@&#34; \
        --msgbox &#34;Could not ping ${remote_machine}. Time to troubleshoot...&#34; 15 50
  exit 100
fi

# Remote machine is visible, ask for credentials and handle user
# choices (like password with a password box)
/bin/rm -f ${tmp_file}
/usr/bin/dialog \
  --title &#34;$TITLE&#34; \
  --clear  \
  --insecure \
  --passwordbox &#34;Please enter your Windows password for ${remote_machine}\n&#34; 16 51 2&gt; $tmp_file
return_value=$?
case $return_value in
  $DIALOG_OK)
    # We have all the information, try to connect using RDP protocol
    /usr/bin/mkdir -p -v $HOME/logs
    /usr/bin/xfreerdp /cert-ignore /sound:sys:alsa /f /u:$REMOTE_USER /v:${remote_machine} /p:$(/bin/cat ${tmp_file})| \
    /usr/bin/tee $HOME/logs/$(/usr/bin/basename $0)-$remote_machine.log
    ;;
  $DIALOG_CANCEL)
    echo &#34;Cancel pressed.&#34;;;
  $DIALOG_HELP)
    echo &#34;Help pressed.&#34;;;
  $DIALOG_EXTRA)
    echo &#34;Extra button pressed.&#34;;;
  $DIALOG_ITEM_HELP)
    echo &#34;Item-help button pressed.&#34;;;
  $DIALOG_ESC)
    if test -s $tmp_file ; then
      /bin/rm -f $tmp_file
    else
      echo &#34;ESC pressed.&#34;
    fi
    ;;
esac
</code></pre><p><img src=https://img.linux.net.cn/data/attachment/album/202311/18/071515zwwg76rzjgbqgbz3.png alt></p><p>你从代码中可以看出，<code>dialog</code> 预期的是位置参数，并且允许你在变量中捕获用户的回应。这实际上使其成为编写文本用户界面的 Bash 扩展。</p><p>上述的小例子只涵盖了一些部件的使用，其实还有更多的文档在 <a href=https://invisible-island.net/dialog/>官方 dialog 网站</a>上。</p><h3 id=dialog-和-jq-是最好的选择吗>Dialog 和 JQ 是最好的选择吗？</h3><p>实现这个功能可以有很多方法（如 <a href=https://textual.textualize.io/>Textual</a>，Gnome 的 <a href="https://gitlab.gnome.org/GNOME/zenity/commits/master?ofs=1900">Zenity</a>，Python 的 <a href=https://docs.python.org/3/library/tkinter.html>TKinker</a>等）。我只是想向你展示一种高效的方式——仅用 100 行代码就完成了这项任务。</p><p><em>确实，它并不完美</em>。更具体地讲，它与 Bash 的深度集成使得代码有些冗长，但仍然保持了易于调试和维护的特性。相比于反复复制粘贴长长的命令，这无疑是一个更好的选择。</p><p>最后，如果你喜欢在 Bash 中使用 <code>jq</code> 处理 JSON，那么你会对这个 <a href=https://nntrn.github.io/jq-recipes/>jq 配方的精彩集合</a> 感兴趣的。</p><p><em>（题图：MJ/a9b7f60a-02ec-4d3f-88ae-2321f49ac0e1）</em></p><hr><p>via: <a href=https://fedoramagazine.org/writing-useful-terminal-tui-on-linux-with-dialog-and-jq/>https://fedoramagazine.org/writing-useful-terminal-tui-on-linux-with-dialog-and-jq/</a></p><p>作者：<a href=https://fedoramagazine.org/author/josevnz/>Jose Nunez</a> 选题：<a href=https://github.com/lujun9972>lujun9972</a> 译者：<a href=https://linux.cn/lctt/ChatGPT>ChatGPT</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/tui/ rel=tag>TUI</a></li><li class=tags__item><a class="tags__link btn" href=/tags/jq/ rel=tag>jq</a></li><li class=tags__item><a class="tags__link btn" href=/tags/dialog/ rel=tag>dialog</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>