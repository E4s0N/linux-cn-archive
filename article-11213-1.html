<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>本地开发如何测试 Webhook - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="本地开发如何测试 Webhook"><meta property="og:description" content="Webhook 可用于外部系统通知你的系统发生了某个事件或更新。"><meta property="og:type" content="article"><meta property="og:url" content="/article-11213-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-08-11T09:06:00+00:00"><meta property="article:modified_time" content="2019-08-11T09:06:00+00:00"><meta itemprop=name content="本地开发如何测试 Webhook"><meta itemprop=description content="Webhook 可用于外部系统通知你的系统发生了某个事件或更新。"><meta itemprop=datePublished content="2019-08-11T09:06:00+00:00"><meta itemprop=dateModified content="2019-08-11T09:06:00+00:00"><meta itemprop=wordCount content="427"><meta itemprop=keywords content="Webhook,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>本地开发如何测试 Webhook</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2019-08-11T09:06:00Z>August 11, 2019</time></div></div></header><div class="content post__content clearfix"><p><img src=/data/attachment/album/201908/11/090540wipp5c65iinyyf63.jpg alt></p><p><a href=https://sendgrid.com/blog/whats-webhook/>Webhook</a> 可用于外部系统通知你的系统发生了某个事件或更新。可能最知名的 <a href=https://sendgrid.com/blog/whats-webhook/>Webhook</a> 类型是支付服务提供商（PSP）通知你的系统支付状态有了更新。</p><p>它们通常以监听的预定义 URL 的形式出现，例如 <code>http://example.com/webhooks/payment-update</code>。同时，另一个系统向该 URL 发送具有特定有效载荷的 POST 请求（例如支付 ID）。一旦请求进入，你就会获得支付 ID，可以通过 PSP 的 API 用这个支付 ID 向它们询问最新状态，然后更新你的数据库。</p><p>其他例子可以在这个对 Webhook 的出色的解释中找到：<a href=https://sendgrid.com/blog/whats-webhook/>https://sendgrid.com/blog/whats-webhook/</a>。</p><p>只要系统可通过互联网公开访问（这可能是你的生产环境或可公开访问的临时环境），测试这些 webhook 就相当顺利。而当你在笔记本电脑上或虚拟机内部（例如，Vagrant 虚拟机）进行本地开发时，它就变得困难了。在这些情况下，发送 webhook 的一方无法公开访问你的本地 URL。此外，监视发送的请求也很困难，这可能使开发和调试变得困难。</p><p>因此，这个例子将解决：</p><ul><li>测试来自本地开发环境的 webhook，该环境无法通过互联网访问。从服务器向 webhook 发送数据的服务无法访问它。</li><li>监控发送的请求和数据，以及应用程序生成的响应。这样可以更轻松地进行调试，从而缩短开发周期。</li></ul><p>前置需求：</p><ul><li><em>可选</em>：如果你使用虚拟机（VM）进行开发，请确保它正在运行，并确保在 VM 中完成后续步骤。</li><li>对于本教程，我们假设你定义了一个 vhost：<code>webhook.example.vagrant</code>。我在本教程中使用了 Vagrant VM，但你可以自由选择 vhost。</li><li>按照这个<a href=https://ngrok.com/download>安装说明</a>安装 <code>ngrok</code>。在 VM 中，我发现它的 Node 版本也很有用：<a href=https://www.npmjs.com/package/ngrok>https://www.npmjs.com/package/ngrok</a>，但你可以随意使用其他方法。</li></ul><p>我假设你没有在你的环境中运行 SSL，但如果你使用了，请将在下面的示例中的端口 80 替换为端口 433，<code>http://</code> 替换为 <code>https://</code>。</p><h3 id=使-webhook-可测试>使 webhook 可测试</h3><p>我们假设以下示例代码。我将使用 PHP，但请将其视作伪代码，因为我留下了一些关键部分（例如 API 密钥、输入验证等）没有编写。</p><p>第一个文件：<code>payment.php</code>。此文件创建一个 <code>$payment</code> 对象，将其注册到 PSP。然后它获取客户需要访问的 URL，以便支付并将用户重定向到客户那里。</p><p>请注意，此示例中的 <code>webhook.example.vagrant</code> 是我们为开发设置定义的本地虚拟主机。它无法从外部世界进入。</p><pre tabindex=0><code>&lt;?php
/*
 * This file creates a payment and tells the PSP what webhook URL to use for updates
 * After creating the payment, we get a URL to send the customer to in order to pay at the PSP
 */
$payment = [
    &#39;order_id&#39; =&gt; 123,
    &#39;amount&#39; =&gt; 25.00,
    &#39;description&#39; =&gt; &#39;Test payment&#39;,
    &#39;redirect_url&#39; =&gt; &#39;http://webhook.example.vagrant/redirect.php&#39;,
    &#39;webhook_url&#39; =&gt; &#39;http://webhook.example.vagrant/webhook.php&#39;,
];

$payment = $paymentProvider-&gt;createPayment($payment);
header(&#34;Location: &#34; . $payment-&gt;getPaymentUrl());
</code></pre><p>第二个文件：<code>webhook.php</code>。此文件等待 PSP 调用以获得有关更新的通知。</p><pre tabindex=0><code>&lt;?php
/*
 * This file gets called by the PSP and in the $_POST they submit an &#39;id&#39;
 * We can use this ID to get the latest status from the PSP and update our internal systems afterward
 */
 
$paymentId = $_POST[&#39;id&#39;];
$paymentInfo = $paymentProvider-&gt;getPayment($paymentId);
$status = $paymentInfo-&gt;getStatus();

// Perform actions in here to update your system
if ($status === &#39;paid&#39;) {
    ..
}
elseif ($status === &#39;cancelled&#39;) {
    ..
}
</code></pre><p>我们的 webhook URL 无法通过互联网访问（请记住它：<code>webhook.example.vagrant</code>）。因此，PSP 永远不可能调用文件 <code>webhook.php</code>，你的系统将永远不会知道付款状态，这最终导致订单永远不会被运送给客户。</p><p>幸运的是，<code>ngrok</code> 可以解决这个问题。 <a href=https://ngrok.com/>ngrok</a> 将自己描述为：</p><blockquote><p>ngrok 通过安全隧道将 NAT 和防火墙后面的本地服务器暴露给公共互联网。</p></blockquote><p>让我们为我们的项目启动一个基本的隧道。在你的环境中（在你的系统上或在 VM 上）运行以下命令：</p><pre tabindex=0><code>ngrok http -host-header=rewrite webhook.example.vagrant:80
</code></pre><blockquote><p>阅读其文档可以了解更多配置选项：<a href=https://ngrok.com/docs>https://ngrok.com/docs</a>。</p></blockquote><p>会出现这样的屏幕：</p><p><img src=/data/attachment/album/201908/11/090802e57kq5ry0nnrv990.png alt></p><p><em>ngrok 输出</em></p><p>我们刚刚做了什么？基本上，我们指示 <code>ngrok</code> 在端口 80 建立了一个到 <code>http://webhook.example.vagrant</code> 的隧道。同一个 URL 也可以通过 <code>http://39741ffc.ngrok.io</code> 或 <code>https://39741ffc.ngrok.io</code> 访问，它们能被任何知道此 URL 的人通过互联网公开访问。</p><p>请注意，你可以同时获得 HTTP 和 HTTPS 两个服务。这个文档提供了如何将此限制为 HTTPS 的示例：<a href=https://ngrok.com/docs#bind-tls>https://ngrok.com/docs#bind-tls</a>。</p><p>那么，我们如何让我们的 webhook 现在工作起来？将 <code>payment.php</code> 更新为以下代码：</p><pre tabindex=0><code>&lt;?php
/*
 * This file creates a payment and tells the PSP what webhook URL to use for updates
 * After creating the payment, we get a URL to send the customer to in order to pay at the PSP
 */
$payment = [
    &#39;order_id&#39; =&gt; 123,
    &#39;amount&#39; =&gt; 25.00,
    &#39;description&#39; =&gt; &#39;Test payment&#39;,
    &#39;redirect_url&#39; =&gt; &#39;http://webhook.example.vagrant/redirect.php&#39;,
    &#39;webhook_url&#39; =&gt; &#39;https://39741ffc.ngrok.io/webhook.php&#39;,
];

$payment = $paymentProvider-&gt;createPayment($payment);
header(&#34;Location: &#34; . $payment-&gt;getPaymentUrl());
</code></pre><p>现在，我们告诉 PSP 通过 HTTPS 调用此隧道 URL。只要 PSP 通过隧道调用 webhook，<code>ngrok</code> 将确保使用未修改的有效负载调用内部 URL。</p><h3 id=如何监控对-webhook-的调用>如何监控对 webhook 的调用？</h3><p>你在上面看到的屏幕截图概述了对隧道主机的调用，这些数据相当有限。幸运的是，<code>ngrok</code> 提供了一个非常好的仪表板，允许你检查所有调用：</p><p><img src=/data/attachment/album/201908/11/090813mfyyssxyyqapxv6f.png alt></p><p>我不会深入研究这个问题，因为它是不言自明的，你只要运行它就行了。因此，我将解释如何在 Vagrant 虚拟机上访问它，因为它不是开箱即用的。</p><p>仪表板将允许你查看所有调用、其状态代码、标头和发送的数据。你将看到应用程序生成的响应。</p><p>仪表板的另一个优点是它允许你重放某个调用。假设你的 webhook 代码遇到了致命的错误，开始新的付款并等待 webhook 被调用将会很繁琐。重放上一个调用可以使你的开发过程更快。</p><p>默认情况下，仪表板可在 <code>http://localhost:4040</code> 访问。</p><h3 id=虚拟机中的仪表盘>虚拟机中的仪表盘</h3><p>为了在 VM 中完成此工作，你必须执行一些额外的步骤：</p><p>首先，确保可以在端口 4040 上访问 VM。然后，在 VM 内创建一个文件已存放此配置：</p><pre tabindex=0><code>web_addr: 0.0.0.0:4040
</code></pre><p>现在，杀死仍在运行的 <code>ngrok</code> 进程，并使用稍微调整过的命令启动它：</p><pre tabindex=0><code>ngrok http -config=/path/to/config/ngrok.conf -host-header=rewrite webhook.example.vagrant:80
</code></pre><p>尽管 ID 已经更改，但你将看到类似于上一屏幕截图的屏幕。之前的网址不再有效，但你有了一个新网址。 此外，<code>Web Interface</code> URL 已更改：</p><p><img src=/data/attachment/album/201908/11/090824gt35e3w35v9ef9su.png alt></p><p>现在将浏览器指向 <code>http://webhook.example.vagrant:4040</code> 以访问仪表板。另外，对 <code>https://e65642b5.ngrok.io/webhook.php</code> 做个调用。这可能会导致你的浏览器出错，但仪表板应显示正有一个请求。</p><h3 id=最后的备注>最后的备注</h3><p>上面的例子是伪代码。原因是每个外部系统都以不同的方式使用 webhook。我试图基于一个虚构的 PSP 实现给出一个例子，因为可能很多开发人员在某个时刻肯定会处理付款。</p><p>请注意，你的 webhook 网址也可能被意图不好的其他人使用。确保验证发送给它的任何输入。</p><p>更好的的，可以向 URL 添加令牌，该令牌对于每个支付是唯一的。只有你的系统和发送 webhook 的系统才能知道此令牌。</p><p>祝你测试和调试你的 webhook 顺利！</p><p>注意：我没有在 Docker 上测试过本教程。但是，这个 Docker 容器看起来是一个很好的起点，并包含了明确的说明：<a href=https://github.com/wernight/docker-ngrok>https://github.com/wernight/docker-ngrok</a> 。</p><hr><p>via: <a href=https://medium.freecodecamp.org/testing-webhooks-while-using-vagrant-for-development-98b5f3bedb1d>https://medium.freecodecamp.org/testing-webhooks-while-using-vagrant-for-development-98b5f3bedb1d</a></p><p>作者：<a href=https://medium.freecodecamp.org/@stefandoorn>Stefan Doorn</a> 译者：<a href=https://github.com/wxy>wxy</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/webhook/ rel=tag>Webhook</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>