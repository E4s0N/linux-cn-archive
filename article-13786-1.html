<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>浅谈慢速的二次算法与快速的 hashmap - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="浅谈慢速的二次算法与快速的 hashmap"><meta property="og:description" content="hashmap 当然不是魔法"><meta property="og:type" content="article"><meta property="og:url" content="/article-13786-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-09-15T09:45:31+00:00"><meta property="article:modified_time" content="2021-09-15T09:45:31+00:00"><meta itemprop=name content="浅谈慢速的二次算法与快速的 hashmap"><meta itemprop=description content="hashmap 当然不是魔法"><meta itemprop=datePublished content="2021-09-15T09:45:31+00:00"><meta itemprop=dateModified content="2021-09-15T09:45:31+00:00"><meta itemprop=wordCount content="511"><meta itemprop=keywords content="hashmap,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>浅谈慢速的二次算法与快速的 hashmap</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2021-09-15T09:45:31Z>September 15, 2021</time></div></div></header><div class="content post__content clearfix"><p><img src=https://img.linux.net.cn/data/attachment/album/202109/15/094524s7dlcq74ksqazyyc.jpg alt></p><p>大家好！昨天我与一位朋友聊天，他正在准备编程面试，并试图学习一些算法基础知识。</p><p>我们聊到了 二次时间 quadratic-time 与 线性时间 linear-time 算法的话题，我认为在这里写这篇文章会很有趣，因为避免二次时间算法不仅在面试中很重要——有时在现实生活中了解一下也是很好的！后面我会快速解释一下什么是“二次时间算法” :)</p><p>以下是我们将要讨论的 3 件事：</p><ol><li>二次时间函数比线性时间函数慢得非常非常多</li><li>有时可以通过使用 hashmap 把二次算法变成线性算法</li><li>这是因为 hashmap 查找非常快（即时查询！）</li></ol><p>我会尽量避免使用数学术语，重点关注真实的代码示例以及它们到底有多快/多慢。</p><h3 id=目标问题取两个列表的交集>目标问题：取两个列表的交集</h3><p>我们来讨论一个简单的面试式问题：获取 2 个数字列表的交集。 例如，<code>intersect([1,2,3], [2,4,5])</code> 应该返回 <code>[2]</code>。</p><p>这个问题也是有些现实应用的——你可以假设有一个真实程序，其需求正是取两个 ID 列表的交集。</p><h3 id=显而易见的解决方案>“显而易见”的解决方案：</h3><p>我们来写一些获取 2 个列表交集的代码。下面是一个实现此需求的程序，命名为 <code>quadratic.py</code>。</p><pre tabindex=0><code>import sys

# 实际运行的代码
def intersection(list1, list2):
    result = []
    for x in list1:
        for y in list2:
            if x == y:
                result.append(y)
    return result

# 一些样板，便于我们从命令行运行程序，处理不同大小的列表
def run(n):
    # 定义两个有 n+1 个元素的列表
    list1 = list(range(3, n)) + [2]
    list2 = list(range(n+1, 2*n)) + [2]
    # 取其交集并输出结果
    print(list(intersection(list1, list2)))

# 使用第一个命令行参数作为输入，运行程序
run(int(sys.argv[1]))
</code></pre><p>程序名为 <code>quadratic.py</code>（LCTT 译注：“quadratic”意为“二次方的”）的原因是：如果 <code>list1</code> 和 <code>list2</code> 的大小为 <code>n</code>，那么内层循环（<code>if x == y</code>）会运行 <code>n^2</code> 次。在数学中，像 <code>x^2</code> 这样的函数就称为“二次”函数。</p><h3 id=quadraticpy-有多慢><code>quadratic.py</code> 有多慢？</h3><p>用一些不同长度的列表来运行这个程序，两个列表的交集总是相同的：<code>[2]</code>。</p><pre tabindex=0><code>$ time python3 quadratic.py 10
[2]

real    0m0.037s
$ time python3 quadratic.py 100
[2]

real    0m0.053s
$ time python3 quadratic.py 1000
[2]

real    0m0.051s
$ time python3 quadratic.py 10000 # 10,000
[2]

real    0m1.661s
</code></pre><p>到目前为止，一切都还不错——程序仍然只花费不到 2 秒的时间。</p><p>然后运行该程序处理两个包含 100,000 个元素的列表，我不得不等待了很长时间。结果如下：</p><pre tabindex=0><code>$ time python3 quadratic.py 100000 # 100,000
[2]

real    2m41.059s
</code></pre><p>这可以说相当慢了！总共花费了 160 秒，几乎是在 10,000 个元素上运行时（1.6 秒）的 100 倍。所以我们可以看到，在某个点之后，每次我们将列表扩大 10 倍，程序运行的时间就会增加大约 100 倍。</p><p>我没有尝试在 1,000,000 个元素上运行这个程序，因为我知道它会花费又 100 倍的时间——可能大约需要 3 个小时。我没时间这样做！</p><p>你现在大概明白了为什么二次时间算法会成为一个问题——即使是这个非常简单的程序也会很快变得非常缓慢。</p><h3 id=快速版linearpy>快速版：<code>linear.py</code></h3><p>好，接下来我们编写一个快速版的程序。我先给你看看程序的样子，然后再分析。</p><pre tabindex=0><code>import sys

# 实际执行的算法
def intersection(list1, list2):
    set1 = set(list1) # this is a hash set
    result = []
    for y in list2:
        if y in set1:
            result.append(y)
    return result

# 一些样板，便于我们从命令行运行程序，处理不同大小的列表
def run(n):
    # 定义两个有 n+1 个元素的列表
    list1 = range(3, n) + [2]
    list2 = range(n+1, 2*n) + [2]
    # 输出交集结果
    print(intersection(list1, list2))

run(int(sys.argv[1]))
</code></pre><p>（这不是最惯用的 Python 使用方式，但我想在尽量避免使用太多 Python 思想的前提下编写代码，以便不了解 Python 的人能够更容易理解）</p><p>这里我们做了两件与慢速版程序不同的事：</p><ol><li>将 <code>list1</code> 转换成名为 <code>set1</code> 的 set 集合</li><li>只使用一个 for 循环而不是两个</li></ol><h3 id=看看-linearpy-程序有多快>看看 <code>linear.py</code> 程序有多快</h3><p>在讨论 <em>为什么</em> 这个程序快之前，我们先在一些大型列表上运行该程序，以此证明它确实是很快的。此处演示该程序依次在大小为 10 到 10,000,000 的列表上运行的过程。（请记住，我们上一个的程序在 100,000 个元素上运行时开始变得非常非常慢）</p><pre tabindex=0><code>$ time python3 linear.py 100
[2]

real    0m0.056s
$ time python3 linear.py 1000
[2]

real    0m0.036s
$ time python3 linear.py 10000 # 10,000
[2]

real    0m0.028s
$ time python3 linear.py 100000 # 100,000
[2]

real    0m0.048s &lt;-- quadratic.py took 2 minutes in this case! we&#39;re doing it in 0.04 seconds now!!! so fast!
$ time python3 linear.py 1000000 # 1,000,000
[2]

real    0m0.178s
$ time python3 linear.py 10000000 # 10,000,000
[2]

real    0m1.560s
</code></pre><h3 id=在极大型列表上运行-linearpy>在极大型列表上运行 <code>linear.py</code></h3><p>如果我们试着在一个非常非常大的列表（100 亿 / 10,000,000,000 个元素）上运行它，那么实际上会遇到另一个问题：它足够 <em>快</em> 了（该列表仅比花费 4.2 秒的列表大 100 倍，因此我们大概应该能在不超过 420 秒的时间内完成），但我的计算机没有足够的内存来存储列表的所有元素，因此程序在运行结束之前崩溃了。</p><pre tabindex=0><code>$ time python3 linear.py 10000000000
Traceback (most recent call last):
  File &#34;/home/bork/work/homepage/linear.py&#34;, line 18, in &lt;module&gt;
    run(int(sys.argv[1]))
  File &#34;/home/bork/work/homepage/linear.py&#34;, line 13, in run
    list1 = [1] * n + [2]
MemoryError

real    0m0.090s
user    0m0.034s
sys 0m0.018s
</code></pre><p>不过本文不讨论内存使用，所以我们可以忽略这个问题。</p><h3 id=那么为什么-linearpy-很快呢>那么，为什么 <code>linear.py</code> 很快呢？</h3><p>现在我将试着解释为什么 <code>linear.py</code> 很快。</p><p>再看一下我们的代码:</p><pre tabindex=0><code>def intersection(list1, list2):
    set1 = set(list1) # this is a hash set
    result = []
    for y in list2:
        if y in set1:
            result.append(y)
    return result
</code></pre><p>假设 <code>list1</code> 和 <code>list2</code> 都是大约 10,000,000 个不同元素的列表，这样的元素数量可以说是很大了！</p><p>那么为什么它还能够运行得如此之快呢？因为 hashmap！！！</p><h3 id=hashmap-查找是即时的常数级时间>hashmap 查找是即时的（“常数级时间”）</h3><p>我们看一下快速版程序中的 <code>if</code> 语句：</p><pre tabindex=0><code>if y in set1:
    result.append(y)
</code></pre><p>你可能会认为如果 <code>set1</code> 包含 1000 万个元素，那么这个查找——<code>if y in set1</code> 会比 <code>set1</code> 包含 1000 个元素时慢。但事实并非如此！无论 <code>set1</code> 有多大，所需时间基本是相同的（超级快）。</p><p>这是因为 <code>set1</code> 是一个哈希集合，它是一种只有键没有值的 hashmap（hashtable）结构。</p><p>我不准备在本文中解释 <em>为什么</em> hashmap 查找是即时的，但是神奇的 Vaidehi Joshi 的 <a href=https://medium.com/basecs>basecs</a> 系列中有关于 <a href=https://medium.com/basecs/taking-hash-tables-off-the-shelf-139cbf4752f0>hash table</a> 和 <a href=https://medium.com/basecs/hashing-out-hash-functions-ea5dd8beb4dd>hash 函数</a> 的解释，其中讨论了 hashmap 即时查找的原因。</p><h3 id=不经意的二次方现实中的二次算法>不经意的二次方：现实中的二次算法！</h3><p>二次时间算法真的很慢，我们看到的的这个问题实际上在现实中也会遇到——Nelson Elhage 有一个很棒的博客，名为 <a href=https://accidentallyquadratic.tumblr.com/>不经意的二次方</a>，其中有关于不经意以二次时间算法运行代码导致性能问题的故事。</p><h3 id=二次时间算法可能会偷袭你>二次时间算法可能会“偷袭”你</h3><p>关于二次时间算法的奇怪之处在于，当你在少量元素（如 1000）上运行它们时，它看起来并没有那么糟糕！没那么慢！但是如果你给它 1,000,000 个元素，它真的会花费几个小时去运行。</p><p>所以我认为它还是值得深入了解的，这样你就可以避免无意中使用二次时间算法，特别是当有一种简单的方法来编写线性时间算法（例如使用 hashmap）时。</p><h3 id=总是让我感到一丝神奇的-hashmap>总是让我感到一丝神奇的 hashmap</h3><p>hashmap 当然不是魔法（你可以学习一下为什么 hashmap 查找是即时的！真的很酷！），但它总是让人 <em>感觉</em> 有点神奇，每次我在程序中使用 hashmap 来加速，都会使我感到开心 :)</p><hr><p>via: <a href=https://jvns.ca/blog/2021/09/10/hashmaps-make-things-fast/>https://jvns.ca/blog/2021/09/10/hashmaps-make-things-fast/</a></p><p>作者：<a href=https://jvns.ca/>Julia Evans</a> 选题：<a href=https://github.com/lujun9972>lujun9972</a> 译者：<a href=https://github.com/unigeorge>unigeorge</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/hashmap/ rel=tag>hashmap</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>