<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>如何使 Jenkins 日志更可读 - Linux.cn Archive</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="如何使 Jenkins 日志更可读"><meta property="og:description" content="Jenkins 的默认日志难以阅读，但日志本不必如此。"><meta property="og:type" content="article"><meta property="og:url" content="/article-13392-1.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-05-15T09:30:25+00:00"><meta property="article:modified_time" content="2021-05-15T09:30:25+00:00"><meta itemprop=name content="如何使 Jenkins 日志更可读"><meta itemprop=description content="Jenkins 的默认日志难以阅读，但日志本不必如此。"><meta itemprop=datePublished content="2021-05-15T09:30:25+00:00"><meta itemprop=dateModified content="2021-05-15T09:30:25+00:00"><meta itemprop=wordCount content="342"><meta itemprop=keywords content="Jenkins,日志,"><link rel=preconnect href=https://fonts.bunny.net crossorigin><link rel=dns-prefetch href=//fonts.bunny.net><link rel=dns-prefetch href=//fonts.bunny.net><link rel=stylesheet href="https://fonts.bunny.net/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Linux.cn Archive" rel=home><div class="logo__item logo__text"><div class=logo__title>Linux.cn Archive</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>Categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>Tags</span></a></li><li class=menu__item><a class=menu__link href><span class=menu__text>RSS</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>如何使 Jenkins 日志更可读</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2021-05-15T09:30:25Z>May 15, 2021</time></div></div></header><div class="content post__content clearfix"><blockquote><p>Jenkins 的默认日志难以阅读，但日志本不必如此。</p></blockquote><p><img src=https://img.linux.net.cn/data/attachment/album/202105/15/093017vd34foo00wpy2yot.jpg alt title="Person using a laptop"></p><p>Jenkins 是一个自由开源的自动化服务器，用于构建、测试和部署代码。它是 持续集成 Continuous Integration （CI）、 持续交付 Continuous Delivery （CD）的基础，可以为开发人员每天节约几小时，并保护他们免受失败的代码上线的影响。一旦代码失效或开发人员需要查看测试输出时，<a href=https://www.jenkins.io/>Jenkins</a> 提供了日志文件以供检查。</p><p>默认的 Jenkins 管道 Pipeline 日志可能难以阅读。这篇关于 Jenkins 日志的基础知识的总结文章提供了一些技巧（和代码），说明了如何提升它们的可读性。</p><h3 id=你获得什么>你获得什么</h3><p>Jenkins 管道分为 <a href=https://www.jenkins.io/doc/book/pipeline/syntax/#stage>几个阶段</a>。Jenkins 自动记录每个阶段的开始，记录内容如下：</p><pre tabindex=0><code>[Pipeline] // stage
[Pipeline] stage (hide)
[Pipeline] { (Apply all openshift resources)
[Pipeline] dir
</code></pre><p>上文显示的内容没有太大区分度，重要的内容（如阶段的开始）未突出显示。在多达数百行的管道日志中，要找到一个阶段的起始和另外一个阶段的终止位置可能会很艰巨。当随意浏览日志寻找一个特定的阶段的时候，这种艰巨尤其明显。</p><p>Jenkins 管道是由 <a href=https://opensource.com/article/20/12/groovy>Groovy</a> 和 Shell 脚本混合编写的。在 Groovy 代码中，日志记录很少。很多时候，日志是由命令中的不起眼的文本组成，没有详细信息。在 Shell 脚本中，打开了调试模式（<code>set -x</code>），所以每条命令都会被完全 具现化 realized （变量被解除引用并打印出数值）并详细记录，输出也是如此。</p><p>鉴于日志可能有很多内容，通读日志获取相关信息可能很繁琐。由于在管道中被处理，并跟着一个 Shell 脚本的 Groovy 日志可读性差，它们很多时候缺少上下文：</p><pre tabindex=0><code>[Pipeline] dir
Running in /home/jenkins/agent/workspace/devop-master/devops-server-pipeline/my-repo-dir/src
[Pipeline] { (hide)
[Pipeline] findFiles
[Pipeline] findFiles
[Pipeline] readYaml
[Pipeline] }
</code></pre><p>我可以知道我正在使用的目录，并且知道我正在使用 Jenkins 的步骤搜索文件、读取 YAML 文件。但是我在寻找什么？我找到并读取的内容是什么？</p><h3 id=能做什么>能做什么？</h3><p>我很高兴你这么问，因为这里有一些简单的做法和一些小的代码片段可以提供帮助。首先，代码如下：</p><pre tabindex=0><code>def echoBanner(def ... msgs) {
   echo createBanner(msgs)
}

def errorBanner(def ... msgs) {
   error(createBanner(msgs))
}

def createBanner(def ... msgs) {
   return &#34;&#34;&#34;
       ===========================================

       ${msgFlatten(null, msgs).join(&#34;\n        &#34;)}

       ===========================================
   &#34;&#34;&#34;
}

// flatten function hack included in case Jenkins security
// is set to preclude calling Groovy flatten() static method
// NOTE: works well on all nested collections except a Map
def msgFlatten(def list, def msgs) {
   list = list ?: []
   if (!(msgs instanceof String) &amp;&amp; !(msgs instanceof GString)) {
       msgs.each { msg -&gt;
           list = msgFlatten(list, msg)
       }
   }
   else {
       list += msgs
   }

   return  list
}
</code></pre><p>将这段代码添加到每个管道的末尾，也可以 <a href=https://www.jenkins.io/doc/pipeline/steps/workflow-cps/#load-evaluate-a-groovy-source-file-into-the-pipeline-script>加载一个 Groovy 文件</a> 或者使其成为 <a href=https://www.jenkins.io/doc/book/pipeline/shared-libraries/>Jenkins 共享库</a> 的一部分，这样更有效。</p><p>在每个阶段起始处（或者在阶段中的特定位置），只需调用 <code>echoBanner</code>：</p><pre tabindex=0><code>echoBanner(&#34;MY STAGE&#34;, [&#34;DOING SOMETHING 1&#34;, &#34;DOING SOMETHING 2&#34;])
</code></pre><p>你的 Jenkins 日志会展示如下：</p><pre tabindex=0><code>    ===========================================

    MY STAGE
    DOING SOMETHING 1
    DOING SOMETHING 2

    ===========================================
</code></pre><p>这个横幅很容易从日志中分辨出来。当正确使用它们时，它们还有助于界定管道流，并且可以很好的将日志分解开来进行阅读。</p><p>我已经在某些地方专业地使用这些代码一些时间了。在帮助管道日志更易读和流程更易理解方面，反馈是非常积极的。</p><p>上述的 <code>errorBanner</code> 方法以相同的方式工作，但是它会立即使脚本失效。这有助于突显失败的位置与原因。</p><h3 id=最佳实践>最佳实践</h3><ol><li>在你的 Groovy 代码中大量使用 <code>echo</code> Jenkins 步骤来通知用户你在做什么。这些也可以帮助记录你的代码。</li><li>使用空的日志语句（Groovy 中空的 echo 步骤、<code>echo ''</code> 或 Shell 中的 <code>echo</code>）来分割输出，提高可读性。你可能在你的代码中为同样的目的使用空行。</li><li>避免在脚本中使用 <code>set +x</code> 的陷阱，因为它隐藏了日志记录已执行的 Shell 语句。它并没有清理你的日志，而是使你的管道成为一个黑盒子，隐藏了管道正在做的行为以及出现的任何错误。确保管道功能尽可能透明。</li><li>如果你的管道创建了 中间工件 Intermediate Artifacts ，开发人员和 DevOps 人员可以使用这些工件来帮助调试问题，那么也要记录它的内容。是的，它会加长日志，但这只是文本。在某些时候，这会是有用的信息，而（利用得当的）日志不就是关于发生了什么和为什么发生的大量信息吗？</li></ol><h3 id=kubernetes-机密信息无法完全透明的地方>Kubernetes 机密信息：无法完全透明的地方</h3><p>有些事情你不希望出现在日志里暴露出来。如果你在使用 Kubernetes 并引用保存在 Kubernetes 机密信息 Secrets 中的数据，那么你绝对不希望在日志中公开该数据，因为这些数据只是被混淆了，而没有被加密。</p><p>假如你想获取一些保存在机密信息中的数据，然后将其注入模板化 JSON 文件中。（机密信息和 JSON 模板的完整内容与此例无关。）按照最佳实践，你希望保持透明并记录你的操作，但你不想公开机密信息数据。</p><p>将脚本模式从调试（<code>set -x</code>）更改为命令记录（<code>set -v</code>）。在脚本敏感部分的结尾，将 Shell 重置为调试模式：</p><pre tabindex=0><code>sh &#34;&#34;&#34;
   # change script mode from debugging to command logging
   set +x -v

   # capture data from secret in shell variable
   MY_SECRET=\$(kubectl get secret my-secret --no-headers -o &#39;custom-column=:.data.my-secret-data&#39;)

   # replace template placeholder inline
   sed s/%TEMPLATE_PARAM%/${MY_SECRET_DATA}/ my-template-file.json

   # do something with modified template-file.json...

   # reset the shell to debugging mode
   set -x +v
&#34;&#34;&#34;
</code></pre><p>这将输出此行到日志：</p><pre tabindex=0><code>sed s/%TEMPLATE_PARAM%/${MY_SECRET_DATA}/ my-template-file.json
</code></pre><p>与 Shell 调试模式中不同，这不会具现化 Shell 变量 <code>MY_SECRET_DATA</code>。显然，如果管道中在这一点出现问题，而你试图找出问题出在哪里，那么这不如调试模式有用。但这是在保持管道执行对开发人员和 DevOps 透明的同时，也保持你的秘密的最佳平衡。</p><hr><p>via: <a href=https://opensource.com/article/21/5/jenkins-logs>https://opensource.com/article/21/5/jenkins-logs</a></p><p>作者：<a href=https://opensource.com/users/hippyod>Evan &ldquo;Hippy&rdquo; Slatis</a> 选题：<a href=https://github.com/lujun9972>lujun9972</a> 译者：<a href=https://github.com/DCOLIVERSUN>DCOLIVERSUN</a> 校对：<a href=https://github.com/wxy>wxy</a></p><p>本文由 <a href=https://github.com/LCTT/TranslateProject>LCTT</a> 原创编译，<a href=https://linux.cn/>Linux中国</a> 荣誉推出</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/jenkins/ rel=tag>Jenkins</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E6%97%A5%E5%BF%97/ rel=tag>日志</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Linux.cn Archive.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>